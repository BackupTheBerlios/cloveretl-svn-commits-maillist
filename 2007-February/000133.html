<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cloveretl-svn-commits] CloverETL repos r2494 - in	trunk/cloveretl.engine/src/org/jetel/util: . ddl2clover
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cloveretl-svn-commits/2007-February/index.html" >
   <LINK REL="made" HREF="mailto:cloveretl-svn-commits%40lists.berlios.de?Subject=Re%3A%20%5BCloveretl-svn-commits%5D%20CloverETL%20repos%20r2494%20-%20in%0A%09trunk/cloveretl.engine/src/org/jetel/util%3A%20.%20ddl2clover&In-Reply-To=%3C200702201444.l1KEi2xk029716%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000130.html">
   <LINK REL="Next"  HREF="000131.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cloveretl-svn-commits] CloverETL repos r2494 - in	trunk/cloveretl.engine/src/org/jetel/util: . ddl2clover</H1>
    <B>cloveretl-svn-commits at lists.berlios.de</B> 
    <A HREF="mailto:cloveretl-svn-commits%40lists.berlios.de?Subject=Re%3A%20%5BCloveretl-svn-commits%5D%20CloverETL%20repos%20r2494%20-%20in%0A%09trunk/cloveretl.engine/src/org/jetel/util%3A%20.%20ddl2clover&In-Reply-To=%3C200702201444.l1KEi2xk029716%40sheep.berlios.de%3E"
       TITLE="[Cloveretl-svn-commits] CloverETL repos r2494 - in	trunk/cloveretl.engine/src/org/jetel/util: . ddl2clover">cloveretl-svn-commits at lists.berlios.de
       </A><BR>
    <I>Tue Feb 20 15:44:02 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000130.html">[Cloveretl-svn-commits] CloverETL repos r2493 -	trunk/cloveretl.engine/src/org/jetel/util/dml2clover
</A></li>
        <LI>Next message: <A HREF="000131.html">[Cloveretl-svn-commits] CloverETL repos r2495 -	trunk/cloveretl.engine/src/org/jetel/util/ddl2clover
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#133">[ date ]</a>
              <a href="thread.html#133">[ thread ]</a>
              <a href="subject.html#133">[ subject ]</a>
              <a href="author.html#133">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jausperger
Date: 2007-02-20 15:44:00 +0100 (Tue, 20 Feb 2007)
New Revision: 2494

Added:
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2Clover.java
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2CloverConstants.java
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2CloverTokenManager.java
Removed:
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2Clover.java
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2CloverConstants.java
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2CloverTokenManager.java
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/
Modified:
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2Clover.jj
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DataType.java
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/ParseException.java
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/SimpleCharStream.java
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/Token.java
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/TokenMgrError.java
Log:
INIT: create metadata from create statement

Copied: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover (from rev 2493, trunk/cloveretl.engine/src/org/jetel/util/dml2clover)

Added: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2Clover.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DDL2Clover.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2Clover.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -0,0 +1,881 @@
+/* Generated By:JavaCC: Do not edit this line. DDL2Clover.java */
+package org.jetel.util.ddl2clover;
+
+import java.util.*;
+import java.io.*;
+import org.jetel.metadata.*;
+import java.math.*;
+
+public class DDL2Clover implements DDL2CloverConstants {
+
+        /**
+		 * The class parses sql script containing only create statements. Output is a DataRecordMetadata List.
+		 */
+
+        private List&lt;DataRecordMetadata&gt; list = new LinkedList&lt;DataRecordMetadata&gt;();
+        private String fieldDelimiter;
+        private String recordDelimiter;
+
+        private static final Long booleanLenght = Long.valueOf(5); // false / true
+        private static final Long byteLenght = Long.valueOf(String.valueOf(Byte.MIN_VALUE).length());
+        private static final Long integerLenght = Long.valueOf(String.valueOf(Integer.MIN_VALUE).length());
+        private static final Long longLenght = Long.valueOf(String.valueOf(Long.MIN_VALUE).length());
+        private static final Long floatLenght = Long.valueOf(String.valueOf(7));
+        private static final Long doubleLenght = Long.valueOf(String.valueOf(15));
+        private static final Long dateLenght = Long.valueOf(10); // &quot;10.10.2007&quot;
+        private static final Long dateTimeLenght = Long.valueOf(24); // &quot;10.10.2007 23:10:10.111&quot;
+
+        public static void main(String args[]) throws ParseException, FileNotFoundException {
+                DDL2Clover parser = new DDL2Clover(new FileInputStream(new File(&quot;text.txt&quot;)));
+                parser.getDataRecordMetadataList(&quot;;&quot;, &quot;\n&quot;);
+                parser.testPrint(parser.list);
+                System.out.println(&quot;Ok&quot;);
+        }
+
+        public List&lt;DataRecordMetadata&gt; getDataRecordMetadataList() throws ParseException {
+                return getDataRecordMetadataList(null, null);
+        }
+
+        public List&lt;DataRecordMetadata&gt; getDataRecordMetadataList(String fieldDelimiter, String recordDelimiter) throws ParseException {
+                this.fieldDelimiter = fieldDelimiter;
+                this.recordDelimiter = recordDelimiter;
+                while (!isEOF()) {
+                        list.add(createTableStatement());
+                }
+                return list;
+        }
+
+        private void testPrint(List&lt;DataRecordMetadata&gt; list) {
+                DataRecordMetadataXMLReaderWriter writer = new DataRecordMetadataXMLReaderWriter();
+                for (DataRecordMetadata dataRecordMetadata : list) {
+                        writer.write(dataRecordMetadata, System.out);
+                        System.out.println();
+                }
+        }
+
+/*******************************************************************
+ * The SQL syntatic grammar starts here
+ *******************************************************************/
+  final public DataRecordMetadata createTableStatement() throws ParseException {
+        DataRecordMetadata dataRecordMetadata;
+        List&lt;DataFieldMetadata&gt; list;
+    jj_consume_token(CREATE);
+    switch (jj_nt.kind) {
+    case GLOBAL:
+    case LOCAL:
+    case TEMPORARY:
+      tableScope();
+      break;
+    default:
+      jj_la1[0] = jj_gen;
+      ;
+    }
+    jj_consume_token(TABLE);
+    if (jj_2_1(2)) {
+      jj_consume_token(IDENTIFIER);
+      jj_consume_token(DOT);
+    } else {
+      ;
+    }
+                                                                           dataRecordMetadata = new DataRecordMetadata(identifier());
+                        list = tableElementList();
+                        for (DataFieldMetadata field : list) {
+                                dataRecordMetadata.addField(field);
+                        }
+    switch (jj_nt.kind) {
+    case ON:
+      jj_consume_token(ON);
+      jj_consume_token(COMMIT);
+      switch (jj_nt.kind) {
+      case DELETE:
+      case PRESERVE:
+        switch (jj_nt.kind) {
+        case PRESERVE:
+          jj_consume_token(PRESERVE);
+          break;
+        case DELETE:
+          jj_consume_token(DELETE);
+          break;
+        default:
+          jj_la1[1] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+      default:
+        jj_la1[2] = jj_gen;
+        ;
+      }
+      jj_consume_token(ROWS);
+      break;
+    default:
+      jj_la1[3] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+                if (fieldDelimiter != null &amp;&amp; recordDelimiter != null) {
+                        dataRecordMetadata.setRecType(DataRecordMetadata.DELIMITED_RECORD);
+                } else if (fieldDelimiter == null &amp;&amp; recordDelimiter == null) {
+                        dataRecordMetadata.setRecType(DataRecordMetadata.FIXEDLEN_RECORD);
+                }
+          {if (true) return dataRecordMetadata;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+  final public List&lt;DataFieldMetadata&gt; tableElementList() throws ParseException {
+        List&lt;DataFieldMetadata&gt; list = new LinkedList&lt;DataFieldMetadata&gt;();
+        DataFieldMetadata ret;
+    jj_consume_token(OPENPAREN);
+    ret = tableElement();
+                ret.setDelimiter(fieldDelimiter);
+                list.add(ret);
+    label_1:
+    while (true) {
+      switch (jj_nt.kind) {
+      case COMA:
+        ;
+        break;
+      default:
+        jj_la1[4] = jj_gen;
+        break label_1;
+      }
+      jj_consume_token(COMA);
+      ret = tableElement();
+                ret.setDelimiter(fieldDelimiter);
+                list.add(ret);
+    }
+         ret.setDelimiter(recordDelimiter);
+    jj_consume_token(CLOSEPAREN);
+          {if (true) return list;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+  final public void tableScope() throws ParseException {
+    switch (jj_nt.kind) {
+    case GLOBAL:
+    case LOCAL:
+      switch (jj_nt.kind) {
+      case GLOBAL:
+        jj_consume_token(GLOBAL);
+        break;
+      case LOCAL:
+        jj_consume_token(LOCAL);
+        break;
+      default:
+        jj_la1[5] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[6] = jj_gen;
+      ;
+    }
+    jj_consume_token(TEMPORARY);
+  }
+
+  final public boolean isEOF() throws ParseException {
+        boolean isEof = false;
+    switch (jj_nt.kind) {
+    case 0:
+      jj_consume_token(0);
+      isEof = t();
+      break;
+    default:
+      jj_la1[7] = jj_gen;
+      ;
+    }
+         {if (true) return isEof;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+  final public boolean t() throws ParseException {
+         {if (true) return true;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public void columnConstraintDefinition() throws ParseException {
+    switch (jj_nt.kind) {
+    case NOT:
+      jj_consume_token(NOT);
+      jj_consume_token(NULL);
+      break;
+    case UNIQUE:
+      jj_consume_token(UNIQUE);
+      break;
+    case PRIMARY:
+      jj_consume_token(PRIMARY);
+      jj_consume_token(KEY);
+      break;
+    case REFERENCES:
+      jj_consume_token(REFERENCES);
+      tableName();
+      jj_consume_token(OPENPAREN);
+      identifierList();
+      jj_consume_token(CLOSEPAREN);
+      break;
+    default:
+      jj_la1[8] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+//+
+  final public DataFieldMetadata columnDefinition() throws ParseException {
+        DataFieldMetadata dataFieldMetadata;
+        String name;
+        DataType type;
+        Object value = null;
+    name = columnName();
+    type = dataType();
+    switch (jj_nt.kind) {
+    case DEFAULT_:
+      jj_consume_token(DEFAULT_);
+      value = defaultValue();
+      break;
+    default:
+      jj_la1[9] = jj_gen;
+      ;
+    }
+    switch (jj_nt.kind) {
+    case NOT:
+    case PRIMARY:
+    case REFERENCES:
+    case UNIQUE:
+      columnConstraintDefinition();
+      break;
+    default:
+      jj_la1[10] = jj_gen;
+      ;
+    }
+          if (type.length == null) {
+                dataFieldMetadata = new DataFieldMetadata(name, type.type, null);
+          } else {
+                //dataFieldMetadata = new DataFieldMetadata(name, type.type, type.length.shortValue());
+                dataFieldMetadata = new DataFieldMetadata(name, type.type, type.length.shortValue());
+          }
+          dataFieldMetadata.setDefaultValue(value);
+          {if (true) return dataFieldMetadata;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+  final public DataFieldMetadata tableElement() throws ParseException {
+        DataFieldMetadata ret = null;
+    ret = columnDefinition();
+          {if (true) return ret;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public String columnName() throws ParseException {
+        String ret;
+    if (jj_2_2(2)) {
+      identifier();
+      jj_consume_token(DOT);
+    } else {
+      ;
+    }
+    ret = identifier();
+          {if (true) return ret;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+TODO dodelat dalsi typu jako DATE, VARCHAR,...
+  final public DataType dataType() throws ParseException {
+        char type;
+        Long temp;
+        Long lenght = null;
+        Long scale = null;
+    switch (jj_nt.kind) {
+    case BOOLEAN:
+      jj_consume_token(BOOLEAN);
+                            type = DataFieldMetadata.INTEGER_FIELD;             lenght = integerLenght;
+      break;
+    case BLOB:
+      jj_consume_token(BLOB);
+                         type = DataFieldMetadata.BYTE_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                    lenght = temp;
+        break;
+      default:
+        jj_la1[11] = jj_gen;
+        ;
+      }
+      break;
+    case CHAR:
+      jj_consume_token(CHAR);
+                         type = DataFieldMetadata.STRING_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                    lenght = temp;
+        break;
+      default:
+        jj_la1[12] = jj_gen;
+        ;
+      }
+      break;
+    case CHARACTER:
+      jj_consume_token(CHARACTER);
+                              type = DataFieldMetadata.STRING_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                            lenght = temp;
+        break;
+      default:
+        jj_la1[13] = jj_gen;
+        ;
+      }
+      break;
+    case CLOB:
+      jj_consume_token(CLOB);
+                         type = DataFieldMetadata.BYTE_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                    lenght = temp;
+        break;
+      default:
+        jj_la1[14] = jj_gen;
+        ;
+      }
+      break;
+    case DATE:
+      jj_consume_token(DATE);
+                         type = DataFieldMetadata.DATE_FIELD;                   lenght = dateLenght;
+      break;
+    case DATETIME:
+      jj_consume_token(DATETIME);
+                             type = DataFieldMetadata.DATE_FIELD;           lenght = dateTimeLenght;
+      break;
+    case DEC:
+      jj_consume_token(DEC);
+                        type = DataFieldMetadata.DECIMAL_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        switch (jj_nt.kind) {
+        case COMA:
+          jj_consume_token(COMA);
+          scale = integerLiteral();
+          break;
+        default:
+          jj_la1[15] = jj_gen;
+          ;
+        }
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                                                        lenght = temp;
+        break;
+      default:
+        jj_la1[16] = jj_gen;
+        ;
+      }
+      break;
+    case DECIMAL:
+      jj_consume_token(DECIMAL);
+                            type = DataFieldMetadata.DECIMAL_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        switch (jj_nt.kind) {
+        case COMA:
+          jj_consume_token(COMA);
+          scale = integerLiteral();
+          break;
+        default:
+          jj_la1[17] = jj_gen;
+          ;
+        }
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                                                lenght = temp;
+        break;
+      default:
+        jj_la1[18] = jj_gen;
+        ;
+      }
+      break;
+    case FLOAT:
+      jj_consume_token(FLOAT);
+                          type = DataFieldMetadata.NUMERIC_FIELD;               lenght = floatLenght;
+      break;
+    case INT:
+      jj_consume_token(INT);
+                        type = DataFieldMetadata.INTEGER_FIELD;                 lenght = integerLenght;
+      break;
+    case INTEGER:
+      jj_consume_token(INTEGER);
+                            type = DataFieldMetadata.INTEGER_FIELD;     lenght = integerLenght;
+      break;
+    case SMALLINT:
+      jj_consume_token(SMALLINT);
+                             type = DataFieldMetadata.INTEGER_FIELD;    lenght = integerLenght;
+      break;
+    case TIMESTAMP:
+      jj_consume_token(TIMESTAMP);
+                              type = DataFieldMetadata.DATE_FIELD;              lenght = dateTimeLenght;
+      break;
+    case NUMERIC:
+      jj_consume_token(NUMERIC);
+                            type = DataFieldMetadata.DECIMAL_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        switch (jj_nt.kind) {
+        case COMA:
+          jj_consume_token(COMA);
+          scale = integerLiteral();
+          break;
+        default:
+          jj_la1[19] = jj_gen;
+          ;
+        }
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                                                lenght = temp;
+        break;
+      default:
+        jj_la1[20] = jj_gen;
+        ;
+      }
+      break;
+    case VARCHAR:
+      jj_consume_token(VARCHAR);
+                            type = DataFieldMetadata.STRING_FIELD;
+      jj_consume_token(OPENPAREN);
+      temp = integerLiteral();
+      jj_consume_token(CLOSEPAREN);
+                                                                                                                           lenght = temp;
+      break;
+    case VARCHAR2:
+      jj_consume_token(VARCHAR2);
+                             type = DataFieldMetadata.STRING_FIELD;
+      jj_consume_token(OPENPAREN);
+      temp = integerLiteral();
+      jj_consume_token(CLOSEPAREN);
+                                                                                                                           lenght = temp;
+      break;
+    default:
+      jj_la1[21] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+          {if (true) return new DataType(type, lenght, scale);}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public Object defaultValue() throws ParseException {
+        Object ret;
+    switch (jj_nt.kind) {
+    case STRING_LITERAL:
+    case INTEGER_LITERAL:
+    case FLOAT_LITERAL:
+      ret = literal();
+      break;
+    case NULL:
+      ret = nullLiteral();
+      break;
+    default:
+      jj_la1[22] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+          {if (true) return ret;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public BigDecimal floatLiteral() throws ParseException {
+    jj_consume_token(FLOAT_LITERAL);
+                          {if (true) return new BigDecimal(token.image);}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public String identifier() throws ParseException {
+    jj_consume_token(IDENTIFIER);
+          {if (true) return token.image;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public void identifierList() throws ParseException {
+    identifier();
+    label_2:
+    while (true) {
+      switch (jj_nt.kind) {
+      case COMA:
+        ;
+        break;
+      default:
+        jj_la1[23] = jj_gen;
+        break label_2;
+      }
+      jj_consume_token(COMA);
+      identifier();
+    }
+  }
+
+//+
+  final public Object literal() throws ParseException {
+        Object ret;
+    switch (jj_nt.kind) {
+    case INTEGER_LITERAL:
+      ret = integerLiteral();
+      break;
+    case FLOAT_LITERAL:
+      ret = floatLiteral();
+      break;
+    case STRING_LITERAL:
+      ret = stringLiteral();
+      break;
+    default:
+      jj_la1[24] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+          {if (true) return ret;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public Long integerLiteral() throws ParseException {
+    jj_consume_token(INTEGER_LITERAL);
+                            {if (true) return new Long(token.image);}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public Object nullLiteral() throws ParseException {
+    jj_consume_token(NULL);
+                 {if (true) return null;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public String stringLiteral() throws ParseException {
+    jj_consume_token(STRING_LITERAL);
+                String value = token.image.intern();
+                {if (true) return value.substring(1, value.length() - 1);}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public void tableName() throws ParseException {
+    jj_consume_token(IDENTIFIER);
+  }
+
+  final private boolean jj_2_1(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_1(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(0, xla); }
+  }
+
+  final private boolean jj_2_2(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_2(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(1, xla); }
+  }
+
+  final private boolean jj_3R_3() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    return false;
+  }
+
+  final private boolean jj_3_2() {
+    if (jj_3R_3()) return true;
+    if (jj_scan_token(DOT)) return true;
+    return false;
+  }
+
+  final private boolean jj_3_1() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    if (jj_scan_token(DOT)) return true;
+    return false;
+  }
+
+  public DDL2CloverTokenManager token_source;
+  SimpleCharStream jj_input_stream;
+  public Token token, jj_nt;
+  private Token jj_scanpos, jj_lastpos;
+  private int jj_la;
+  public boolean lookingAhead = false;
+  private boolean jj_semLA;
+  private int jj_gen;
+  final private int[] jj_la1 = new int[25];
+  static private int[] jj_la1_0;
+  static private int[] jj_la1_1;
+  static {
+      jj_la1_0();
+      jj_la1_1();
+   }
+   private static void jj_la1_0() {
+      jj_la1_0 = new int[] {0x44000000,0x1000000,0x1000000,0x0,0x0,0x44000000,0x44000000,0x1,0x80000000,0x800000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1a79f000,0x0,0x0,0x0,};
+   }
+   private static void jj_la1_1() {
+      jj_la1_1 = new int[] {0x800,0x10,0x10,0x8,0x800000,0x0,0x0,0x0,0x1060,0x0,0x1060,0x2000000,0x2000000,0x2000000,0x2000000,0x800000,0x2000000,0x800000,0x2000000,0x800000,0x2000000,0x6504,0x38001,0x800000,0x38000,};
+   }
+  final private JJCalls[] jj_2_rtns = new JJCalls[2];
+  private boolean jj_rescan = false;
+  private int jj_gc = 0;
+
+  public DDL2Clover(java.io.InputStream stream) {
+     this(stream, null);
+  }
+  public DDL2Clover(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source = new DDL2CloverTokenManager(jj_input_stream);
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public void ReInit(java.io.InputStream stream) {
+     ReInit(stream, null);
+  }
+  public void ReInit(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public DDL2Clover(java.io.Reader stream) {
+    jj_input_stream = new SimpleCharStream(stream, 1, 1);
+    token_source = new DDL2CloverTokenManager(jj_input_stream);
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public void ReInit(java.io.Reader stream) {
+    jj_input_stream.ReInit(stream, 1, 1);
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public DDL2Clover(DDL2CloverTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public void ReInit(DDL2CloverTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  final private Token jj_consume_token(int kind) throws ParseException {
+    Token oldToken = token;
+    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
+    else jj_nt = jj_nt.next = token_source.getNextToken();
+    if (token.kind == kind) {
+      jj_gen++;
+      if (++jj_gc &gt; 100) {
+        jj_gc = 0;
+        for (int i = 0; i &lt; jj_2_rtns.length; i++) {
+          JJCalls c = jj_2_rtns[i];
+          while (c != null) {
+            if (c.gen &lt; jj_gen) c.first = null;
+            c = c.next;
+          }
+        }
+      }
+      return token;
+    }
+    jj_nt = token;
+    token = oldToken;
+    jj_kind = kind;
+    throw generateParseException();
+  }
+
+  static private final class LookaheadSuccess extends java.lang.Error { }
+  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
+  final private boolean jj_scan_token(int kind) {
+    if (jj_scanpos == jj_lastpos) {
+      jj_la--;
+      if (jj_scanpos.next == null) {
+        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
+      } else {
+        jj_lastpos = jj_scanpos = jj_scanpos.next;
+      }
+    } else {
+      jj_scanpos = jj_scanpos.next;
+    }
+    if (jj_rescan) {
+      int i = 0; Token tok = token;
+      while (tok != null &amp;&amp; tok != jj_scanpos) { i++; tok = tok.next; }
+      if (tok != null) jj_add_error_token(kind, i);
+    }
+    if (jj_scanpos.kind != kind) return true;
+    if (jj_la == 0 &amp;&amp; jj_scanpos == jj_lastpos) throw jj_ls;
+    return false;
+  }
+
+  final public Token getNextToken() {
+    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
+    else jj_nt = jj_nt.next = token_source.getNextToken();
+    jj_gen++;
+    return token;
+  }
+
+  final public Token getToken(int index) {
+    Token t = lookingAhead ? jj_scanpos : token;
+    for (int i = 0; i &lt; index; i++) {
+      if (t.next != null) t = t.next;
+      else t = t.next = token_source.getNextToken();
+    }
+    return t;
+  }
+
+  private java.util.Vector&lt;int[]&gt; jj_expentries = new java.util.Vector&lt;int[]&gt;();
+  private int[] jj_expentry;
+  private int jj_kind = -1;
+  private int[] jj_lasttokens = new int[100];
+  private int jj_endpos;
+
+  private void jj_add_error_token(int kind, int pos) {
+    if (pos &gt;= 100) return;
+    if (pos == jj_endpos + 1) {
+      jj_lasttokens[jj_endpos++] = kind;
+    } else if (jj_endpos != 0) {
+      jj_expentry = new int[jj_endpos];
+      for (int i = 0; i &lt; jj_endpos; i++) {
+        jj_expentry[i] = jj_lasttokens[i];
+      }
+      boolean exists = false;
+      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
+        int[] oldentry = (int[])(e.nextElement());
+        if (oldentry.length == jj_expentry.length) {
+          exists = true;
+          for (int i = 0; i &lt; jj_expentry.length; i++) {
+            if (oldentry[i] != jj_expentry[i]) {
+              exists = false;
+              break;
+            }
+          }
+          if (exists) break;
+        }
+      }
+      if (!exists) jj_expentries.addElement(jj_expentry);
+      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
+    }
+  }
+
+  public ParseException generateParseException() {
+    jj_expentries.removeAllElements();
+    boolean[] la1tokens = new boolean[59];
+    for (int i = 0; i &lt; 59; i++) {
+      la1tokens[i] = false;
+    }
+    if (jj_kind &gt;= 0) {
+      la1tokens[jj_kind] = true;
+      jj_kind = -1;
+    }
+    for (int i = 0; i &lt; 25; i++) {
+      if (jj_la1[i] == jj_gen) {
+        for (int j = 0; j &lt; 32; j++) {
+          if ((jj_la1_0[i] &amp; (1&lt;&lt;j)) != 0) {
+            la1tokens[j] = true;
+          }
+          if ((jj_la1_1[i] &amp; (1&lt;&lt;j)) != 0) {
+            la1tokens[32+j] = true;
+          }
+        }
+      }
+    }
+    for (int i = 0; i &lt; 59; i++) {
+      if (la1tokens[i]) {
+        jj_expentry = new int[1];
+        jj_expentry[0] = i;
+        jj_expentries.addElement(jj_expentry);
+      }
+    }
+    jj_endpos = 0;
+    jj_rescan_token();
+    jj_add_error_token(0, 0);
+    int[][] exptokseq = new int[jj_expentries.size()][];
+    for (int i = 0; i &lt; jj_expentries.size(); i++) {
+      exptokseq[i] = (int[])jj_expentries.elementAt(i);
+    }
+    return new ParseException(token, exptokseq, tokenImage);
+  }
+
+  final public void enable_tracing() {
+  }
+
+  final public void disable_tracing() {
+  }
+
+  final private void jj_rescan_token() {
+    jj_rescan = true;
+    for (int i = 0; i &lt; 2; i++) {
+    try {
+      JJCalls p = jj_2_rtns[i];
+      do {
+        if (p.gen &gt; jj_gen) {
+          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
+          switch (i) {
+            case 0: jj_3_1(); break;
+            case 1: jj_3_2(); break;
+          }
+        }
+        p = p.next;
+      } while (p != null);
+      } catch(LookaheadSuccess ls) { }
+    }
+    jj_rescan = false;
+  }
+
+  final private void jj_save(int index, int xla) {
+    JJCalls p = jj_2_rtns[index];
+    while (p.gen &gt; jj_gen) {
+      if (p.next == null) { p = p.next = new JJCalls(); break; }
+      p = p.next;
+    }
+    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
+  }
+
+  static final class JJCalls {
+    int gen;
+    Token first;
+    int arg;
+    JJCalls next;
+  }
+
+}

Added: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2CloverConstants.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DDL2CloverConstants.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2CloverConstants.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -0,0 +1,121 @@
+/* Generated By:JavaCC: Do not edit this line. DML2CloverConstants.java */
+package org.jetel.util.ddl2clover;
+
+public interface DDL2CloverConstants {
+
+  int EOF = 0;
+  int BOOLEAN = 12;
+  int BLOB = 13;
+  int CHAR = 14;
+  int CHARACTER = 15;
+  int CLOB = 16;
+  int COMMIT = 17;
+  int CREATE = 18;
+  int DATE = 19;
+  int DATETIME = 20;
+  int DEC = 21;
+  int DECIMAL = 22;
+  int DEFAULT_ = 23;
+  int DELETE = 24;
+  int FLOAT = 25;
+  int GLOBAL = 26;
+  int INT = 27;
+  int INTEGER = 28;
+  int KEY = 29;
+  int LOCAL = 30;
+  int NOT = 31;
+  int NULL = 32;
+  int NUMBER = 33;
+  int NUMERIC = 34;
+  int ON = 35;
+  int PRESERVE = 36;
+  int PRIMARY = 37;
+  int REFERENCES = 38;
+  int ROWS = 39;
+  int SMALLINT = 40;
+  int TABLE = 41;
+  int TIMESTAMP = 42;
+  int TEMPORARY = 43;
+  int UNIQUE = 44;
+  int VARCHAR = 45;
+  int VARCHAR2 = 46;
+  int STRING_LITERAL = 47;
+  int INTEGER_LITERAL = 48;
+  int FLOAT_LITERAL = 49;
+  int EXP = 50;
+  int IDENTIFIER = 51;
+  int LETTER = 52;
+  int DIGIT = 53;
+  int CLOSEPAREN = 54;
+  int COMA = 55;
+  int DOT = 56;
+  int OPENPAREN = 57;
+  int SEMICOLON = 58;
+
+  int DEFAULT = 0;
+  int WithinComment = 1;
+  int WithinLineComment = 2;
+
+  String[] tokenImage = {
+    &quot;&lt;EOF&gt;&quot;,
+    &quot;\&quot; \&quot;&quot;,
+    &quot;\&quot;\\t\&quot;&quot;,
+    &quot;\&quot;\\n\&quot;&quot;,
+    &quot;\&quot;\\r\&quot;&quot;,
+    &quot;\&quot;\\n\\r\&quot;&quot;,
+    &quot;\&quot;/*\&quot;&quot;,
+    &quot;\&quot;*/\&quot;&quot;,
+    &quot;&lt;token of kind 8&gt;&quot;,
+    &quot;\&quot;//\&quot;&quot;,
+    &quot;\&quot;\\n\&quot;&quot;,
+    &quot;&lt;token of kind 11&gt;&quot;,
+    &quot;\&quot;boolean\&quot;&quot;,
+    &quot;\&quot;blob\&quot;&quot;,
+    &quot;\&quot;char\&quot;&quot;,
+    &quot;\&quot;character\&quot;&quot;,
+    &quot;\&quot;clob\&quot;&quot;,
+    &quot;\&quot;commit\&quot;&quot;,
+    &quot;\&quot;create\&quot;&quot;,
+    &quot;\&quot;date\&quot;&quot;,
+    &quot;\&quot;datetime\&quot;&quot;,
+    &quot;\&quot;dec\&quot;&quot;,
+    &quot;\&quot;decimal\&quot;&quot;,
+    &quot;\&quot;default\&quot;&quot;,
+    &quot;\&quot;delete\&quot;&quot;,
+    &quot;\&quot;float\&quot;&quot;,
+    &quot;\&quot;global\&quot;&quot;,
+    &quot;\&quot;int\&quot;&quot;,
+    &quot;\&quot;integer\&quot;&quot;,
+    &quot;\&quot;key\&quot;&quot;,
+    &quot;\&quot;local\&quot;&quot;,
+    &quot;\&quot;not\&quot;&quot;,
+    &quot;\&quot;null\&quot;&quot;,
+    &quot;\&quot;number\&quot;&quot;,
+    &quot;\&quot;numeric\&quot;&quot;,
+    &quot;\&quot;on\&quot;&quot;,
+    &quot;\&quot;preserve\&quot;&quot;,
+    &quot;\&quot;primary\&quot;&quot;,
+    &quot;\&quot;references\&quot;&quot;,
+    &quot;\&quot;rows\&quot;&quot;,
+    &quot;\&quot;smallint\&quot;&quot;,
+    &quot;\&quot;table\&quot;&quot;,
+    &quot;\&quot;timestamp\&quot;&quot;,
+    &quot;\&quot;TEMPORARY\&quot;&quot;,
+    &quot;\&quot;unique\&quot;&quot;,
+    &quot;\&quot;varchar\&quot;&quot;,
+    &quot;\&quot;varchar2\&quot;&quot;,
+    &quot;&lt;STRING_LITERAL&gt;&quot;,
+    &quot;&lt;INTEGER_LITERAL&gt;&quot;,
+    &quot;&lt;FLOAT_LITERAL&gt;&quot;,
+    &quot;&lt;EXP&gt;&quot;,
+    &quot;&lt;IDENTIFIER&gt;&quot;,
+    &quot;&lt;LETTER&gt;&quot;,
+    &quot;&lt;DIGIT&gt;&quot;,
+    &quot;\&quot;)\&quot;&quot;,
+    &quot;\&quot;,\&quot;&quot;,
+    &quot;\&quot;.\&quot;&quot;,
+    &quot;\&quot;(\&quot;&quot;,
+    &quot;\&quot;;\&quot;&quot;,
+  };
+
+}

Added: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2CloverTokenManager.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DDL2CloverTokenManager.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2CloverTokenManager.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -0,0 +1,1197 @@
+/* Generated By:JavaCC: Do not edit this line. DML2CloverTokenManager.java */
+package org.jetel.util.ddl2clover;
+import java.util.*;
+import java.io.*;
+import org.jetel.metadata.*;
+import java.math.*;
+
+public class DDL2CloverTokenManager implements DDL2CloverConstants
+{
+  public  java.io.PrintStream debugStream = System.out;
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_0(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 &amp; 0x7ffffffff000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            return 25;
+         }
+         if ((active0 &amp; 0x100000000000000L) != 0L)
+            return 7;
+         return -1;
+      case 1:
+         if ((active0 &amp; 0x7ff7fffff000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 1;
+            return 25;
+         }
+         if ((active0 &amp; 0x800000000L) != 0L)
+            return 25;
+         return -1;
+      case 2:
+         if ((active0 &amp; 0x7ff7479ff000L) != 0L)
+         {
+            if (jjmatchedPos != 2)
+            {
+               jjmatchedKind = 51;
+               jjmatchedPos = 2;
+            }
+            return 25;
+         }
+         if ((active0 &amp; 0xb8600000L) != 0L)
+            return 25;
+         return -1;
+      case 3:
+         if ((active0 &amp; 0x7f7657c61000L) != 0L)
+         {
+            if (jjmatchedPos != 3)
+            {
+               jjmatchedKind = 51;
+               jjmatchedPos = 3;
+            }
+            return 25;
+         }
+         if ((active0 &amp; 0x810019e000L) != 0L)
+            return 25;
+         return -1;
+      case 4:
+         if ((active0 &amp; 0x20042000000L) != 0L)
+            return 25;
+         if ((active0 &amp; 0x7d7615d69000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 4;
+            return 25;
+         }
+         return -1;
+      case 5:
+         if ((active0 &amp; 0x6d7410d09000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 5;
+            return 25;
+         }
+         if ((active0 &amp; 0x100205060000L) != 0L)
+            return 25;
+         return -1;
+      case 6:
+         if ((active0 &amp; 0xd5000108000L) != 0L)
+         {
+            if (jjmatchedPos != 6)
+            {
+               jjmatchedKind = 51;
+               jjmatchedPos = 6;
+            }
+            return 25;
+         }
+         if ((active0 &amp; 0x602410c01000L) != 0L)
+            return 25;
+         return -1;
+      case 7:
+         if ((active0 &amp; 0x400000000000L) != 0L)
+            return 24;
+         if ((active0 &amp; 0x11000100000L) != 0L)
+            return 25;
+         if ((active0 &amp; 0xc4000008000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 7;
+            return 25;
+         }
+         return -1;
+      case 8:
+         if ((active0 &amp; 0x4000000000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 8;
+            return 25;
+         }
+         if ((active0 &amp; 0xc0000008000L) != 0L)
+            return 25;
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_0(int pos, long active0)
+{
+   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
+}
+private final int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private final int jjStartNfaWithStates_0(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_0(state, pos + 1);
+}
+private final int jjMoveStringLiteralDfa0_0()
+{
+   switch(curChar)
+   {
+      case 10:
+         jjmatchedKind = 3;
+         return jjMoveStringLiteralDfa1_0(0x20L);
+      case 40:
+         return jjStopAtPos(0, 57);
+      case 41:
+         return jjStopAtPos(0, 54);
+      case 44:
+         return jjStopAtPos(0, 55);
+      case 46:
+         return jjStartNfaWithStates_0(0, 56, 7);
+      case 47:
+         return jjMoveStringLiteralDfa1_0(0x240L);
+      case 59:
+         return jjStopAtPos(0, 58);
+      case 66:
+      case 98:
+         return jjMoveStringLiteralDfa1_0(0x3000L);
+      case 67:
+      case 99:
+         return jjMoveStringLiteralDfa1_0(0x7c000L);
+      case 68:
+      case 100:
+         return jjMoveStringLiteralDfa1_0(0x1f80000L);
+      case 70:
+      case 102:
+         return jjMoveStringLiteralDfa1_0(0x2000000L);
+      case 71:
+      case 103:
+         return jjMoveStringLiteralDfa1_0(0x4000000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa1_0(0x18000000L);
+      case 75:
+      case 107:
+         return jjMoveStringLiteralDfa1_0(0x20000000L);
+      case 76:
+      case 108:
+         return jjMoveStringLiteralDfa1_0(0x40000000L);
+      case 78:
+      case 110:
+         return jjMoveStringLiteralDfa1_0(0x780000000L);
+      case 79:
+      case 111:
+         return jjMoveStringLiteralDfa1_0(0x800000000L);
+      case 80:
+      case 112:
+         return jjMoveStringLiteralDfa1_0(0x3000000000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa1_0(0xc000000000L);
+      case 83:
+      case 115:
+         return jjMoveStringLiteralDfa1_0(0x10000000000L);
+      case 84:
+      case 116:
+         return jjMoveStringLiteralDfa1_0(0xe0000000000L);
+      case 85:
+      case 117:
+         return jjMoveStringLiteralDfa1_0(0x100000000000L);
+      case 86:
+      case 118:
+         return jjMoveStringLiteralDfa1_0(0x600000000000L);
+      default :
+         return jjMoveNfa_0(0, 0);
+   }
+}
+private final int jjMoveStringLiteralDfa1_0(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 13:
+         if ((active0 &amp; 0x20L) != 0L)
+            return jjStopAtPos(1, 5);
+         break;
+      case 42:
+         if ((active0 &amp; 0x40L) != 0L)
+            return jjStopAtPos(1, 6);
+         break;
+      case 47:
+         if ((active0 &amp; 0x200L) != 0L)
+            return jjStopAtPos(1, 9);
+         break;
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa2_0(active0, 0x620000180000L);
+      case 69:
+      case 101:
+         return jjMoveStringLiteralDfa2_0(active0, 0x84021e00000L);
+      case 72:
+      case 104:
+         return jjMoveStringLiteralDfa2_0(active0, 0xc000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa2_0(active0, 0x40000000000L);
+      case 76:
+      case 108:
+         return jjMoveStringLiteralDfa2_0(active0, 0x6012000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa2_0(active0, 0x10000000000L);
+      case 78:
+      case 110:
+         if ((active0 &amp; 0x800000000L) != 0L)
+            return jjStartNfaWithStates_0(1, 35, 25);
+         return jjMoveStringLiteralDfa2_0(active0, 0x100018000000L);
+      case 79:
+      case 111:
+         return jjMoveStringLiteralDfa2_0(active0, 0x80c0021000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa2_0(active0, 0x3000040000L);
+      case 85:
+      case 117:
+         return jjMoveStringLiteralDfa2_0(active0, 0x700000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(0, active0);
+}
+private final int jjMoveStringLiteralDfa2_0(long old0, long active0)
+{
+   if (((active0 &amp;= old0)) == 0L)
+      return jjStartNfa_0(0, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(1, active0);
+      return 2;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa3_0(active0, 0x1000000c000L);
+      case 66:
+      case 98:
+         return jjMoveStringLiteralDfa3_0(active0, 0x20000000000L);
+      case 67:
+      case 99:
+         if ((active0 &amp; 0x200000L) != 0L)
+         {
+            jjmatchedKind = 21;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x40400000L);
+      case 69:
+      case 101:
+         return jjMoveStringLiteralDfa3_0(active0, 0x1000040000L);
+      case 70:
+      case 102:
+         return jjMoveStringLiteralDfa3_0(active0, 0x4000800000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa3_0(active0, 0x102000000000L);
+      case 76:
+      case 108:
+         return jjMoveStringLiteralDfa3_0(active0, 0x101000000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa3_0(active0, 0xc0600020000L);
+      case 79:
+      case 111:
+         return jjMoveStringLiteralDfa3_0(active0, 0x6013000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa3_0(active0, 0x600000000000L);
+      case 84:
+      case 116:
+         if ((active0 &amp; 0x8000000L) != 0L)
+         {
+            jjmatchedKind = 27;
+            jjmatchedPos = 2;
+         }
+         else if ((active0 &amp; 0x80000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 31, 25);
+         return jjMoveStringLiteralDfa3_0(active0, 0x10180000L);
+      case 87:
+      case 119:
+         return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L);
+      case 89:
+      case 121:
+         if ((active0 &amp; 0x20000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 29, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(1, active0);
+}
+private final int jjMoveStringLiteralDfa3_0(long old0, long active0)
+{
+   if (((active0 &amp;= old0)) == 0L)
+      return jjStartNfa_0(1, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(2, active0);
+      return 3;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa4_0(active0, 0x42840000L);
+      case 66:
+      case 98:
+         if ((active0 &amp; 0x2000L) != 0L)
+            return jjStartNfaWithStates_0(3, 13, 25);
+         else if ((active0 &amp; 0x10000L) != 0L)
+            return jjStartNfaWithStates_0(3, 16, 25);
+         return jjMoveStringLiteralDfa4_0(active0, 0x204000000L);
+      case 67:
+      case 99:
+         return jjMoveStringLiteralDfa4_0(active0, 0x600000000000L);
+      case 69:
+      case 101:
+         if ((active0 &amp; 0x80000L) != 0L)
+         {
+            jjmatchedKind = 19;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x44411100000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa4_0(active0, 0x400000L);
+      case 76:
+      case 108:
+         if ((active0 &amp; 0x100000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 32, 25);
+         return jjMoveStringLiteralDfa4_0(active0, 0x30000001000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa4_0(active0, 0x2000020000L);
+      case 80:
+      case 112:
+         return jjMoveStringLiteralDfa4_0(active0, 0x80000000000L);
+      case 81:
+      case 113:
+         return jjMoveStringLiteralDfa4_0(active0, 0x100000000000L);
+      case 82:
+      case 114:
+         if ((active0 &amp; 0x4000L) != 0L)
+         {
+            jjmatchedKind = 14;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x8000L);
+      case 83:
+      case 115:
+         if ((active0 &amp; 0x8000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 39, 25);
+         return jjMoveStringLiteralDfa4_0(active0, 0x1000000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(2, active0);
+}
+private final int jjMoveStringLiteralDfa4_0(long old0, long active0)
+{
+   if (((active0 &amp;= old0)) == 0L)
+      return jjStartNfa_0(2, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(3, active0);
+      return 4;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa5_0(active0, 0x2004008000L);
+      case 69:
+      case 101:
+         if ((active0 &amp; 0x20000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 41, 25);
+         return jjMoveStringLiteralDfa5_0(active0, 0x1200001000L);
+      case 71:
+      case 103:
+         return jjMoveStringLiteralDfa5_0(active0, 0x10000000L);
+      case 72:
+      case 104:
+         return jjMoveStringLiteralDfa5_0(active0, 0x600000000000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa5_0(active0, 0x20000L);
+      case 76:
+      case 108:
+         if ((active0 &amp; 0x40000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 30, 25);
+         return jjMoveStringLiteralDfa5_0(active0, 0x10000000000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa5_0(active0, 0x400000L);
+      case 79:
+      case 111:
+         return jjMoveStringLiteralDfa5_0(active0, 0x80000000000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa5_0(active0, 0x4400000000L);
+      case 83:
+      case 115:
+         return jjMoveStringLiteralDfa5_0(active0, 0x40000000000L);
+      case 84:
+      case 116:
+         if ((active0 &amp; 0x2000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 25, 25);
+         return jjMoveStringLiteralDfa5_0(active0, 0x1140000L);
+      case 85:
+      case 117:
+         return jjMoveStringLiteralDfa5_0(active0, 0x100000800000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(3, active0);
+}
+private final int jjMoveStringLiteralDfa5_0(long old0, long active0)
+{
+   if (((active0 &amp;= old0)) == 0L)
+      return jjStartNfa_0(3, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(4, active0);
+      return 5;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa6_0(active0, 0x600000401000L);
+      case 67:
+      case 99:
+         return jjMoveStringLiteralDfa6_0(active0, 0x8000L);
+      case 69:
+      case 101:
+         if ((active0 &amp; 0x40000L) != 0L)
+            return jjStartNfaWithStates_0(5, 18, 25);
+         else if ((active0 &amp; 0x1000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 24, 25);
+         else if ((active0 &amp; 0x100000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 44, 25);
+         return jjMoveStringLiteralDfa6_0(active0, 0x4010000000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa6_0(active0, 0x10400100000L);
+      case 76:
+      case 108:
+         if ((active0 &amp; 0x4000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 26, 25);
+         return jjMoveStringLiteralDfa6_0(active0, 0x800000L);
+      case 82:
+      case 114:
+         if ((active0 &amp; 0x200000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 33, 25);
+         return jjMoveStringLiteralDfa6_0(active0, 0x83000000000L);
+      case 84:
+      case 116:
+         if ((active0 &amp; 0x20000L) != 0L)
+            return jjStartNfaWithStates_0(5, 17, 25);
+         return jjMoveStringLiteralDfa6_0(active0, 0x40000000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(4, active0);
+}
+private final int jjMoveStringLiteralDfa6_0(long old0, long active0)
+{
+   if (((active0 &amp;= old0)) == 0L)
+      return jjStartNfa_0(4, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(5, active0);
+      return 6;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa7_0(active0, 0xc0000000000L);
+      case 67:
+      case 99:
+         if ((active0 &amp; 0x400000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 34, 25);
+         break;
+      case 76:
+      case 108:
+         if ((active0 &amp; 0x400000L) != 0L)
+            return jjStartNfaWithStates_0(6, 22, 25);
+         break;
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa7_0(active0, 0x100000L);
+      case 78:
+      case 110:
+         if ((active0 &amp; 0x1000L) != 0L)
+            return jjStartNfaWithStates_0(6, 12, 25);
+         return jjMoveStringLiteralDfa7_0(active0, 0x14000000000L);
+      case 82:
+      case 114:
+         if ((active0 &amp; 0x10000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 28, 25);
+         else if ((active0 &amp; 0x200000000000L) != 0L)
+         {
+            jjmatchedKind = 45;
+            jjmatchedPos = 6;
+         }
+         return jjMoveStringLiteralDfa7_0(active0, 0x400000000000L);
+      case 84:
+      case 116:
+         if ((active0 &amp; 0x800000L) != 0L)
+            return jjStartNfaWithStates_0(6, 23, 25);
+         return jjMoveStringLiteralDfa7_0(active0, 0x8000L);
+      case 86:
+      case 118:
+         return jjMoveStringLiteralDfa7_0(active0, 0x1000000000L);
+      case 89:
+      case 121:
+         if ((active0 &amp; 0x2000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 37, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(5, active0);
+}
+private final int jjMoveStringLiteralDfa7_0(long old0, long active0)
+{
+   if (((active0 &amp;= old0)) == 0L)
+      return jjStartNfa_0(5, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(6, active0);
+      return 7;
+   }
+   switch(curChar)
+   {
+      case 50:
+         if ((active0 &amp; 0x400000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 46, 24);
+         break;
+      case 67:
+      case 99:
+         return jjMoveStringLiteralDfa8_0(active0, 0x4000000000L);
+      case 69:
+      case 101:
+         if ((active0 &amp; 0x100000L) != 0L)
+            return jjStartNfaWithStates_0(7, 20, 25);
+         else if ((active0 &amp; 0x1000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 36, 25);
+         return jjMoveStringLiteralDfa8_0(active0, 0x8000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa8_0(active0, 0x40000000000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa8_0(active0, 0x80000000000L);
+      case 84:
+      case 116:
+         if ((active0 &amp; 0x10000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 40, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(6, active0);
+}
+private final int jjMoveStringLiteralDfa8_0(long old0, long active0)
+{
+   if (((active0 &amp;= old0)) == 0L)
+      return jjStartNfa_0(6, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(7, active0);
+      return 8;
+   }
+   switch(curChar)
+   {
+      case 69:
+      case 101:
+         return jjMoveStringLiteralDfa9_0(active0, 0x4000000000L);
+      case 80:
+      case 112:
+         if ((active0 &amp; 0x40000000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 42, 25);
+         break;
+      case 82:
+      case 114:
+         if ((active0 &amp; 0x8000L) != 0L)
+            return jjStartNfaWithStates_0(8, 15, 25);
+         break;
+      case 89:
+      case 121:
+         if ((active0 &amp; 0x80000000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 43, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(7, active0);
+}
+private final int jjMoveStringLiteralDfa9_0(long old0, long active0)
+{
+   if (((active0 &amp;= old0)) == 0L)
+      return jjStartNfa_0(7, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(8, active0);
+      return 9;
+   }
+   switch(curChar)
+   {
+      case 83:
+      case 115:
+         if ((active0 &amp; 0x4000000000L) != 0L)
+            return jjStartNfaWithStates_0(9, 38, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(8, active0);
+}
+private final void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private final void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private final void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+private final void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+private final void jjCheckNAddStates(int start)
+{
+   jjCheckNAdd(jjnextStates[start]);
+   jjCheckNAdd(jjnextStates[start + 1]);
+}
+static final long[] jjbitVec0 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+private final int jjMoveNfa_0(int startState, int curPos)
+{
+   int[] nextStates;
+   int startsAt = 0;
+   jjnewStateCnt = 25;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int j, kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar &lt; 64)
+      {
+         long l = 1L &lt;&lt; curChar;
+         MatchLoop: do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x3ff000000000000L &amp; l) != 0L)
+                  {
+                     if (kind &gt; 48)
+                        kind = 48;
+                     jjCheckNAddStates(0, 4);
+                  }
+                  else if (curChar == 46)
+                     jjCheckNAdd(7);
+                  else if (curChar == 39)
+                     jjCheckNAddStates(5, 7);
+                  break;
+               case 25:
+               case 24:
+                  if ((0x3ff001800000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 51)
+                     kind = 51;
+                  jjCheckNAdd(24);
+                  break;
+               case 1:
+                  if ((0xffffff7fffffffffL &amp; l) != 0L)
+                     jjCheckNAddStates(5, 7);
+                  break;
+               case 2:
+                  if (curChar == 39)
+                     jjCheckNAddStates(8, 10);
+                  break;
+               case 3:
+                  if (curChar == 39)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  break;
+               case 4:
+                  if ((0xffffff7fffffffffL &amp; l) != 0L)
+                     jjCheckNAddStates(8, 10);
+                  break;
+               case 5:
+                  if (curChar == 39 &amp;&amp; kind &gt; 47)
+                     kind = 47;
+                  break;
+               case 6:
+                  if (curChar == 46)
+                     jjCheckNAdd(7);
+                  break;
+               case 7:
+                  if ((0x3ff000000000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 49)
+                     kind = 49;
+                  jjCheckNAddTwoStates(7, 8);
+                  break;
+               case 9:
+                  if ((0x280000000000L &amp; l) != 0L)
+                     jjCheckNAdd(10);
+                  break;
+               case 10:
+                  if ((0x3ff000000000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 49)
+                     kind = 49;
+                  jjCheckNAdd(10);
+                  break;
+               case 11:
+                  if ((0x3ff000000000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 48)
+                     kind = 48;
+                  jjCheckNAddStates(0, 4);
+                  break;
+               case 12:
+                  if ((0x3ff000000000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 48)
+                     kind = 48;
+                  jjCheckNAdd(12);
+                  break;
+               case 13:
+                  if ((0x3ff000000000000L &amp; l) != 0L)
+                     jjCheckNAddTwoStates(13, 14);
+                  break;
+               case 14:
+                  if (curChar == 46)
+                     jjCheckNAdd(15);
+                  break;
+               case 15:
+                  if ((0x3ff000000000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 49)
+                     kind = 49;
+                  jjCheckNAddTwoStates(15, 16);
+                  break;
+               case 17:
+                  if ((0x280000000000L &amp; l) != 0L)
+                     jjCheckNAdd(18);
+                  break;
+               case 18:
+                  if ((0x3ff000000000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 49)
+                     kind = 49;
+                  jjCheckNAdd(18);
+                  break;
+               case 19:
+                  if ((0x3ff000000000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 49)
+                     kind = 49;
+                  jjCheckNAddTwoStates(19, 20);
+                  break;
+               case 21:
+                  if ((0x280000000000L &amp; l) != 0L)
+                     jjCheckNAdd(22);
+                  break;
+               case 22:
+                  if ((0x3ff000000000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 49)
+                     kind = 49;
+                  jjCheckNAdd(22);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar &lt; 128)
+      {
+         long l = 1L &lt;&lt; (curChar &amp; 077);
+         MatchLoop: do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 23:
+                  if ((0x7fffffe07fffffeL &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 51)
+                     kind = 51;
+                  jjCheckNAddTwoStates(23, 24);
+                  break;
+               case 25:
+                  if ((0x7fffffe87fffffeL &amp; l) != 0L)
+                  {
+                     if (kind &gt; 51)
+                        kind = 51;
+                     jjCheckNAdd(24);
+                  }
+                  if ((0x7fffffe07fffffeL &amp; l) != 0L)
+                  {
+                     if (kind &gt; 51)
+                        kind = 51;
+                     jjCheckNAddTwoStates(23, 24);
+                  }
+                  break;
+               case 1:
+                  jjCheckNAddStates(5, 7);
+                  break;
+               case 4:
+                  jjCheckNAddStates(8, 10);
+                  break;
+               case 8:
+                  if ((0x2000000020L &amp; l) != 0L)
+                     jjAddStates(11, 12);
+                  break;
+               case 16:
+                  if ((0x2000000020L &amp; l) != 0L)
+                     jjAddStates(13, 14);
+                  break;
+               case 20:
+                  if ((0x2000000020L &amp; l) != 0L)
+                     jjAddStates(15, 16);
+                  break;
+               case 24:
+                  if ((0x7fffffe87fffffeL &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 51)
+                     kind = 51;
+                  jjCheckNAdd(24);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int i2 = (curChar &amp; 0xff) &gt;&gt; 6;
+         long l2 = 1L &lt;&lt; (curChar &amp; 077);
+         MatchLoop: do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 1:
+                  if ((jjbitVec0[i2] &amp; l2) != 0L)
+                     jjCheckNAddStates(5, 7);
+                  break;
+               case 4:
+                  if ((jjbitVec0[i2] &amp; l2) != 0L)
+                     jjCheckNAddStates(8, 10);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 25 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private final int jjMoveStringLiteralDfa0_2()
+{
+   switch(curChar)
+   {
+      case 10:
+         return jjStopAtPos(0, 10);
+      default :
+         return 1;
+   }
+}
+private final int jjMoveStringLiteralDfa0_1()
+{
+   switch(curChar)
+   {
+      case 42:
+         return jjMoveStringLiteralDfa1_1(0x80L);
+      default :
+         return 1;
+   }
+}
+private final int jjMoveStringLiteralDfa1_1(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 47:
+         if ((active0 &amp; 0x80L) != 0L)
+            return jjStopAtPos(1, 7);
+         break;
+      default :
+         return 2;
+   }
+   return 2;
+}
+static final int[] jjnextStates = {
+   12, 13, 14, 19, 20, 1, 3, 5, 3, 4, 5, 9, 10, 17, 18, 21, 
+   22, 
+};
+public static final String[] jjstrLiteralImages = {
+&quot;&quot;, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, &quot;\51&quot;, 
+&quot;\54&quot;, &quot;\56&quot;, &quot;\50&quot;, &quot;\73&quot;, };
+public static final String[] lexStateNames = {
+   &quot;DEFAULT&quot;, 
+   &quot;WithinComment&quot;, 
+   &quot;WithinLineComment&quot;, 
+};
+public static final int[] jjnewLexState = {
+   -1, -1, -1, -1, -1, -1, 1, 0, -1, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+};
+static final long[] jjtoToken = {
+   0x7fbfffffffff001L, 
+};
+static final long[] jjtoSkip = {
+   0x6feL, 
+};
+static final long[] jjtoSpecial = {
+   0x6c0L, 
+};
+static final long[] jjtoMore = {
+   0x900L, 
+};
+protected SimpleCharStream input_stream;
+private final int[] jjrounds = new int[25];
+private final int[] jjstateSet = new int[50];
+StringBuffer image;
+int jjimageLen;
+int lengthOfMatch;
+protected char curChar;
+public DDL2CloverTokenManager(SimpleCharStream stream){
+   if (SimpleCharStream.staticFlag)
+      throw new Error(&quot;ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.&quot;);
+   input_stream = stream;
+}
+public DDL2CloverTokenManager(SimpleCharStream stream, int lexState){
+   this(stream);
+   SwitchTo(lexState);
+}
+public void ReInit(SimpleCharStream stream)
+{
+   jjmatchedPos = jjnewStateCnt = 0;
+   curLexState = defaultLexState;
+   input_stream = stream;
+   ReInitRounds();
+}
+private final void ReInitRounds()
+{
+   int i;
+   jjround = 0x80000001;
+   for (i = 25; i-- &gt; 0;)
+      jjrounds[i] = 0x80000000;
+}
+public void ReInit(SimpleCharStream stream, int lexState)
+{
+   ReInit(stream);
+   SwitchTo(lexState);
+}
+public void SwitchTo(int lexState)
+{
+   if (lexState &gt;= 3 || lexState &lt; 0)
+      throw new TokenMgrError(&quot;Error: Ignoring invalid lexical state : &quot; + lexState + &quot;. State unchanged.&quot;, TokenMgrError.INVALID_LEXICAL_STATE);
+   else
+      curLexState = lexState;
+}
+
+protected Token jjFillToken()
+{
+   Token t = Token.newToken(jjmatchedKind);
+   t.kind = jjmatchedKind;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   t.image = (im == null) ? input_stream.GetImage() : im;
+   t.beginLine = input_stream.getBeginLine();
+   t.beginColumn = input_stream.getBeginColumn();
+   t.endLine = input_stream.getEndLine();
+   t.endColumn = input_stream.getEndColumn();
+   return t;
+}
+
+int curLexState = 0;
+int defaultLexState = 0;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+public Token getNextToken() 
+{
+  int kind;
+  Token specialToken = null;
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {   
+   try   
+   {     
+      curChar = input_stream.BeginToken();
+   }     
+   catch(java.io.IOException e)
+   {        
+      jjmatchedKind = 0;
+      matchedToken = jjFillToken();
+      matchedToken.specialToken = specialToken;
+      return matchedToken;
+   }
+   image = null;
+   jjimageLen = 0;
+
+   for (;;)
+   {
+     switch(curLexState)
+     {
+       case 0:
+         try { input_stream.backup(0);
+            while (curChar &lt;= 32 &amp;&amp; (0x100002200L &amp; (1L &lt;&lt; curChar)) != 0L)
+               curChar = input_stream.BeginToken();
+         }
+         catch (java.io.IOException e1) { continue EOFLoop; }
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_0();
+         break;
+       case 1:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_1();
+         if (jjmatchedPos == 0 &amp;&amp; jjmatchedKind &gt; 8)
+         {
+            jjmatchedKind = 8;
+         }
+         break;
+       case 2:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_2();
+         if (jjmatchedPos == 0 &amp;&amp; jjmatchedKind &gt; 11)
+         {
+            jjmatchedKind = 11;
+         }
+         break;
+     }
+     if (jjmatchedKind != 0x7fffffff)
+     {
+        if (jjmatchedPos + 1 &lt; curPos)
+           input_stream.backup(curPos - jjmatchedPos - 1);
+        if ((jjtoToken[jjmatchedKind &gt;&gt; 6] &amp; (1L &lt;&lt; (jjmatchedKind &amp; 077))) != 0L)
+        {
+           matchedToken = jjFillToken();
+           matchedToken.specialToken = specialToken;
+       if (jjnewLexState[jjmatchedKind] != -1)
+         curLexState = jjnewLexState[jjmatchedKind];
+           return matchedToken;
+        }
+        else if ((jjtoSkip[jjmatchedKind &gt;&gt; 6] &amp; (1L &lt;&lt; (jjmatchedKind &amp; 077))) != 0L)
+        {
+           if ((jjtoSpecial[jjmatchedKind &gt;&gt; 6] &amp; (1L &lt;&lt; (jjmatchedKind &amp; 077))) != 0L)
+           {
+              matchedToken = jjFillToken();
+              if (specialToken == null)
+                 specialToken = matchedToken;
+              else
+              {
+                 matchedToken.specialToken = specialToken;
+                 specialToken = (specialToken.next = matchedToken);
+              }
+              SkipLexicalActions(matchedToken);
+           }
+           else 
+              SkipLexicalActions(null);
+         if (jjnewLexState[jjmatchedKind] != -1)
+           curLexState = jjnewLexState[jjmatchedKind];
+           continue EOFLoop;
+        }
+        jjimageLen += jjmatchedPos + 1;
+      if (jjnewLexState[jjmatchedKind] != -1)
+        curLexState = jjnewLexState[jjmatchedKind];
+        curPos = 0;
+        jjmatchedKind = 0x7fffffff;
+        try {
+           curChar = input_stream.readChar();
+           continue;
+        }
+        catch (java.io.IOException e1) { }
+     }
+     int error_line = input_stream.getEndLine();
+     int error_column = input_stream.getEndColumn();
+     String error_after = null;
+     boolean EOFSeen = false;
+     try { input_stream.readChar(); input_stream.backup(1); }
+     catch (java.io.IOException e1) {
+        EOFSeen = true;
+        error_after = curPos &lt;= 1 ? &quot;&quot; : input_stream.GetImage();
+        if (curChar == '\n' || curChar == '\r') {
+           error_line++;
+           error_column = 0;
+        }
+        else
+           error_column++;
+     }
+     if (!EOFSeen) {
+        input_stream.backup(1);
+        error_after = curPos &lt;= 1 ? &quot;&quot; : input_stream.GetImage();
+     }
+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+   }
+  }
+}
+
+void SkipLexicalActions(Token matchedToken)
+{
+   switch(jjmatchedKind)
+   {
+      default :
+         break;
+   }
+}
+}

Deleted: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2Clover.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2Clover.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2Clover.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -1,881 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. DML2Clover.java */
-package org.jetel.util.dml2clover;
-
-import java.util.*;
-import java.io.*;
-import org.jetel.metadata.*;
-import java.math.*;
-
-public class DML2Clover implements DML2CloverConstants {
-
-        /**
-		 * The class parses sql script containing only create statements. Output is a DataRecordMetadata List.
-		 */
-
-        private List&lt;DataRecordMetadata&gt; list = new LinkedList&lt;DataRecordMetadata&gt;();
-        private String fieldDelimiter;
-        private String recordDelimiter;
-
-        private static final Long booleanLenght = Long.valueOf(5); // false / true
-        private static final Long byteLenght = Long.valueOf(String.valueOf(Byte.MIN_VALUE).length());
-        private static final Long integerLenght = Long.valueOf(String.valueOf(Integer.MIN_VALUE).length());
-        private static final Long longLenght = Long.valueOf(String.valueOf(Long.MIN_VALUE).length());
-        private static final Long floatLenght = Long.valueOf(String.valueOf(7));
-        private static final Long doubleLenght = Long.valueOf(String.valueOf(15));
-        private static final Long dateLenght = Long.valueOf(10); // &quot;10.10.2007&quot;
-        private static final Long dateTimeLenght = Long.valueOf(24); // &quot;10.10.2007 23:10:10.111&quot;
-
-        public static void main(String args[]) throws ParseException, FileNotFoundException {
-                DML2Clover parser = new DML2Clover(new FileInputStream(new File(&quot;text.txt&quot;)));
-                parser.getDataRecordMetadataList(&quot;;&quot;, &quot;\n&quot;);
-                parser.testPrint(parser.list);
-                System.out.println(&quot;Ok&quot;);
-        }
-
-        public List&lt;DataRecordMetadata&gt; getDataRecordMetadataList() throws ParseException {
-                return getDataRecordMetadataList(null, null);
-        }
-
-        public List&lt;DataRecordMetadata&gt; getDataRecordMetadataList(String fieldDelimiter, String recordDelimiter) throws ParseException {
-                this.fieldDelimiter = fieldDelimiter;
-                this.recordDelimiter = recordDelimiter;
-                while (!isEOF()) {
-                        list.add(createTableStatement());
-                }
-                return list;
-        }
-
-        private void testPrint(List&lt;DataRecordMetadata&gt; list) {
-                DataRecordMetadataXMLReaderWriter writer = new DataRecordMetadataXMLReaderWriter();
-                for (DataRecordMetadata dataRecordMetadata : list) {
-                        writer.write(dataRecordMetadata, System.out);
-                        System.out.println();
-                }
-        }
-
-/*******************************************************************
- * The SQL syntatic grammar starts here
- *******************************************************************/
-  final public DataRecordMetadata createTableStatement() throws ParseException {
-        DataRecordMetadata dataRecordMetadata;
-        List&lt;DataFieldMetadata&gt; list;
-    jj_consume_token(CREATE);
-    switch (jj_nt.kind) {
-    case GLOBAL:
-    case LOCAL:
-    case TEMPORARY:
-      tableScope();
-      break;
-    default:
-      jj_la1[0] = jj_gen;
-      ;
-    }
-    jj_consume_token(TABLE);
-    if (jj_2_1(2)) {
-      jj_consume_token(IDENTIFIER);
-      jj_consume_token(DOT);
-    } else {
-      ;
-    }
-                                                                           dataRecordMetadata = new DataRecordMetadata(identifier());
-                        list = tableElementList();
-                        for (DataFieldMetadata field : list) {
-                                dataRecordMetadata.addField(field);
-                        }
-    switch (jj_nt.kind) {
-    case ON:
-      jj_consume_token(ON);
-      jj_consume_token(COMMIT);
-      switch (jj_nt.kind) {
-      case DELETE:
-      case PRESERVE:
-        switch (jj_nt.kind) {
-        case PRESERVE:
-          jj_consume_token(PRESERVE);
-          break;
-        case DELETE:
-          jj_consume_token(DELETE);
-          break;
-        default:
-          jj_la1[1] = jj_gen;
-          jj_consume_token(-1);
-          throw new ParseException();
-        }
-        break;
-      default:
-        jj_la1[2] = jj_gen;
-        ;
-      }
-      jj_consume_token(ROWS);
-      break;
-    default:
-      jj_la1[3] = jj_gen;
-      ;
-    }
-    jj_consume_token(SEMICOLON);
-                if (fieldDelimiter != null &amp;&amp; recordDelimiter != null) {
-                        dataRecordMetadata.setRecType(DataRecordMetadata.DELIMITED_RECORD);
-                } else if (fieldDelimiter == null &amp;&amp; recordDelimiter == null) {
-                        dataRecordMetadata.setRecType(DataRecordMetadata.FIXEDLEN_RECORD);
-                }
-          {if (true) return dataRecordMetadata;}
-    throw new Error(&quot;Missing return statement in function&quot;);
-  }
-
-  final public List&lt;DataFieldMetadata&gt; tableElementList() throws ParseException {
-        List&lt;DataFieldMetadata&gt; list = new LinkedList&lt;DataFieldMetadata&gt;();
-        DataFieldMetadata ret;
-    jj_consume_token(OPENPAREN);
-    ret = tableElement();
-                ret.setDelimiter(fieldDelimiter);
-                list.add(ret);
-    label_1:
-    while (true) {
-      switch (jj_nt.kind) {
-      case COMA:
-        ;
-        break;
-      default:
-        jj_la1[4] = jj_gen;
-        break label_1;
-      }
-      jj_consume_token(COMA);
-      ret = tableElement();
-                ret.setDelimiter(fieldDelimiter);
-                list.add(ret);
-    }
-         ret.setDelimiter(recordDelimiter);
-    jj_consume_token(CLOSEPAREN);
-          {if (true) return list;}
-    throw new Error(&quot;Missing return statement in function&quot;);
-  }
-
-  final public void tableScope() throws ParseException {
-    switch (jj_nt.kind) {
-    case GLOBAL:
-    case LOCAL:
-      switch (jj_nt.kind) {
-      case GLOBAL:
-        jj_consume_token(GLOBAL);
-        break;
-      case LOCAL:
-        jj_consume_token(LOCAL);
-        break;
-      default:
-        jj_la1[5] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-      break;
-    default:
-      jj_la1[6] = jj_gen;
-      ;
-    }
-    jj_consume_token(TEMPORARY);
-  }
-
-  final public boolean isEOF() throws ParseException {
-        boolean isEof = false;
-    switch (jj_nt.kind) {
-    case 0:
-      jj_consume_token(0);
-      isEof = t();
-      break;
-    default:
-      jj_la1[7] = jj_gen;
-      ;
-    }
-         {if (true) return isEof;}
-    throw new Error(&quot;Missing return statement in function&quot;);
-  }
-
-  final public boolean t() throws ParseException {
-         {if (true) return true;}
-    throw new Error(&quot;Missing return statement in function&quot;);
-  }
-
-//+
-  final public void columnConstraintDefinition() throws ParseException {
-    switch (jj_nt.kind) {
-    case NOT:
-      jj_consume_token(NOT);
-      jj_consume_token(NULL);
-      break;
-    case UNIQUE:
-      jj_consume_token(UNIQUE);
-      break;
-    case PRIMARY:
-      jj_consume_token(PRIMARY);
-      jj_consume_token(KEY);
-      break;
-    case REFERENCES:
-      jj_consume_token(REFERENCES);
-      tableName();
-      jj_consume_token(OPENPAREN);
-      identifierList();
-      jj_consume_token(CLOSEPAREN);
-      break;
-    default:
-      jj_la1[8] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-  }
-
-//+
-  final public DataFieldMetadata columnDefinition() throws ParseException {
-        DataFieldMetadata dataFieldMetadata;
-        String name;
-        DataType type;
-        Object value = null;
-    name = columnName();
-    type = dataType();
-    switch (jj_nt.kind) {
-    case DEFAULT_:
-      jj_consume_token(DEFAULT_);
-      value = defaultValue();
-      break;
-    default:
-      jj_la1[9] = jj_gen;
-      ;
-    }
-    switch (jj_nt.kind) {
-    case NOT:
-    case PRIMARY:
-    case REFERENCES:
-    case UNIQUE:
-      columnConstraintDefinition();
-      break;
-    default:
-      jj_la1[10] = jj_gen;
-      ;
-    }
-          if (type.length == null) {
-                dataFieldMetadata = new DataFieldMetadata(name, type.type, null);
-          } else {
-                //dataFieldMetadata = new DataFieldMetadata(name, type.type, type.length.shortValue());
-                dataFieldMetadata = new DataFieldMetadata(name, type.type, type.length.shortValue());
-          }
-          dataFieldMetadata.setDefaultValue(value);
-          {if (true) return dataFieldMetadata;}
-    throw new Error(&quot;Missing return statement in function&quot;);
-  }
-
-  final public DataFieldMetadata tableElement() throws ParseException {
-        DataFieldMetadata ret = null;
-    ret = columnDefinition();
-          {if (true) return ret;}
-    throw new Error(&quot;Missing return statement in function&quot;);
-  }
-
-//+
-  final public String columnName() throws ParseException {
-        String ret;
-    if (jj_2_2(2)) {
-      identifier();
-      jj_consume_token(DOT);
-    } else {
-      ;
-    }
-    ret = identifier();
-          {if (true) return ret;}
-    throw new Error(&quot;Missing return statement in function&quot;);
-  }
-
-//+TODO dodelat dalsi typu jako DATE, VARCHAR,...
-  final public DataType dataType() throws ParseException {
-        char type;
-        Long temp;
-        Long lenght = null;
-        Long scale = null;
-    switch (jj_nt.kind) {
-    case BOOLEAN:
-      jj_consume_token(BOOLEAN);
-                            type = DataFieldMetadata.INTEGER_FIELD;             lenght = integerLenght;
-      break;
-    case BLOB:
-      jj_consume_token(BLOB);
-                         type = DataFieldMetadata.BYTE_FIELD;
-      switch (jj_nt.kind) {
-      case OPENPAREN:
-        jj_consume_token(OPENPAREN);
-        temp = integerLiteral();
-        jj_consume_token(CLOSEPAREN);
-                                                                                                                                    lenght = temp;
-        break;
-      default:
-        jj_la1[11] = jj_gen;
-        ;
-      }
-      break;
-    case CHAR:
-      jj_consume_token(CHAR);
-                         type = DataFieldMetadata.STRING_FIELD;
-      switch (jj_nt.kind) {
-      case OPENPAREN:
-        jj_consume_token(OPENPAREN);
-        temp = integerLiteral();
-        jj_consume_token(CLOSEPAREN);
-                                                                                                                                    lenght = temp;
-        break;
-      default:
-        jj_la1[12] = jj_gen;
-        ;
-      }
-      break;
-    case CHARACTER:
-      jj_consume_token(CHARACTER);
-                              type = DataFieldMetadata.STRING_FIELD;
-      switch (jj_nt.kind) {
-      case OPENPAREN:
-        jj_consume_token(OPENPAREN);
-        temp = integerLiteral();
-        jj_consume_token(CLOSEPAREN);
-                                                                                                                            lenght = temp;
-        break;
-      default:
-        jj_la1[13] = jj_gen;
-        ;
-      }
-      break;
-    case CLOB:
-      jj_consume_token(CLOB);
-                         type = DataFieldMetadata.BYTE_FIELD;
-      switch (jj_nt.kind) {
-      case OPENPAREN:
-        jj_consume_token(OPENPAREN);
-        temp = integerLiteral();
-        jj_consume_token(CLOSEPAREN);
-                                                                                                                                    lenght = temp;
-        break;
-      default:
-        jj_la1[14] = jj_gen;
-        ;
-      }
-      break;
-    case DATE:
-      jj_consume_token(DATE);
-                         type = DataFieldMetadata.DATE_FIELD;                   lenght = dateLenght;
-      break;
-    case DATETIME:
-      jj_consume_token(DATETIME);
-                             type = DataFieldMetadata.DATE_FIELD;           lenght = dateTimeLenght;
-      break;
-    case DEC:
-      jj_consume_token(DEC);
-                        type = DataFieldMetadata.DECIMAL_FIELD;
-      switch (jj_nt.kind) {
-      case OPENPAREN:
-        jj_consume_token(OPENPAREN);
-        temp = integerLiteral();
-        switch (jj_nt.kind) {
-        case COMA:
-          jj_consume_token(COMA);
-          scale = integerLiteral();
-          break;
-        default:
-          jj_la1[15] = jj_gen;
-          ;
-        }
-        jj_consume_token(CLOSEPAREN);
-                                                                                                                                                                        lenght = temp;
-        break;
-      default:
-        jj_la1[16] = jj_gen;
-        ;
-      }
-      break;
-    case DECIMAL:
-      jj_consume_token(DECIMAL);
-                            type = DataFieldMetadata.DECIMAL_FIELD;
-      switch (jj_nt.kind) {
-      case OPENPAREN:
-        jj_consume_token(OPENPAREN);
-        temp = integerLiteral();
-        switch (jj_nt.kind) {
-        case COMA:
-          jj_consume_token(COMA);
-          scale = integerLiteral();
-          break;
-        default:
-          jj_la1[17] = jj_gen;
-          ;
-        }
-        jj_consume_token(CLOSEPAREN);
-                                                                                                                                                                lenght = temp;
-        break;
-      default:
-        jj_la1[18] = jj_gen;
-        ;
-      }
-      break;
-    case FLOAT:
-      jj_consume_token(FLOAT);
-                          type = DataFieldMetadata.NUMERIC_FIELD;               lenght = floatLenght;
-      break;
-    case INT:
-      jj_consume_token(INT);
-                        type = DataFieldMetadata.INTEGER_FIELD;                 lenght = integerLenght;
-      break;
-    case INTEGER:
-      jj_consume_token(INTEGER);
-                            type = DataFieldMetadata.INTEGER_FIELD;     lenght = integerLenght;
-      break;
-    case SMALLINT:
-      jj_consume_token(SMALLINT);
-                             type = DataFieldMetadata.INTEGER_FIELD;    lenght = integerLenght;
-      break;
-    case TIMESTAMP:
-      jj_consume_token(TIMESTAMP);
-                              type = DataFieldMetadata.DATE_FIELD;              lenght = dateTimeLenght;
-      break;
-    case NUMERIC:
-      jj_consume_token(NUMERIC);
-                            type = DataFieldMetadata.DECIMAL_FIELD;
-      switch (jj_nt.kind) {
-      case OPENPAREN:
-        jj_consume_token(OPENPAREN);
-        temp = integerLiteral();
-        switch (jj_nt.kind) {
-        case COMA:
-          jj_consume_token(COMA);
-          scale = integerLiteral();
-          break;
-        default:
-          jj_la1[19] = jj_gen;
-          ;
-        }
-        jj_consume_token(CLOSEPAREN);
-                                                                                                                                                                lenght = temp;
-        break;
-      default:
-        jj_la1[20] = jj_gen;
-        ;
-      }
-      break;
-    case VARCHAR:
-      jj_consume_token(VARCHAR);
-                            type = DataFieldMetadata.STRING_FIELD;
-      jj_consume_token(OPENPAREN);
-      temp = integerLiteral();
-      jj_consume_token(CLOSEPAREN);
-                                                                                                                           lenght = temp;
-      break;
-    case VARCHAR2:
-      jj_consume_token(VARCHAR2);
-                             type = DataFieldMetadata.STRING_FIELD;
-      jj_consume_token(OPENPAREN);
-      temp = integerLiteral();
-      jj_consume_token(CLOSEPAREN);
-                                                                                                                           lenght = temp;
-      break;
-    default:
-      jj_la1[21] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-          {if (true) return new DataType(type, lenght, scale);}
-    throw new Error(&quot;Missing return statement in function&quot;);
-  }
-
-//+
-  final public Object defaultValue() throws ParseException {
-        Object ret;
-    switch (jj_nt.kind) {
-    case STRING_LITERAL:
-    case INTEGER_LITERAL:
-    case FLOAT_LITERAL:
-      ret = literal();
-      break;
-    case NULL:
-      ret = nullLiteral();
-      break;
-    default:
-      jj_la1[22] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-          {if (true) return ret;}
-    throw new Error(&quot;Missing return statement in function&quot;);
-  }
-
-//+
-  final public BigDecimal floatLiteral() throws ParseException {
-    jj_consume_token(FLOAT_LITERAL);
-                          {if (true) return new BigDecimal(token.image);}
-    throw new Error(&quot;Missing return statement in function&quot;);
-  }
-
-//+
-  final public String identifier() throws ParseException {
-    jj_consume_token(IDENTIFIER);
-          {if (true) return token.image;}
-    throw new Error(&quot;Missing return statement in function&quot;);
-  }
-
-//+
-  final public void identifierList() throws ParseException {
-    identifier();
-    label_2:
-    while (true) {
-      switch (jj_nt.kind) {
-      case COMA:
-        ;
-        break;
-      default:
-        jj_la1[23] = jj_gen;
-        break label_2;
-      }
-      jj_consume_token(COMA);
-      identifier();
-    }
-  }
-
-//+
-  final public Object literal() throws ParseException {
-        Object ret;
-    switch (jj_nt.kind) {
-    case INTEGER_LITERAL:
-      ret = integerLiteral();
-      break;
-    case FLOAT_LITERAL:
-      ret = floatLiteral();
-      break;
-    case STRING_LITERAL:
-      ret = stringLiteral();
-      break;
-    default:
-      jj_la1[24] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-          {if (true) return ret;}
-    throw new Error(&quot;Missing return statement in function&quot;);
-  }
-
-//+
-  final public Long integerLiteral() throws ParseException {
-    jj_consume_token(INTEGER_LITERAL);
-                            {if (true) return new Long(token.image);}
-    throw new Error(&quot;Missing return statement in function&quot;);
-  }
-
-//+
-  final public Object nullLiteral() throws ParseException {
-    jj_consume_token(NULL);
-                 {if (true) return null;}
-    throw new Error(&quot;Missing return statement in function&quot;);
-  }
-
-//+
-  final public String stringLiteral() throws ParseException {
-    jj_consume_token(STRING_LITERAL);
-                String value = token.image.intern();
-                {if (true) return value.substring(1, value.length() - 1);}
-    throw new Error(&quot;Missing return statement in function&quot;);
-  }
-
-//+
-  final public void tableName() throws ParseException {
-    jj_consume_token(IDENTIFIER);
-  }
-
-  final private boolean jj_2_1(int xla) {
-    jj_la = xla; jj_lastpos = jj_scanpos = token;
-    try { return !jj_3_1(); }
-    catch(LookaheadSuccess ls) { return true; }
-    finally { jj_save(0, xla); }
-  }
-
-  final private boolean jj_2_2(int xla) {
-    jj_la = xla; jj_lastpos = jj_scanpos = token;
-    try { return !jj_3_2(); }
-    catch(LookaheadSuccess ls) { return true; }
-    finally { jj_save(1, xla); }
-  }
-
-  final private boolean jj_3R_3() {
-    if (jj_scan_token(IDENTIFIER)) return true;
-    return false;
-  }
-
-  final private boolean jj_3_2() {
-    if (jj_3R_3()) return true;
-    if (jj_scan_token(DOT)) return true;
-    return false;
-  }
-
-  final private boolean jj_3_1() {
-    if (jj_scan_token(IDENTIFIER)) return true;
-    if (jj_scan_token(DOT)) return true;
-    return false;
-  }
-
-  public DML2CloverTokenManager token_source;
-  SimpleCharStream jj_input_stream;
-  public Token token, jj_nt;
-  private Token jj_scanpos, jj_lastpos;
-  private int jj_la;
-  public boolean lookingAhead = false;
-  private boolean jj_semLA;
-  private int jj_gen;
-  final private int[] jj_la1 = new int[25];
-  static private int[] jj_la1_0;
-  static private int[] jj_la1_1;
-  static {
-      jj_la1_0();
-      jj_la1_1();
-   }
-   private static void jj_la1_0() {
-      jj_la1_0 = new int[] {0x44000000,0x1000000,0x1000000,0x0,0x0,0x44000000,0x44000000,0x1,0x80000000,0x800000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1a79f000,0x0,0x0,0x0,};
-   }
-   private static void jj_la1_1() {
-      jj_la1_1 = new int[] {0x800,0x10,0x10,0x8,0x800000,0x0,0x0,0x0,0x1060,0x0,0x1060,0x2000000,0x2000000,0x2000000,0x2000000,0x800000,0x2000000,0x800000,0x2000000,0x800000,0x2000000,0x6504,0x38001,0x800000,0x38000,};
-   }
-  final private JJCalls[] jj_2_rtns = new JJCalls[2];
-  private boolean jj_rescan = false;
-  private int jj_gc = 0;
-
-  public DML2Clover(java.io.InputStream stream) {
-     this(stream, null);
-  }
-  public DML2Clover(java.io.InputStream stream, String encoding) {
-    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
-    token_source = new DML2CloverTokenManager(jj_input_stream);
-    token = new Token();
-    token.next = jj_nt = token_source.getNextToken();
-    jj_gen = 0;
-    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
-    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  public void ReInit(java.io.InputStream stream) {
-     ReInit(stream, null);
-  }
-  public void ReInit(java.io.InputStream stream, String encoding) {
-    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
-    token_source.ReInit(jj_input_stream);
-    token = new Token();
-    token.next = jj_nt = token_source.getNextToken();
-    jj_gen = 0;
-    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
-    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  public DML2Clover(java.io.Reader stream) {
-    jj_input_stream = new SimpleCharStream(stream, 1, 1);
-    token_source = new DML2CloverTokenManager(jj_input_stream);
-    token = new Token();
-    token.next = jj_nt = token_source.getNextToken();
-    jj_gen = 0;
-    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
-    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  public void ReInit(java.io.Reader stream) {
-    jj_input_stream.ReInit(stream, 1, 1);
-    token_source.ReInit(jj_input_stream);
-    token = new Token();
-    token.next = jj_nt = token_source.getNextToken();
-    jj_gen = 0;
-    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
-    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  public DML2Clover(DML2CloverTokenManager tm) {
-    token_source = tm;
-    token = new Token();
-    token.next = jj_nt = token_source.getNextToken();
-    jj_gen = 0;
-    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
-    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  public void ReInit(DML2CloverTokenManager tm) {
-    token_source = tm;
-    token = new Token();
-    token.next = jj_nt = token_source.getNextToken();
-    jj_gen = 0;
-    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
-    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  final private Token jj_consume_token(int kind) throws ParseException {
-    Token oldToken = token;
-    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
-    else jj_nt = jj_nt.next = token_source.getNextToken();
-    if (token.kind == kind) {
-      jj_gen++;
-      if (++jj_gc &gt; 100) {
-        jj_gc = 0;
-        for (int i = 0; i &lt; jj_2_rtns.length; i++) {
-          JJCalls c = jj_2_rtns[i];
-          while (c != null) {
-            if (c.gen &lt; jj_gen) c.first = null;
-            c = c.next;
-          }
-        }
-      }
-      return token;
-    }
-    jj_nt = token;
-    token = oldToken;
-    jj_kind = kind;
-    throw generateParseException();
-  }
-
-  static private final class LookaheadSuccess extends java.lang.Error { }
-  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
-  final private boolean jj_scan_token(int kind) {
-    if (jj_scanpos == jj_lastpos) {
-      jj_la--;
-      if (jj_scanpos.next == null) {
-        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
-      } else {
-        jj_lastpos = jj_scanpos = jj_scanpos.next;
-      }
-    } else {
-      jj_scanpos = jj_scanpos.next;
-    }
-    if (jj_rescan) {
-      int i = 0; Token tok = token;
-      while (tok != null &amp;&amp; tok != jj_scanpos) { i++; tok = tok.next; }
-      if (tok != null) jj_add_error_token(kind, i);
-    }
-    if (jj_scanpos.kind != kind) return true;
-    if (jj_la == 0 &amp;&amp; jj_scanpos == jj_lastpos) throw jj_ls;
-    return false;
-  }
-
-  final public Token getNextToken() {
-    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
-    else jj_nt = jj_nt.next = token_source.getNextToken();
-    jj_gen++;
-    return token;
-  }
-
-  final public Token getToken(int index) {
-    Token t = lookingAhead ? jj_scanpos : token;
-    for (int i = 0; i &lt; index; i++) {
-      if (t.next != null) t = t.next;
-      else t = t.next = token_source.getNextToken();
-    }
-    return t;
-  }
-
-  private java.util.Vector&lt;int[]&gt; jj_expentries = new java.util.Vector&lt;int[]&gt;();
-  private int[] jj_expentry;
-  private int jj_kind = -1;
-  private int[] jj_lasttokens = new int[100];
-  private int jj_endpos;
-
-  private void jj_add_error_token(int kind, int pos) {
-    if (pos &gt;= 100) return;
-    if (pos == jj_endpos + 1) {
-      jj_lasttokens[jj_endpos++] = kind;
-    } else if (jj_endpos != 0) {
-      jj_expentry = new int[jj_endpos];
-      for (int i = 0; i &lt; jj_endpos; i++) {
-        jj_expentry[i] = jj_lasttokens[i];
-      }
-      boolean exists = false;
-      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
-        int[] oldentry = (int[])(e.nextElement());
-        if (oldentry.length == jj_expentry.length) {
-          exists = true;
-          for (int i = 0; i &lt; jj_expentry.length; i++) {
-            if (oldentry[i] != jj_expentry[i]) {
-              exists = false;
-              break;
-            }
-          }
-          if (exists) break;
-        }
-      }
-      if (!exists) jj_expentries.addElement(jj_expentry);
-      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
-    }
-  }
-
-  public ParseException generateParseException() {
-    jj_expentries.removeAllElements();
-    boolean[] la1tokens = new boolean[59];
-    for (int i = 0; i &lt; 59; i++) {
-      la1tokens[i] = false;
-    }
-    if (jj_kind &gt;= 0) {
-      la1tokens[jj_kind] = true;
-      jj_kind = -1;
-    }
-    for (int i = 0; i &lt; 25; i++) {
-      if (jj_la1[i] == jj_gen) {
-        for (int j = 0; j &lt; 32; j++) {
-          if ((jj_la1_0[i] &amp; (1&lt;&lt;j)) != 0) {
-            la1tokens[j] = true;
-          }
-          if ((jj_la1_1[i] &amp; (1&lt;&lt;j)) != 0) {
-            la1tokens[32+j] = true;
-          }
-        }
-      }
-    }
-    for (int i = 0; i &lt; 59; i++) {
-      if (la1tokens[i]) {
-        jj_expentry = new int[1];
-        jj_expentry[0] = i;
-        jj_expentries.addElement(jj_expentry);
-      }
-    }
-    jj_endpos = 0;
-    jj_rescan_token();
-    jj_add_error_token(0, 0);
-    int[][] exptokseq = new int[jj_expentries.size()][];
-    for (int i = 0; i &lt; jj_expentries.size(); i++) {
-      exptokseq[i] = (int[])jj_expentries.elementAt(i);
-    }
-    return new ParseException(token, exptokseq, tokenImage);
-  }
-
-  final public void enable_tracing() {
-  }
-
-  final public void disable_tracing() {
-  }
-
-  final private void jj_rescan_token() {
-    jj_rescan = true;
-    for (int i = 0; i &lt; 2; i++) {
-    try {
-      JJCalls p = jj_2_rtns[i];
-      do {
-        if (p.gen &gt; jj_gen) {
-          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
-          switch (i) {
-            case 0: jj_3_1(); break;
-            case 1: jj_3_2(); break;
-          }
-        }
-        p = p.next;
-      } while (p != null);
-      } catch(LookaheadSuccess ls) { }
-    }
-    jj_rescan = false;
-  }
-
-  final private void jj_save(int index, int xla) {
-    JJCalls p = jj_2_rtns[index];
-    while (p.gen &gt; jj_gen) {
-      if (p.next == null) { p = p.next = new JJCalls(); break; }
-      p = p.next;
-    }
-    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
-  }
-
-  static final class JJCalls {
-    int gen;
-    Token first;
-    int arg;
-    JJCalls next;
-  }
-
-}

Modified: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2Clover.jj
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2Clover.jj	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2Clover.jj	2007-02-20 14:44:00 UTC (rev 2494)
@@ -10,15 +10,15 @@
 	IGNORE_CASE=true;
 }
 
-PARSER_BEGIN(DML2Clover)
-package org.jetel.util.dml2clover;
+PARSER_BEGIN(DDL2Clover)
+package org.jetel.util.ddl2clover;
 
 import java.util.*;
 import java.io.*;
 import org.jetel.metadata.*;
 import java.math.*;
 
-public class DML2Clover {
+public class DDL2Clover {
 
 	/**
 		 * The class parses sql script containing only create statements. Output is a DataRecordMetadata List.
@@ -38,7 +38,7 @@
 	private static final Long dateTimeLenght = Long.valueOf(24); // &quot;10.10.2007 23:10:10.111&quot;
 	
 	public static void main(String args[]) throws ParseException, FileNotFoundException {
-		DML2Clover parser = new DML2Clover(new FileInputStream(new File(&quot;text.txt&quot;)));
+		DDL2Clover parser = new DDL2Clover(new FileInputStream(new File(&quot;text.txt&quot;)));
 		parser.getDataRecordMetadataList(&quot;;&quot;, &quot;\n&quot;);
 		parser.testPrint(parser.list);
 		System.out.println(&quot;Ok&quot;);
@@ -67,7 +67,7 @@
 	
 }
 
-PARSER_END(DML2Clover)
+PARSER_END(DDL2Clover)
 
 // The SQL lexical grammar
 

Deleted: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2CloverConstants.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverConstants.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2CloverConstants.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -1,121 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. DML2CloverConstants.java */
-package org.jetel.util.dml2clover;
-
-public interface DML2CloverConstants {
-
-  int EOF = 0;
-  int BOOLEAN = 12;
-  int BLOB = 13;
-  int CHAR = 14;
-  int CHARACTER = 15;
-  int CLOB = 16;
-  int COMMIT = 17;
-  int CREATE = 18;
-  int DATE = 19;
-  int DATETIME = 20;
-  int DEC = 21;
-  int DECIMAL = 22;
-  int DEFAULT_ = 23;
-  int DELETE = 24;
-  int FLOAT = 25;
-  int GLOBAL = 26;
-  int INT = 27;
-  int INTEGER = 28;
-  int KEY = 29;
-  int LOCAL = 30;
-  int NOT = 31;
-  int NULL = 32;
-  int NUMBER = 33;
-  int NUMERIC = 34;
-  int ON = 35;
-  int PRESERVE = 36;
-  int PRIMARY = 37;
-  int REFERENCES = 38;
-  int ROWS = 39;
-  int SMALLINT = 40;
-  int TABLE = 41;
-  int TIMESTAMP = 42;
-  int TEMPORARY = 43;
-  int UNIQUE = 44;
-  int VARCHAR = 45;
-  int VARCHAR2 = 46;
-  int STRING_LITERAL = 47;
-  int INTEGER_LITERAL = 48;
-  int FLOAT_LITERAL = 49;
-  int EXP = 50;
-  int IDENTIFIER = 51;
-  int LETTER = 52;
-  int DIGIT = 53;
-  int CLOSEPAREN = 54;
-  int COMA = 55;
-  int DOT = 56;
-  int OPENPAREN = 57;
-  int SEMICOLON = 58;
-
-  int DEFAULT = 0;
-  int WithinComment = 1;
-  int WithinLineComment = 2;
-
-  String[] tokenImage = {
-    &quot;&lt;EOF&gt;&quot;,
-    &quot;\&quot; \&quot;&quot;,
-    &quot;\&quot;\\t\&quot;&quot;,
-    &quot;\&quot;\\n\&quot;&quot;,
-    &quot;\&quot;\\r\&quot;&quot;,
-    &quot;\&quot;\\n\\r\&quot;&quot;,
-    &quot;\&quot;/*\&quot;&quot;,
-    &quot;\&quot;*/\&quot;&quot;,
-    &quot;&lt;token of kind 8&gt;&quot;,
-    &quot;\&quot;//\&quot;&quot;,
-    &quot;\&quot;\\n\&quot;&quot;,
-    &quot;&lt;token of kind 11&gt;&quot;,
-    &quot;\&quot;boolean\&quot;&quot;,
-    &quot;\&quot;blob\&quot;&quot;,
-    &quot;\&quot;char\&quot;&quot;,
-    &quot;\&quot;character\&quot;&quot;,
-    &quot;\&quot;clob\&quot;&quot;,
-    &quot;\&quot;commit\&quot;&quot;,
-    &quot;\&quot;create\&quot;&quot;,
-    &quot;\&quot;date\&quot;&quot;,
-    &quot;\&quot;datetime\&quot;&quot;,
-    &quot;\&quot;dec\&quot;&quot;,
-    &quot;\&quot;decimal\&quot;&quot;,
-    &quot;\&quot;default\&quot;&quot;,
-    &quot;\&quot;delete\&quot;&quot;,
-    &quot;\&quot;float\&quot;&quot;,
-    &quot;\&quot;global\&quot;&quot;,
-    &quot;\&quot;int\&quot;&quot;,
-    &quot;\&quot;integer\&quot;&quot;,
-    &quot;\&quot;key\&quot;&quot;,
-    &quot;\&quot;local\&quot;&quot;,
-    &quot;\&quot;not\&quot;&quot;,
-    &quot;\&quot;null\&quot;&quot;,
-    &quot;\&quot;number\&quot;&quot;,
-    &quot;\&quot;numeric\&quot;&quot;,
-    &quot;\&quot;on\&quot;&quot;,
-    &quot;\&quot;preserve\&quot;&quot;,
-    &quot;\&quot;primary\&quot;&quot;,
-    &quot;\&quot;references\&quot;&quot;,
-    &quot;\&quot;rows\&quot;&quot;,
-    &quot;\&quot;smallint\&quot;&quot;,
-    &quot;\&quot;table\&quot;&quot;,
-    &quot;\&quot;timestamp\&quot;&quot;,
-    &quot;\&quot;TEMPORARY\&quot;&quot;,
-    &quot;\&quot;unique\&quot;&quot;,
-    &quot;\&quot;varchar\&quot;&quot;,
-    &quot;\&quot;varchar2\&quot;&quot;,
-    &quot;&lt;STRING_LITERAL&gt;&quot;,
-    &quot;&lt;INTEGER_LITERAL&gt;&quot;,
-    &quot;&lt;FLOAT_LITERAL&gt;&quot;,
-    &quot;&lt;EXP&gt;&quot;,
-    &quot;&lt;IDENTIFIER&gt;&quot;,
-    &quot;&lt;LETTER&gt;&quot;,
-    &quot;&lt;DIGIT&gt;&quot;,
-    &quot;\&quot;)\&quot;&quot;,
-    &quot;\&quot;,\&quot;&quot;,
-    &quot;\&quot;.\&quot;&quot;,
-    &quot;\&quot;(\&quot;&quot;,
-    &quot;\&quot;;\&quot;&quot;,
-  };
-
-}

Deleted: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2CloverTokenManager.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverTokenManager.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2CloverTokenManager.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -1,1197 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. DML2CloverTokenManager.java */
-package org.jetel.util.dml2clover;
-import java.util.*;
-import java.io.*;
-import org.jetel.metadata.*;
-import java.math.*;
-
-public class DML2CloverTokenManager implements DML2CloverConstants
-{
-  public  java.io.PrintStream debugStream = System.out;
-  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
-private final int jjStopStringLiteralDfa_0(int pos, long active0)
-{
-   switch (pos)
-   {
-      case 0:
-         if ((active0 &amp; 0x7ffffffff000L) != 0L)
-         {
-            jjmatchedKind = 51;
-            return 25;
-         }
-         if ((active0 &amp; 0x100000000000000L) != 0L)
-            return 7;
-         return -1;
-      case 1:
-         if ((active0 &amp; 0x7ff7fffff000L) != 0L)
-         {
-            jjmatchedKind = 51;
-            jjmatchedPos = 1;
-            return 25;
-         }
-         if ((active0 &amp; 0x800000000L) != 0L)
-            return 25;
-         return -1;
-      case 2:
-         if ((active0 &amp; 0x7ff7479ff000L) != 0L)
-         {
-            if (jjmatchedPos != 2)
-            {
-               jjmatchedKind = 51;
-               jjmatchedPos = 2;
-            }
-            return 25;
-         }
-         if ((active0 &amp; 0xb8600000L) != 0L)
-            return 25;
-         return -1;
-      case 3:
-         if ((active0 &amp; 0x7f7657c61000L) != 0L)
-         {
-            if (jjmatchedPos != 3)
-            {
-               jjmatchedKind = 51;
-               jjmatchedPos = 3;
-            }
-            return 25;
-         }
-         if ((active0 &amp; 0x810019e000L) != 0L)
-            return 25;
-         return -1;
-      case 4:
-         if ((active0 &amp; 0x20042000000L) != 0L)
-            return 25;
-         if ((active0 &amp; 0x7d7615d69000L) != 0L)
-         {
-            jjmatchedKind = 51;
-            jjmatchedPos = 4;
-            return 25;
-         }
-         return -1;
-      case 5:
-         if ((active0 &amp; 0x6d7410d09000L) != 0L)
-         {
-            jjmatchedKind = 51;
-            jjmatchedPos = 5;
-            return 25;
-         }
-         if ((active0 &amp; 0x100205060000L) != 0L)
-            return 25;
-         return -1;
-      case 6:
-         if ((active0 &amp; 0xd5000108000L) != 0L)
-         {
-            if (jjmatchedPos != 6)
-            {
-               jjmatchedKind = 51;
-               jjmatchedPos = 6;
-            }
-            return 25;
-         }
-         if ((active0 &amp; 0x602410c01000L) != 0L)
-            return 25;
-         return -1;
-      case 7:
-         if ((active0 &amp; 0x400000000000L) != 0L)
-            return 24;
-         if ((active0 &amp; 0x11000100000L) != 0L)
-            return 25;
-         if ((active0 &amp; 0xc4000008000L) != 0L)
-         {
-            jjmatchedKind = 51;
-            jjmatchedPos = 7;
-            return 25;
-         }
-         return -1;
-      case 8:
-         if ((active0 &amp; 0x4000000000L) != 0L)
-         {
-            jjmatchedKind = 51;
-            jjmatchedPos = 8;
-            return 25;
-         }
-         if ((active0 &amp; 0xc0000008000L) != 0L)
-            return 25;
-         return -1;
-      default :
-         return -1;
-   }
-}
-private final int jjStartNfa_0(int pos, long active0)
-{
-   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
-}
-private final int jjStopAtPos(int pos, int kind)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   return pos + 1;
-}
-private final int jjStartNfaWithStates_0(int pos, int kind, int state)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_0(state, pos + 1);
-}
-private final int jjMoveStringLiteralDfa0_0()
-{
-   switch(curChar)
-   {
-      case 10:
-         jjmatchedKind = 3;
-         return jjMoveStringLiteralDfa1_0(0x20L);
-      case 40:
-         return jjStopAtPos(0, 57);
-      case 41:
-         return jjStopAtPos(0, 54);
-      case 44:
-         return jjStopAtPos(0, 55);
-      case 46:
-         return jjStartNfaWithStates_0(0, 56, 7);
-      case 47:
-         return jjMoveStringLiteralDfa1_0(0x240L);
-      case 59:
-         return jjStopAtPos(0, 58);
-      case 66:
-      case 98:
-         return jjMoveStringLiteralDfa1_0(0x3000L);
-      case 67:
-      case 99:
-         return jjMoveStringLiteralDfa1_0(0x7c000L);
-      case 68:
-      case 100:
-         return jjMoveStringLiteralDfa1_0(0x1f80000L);
-      case 70:
-      case 102:
-         return jjMoveStringLiteralDfa1_0(0x2000000L);
-      case 71:
-      case 103:
-         return jjMoveStringLiteralDfa1_0(0x4000000L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa1_0(0x18000000L);
-      case 75:
-      case 107:
-         return jjMoveStringLiteralDfa1_0(0x20000000L);
-      case 76:
-      case 108:
-         return jjMoveStringLiteralDfa1_0(0x40000000L);
-      case 78:
-      case 110:
-         return jjMoveStringLiteralDfa1_0(0x780000000L);
-      case 79:
-      case 111:
-         return jjMoveStringLiteralDfa1_0(0x800000000L);
-      case 80:
-      case 112:
-         return jjMoveStringLiteralDfa1_0(0x3000000000L);
-      case 82:
-      case 114:
-         return jjMoveStringLiteralDfa1_0(0xc000000000L);
-      case 83:
-      case 115:
-         return jjMoveStringLiteralDfa1_0(0x10000000000L);
-      case 84:
-      case 116:
-         return jjMoveStringLiteralDfa1_0(0xe0000000000L);
-      case 85:
-      case 117:
-         return jjMoveStringLiteralDfa1_0(0x100000000000L);
-      case 86:
-      case 118:
-         return jjMoveStringLiteralDfa1_0(0x600000000000L);
-      default :
-         return jjMoveNfa_0(0, 0);
-   }
-}
-private final int jjMoveStringLiteralDfa1_0(long active0)
-{
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(0, active0);
-      return 1;
-   }
-   switch(curChar)
-   {
-      case 13:
-         if ((active0 &amp; 0x20L) != 0L)
-            return jjStopAtPos(1, 5);
-         break;
-      case 42:
-         if ((active0 &amp; 0x40L) != 0L)
-            return jjStopAtPos(1, 6);
-         break;
-      case 47:
-         if ((active0 &amp; 0x200L) != 0L)
-            return jjStopAtPos(1, 9);
-         break;
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa2_0(active0, 0x620000180000L);
-      case 69:
-      case 101:
-         return jjMoveStringLiteralDfa2_0(active0, 0x84021e00000L);
-      case 72:
-      case 104:
-         return jjMoveStringLiteralDfa2_0(active0, 0xc000L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa2_0(active0, 0x40000000000L);
-      case 76:
-      case 108:
-         return jjMoveStringLiteralDfa2_0(active0, 0x6012000L);
-      case 77:
-      case 109:
-         return jjMoveStringLiteralDfa2_0(active0, 0x10000000000L);
-      case 78:
-      case 110:
-         if ((active0 &amp; 0x800000000L) != 0L)
-            return jjStartNfaWithStates_0(1, 35, 25);
-         return jjMoveStringLiteralDfa2_0(active0, 0x100018000000L);
-      case 79:
-      case 111:
-         return jjMoveStringLiteralDfa2_0(active0, 0x80c0021000L);
-      case 82:
-      case 114:
-         return jjMoveStringLiteralDfa2_0(active0, 0x3000040000L);
-      case 85:
-      case 117:
-         return jjMoveStringLiteralDfa2_0(active0, 0x700000000L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(0, active0);
-}
-private final int jjMoveStringLiteralDfa2_0(long old0, long active0)
-{
-   if (((active0 &amp;= old0)) == 0L)
-      return jjStartNfa_0(0, old0); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(1, active0);
-      return 2;
-   }
-   switch(curChar)
-   {
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa3_0(active0, 0x1000000c000L);
-      case 66:
-      case 98:
-         return jjMoveStringLiteralDfa3_0(active0, 0x20000000000L);
-      case 67:
-      case 99:
-         if ((active0 &amp; 0x200000L) != 0L)
-         {
-            jjmatchedKind = 21;
-            jjmatchedPos = 2;
-         }
-         return jjMoveStringLiteralDfa3_0(active0, 0x40400000L);
-      case 69:
-      case 101:
-         return jjMoveStringLiteralDfa3_0(active0, 0x1000040000L);
-      case 70:
-      case 102:
-         return jjMoveStringLiteralDfa3_0(active0, 0x4000800000L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa3_0(active0, 0x102000000000L);
-      case 76:
-      case 108:
-         return jjMoveStringLiteralDfa3_0(active0, 0x101000000L);
-      case 77:
-      case 109:
-         return jjMoveStringLiteralDfa3_0(active0, 0xc0600020000L);
-      case 79:
-      case 111:
-         return jjMoveStringLiteralDfa3_0(active0, 0x6013000L);
-      case 82:
-      case 114:
-         return jjMoveStringLiteralDfa3_0(active0, 0x600000000000L);
-      case 84:
-      case 116:
-         if ((active0 &amp; 0x8000000L) != 0L)
-         {
-            jjmatchedKind = 27;
-            jjmatchedPos = 2;
-         }
-         else if ((active0 &amp; 0x80000000L) != 0L)
-            return jjStartNfaWithStates_0(2, 31, 25);
-         return jjMoveStringLiteralDfa3_0(active0, 0x10180000L);
-      case 87:
-      case 119:
-         return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L);
-      case 89:
-      case 121:
-         if ((active0 &amp; 0x20000000L) != 0L)
-            return jjStartNfaWithStates_0(2, 29, 25);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(1, active0);
-}
-private final int jjMoveStringLiteralDfa3_0(long old0, long active0)
-{
-   if (((active0 &amp;= old0)) == 0L)
-      return jjStartNfa_0(1, old0); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(2, active0);
-      return 3;
-   }
-   switch(curChar)
-   {
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa4_0(active0, 0x42840000L);
-      case 66:
-      case 98:
-         if ((active0 &amp; 0x2000L) != 0L)
-            return jjStartNfaWithStates_0(3, 13, 25);
-         else if ((active0 &amp; 0x10000L) != 0L)
-            return jjStartNfaWithStates_0(3, 16, 25);
-         return jjMoveStringLiteralDfa4_0(active0, 0x204000000L);
-      case 67:
-      case 99:
-         return jjMoveStringLiteralDfa4_0(active0, 0x600000000000L);
-      case 69:
-      case 101:
-         if ((active0 &amp; 0x80000L) != 0L)
-         {
-            jjmatchedKind = 19;
-            jjmatchedPos = 3;
-         }
-         return jjMoveStringLiteralDfa4_0(active0, 0x44411100000L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa4_0(active0, 0x400000L);
-      case 76:
-      case 108:
-         if ((active0 &amp; 0x100000000L) != 0L)
-            return jjStartNfaWithStates_0(3, 32, 25);
-         return jjMoveStringLiteralDfa4_0(active0, 0x30000001000L);
-      case 77:
-      case 109:
-         return jjMoveStringLiteralDfa4_0(active0, 0x2000020000L);
-      case 80:
-      case 112:
-         return jjMoveStringLiteralDfa4_0(active0, 0x80000000000L);
-      case 81:
-      case 113:
-         return jjMoveStringLiteralDfa4_0(active0, 0x100000000000L);
-      case 82:
-      case 114:
-         if ((active0 &amp; 0x4000L) != 0L)
-         {
-            jjmatchedKind = 14;
-            jjmatchedPos = 3;
-         }
-         return jjMoveStringLiteralDfa4_0(active0, 0x8000L);
-      case 83:
-      case 115:
-         if ((active0 &amp; 0x8000000000L) != 0L)
-            return jjStartNfaWithStates_0(3, 39, 25);
-         return jjMoveStringLiteralDfa4_0(active0, 0x1000000000L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(2, active0);
-}
-private final int jjMoveStringLiteralDfa4_0(long old0, long active0)
-{
-   if (((active0 &amp;= old0)) == 0L)
-      return jjStartNfa_0(2, old0); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(3, active0);
-      return 4;
-   }
-   switch(curChar)
-   {
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa5_0(active0, 0x2004008000L);
-      case 69:
-      case 101:
-         if ((active0 &amp; 0x20000000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 41, 25);
-         return jjMoveStringLiteralDfa5_0(active0, 0x1200001000L);
-      case 71:
-      case 103:
-         return jjMoveStringLiteralDfa5_0(active0, 0x10000000L);
-      case 72:
-      case 104:
-         return jjMoveStringLiteralDfa5_0(active0, 0x600000000000L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa5_0(active0, 0x20000L);
-      case 76:
-      case 108:
-         if ((active0 &amp; 0x40000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 30, 25);
-         return jjMoveStringLiteralDfa5_0(active0, 0x10000000000L);
-      case 77:
-      case 109:
-         return jjMoveStringLiteralDfa5_0(active0, 0x400000L);
-      case 79:
-      case 111:
-         return jjMoveStringLiteralDfa5_0(active0, 0x80000000000L);
-      case 82:
-      case 114:
-         return jjMoveStringLiteralDfa5_0(active0, 0x4400000000L);
-      case 83:
-      case 115:
-         return jjMoveStringLiteralDfa5_0(active0, 0x40000000000L);
-      case 84:
-      case 116:
-         if ((active0 &amp; 0x2000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 25, 25);
-         return jjMoveStringLiteralDfa5_0(active0, 0x1140000L);
-      case 85:
-      case 117:
-         return jjMoveStringLiteralDfa5_0(active0, 0x100000800000L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(3, active0);
-}
-private final int jjMoveStringLiteralDfa5_0(long old0, long active0)
-{
-   if (((active0 &amp;= old0)) == 0L)
-      return jjStartNfa_0(3, old0); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(4, active0);
-      return 5;
-   }
-   switch(curChar)
-   {
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa6_0(active0, 0x600000401000L);
-      case 67:
-      case 99:
-         return jjMoveStringLiteralDfa6_0(active0, 0x8000L);
-      case 69:
-      case 101:
-         if ((active0 &amp; 0x40000L) != 0L)
-            return jjStartNfaWithStates_0(5, 18, 25);
-         else if ((active0 &amp; 0x1000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 24, 25);
-         else if ((active0 &amp; 0x100000000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 44, 25);
-         return jjMoveStringLiteralDfa6_0(active0, 0x4010000000L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa6_0(active0, 0x10400100000L);
-      case 76:
-      case 108:
-         if ((active0 &amp; 0x4000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 26, 25);
-         return jjMoveStringLiteralDfa6_0(active0, 0x800000L);
-      case 82:
-      case 114:
-         if ((active0 &amp; 0x200000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 33, 25);
-         return jjMoveStringLiteralDfa6_0(active0, 0x83000000000L);
-      case 84:
-      case 116:
-         if ((active0 &amp; 0x20000L) != 0L)
-            return jjStartNfaWithStates_0(5, 17, 25);
-         return jjMoveStringLiteralDfa6_0(active0, 0x40000000000L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(4, active0);
-}
-private final int jjMoveStringLiteralDfa6_0(long old0, long active0)
-{
-   if (((active0 &amp;= old0)) == 0L)
-      return jjStartNfa_0(4, old0); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(5, active0);
-      return 6;
-   }
-   switch(curChar)
-   {
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa7_0(active0, 0xc0000000000L);
-      case 67:
-      case 99:
-         if ((active0 &amp; 0x400000000L) != 0L)
-            return jjStartNfaWithStates_0(6, 34, 25);
-         break;
-      case 76:
-      case 108:
-         if ((active0 &amp; 0x400000L) != 0L)
-            return jjStartNfaWithStates_0(6, 22, 25);
-         break;
-      case 77:
-      case 109:
-         return jjMoveStringLiteralDfa7_0(active0, 0x100000L);
-      case 78:
-      case 110:
-         if ((active0 &amp; 0x1000L) != 0L)
-            return jjStartNfaWithStates_0(6, 12, 25);
-         return jjMoveStringLiteralDfa7_0(active0, 0x14000000000L);
-      case 82:
-      case 114:
-         if ((active0 &amp; 0x10000000L) != 0L)
-            return jjStartNfaWithStates_0(6, 28, 25);
-         else if ((active0 &amp; 0x200000000000L) != 0L)
-         {
-            jjmatchedKind = 45;
-            jjmatchedPos = 6;
-         }
-         return jjMoveStringLiteralDfa7_0(active0, 0x400000000000L);
-      case 84:
-      case 116:
-         if ((active0 &amp; 0x800000L) != 0L)
-            return jjStartNfaWithStates_0(6, 23, 25);
-         return jjMoveStringLiteralDfa7_0(active0, 0x8000L);
-      case 86:
-      case 118:
-         return jjMoveStringLiteralDfa7_0(active0, 0x1000000000L);
-      case 89:
-      case 121:
-         if ((active0 &amp; 0x2000000000L) != 0L)
-            return jjStartNfaWithStates_0(6, 37, 25);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(5, active0);
-}
-private final int jjMoveStringLiteralDfa7_0(long old0, long active0)
-{
-   if (((active0 &amp;= old0)) == 0L)
-      return jjStartNfa_0(5, old0); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(6, active0);
-      return 7;
-   }
-   switch(curChar)
-   {
-      case 50:
-         if ((active0 &amp; 0x400000000000L) != 0L)
-            return jjStartNfaWithStates_0(7, 46, 24);
-         break;
-      case 67:
-      case 99:
-         return jjMoveStringLiteralDfa8_0(active0, 0x4000000000L);
-      case 69:
-      case 101:
-         if ((active0 &amp; 0x100000L) != 0L)
-            return jjStartNfaWithStates_0(7, 20, 25);
-         else if ((active0 &amp; 0x1000000000L) != 0L)
-            return jjStartNfaWithStates_0(7, 36, 25);
-         return jjMoveStringLiteralDfa8_0(active0, 0x8000L);
-      case 77:
-      case 109:
-         return jjMoveStringLiteralDfa8_0(active0, 0x40000000000L);
-      case 82:
-      case 114:
-         return jjMoveStringLiteralDfa8_0(active0, 0x80000000000L);
-      case 84:
-      case 116:
-         if ((active0 &amp; 0x10000000000L) != 0L)
-            return jjStartNfaWithStates_0(7, 40, 25);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(6, active0);
-}
-private final int jjMoveStringLiteralDfa8_0(long old0, long active0)
-{
-   if (((active0 &amp;= old0)) == 0L)
-      return jjStartNfa_0(6, old0); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(7, active0);
-      return 8;
-   }
-   switch(curChar)
-   {
-      case 69:
-      case 101:
-         return jjMoveStringLiteralDfa9_0(active0, 0x4000000000L);
-      case 80:
-      case 112:
-         if ((active0 &amp; 0x40000000000L) != 0L)
-            return jjStartNfaWithStates_0(8, 42, 25);
-         break;
-      case 82:
-      case 114:
-         if ((active0 &amp; 0x8000L) != 0L)
-            return jjStartNfaWithStates_0(8, 15, 25);
-         break;
-      case 89:
-      case 121:
-         if ((active0 &amp; 0x80000000000L) != 0L)
-            return jjStartNfaWithStates_0(8, 43, 25);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(7, active0);
-}
-private final int jjMoveStringLiteralDfa9_0(long old0, long active0)
-{
-   if (((active0 &amp;= old0)) == 0L)
-      return jjStartNfa_0(7, old0); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(8, active0);
-      return 9;
-   }
-   switch(curChar)
-   {
-      case 83:
-      case 115:
-         if ((active0 &amp; 0x4000000000L) != 0L)
-            return jjStartNfaWithStates_0(9, 38, 25);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(8, active0);
-}
-private final void jjCheckNAdd(int state)
-{
-   if (jjrounds[state] != jjround)
-   {
-      jjstateSet[jjnewStateCnt++] = state;
-      jjrounds[state] = jjround;
-   }
-}
-private final void jjAddStates(int start, int end)
-{
-   do {
-      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
-   } while (start++ != end);
-}
-private final void jjCheckNAddTwoStates(int state1, int state2)
-{
-   jjCheckNAdd(state1);
-   jjCheckNAdd(state2);
-}
-private final void jjCheckNAddStates(int start, int end)
-{
-   do {
-      jjCheckNAdd(jjnextStates[start]);
-   } while (start++ != end);
-}
-private final void jjCheckNAddStates(int start)
-{
-   jjCheckNAdd(jjnextStates[start]);
-   jjCheckNAdd(jjnextStates[start + 1]);
-}
-static final long[] jjbitVec0 = {
-   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
-};
-private final int jjMoveNfa_0(int startState, int curPos)
-{
-   int[] nextStates;
-   int startsAt = 0;
-   jjnewStateCnt = 25;
-   int i = 1;
-   jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
-   for (;;)
-   {
-      if (++jjround == 0x7fffffff)
-         ReInitRounds();
-      if (curChar &lt; 64)
-      {
-         long l = 1L &lt;&lt; curChar;
-         MatchLoop: do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-                  if ((0x3ff000000000000L &amp; l) != 0L)
-                  {
-                     if (kind &gt; 48)
-                        kind = 48;
-                     jjCheckNAddStates(0, 4);
-                  }
-                  else if (curChar == 46)
-                     jjCheckNAdd(7);
-                  else if (curChar == 39)
-                     jjCheckNAddStates(5, 7);
-                  break;
-               case 25:
-               case 24:
-                  if ((0x3ff001800000000L &amp; l) == 0L)
-                     break;
-                  if (kind &gt; 51)
-                     kind = 51;
-                  jjCheckNAdd(24);
-                  break;
-               case 1:
-                  if ((0xffffff7fffffffffL &amp; l) != 0L)
-                     jjCheckNAddStates(5, 7);
-                  break;
-               case 2:
-                  if (curChar == 39)
-                     jjCheckNAddStates(8, 10);
-                  break;
-               case 3:
-                  if (curChar == 39)
-                     jjstateSet[jjnewStateCnt++] = 2;
-                  break;
-               case 4:
-                  if ((0xffffff7fffffffffL &amp; l) != 0L)
-                     jjCheckNAddStates(8, 10);
-                  break;
-               case 5:
-                  if (curChar == 39 &amp;&amp; kind &gt; 47)
-                     kind = 47;
-                  break;
-               case 6:
-                  if (curChar == 46)
-                     jjCheckNAdd(7);
-                  break;
-               case 7:
-                  if ((0x3ff000000000000L &amp; l) == 0L)
-                     break;
-                  if (kind &gt; 49)
-                     kind = 49;
-                  jjCheckNAddTwoStates(7, 8);
-                  break;
-               case 9:
-                  if ((0x280000000000L &amp; l) != 0L)
-                     jjCheckNAdd(10);
-                  break;
-               case 10:
-                  if ((0x3ff000000000000L &amp; l) == 0L)
-                     break;
-                  if (kind &gt; 49)
-                     kind = 49;
-                  jjCheckNAdd(10);
-                  break;
-               case 11:
-                  if ((0x3ff000000000000L &amp; l) == 0L)
-                     break;
-                  if (kind &gt; 48)
-                     kind = 48;
-                  jjCheckNAddStates(0, 4);
-                  break;
-               case 12:
-                  if ((0x3ff000000000000L &amp; l) == 0L)
-                     break;
-                  if (kind &gt; 48)
-                     kind = 48;
-                  jjCheckNAdd(12);
-                  break;
-               case 13:
-                  if ((0x3ff000000000000L &amp; l) != 0L)
-                     jjCheckNAddTwoStates(13, 14);
-                  break;
-               case 14:
-                  if (curChar == 46)
-                     jjCheckNAdd(15);
-                  break;
-               case 15:
-                  if ((0x3ff000000000000L &amp; l) == 0L)
-                     break;
-                  if (kind &gt; 49)
-                     kind = 49;
-                  jjCheckNAddTwoStates(15, 16);
-                  break;
-               case 17:
-                  if ((0x280000000000L &amp; l) != 0L)
-                     jjCheckNAdd(18);
-                  break;
-               case 18:
-                  if ((0x3ff000000000000L &amp; l) == 0L)
-                     break;
-                  if (kind &gt; 49)
-                     kind = 49;
-                  jjCheckNAdd(18);
-                  break;
-               case 19:
-                  if ((0x3ff000000000000L &amp; l) == 0L)
-                     break;
-                  if (kind &gt; 49)
-                     kind = 49;
-                  jjCheckNAddTwoStates(19, 20);
-                  break;
-               case 21:
-                  if ((0x280000000000L &amp; l) != 0L)
-                     jjCheckNAdd(22);
-                  break;
-               case 22:
-                  if ((0x3ff000000000000L &amp; l) == 0L)
-                     break;
-                  if (kind &gt; 49)
-                     kind = 49;
-                  jjCheckNAdd(22);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else if (curChar &lt; 128)
-      {
-         long l = 1L &lt;&lt; (curChar &amp; 077);
-         MatchLoop: do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-               case 23:
-                  if ((0x7fffffe07fffffeL &amp; l) == 0L)
-                     break;
-                  if (kind &gt; 51)
-                     kind = 51;
-                  jjCheckNAddTwoStates(23, 24);
-                  break;
-               case 25:
-                  if ((0x7fffffe87fffffeL &amp; l) != 0L)
-                  {
-                     if (kind &gt; 51)
-                        kind = 51;
-                     jjCheckNAdd(24);
-                  }
-                  if ((0x7fffffe07fffffeL &amp; l) != 0L)
-                  {
-                     if (kind &gt; 51)
-                        kind = 51;
-                     jjCheckNAddTwoStates(23, 24);
-                  }
-                  break;
-               case 1:
-                  jjCheckNAddStates(5, 7);
-                  break;
-               case 4:
-                  jjCheckNAddStates(8, 10);
-                  break;
-               case 8:
-                  if ((0x2000000020L &amp; l) != 0L)
-                     jjAddStates(11, 12);
-                  break;
-               case 16:
-                  if ((0x2000000020L &amp; l) != 0L)
-                     jjAddStates(13, 14);
-                  break;
-               case 20:
-                  if ((0x2000000020L &amp; l) != 0L)
-                     jjAddStates(15, 16);
-                  break;
-               case 24:
-                  if ((0x7fffffe87fffffeL &amp; l) == 0L)
-                     break;
-                  if (kind &gt; 51)
-                     kind = 51;
-                  jjCheckNAdd(24);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else
-      {
-         int i2 = (curChar &amp; 0xff) &gt;&gt; 6;
-         long l2 = 1L &lt;&lt; (curChar &amp; 077);
-         MatchLoop: do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 1:
-                  if ((jjbitVec0[i2] &amp; l2) != 0L)
-                     jjCheckNAddStates(5, 7);
-                  break;
-               case 4:
-                  if ((jjbitVec0[i2] &amp; l2) != 0L)
-                     jjCheckNAddStates(8, 10);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      if (kind != 0x7fffffff)
-      {
-         jjmatchedKind = kind;
-         jjmatchedPos = curPos;
-         kind = 0x7fffffff;
-      }
-      ++curPos;
-      if ((i = jjnewStateCnt) == (startsAt = 25 - (jjnewStateCnt = startsAt)))
-         return curPos;
-      try { curChar = input_stream.readChar(); }
-      catch(java.io.IOException e) { return curPos; }
-   }
-}
-private final int jjMoveStringLiteralDfa0_2()
-{
-   switch(curChar)
-   {
-      case 10:
-         return jjStopAtPos(0, 10);
-      default :
-         return 1;
-   }
-}
-private final int jjMoveStringLiteralDfa0_1()
-{
-   switch(curChar)
-   {
-      case 42:
-         return jjMoveStringLiteralDfa1_1(0x80L);
-      default :
-         return 1;
-   }
-}
-private final int jjMoveStringLiteralDfa1_1(long active0)
-{
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      return 1;
-   }
-   switch(curChar)
-   {
-      case 47:
-         if ((active0 &amp; 0x80L) != 0L)
-            return jjStopAtPos(1, 7);
-         break;
-      default :
-         return 2;
-   }
-   return 2;
-}
-static final int[] jjnextStates = {
-   12, 13, 14, 19, 20, 1, 3, 5, 3, 4, 5, 9, 10, 17, 18, 21, 
-   22, 
-};
-public static final String[] jjstrLiteralImages = {
-&quot;&quot;, null, null, null, null, null, null, null, null, null, null, null, null, 
-null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
-null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
-null, null, null, null, null, null, null, null, null, null, null, null, null, &quot;\51&quot;, 
-&quot;\54&quot;, &quot;\56&quot;, &quot;\50&quot;, &quot;\73&quot;, };
-public static final String[] lexStateNames = {
-   &quot;DEFAULT&quot;, 
-   &quot;WithinComment&quot;, 
-   &quot;WithinLineComment&quot;, 
-};
-public static final int[] jjnewLexState = {
-   -1, -1, -1, -1, -1, -1, 1, 0, -1, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-};
-static final long[] jjtoToken = {
-   0x7fbfffffffff001L, 
-};
-static final long[] jjtoSkip = {
-   0x6feL, 
-};
-static final long[] jjtoSpecial = {
-   0x6c0L, 
-};
-static final long[] jjtoMore = {
-   0x900L, 
-};
-protected SimpleCharStream input_stream;
-private final int[] jjrounds = new int[25];
-private final int[] jjstateSet = new int[50];
-StringBuffer image;
-int jjimageLen;
-int lengthOfMatch;
-protected char curChar;
-public DML2CloverTokenManager(SimpleCharStream stream){
-   if (SimpleCharStream.staticFlag)
-      throw new Error(&quot;ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.&quot;);
-   input_stream = stream;
-}
-public DML2CloverTokenManager(SimpleCharStream stream, int lexState){
-   this(stream);
-   SwitchTo(lexState);
-}
-public void ReInit(SimpleCharStream stream)
-{
-   jjmatchedPos = jjnewStateCnt = 0;
-   curLexState = defaultLexState;
-   input_stream = stream;
-   ReInitRounds();
-}
-private final void ReInitRounds()
-{
-   int i;
-   jjround = 0x80000001;
-   for (i = 25; i-- &gt; 0;)
-      jjrounds[i] = 0x80000000;
-}
-public void ReInit(SimpleCharStream stream, int lexState)
-{
-   ReInit(stream);
-   SwitchTo(lexState);
-}
-public void SwitchTo(int lexState)
-{
-   if (lexState &gt;= 3 || lexState &lt; 0)
-      throw new TokenMgrError(&quot;Error: Ignoring invalid lexical state : &quot; + lexState + &quot;. State unchanged.&quot;, TokenMgrError.INVALID_LEXICAL_STATE);
-   else
-      curLexState = lexState;
-}
-
-protected Token jjFillToken()
-{
-   Token t = Token.newToken(jjmatchedKind);
-   t.kind = jjmatchedKind;
-   String im = jjstrLiteralImages[jjmatchedKind];
-   t.image = (im == null) ? input_stream.GetImage() : im;
-   t.beginLine = input_stream.getBeginLine();
-   t.beginColumn = input_stream.getBeginColumn();
-   t.endLine = input_stream.getEndLine();
-   t.endColumn = input_stream.getEndColumn();
-   return t;
-}
-
-int curLexState = 0;
-int defaultLexState = 0;
-int jjnewStateCnt;
-int jjround;
-int jjmatchedPos;
-int jjmatchedKind;
-
-public Token getNextToken() 
-{
-  int kind;
-  Token specialToken = null;
-  Token matchedToken;
-  int curPos = 0;
-
-  EOFLoop :
-  for (;;)
-  {   
-   try   
-   {     
-      curChar = input_stream.BeginToken();
-   }     
-   catch(java.io.IOException e)
-   {        
-      jjmatchedKind = 0;
-      matchedToken = jjFillToken();
-      matchedToken.specialToken = specialToken;
-      return matchedToken;
-   }
-   image = null;
-   jjimageLen = 0;
-
-   for (;;)
-   {
-     switch(curLexState)
-     {
-       case 0:
-         try { input_stream.backup(0);
-            while (curChar &lt;= 32 &amp;&amp; (0x100002200L &amp; (1L &lt;&lt; curChar)) != 0L)
-               curChar = input_stream.BeginToken();
-         }
-         catch (java.io.IOException e1) { continue EOFLoop; }
-         jjmatchedKind = 0x7fffffff;
-         jjmatchedPos = 0;
-         curPos = jjMoveStringLiteralDfa0_0();
-         break;
-       case 1:
-         jjmatchedKind = 0x7fffffff;
-         jjmatchedPos = 0;
-         curPos = jjMoveStringLiteralDfa0_1();
-         if (jjmatchedPos == 0 &amp;&amp; jjmatchedKind &gt; 8)
-         {
-            jjmatchedKind = 8;
-         }
-         break;
-       case 2:
-         jjmatchedKind = 0x7fffffff;
-         jjmatchedPos = 0;
-         curPos = jjMoveStringLiteralDfa0_2();
-         if (jjmatchedPos == 0 &amp;&amp; jjmatchedKind &gt; 11)
-         {
-            jjmatchedKind = 11;
-         }
-         break;
-     }
-     if (jjmatchedKind != 0x7fffffff)
-     {
-        if (jjmatchedPos + 1 &lt; curPos)
-           input_stream.backup(curPos - jjmatchedPos - 1);
-        if ((jjtoToken[jjmatchedKind &gt;&gt; 6] &amp; (1L &lt;&lt; (jjmatchedKind &amp; 077))) != 0L)
-        {
-           matchedToken = jjFillToken();
-           matchedToken.specialToken = specialToken;
-       if (jjnewLexState[jjmatchedKind] != -1)
-         curLexState = jjnewLexState[jjmatchedKind];
-           return matchedToken;
-        }
-        else if ((jjtoSkip[jjmatchedKind &gt;&gt; 6] &amp; (1L &lt;&lt; (jjmatchedKind &amp; 077))) != 0L)
-        {
-           if ((jjtoSpecial[jjmatchedKind &gt;&gt; 6] &amp; (1L &lt;&lt; (jjmatchedKind &amp; 077))) != 0L)
-           {
-              matchedToken = jjFillToken();
-              if (specialToken == null)
-                 specialToken = matchedToken;
-              else
-              {
-                 matchedToken.specialToken = specialToken;
-                 specialToken = (specialToken.next = matchedToken);
-              }
-              SkipLexicalActions(matchedToken);
-           }
-           else 
-              SkipLexicalActions(null);
-         if (jjnewLexState[jjmatchedKind] != -1)
-           curLexState = jjnewLexState[jjmatchedKind];
-           continue EOFLoop;
-        }
-        jjimageLen += jjmatchedPos + 1;
-      if (jjnewLexState[jjmatchedKind] != -1)
-        curLexState = jjnewLexState[jjmatchedKind];
-        curPos = 0;
-        jjmatchedKind = 0x7fffffff;
-        try {
-           curChar = input_stream.readChar();
-           continue;
-        }
-        catch (java.io.IOException e1) { }
-     }
-     int error_line = input_stream.getEndLine();
-     int error_column = input_stream.getEndColumn();
-     String error_after = null;
-     boolean EOFSeen = false;
-     try { input_stream.readChar(); input_stream.backup(1); }
-     catch (java.io.IOException e1) {
-        EOFSeen = true;
-        error_after = curPos &lt;= 1 ? &quot;&quot; : input_stream.GetImage();
-        if (curChar == '\n' || curChar == '\r') {
-           error_line++;
-           error_column = 0;
-        }
-        else
-           error_column++;
-     }
-     if (!EOFSeen) {
-        input_stream.backup(1);
-        error_after = curPos &lt;= 1 ? &quot;&quot; : input_stream.GetImage();
-     }
-     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
-   }
-  }
-}
-
-void SkipLexicalActions(Token matchedToken)
-{
-   switch(jjmatchedKind)
-   {
-      default :
-         break;
-   }
-}
-}

Modified: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DataType.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DataType.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DataType.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -1,4 +1,4 @@
-package org.jetel.util.dml2clover;
+package org.jetel.util.ddl2clover;
 public final class DataType {
 
     /** Data type, based on java.sql.Types */

Modified: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/ParseException.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/ParseException.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/ParseException.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -1,5 +1,5 @@
 /* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */
-package org.jetel.util.dml2clover;
+package org.jetel.util.ddl2clover;
 
 /**
  * This exception is thrown when parse errors are encountered.

Modified: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/SimpleCharStream.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/SimpleCharStream.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/SimpleCharStream.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -1,5 +1,5 @@
 /* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.0 */
-package org.jetel.util.dml2clover;
+package org.jetel.util.ddl2clover;
 
 /**
  * An implementation of interface CharStream, where the stream is assumed to

Modified: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/Token.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/Token.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/Token.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -1,5 +1,5 @@
 /* Generated By:JavaCC: Do not edit this line. Token.java Version 3.0 */
-package org.jetel.util.dml2clover;
+package org.jetel.util.ddl2clover;
 
 /**
  * Describes the input token stream.

Modified: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/TokenMgrError.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/TokenMgrError.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/TokenMgrError.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -1,5 +1,5 @@
 /* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 3.0 */
-package org.jetel.util.dml2clover;
+package org.jetel.util.ddl2clover;
 
 public class TokenMgrError extends Error
 {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000130.html">[Cloveretl-svn-commits] CloverETL repos r2493 -	trunk/cloveretl.engine/src/org/jetel/util/dml2clover
</A></li>
	<LI>Next message: <A HREF="000131.html">[Cloveretl-svn-commits] CloverETL repos r2495 -	trunk/cloveretl.engine/src/org/jetel/util/ddl2clover
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#133">[ date ]</a>
              <a href="thread.html#133">[ thread ]</a>
              <a href="subject.html#133">[ subject ]</a>
              <a href="author.html#133">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cloveretl-svn-commits">More information about the Cloveretl-svn-commits
mailing list</a><br>
</body></html>
