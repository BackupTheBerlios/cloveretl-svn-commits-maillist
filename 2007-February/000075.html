<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cloveretl-svn-commits] CloverETL repos r2438 - in trunk:	cloveretl.component/src/org/jetel/component	cloveretl.engine/src/org/jetel/component	cloveretl.engine/src/org/jetel/main
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cloveretl-svn-commits/2007-February/index.html" >
   <LINK REL="made" HREF="mailto:cloveretl-svn-commits%40lists.berlios.de?Subject=Re%3A%20%5BCloveretl-svn-commits%5D%20CloverETL%20repos%20r2438%20-%20in%20trunk%3A%0A%09cloveretl.component/src/org/jetel/component%0A%09cloveretl.engine/src/org/jetel/component%0A%09cloveretl.engine/src/org/jetel/main&In-Reply-To=%3C200702061457.l16Ev50O017565%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000074.html">
   <LINK REL="Next"  HREF="000076.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cloveretl-svn-commits] CloverETL repos r2438 - in trunk:	cloveretl.component/src/org/jetel/component	cloveretl.engine/src/org/jetel/component	cloveretl.engine/src/org/jetel/main</H1>
    <B>cloveretl-svn-commits at lists.berlios.de</B> 
    <A HREF="mailto:cloveretl-svn-commits%40lists.berlios.de?Subject=Re%3A%20%5BCloveretl-svn-commits%5D%20CloverETL%20repos%20r2438%20-%20in%20trunk%3A%0A%09cloveretl.component/src/org/jetel/component%0A%09cloveretl.engine/src/org/jetel/component%0A%09cloveretl.engine/src/org/jetel/main&In-Reply-To=%3C200702061457.l16Ev50O017565%40sheep.berlios.de%3E"
       TITLE="[Cloveretl-svn-commits] CloverETL repos r2438 - in trunk:	cloveretl.component/src/org/jetel/component	cloveretl.engine/src/org/jetel/component	cloveretl.engine/src/org/jetel/main">cloveretl-svn-commits at lists.berlios.de
       </A><BR>
    <I>Tue Feb  6 15:57:05 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000074.html">[Cloveretl-svn-commits] CloverETL repos r2437 -	trunk/cloveretl.engine/test/org/jetel/component
</A></li>
        <LI>Next message: <A HREF="000076.html">[Cloveretl-svn-commits] CloverETL repos r2439 - in trunk:	cloveretl.component cloveretl.engine/plugins/org.jetel.component
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#75">[ date ]</a>
              <a href="thread.html#75">[ thread ]</a>
              <a href="subject.html#75">[ subject ]</a>
              <a href="author.html#75">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ausperger
Date: 2007-02-06 15:57:04 +0100 (Tue, 06 Feb 2007)
New Revision: 2438

Added:
   trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java
   trunk/cloveretl.engine/src/org/jetel/main/showData.java
Removed:
   trunk/cloveretl.component/src/org/jetel/component/TextWriter.java
   trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java
Modified:
   trunk/cloveretl.engine/src/org/jetel/component/ComponentFactory.java
Log:
FIX: showData - removing dependencies, making comments,..

Copied: trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java (from rev 2422, trunk/cloveretl.component/src/org/jetel/component/TextWriter.java)
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/TextWriter.java	2007-02-01 10:20:59 UTC (rev 2422)
+++ trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java	2007-02-06 14:57:04 UTC (rev 2438)
@@ -0,0 +1,279 @@
+
+/*
+*    jETeL/Clover - Java based ETL application framework.
+*    Copyright (C) 2005-06  Javlin Consulting &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/cloveretl-svn-commits">info at javlinconsulting.cz</A>&gt;
+*    
+*    This library is free software; you can redistribute it and/or
+*    modify it under the terms of the GNU Lesser General Public
+*    License as published by the Free Software Foundation; either
+*    version 2.1 of the License, or (at your option) any later version.
+*    
+*    This library is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
+*    Lesser General Public License for more details.
+*    
+*    You should have received a copy of the GNU Lesser General Public
+*    License along with this library; if not, write to the Free Software
+*    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*
+*/
+
+package org.jetel.component;
+
+import java.io.IOException;
+import java.nio.channels.Channels;
+import java.nio.channels.WritableByteChannel;
+
+import org.jetel.data.DataRecord;
+import org.jetel.data.Defaults;
+import org.jetel.data.formatter.TextTableFormatter;
+import org.jetel.exception.ComponentNotReadyException;
+import org.jetel.exception.ConfigurationProblem;
+import org.jetel.exception.ConfigurationStatus;
+import org.jetel.graph.InputPort;
+import org.jetel.graph.Node;
+import org.jetel.graph.Result;
+import org.jetel.graph.TransformationGraph;
+import org.jetel.util.ComponentXMLAttributes;
+import org.jetel.util.FileUtils;
+import org.jetel.util.StringUtils;
+import org.jetel.util.SynchronizeUtils;
+import org.w3c.dom.Element;
+
+/**
+ *  &lt;h3&gt;TextTableWriter Component&lt;/h3&gt;
+ *
+ * &lt;!-- All records from input port [0] are formatted to table and written to specified file or on screen--&gt;
+ * 
+ * &lt;table border=&quot;1&quot;&gt;
+ *  &lt;th&gt;Component:&lt;/th&gt;
+ * &lt;tr&gt;&lt;td&gt;&lt;h4&gt;&lt;i&gt;Name:&lt;/i&gt;&lt;/h4&gt;&lt;/td&gt;
+ * &lt;td&gt;TextTableWriter&lt;/td&gt;&lt;/tr&gt;
+ * &lt;tr&gt;&lt;td&gt;&lt;h4&gt;&lt;i&gt;Category:&lt;/i&gt;&lt;/h4&gt;&lt;/td&gt;
+ * &lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
+ * &lt;tr&gt;&lt;td&gt;&lt;h4&gt;&lt;i&gt;Description:&lt;/i&gt;&lt;/h4&gt;&lt;/td&gt;
+ * &lt;td&gt;All records from input port [0] are formatted to table and written to specified file or on screen.&lt;/td&gt;&lt;/tr&gt;
+ * &lt;tr&gt;&lt;td&gt;&lt;h4&gt;&lt;i&gt;Inputs:&lt;/i&gt;&lt;/h4&gt;&lt;/td&gt;
+ * &lt;td&gt;[0]- input records&lt;/td&gt;&lt;/tr&gt;
+ * &lt;tr&gt;&lt;td&gt;&lt;h4&gt;&lt;i&gt;Outputs:&lt;/i&gt;&lt;/h4&gt;&lt;/td&gt;
+ * &lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
+ * &lt;tr&gt;&lt;td&gt;&lt;h4&gt;&lt;i&gt;Comment:&lt;/i&gt;&lt;/h4&gt;&lt;/td&gt;
+ * &lt;td&gt;This component uses java.nio.* classes.&lt;/td&gt;&lt;/tr&gt;
+ * &lt;/table&gt;
+ *  &lt;br&gt;  
+ *  &lt;table border=&quot;1&quot;&gt;
+ *  &lt;th&gt;XML attributes:&lt;/th&gt;
+ *  &lt;tr&gt;&lt;td&gt;&lt;b&gt;type&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&quot;STRUCTURE_WRITER&quot;&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td&gt;&lt;b&gt;id&lt;/b&gt;&lt;/td&gt;&lt;td&gt;component identification&lt;/td&gt;
+ *  &lt;tr&gt;&lt;td&gt;&lt;b&gt;fileURL&lt;/b&gt;&lt;/td&gt;&lt;td&gt;Output files mask.
+ *  Use wildcard '#' to specify where to insert sequential number of file. Number of consecutive wildcards specifies
+ *  minimal length of the number. Name without wildcard specifies only one file.&lt;/td&gt;
+ *  &lt;tr&gt;&lt;td&gt;&lt;b&gt;charset&lt;/b&gt;&lt;/td&gt;&lt;td&gt;character encoding of the output file (if not specified, then ISO-8859-1 is used)&lt;/td&gt;
+ *  &lt;tr&gt;&lt;td&gt;&lt;b&gt;append&lt;/b&gt;&lt;/td&gt;&lt;td&gt;whether to append data at the end if output file exists or replace it (values: true/false)&lt;/td&gt;
+ *  &lt;/tr&gt;
+ *  &lt;/table&gt;  
+ *
+ * &lt;h4&gt;Example:&lt;/h4&gt;
+ * &lt;pre&gt;&lt;Node append=&quot;true&quot; fileURL=&quot;${WORKSPACE}/output/structured_customers.txt&quot;
+ *  id=&quot;TEXT_TABLE_WRITER0&quot; type=&quot;TEXT_TABLE_WRITER&quot;&gt;
+ * &lt;/Node&gt;
+ * 
+ * 
+ * @author ausperger; 
+ * (c) JavlinConsulting s.r.o.
+ *  www.javlinconsulting.cz
+ *
+ * @since Feb 6, 2007
+ *
+ */
+public class TextTableWriter extends Node {
+
+	public static final String XML_APPEND_ATTRIBUTE = &quot;append&quot;;
+	public static final String XML_FILEURL_ATTRIBUTE = &quot;fileURL&quot;;
+	public static final String XML_CHARSET_ATTRIBUTE = &quot;charset&quot;;
+	public static final String XML_MASK_ATTRIBUTE = &quot;mask&quot;;
+	public static final String XML_HEADER_ATTRIBUTE = &quot;header&quot;;
+	public static final String XML_RECORD_FROM_ATTRIBUTE = &quot;recordFrom&quot;;
+	public static final String XML_RECORD_COUNT_ATTRIBUTE = &quot;recordCount&quot;;
+
+	private String fileURL;
+	private boolean appendData;
+	private TextTableFormatter formatter;
+	private boolean header = true;
+	private WritableByteChannel writer;
+	private String charset;
+	private long recordFrom = -1;
+	private long recordCount = -1;
+	
+	public final static String COMPONENT_TYPE = &quot;TEXT_TABLE_WRITER&quot;;
+	private final static int READ_FROM_PORT = 0;
+
+	/**
+	 * Constructor
+	 * 
+	 * @param id
+	 * @param fileURL
+	 * @param charset
+	 * @param appendData
+	 * @param mask
+	 */
+	public TextTableWriter(String id, String fileURL, String charset, 
+			boolean appendData, String[] fields) {
+		super(id);
+		this.fileURL = fileURL;
+		this.appendData = appendData;
+		this.charset = charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER;
+		formatter = charset == null ? new TextTableFormatter() : 
+			new TextTableFormatter(charset);
+		formatter.setMask(fields);
+	}
+
+	/* (non-Javadoc)
+	 * @see org.jetel.graph.Node#getType()
+	 */
+	@Override
+	public String getType() {
+		return COMPONENT_TYPE;
+	}
+
+	@Override
+	public Result execute() throws Exception {
+		//write header
+		InputPort inPort = getInputPort(READ_FROM_PORT);
+		DataRecord record = new DataRecord(inPort.getMetadata());
+		long iRec = 0;
+		long recordTo = recordCount &lt; 0 ? Long.MAX_VALUE : (recordFrom &lt; 0 ? recordCount+1 : recordFrom + recordCount);
+		record.init();
+		//write records
+		try {
+			while (record != null &amp;&amp; runIt) {
+				iRec++;
+				record = inPort.readRecord(record);
+				if (recordFrom &gt; iRec || recordTo &lt;= iRec) continue;
+				if (record != null) {
+					formatter.write(record);
+				}
+				SynchronizeUtils.cloverYield();
+			}
+			formatter.eof();
+		} catch (Exception e) {
+			throw e;
+		}finally{
+			//close output
+			writer.close();
+		}
+        return runIt ? Result.FINISHED_OK : Result.ABORTED;
+	}
+
+	@Override
+	public void free() {
+		super.free();
+		formatter.close();
+	}
+	/* (non-Javadoc)
+	 * @see org.jetel.graph.GraphElement#checkConfig()
+	 */
+    @Override
+    public ConfigurationStatus checkConfig(ConfigurationStatus status) {
+		super.checkConfig(status);
+		 
+		checkInputPorts(status, 1, 1);
+        checkOutputPorts(status, 0, 0);
+
+        try {
+            init();
+            free();
+        } catch (ComponentNotReadyException e) {
+            ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
+            if(!StringUtils.isEmpty(e.getAttributeName())) {
+                problem.setAttributeName(e.getAttributeName());
+            }
+            status.add(problem);
+        }
+        
+        return status;
+    }
+	
+	/* (non-Javadoc)
+	 * @see org.jetel.graph.GraphElement#init()
+	 */
+	@Override
+	public void init() throws ComponentNotReadyException {
+		super.init();
+		// based on file mask, create/open output file
+		try {
+			writer = fileURL == null ? Channels.newChannel(System.out) : FileUtils.getWritableChannel(getGraph().getProjectURL(), fileURL, appendData);
+			formatter.init(getInputPort(READ_FROM_PORT).getMetadata());
+            formatter.setDataTarget(writer);
+            formatter.setHeader(header);
+		} catch (IOException ex) {
+			throw new ComponentNotReadyException(getId() + &quot;IOError: &quot; + ex.getMessage());
+		}
+	}
+
+	/* (non-Javadoc)
+	 * @see org.jetel.graph.Node#fromXML(org.jetel.graph.TransformationGraph, org.w3c.dom.Element)
+	 */
+	public static Node fromXML(TransformationGraph graph, Element nodeXML) {
+		ComponentXMLAttributes xattribs=new ComponentXMLAttributes(nodeXML, graph);
+		TextTableWriter aDataWriter = null;
+		
+		try{
+			String fields = xattribs.getString(XML_MASK_ATTRIBUTE,null);
+			String[] aFields = fields == null ? null : fields.split(&quot;;&quot;);
+			aDataWriter = new TextTableWriter(xattribs.getString(Node.XML_ID_ATTRIBUTE),
+									xattribs.getString(XML_FILEURL_ATTRIBUTE),
+									xattribs.getString(XML_CHARSET_ATTRIBUTE,null),
+									xattribs.getBoolean(XML_APPEND_ATTRIBUTE, false),
+									aFields);
+			if (xattribs.exists(XML_HEADER_ATTRIBUTE)){
+				aDataWriter.setHeader(Boolean.parseBoolean(xattribs.getString(XML_HEADER_ATTRIBUTE)));
+			}
+			if (xattribs.exists(XML_RECORD_FROM_ATTRIBUTE)){
+				aDataWriter.setRecordFrom(Long.parseLong(xattribs.getString(XML_RECORD_FROM_ATTRIBUTE)));
+			}
+			if (xattribs.exists(XML_RECORD_COUNT_ATTRIBUTE)){
+				aDataWriter.setRecordCount(Long.parseLong(xattribs.getString(XML_RECORD_COUNT_ATTRIBUTE)));
+			}
+		}catch(Exception ex){
+			System.err.println(COMPONENT_TYPE + &quot;:&quot; + xattribs.getString(Node.XML_ID_ATTRIBUTE,&quot;unknown ID&quot;) + &quot;:&quot; + ex.getMessage());
+			return null;
+		}
+		
+		return aDataWriter;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.jetel.graph.Node#toXML(org.w3c.dom.Element)
+	 */
+	public void toXML(org.w3c.dom.Element xmlElement) {
+		super.toXML(xmlElement);
+		xmlElement.setAttribute(XML_FILEURL_ATTRIBUTE,this.fileURL);
+		String charSet = this.formatter.getCharsetName();
+		if (charSet != null) {
+			xmlElement.setAttribute(XML_CHARSET_ATTRIBUTE, this.formatter.getCharsetName());
+		}
+		xmlElement.setAttribute(XML_APPEND_ATTRIBUTE, String.valueOf(this.appendData));
+		xmlElement.setAttribute(XML_HEADER_ATTRIBUTE,String.valueOf(header));
+		if (recordFrom != -1){
+			xmlElement.setAttribute(XML_RECORD_FROM_ATTRIBUTE, String.valueOf(recordFrom));
+		}
+		if (recordCount != -1){
+			xmlElement.setAttribute(XML_RECORD_COUNT_ATTRIBUTE,String.valueOf(recordCount));
+		}
+	}
+	
+	public void setHeader(boolean header) {
+		this.header = header;
+	}
+
+	public void setRecordFrom(long recordFrom) {
+		this.recordFrom = recordFrom;
+	}
+
+	public void setRecordCount(long recordCount) {
+		this.recordCount = recordCount;
+	}
+
+}

Deleted: trunk/cloveretl.component/src/org/jetel/component/TextWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/TextWriter.java	2007-02-06 11:16:36 UTC (rev 2437)
+++ trunk/cloveretl.component/src/org/jetel/component/TextWriter.java	2007-02-06 14:57:04 UTC (rev 2438)
@@ -1,297 +0,0 @@
-
-/*
-*    jETeL/Clover - Java based ETL application framework.
-*    Copyright (C) 2005-06  Javlin Consulting &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/cloveretl-svn-commits">info at javlinconsulting.cz</A>&gt;
-*    
-*    This library is free software; you can redistribute it and/or
-*    modify it under the terms of the GNU Lesser General Public
-*    License as published by the Free Software Foundation; either
-*    version 2.1 of the License, or (at your option) any later version.
-*    
-*    This library is distributed in the hope that it will be useful,
-*    but WITHOUT ANY WARRANTY; without even the implied warranty of
-*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
-*    Lesser General Public License for more details.
-*    
-*    You should have received a copy of the GNU Lesser General Public
-*    License along with this library; if not, write to the Free Software
-*    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*
-*/
-
-package org.jetel.component;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.Channels;
-import java.nio.channels.WritableByteChannel;
-
-import org.jetel.data.DataRecord;
-import org.jetel.data.Defaults;
-import org.jetel.data.formatter.TextTableFormatter;
-import org.jetel.exception.ComponentNotReadyException;
-import org.jetel.exception.ConfigurationProblem;
-import org.jetel.exception.ConfigurationStatus;
-import org.jetel.graph.InputPort;
-import org.jetel.graph.Node;
-import org.jetel.graph.Result;
-import org.jetel.graph.TransformationGraph;
-import org.jetel.util.ByteBufferUtils;
-import org.jetel.util.ComponentXMLAttributes;
-import org.jetel.util.FileUtils;
-import org.jetel.util.StringUtils;
-import org.jetel.util.SynchronizeUtils;
-import org.w3c.dom.Element;
-
-/**
- *  &lt;h3&gt;StructureWriter Component&lt;/h3&gt;
- *
- * &lt;!-- All records from input port [0] are formatted due to given mask and written to specified file --&gt;
- * 
- * &lt;table border=&quot;1&quot;&gt;
- *  &lt;th&gt;Component:&lt;/th&gt;
- * &lt;tr&gt;&lt;td&gt;&lt;h4&gt;&lt;i&gt;Name:&lt;/i&gt;&lt;/h4&gt;&lt;/td&gt;
- * &lt;td&gt;StructureWriter&lt;/td&gt;&lt;/tr&gt;
- * &lt;tr&gt;&lt;td&gt;&lt;h4&gt;&lt;i&gt;Category:&lt;/i&gt;&lt;/h4&gt;&lt;/td&gt;
- * &lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
- * &lt;tr&gt;&lt;td&gt;&lt;h4&gt;&lt;i&gt;Description:&lt;/i&gt;&lt;/h4&gt;&lt;/td&gt;
- * &lt;td&gt;All records from input port [0] are formatted due to given mask and written to specified file.
- * Records can be preceded by some text (header) or be trailed by a text (footer)&lt;/td&gt;&lt;/tr&gt;
- * &lt;tr&gt;&lt;td&gt;&lt;h4&gt;&lt;i&gt;Inputs:&lt;/i&gt;&lt;/h4&gt;&lt;/td&gt;
- * &lt;td&gt;[0]- input records&lt;/td&gt;&lt;/tr&gt;
- * &lt;tr&gt;&lt;td&gt;&lt;h4&gt;&lt;i&gt;Outputs:&lt;/i&gt;&lt;/h4&gt;&lt;/td&gt;
- * &lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
- * &lt;tr&gt;&lt;td&gt;&lt;h4&gt;&lt;i&gt;Comment:&lt;/i&gt;&lt;/h4&gt;&lt;/td&gt;
- * &lt;td&gt;This component uses java.nio.* classes.&lt;/td&gt;&lt;/tr&gt;
- * &lt;/table&gt;
- *  &lt;br&gt;  
- *  &lt;table border=&quot;1&quot;&gt;
- *  &lt;th&gt;XML attributes:&lt;/th&gt;
- *  &lt;tr&gt;&lt;td&gt;&lt;b&gt;type&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&quot;STRUCTURE_WRITER&quot;&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td&gt;&lt;b&gt;id&lt;/b&gt;&lt;/td&gt;&lt;td&gt;component identification&lt;/td&gt;
- *  &lt;tr&gt;&lt;td&gt;&lt;b&gt;fileURL&lt;/b&gt;&lt;/td&gt;&lt;td&gt;Output files mask.
- *  Use wildcard '#' to specify where to insert sequential number of file. Number of consecutive wildcards specifies
- *  minimal length of the number. Name without wildcard specifies only one file.&lt;/td&gt;
- *  &lt;tr&gt;&lt;td&gt;&lt;b&gt;charset&lt;/b&gt;&lt;/td&gt;&lt;td&gt;character encoding of the output file (if not specified, then ISO-8859-1 is used)&lt;/td&gt;
- *  &lt;tr&gt;&lt;td&gt;&lt;b&gt;append&lt;/b&gt;&lt;/td&gt;&lt;td&gt;whether to append data at the end if output file exists or replace it (values: true/false)&lt;/td&gt;
- *  &lt;tr&gt;&lt;td&gt;&lt;b&gt;mask&lt;/b&gt;&lt;/td&gt;&lt;td&gt;template for formating records. Every occurrence 
- *  of $fieldName will be replaced by value of the fieldName. The rest of text will
- *  be unchanged. If not given there is used default mask:
- *  &lt; recordName field1=$field1 field2=$field2 ... fieldn=$fieldn /&gt;
- *  where field1 ,.., fieldn are record's fields from metadata&lt;/td&gt;
- *  &lt;tr&gt;&lt;td&gt;&lt;b&gt;header&lt;/b&gt;&lt;/td&gt;&lt;td&gt;text to write before records&lt;/td&gt;
- *  &lt;tr&gt;&lt;td&gt;&lt;b&gt;footer&lt;/b&gt;&lt;/td&gt;&lt;td&gt;text to write after records&lt;/td&gt;
- *  &lt;/tr&gt;
- *  &lt;/table&gt;  
- *
- * &lt;h4&gt;Example:&lt;/h4&gt;
- * &lt;pre&gt;&lt;Node append=&quot;true&quot; fileURL=&quot;${WORKSPACE}/output/structured_customers.txt&quot;
- *  id=&quot;STRUCTURE_WRITER0&quot; type=&quot;STRUCTURE_WRITER&quot;&gt;
- * &lt;attr name=&quot;header&quot;&gt;dir = ${WORKSPACE}&lt;/attr&gt;
- * &lt;attr name=&quot;mask&quot;&gt;
- * &lt;Customer id=$customer_id&gt;
- * 	&lt;last name = $lname&gt;
- *	&lt;first name = $fname&gt;
- * &lt;/Customer&gt;
- * &lt;/attr&gt;
- * &lt;attr name=&quot;footer&quot;&gt;end of file&lt;/attr&gt;
- * &lt;/Node&gt;
- * 
- * 
- * @author avackova (<A HREF="https://lists.berlios.de/mailman/listinfo/cloveretl-svn-commits">agata.vackova at javlinconsulting.cz</A>) ; 
- * (c) JavlinConsulting s.r.o.
- *  www.javlinconsulting.cz
- *
- * @since Oct 30, 2006
- *
- */
-public class TextWriter extends Node {
-
-	public static final String XML_APPEND_ATTRIBUTE = &quot;append&quot;;
-	public static final String XML_FILEURL_ATTRIBUTE = &quot;fileURL&quot;;
-	public static final String XML_CHARSET_ATTRIBUTE = &quot;charset&quot;;
-	public static final String XML_MASK_ATTRIBUTE = &quot;mask&quot;;
-	public static final String XML_HEADER_ATTRIBUTE = &quot;header&quot;;
-	public static final String XML_RECORD_FROM_ATTRIBUTE = &quot;recordFrom&quot;;
-	public static final String XML_RECORD_COUNT_ATTRIBUTE = &quot;recordCount&quot;;
-
-	private String fileURL;
-	private boolean appendData;
-	private TextTableFormatter formatter;
-	private boolean header = true;
-	private WritableByteChannel writer;
-	private String charset;
-	private long recordFrom = -1;
-	private long recordCount = -1;
-	
-	public final static String COMPONENT_TYPE = &quot;STRUCTURE_WRITER&quot;;
-	private final static int READ_FROM_PORT = 0;
-
-	/**
-	 * Constructor
-	 * 
-	 * @param id
-	 * @param fileURL
-	 * @param charset
-	 * @param appendData
-	 * @param mask
-	 */
-	public TextWriter(String id, String fileURL, String charset, 
-			boolean appendData, String[] fields) {
-		super(id);
-		this.fileURL = fileURL;
-		this.appendData = appendData;
-		this.charset = charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER;
-		formatter = charset == null ? new TextTableFormatter() : 
-			new TextTableFormatter(charset);
-		formatter.setMask(fields);
-	}
-
-	/* (non-Javadoc)
-	 * @see org.jetel.graph.Node#getType()
-	 */
-	@Override
-	public String getType() {
-		return COMPONENT_TYPE;
-	}
-
-	@Override
-	public Result execute() throws Exception {
-		//write header
-		InputPort inPort = getInputPort(READ_FROM_PORT);
-		DataRecord record = new DataRecord(inPort.getMetadata());
-		long iRec = 0;
-		long recordTo = recordCount &lt; 0 ? Long.MAX_VALUE : (recordFrom &lt; 0 ? recordCount+1 : recordFrom + recordCount);
-		record.init();
-		//write records
-		try {
-			while (record != null &amp;&amp; runIt) {
-				iRec++;
-				record = inPort.readRecord(record);
-				if (recordFrom &gt; iRec || recordTo &lt;= iRec) continue;
-				if (record != null) {
-					formatter.write(record);
-				}
-				SynchronizeUtils.cloverYield();
-			}
-			formatter.eof();
-		} catch (Exception e) {
-			throw e;
-		}finally{
-			//close output
-			writer.close();
-		}
-        return runIt ? Result.FINISHED_OK : Result.ABORTED;
-	}
-
-	@Override
-	public void free() {
-		super.free();
-		formatter.close();
-	}
-	/* (non-Javadoc)
-	 * @see org.jetel.graph.GraphElement#checkConfig()
-	 */
-    @Override
-    public ConfigurationStatus checkConfig(ConfigurationStatus status) {
-		super.checkConfig(status);
-		 
-		checkInputPorts(status, 1, 1);
-        checkOutputPorts(status, 0, 0);
-
-        try {
-            init();
-            free();
-        } catch (ComponentNotReadyException e) {
-            ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
-            if(!StringUtils.isEmpty(e.getAttributeName())) {
-                problem.setAttributeName(e.getAttributeName());
-            }
-            status.add(problem);
-        }
-        
-        return status;
-    }
-	
-	/* (non-Javadoc)
-	 * @see org.jetel.graph.GraphElement#init()
-	 */
-	@Override
-	public void init() throws ComponentNotReadyException {
-		super.init();
-		// based on file mask, create/open output file
-		try {
-			writer = fileURL == null ? Channels.newChannel(System.out) : FileUtils.getWritableChannel(getGraph().getProjectURL(), fileURL, appendData);
-			formatter.init(getInputPort(READ_FROM_PORT).getMetadata());
-            formatter.setDataTarget(writer);
-            formatter.setHeader(header);
-		} catch (IOException ex) {
-			throw new ComponentNotReadyException(getId() + &quot;IOError: &quot; + ex.getMessage());
-		}
-	}
-
-	/* (non-Javadoc)
-	 * @see org.jetel.graph.Node#fromXML(org.jetel.graph.TransformationGraph, org.w3c.dom.Element)
-	 */
-	public static Node fromXML(TransformationGraph graph, Element nodeXML) {
-		ComponentXMLAttributes xattribs=new ComponentXMLAttributes(nodeXML, graph);
-		TextWriter aDataWriter = null;
-		
-		try{
-			String fields = xattribs.getString(XML_MASK_ATTRIBUTE,null);
-			String[] aFields = fields == null ? null : fields.split(&quot;;&quot;);
-			aDataWriter = new TextWriter(xattribs.getString(Node.XML_ID_ATTRIBUTE),
-									xattribs.getString(XML_FILEURL_ATTRIBUTE),
-									xattribs.getString(XML_CHARSET_ATTRIBUTE,null),
-									xattribs.getBoolean(XML_APPEND_ATTRIBUTE, false),
-									aFields);
-			if (xattribs.exists(XML_HEADER_ATTRIBUTE)){
-				aDataWriter.setHeader(Boolean.parseBoolean(xattribs.getString(XML_HEADER_ATTRIBUTE)));
-			}
-			if (xattribs.exists(XML_RECORD_FROM_ATTRIBUTE)){
-				aDataWriter.setRecordFrom(Long.parseLong(xattribs.getString(XML_RECORD_FROM_ATTRIBUTE)));
-			}
-			if (xattribs.exists(XML_RECORD_COUNT_ATTRIBUTE)){
-				aDataWriter.setRecordCount(Long.parseLong(xattribs.getString(XML_RECORD_COUNT_ATTRIBUTE)));
-			}
-		}catch(Exception ex){
-			System.err.println(COMPONENT_TYPE + &quot;:&quot; + xattribs.getString(Node.XML_ID_ATTRIBUTE,&quot;unknown ID&quot;) + &quot;:&quot; + ex.getMessage());
-			return null;
-		}
-		
-		return aDataWriter;
-	}
-
-	/* (non-Javadoc)
-	 * @see org.jetel.graph.Node#toXML(org.w3c.dom.Element)
-	 */
-	public void toXML(org.w3c.dom.Element xmlElement) {
-		super.toXML(xmlElement);
-		xmlElement.setAttribute(XML_FILEURL_ATTRIBUTE,this.fileURL);
-		String charSet = this.formatter.getCharsetName();
-		if (charSet != null) {
-			xmlElement.setAttribute(XML_CHARSET_ATTRIBUTE, this.formatter.getCharsetName());
-		}
-		xmlElement.setAttribute(XML_APPEND_ATTRIBUTE, String.valueOf(this.appendData));
-		xmlElement.setAttribute(XML_HEADER_ATTRIBUTE,String.valueOf(header));
-		if (recordFrom != -1){
-			xmlElement.setAttribute(XML_RECORD_FROM_ATTRIBUTE, String.valueOf(recordFrom));
-		}
-		if (recordCount != -1){
-			xmlElement.setAttribute(XML_RECORD_COUNT_ATTRIBUTE,String.valueOf(recordCount));
-		}
-	}
-	
-	public void setHeader(boolean header) {
-		this.header = header;
-	}
-
-	public void setRecordFrom(long recordFrom) {
-		this.recordFrom = recordFrom;
-	}
-
-	public void setRecordCount(long recordCount) {
-		this.recordCount = recordCount;
-	}
-
-}

Modified: trunk/cloveretl.engine/src/org/jetel/component/ComponentFactory.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/component/ComponentFactory.java	2007-02-06 11:16:36 UTC (rev 2437)
+++ trunk/cloveretl.engine/src/org/jetel/component/ComponentFactory.java	2007-02-06 14:57:04 UTC (rev 2438)
@@ -85,7 +85,7 @@
      * @param componentType
      * @return class from the given component type
      */
-    private final static Class getComponentClass(String componentType) {
+    public final static Class getComponentClass(String componentType) {
         String className = null;
         ComponentDescription componentDescription = (ComponentDescription) componentMap.get(componentType);
         

Deleted: trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java	2007-02-06 11:16:36 UTC (rev 2437)
+++ trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java	2007-02-06 14:57:04 UTC (rev 2438)
@@ -1,620 +0,0 @@
-/*
- *  jETeL/Clover - Java based ETL application framework.
- *  Copyright (C) 2002-03  David Pavlis
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License as published by the Free Software Foundation; either
- *    version 2.1 of the License, or (at your option) any later version.
- *    
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
- *    Lesser General Public License for more details.
- *    
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-package org.jetel.main;
-
-import java.io.BufferedInputStream;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URL;
-import java.util.Map;
-import java.util.Properties;
-
-import org.apache.commons.cli.CommandLine;
-import org.apache.commons.cli.Option;
-import org.apache.commons.cli.Options;
-import org.apache.commons.cli.ParseException;
-import org.apache.commons.cli.PosixParser;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.log4j.Level;
-import org.apache.log4j.Logger;
-import org.apache.log4j.net.SocketAppender;
-import org.jetel.component.DataWriter;
-import org.jetel.component.ExtFilter;
-import org.jetel.component.StructureWriter;
-import org.jetel.component.TextWriter;
-import org.jetel.data.Defaults;
-import org.jetel.exception.ConfigurationStatus;
-import org.jetel.exception.GraphConfigurationException;
-import org.jetel.exception.XMLConfigurationException;
-import org.jetel.graph.Edge;
-import org.jetel.graph.Node;
-import org.jetel.graph.Phase;
-import org.jetel.graph.Result;
-import org.jetel.graph.TransformationGraph;
-import org.jetel.graph.TransformationGraphXMLReaderWriter;
-import org.jetel.metadata.DataRecordMetadata;
-import org.jetel.plugin.Plugins;
-import org.jetel.util.FileUtils;
-import org.jetel.util.JetelVersion;
-import org.jetel.util.crypto.Enigma;
-
-/**
- *  class for reading and showing data over input components&lt;br&gt;&lt;br&gt;
- *  The graph layout is read from specified XML file and over component id is written data to output.&lt;br&gt;
- *  &lt;tt&gt;&lt;pre&gt;
- *  Program parameters:
- *  &lt;table&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;-v&lt;/td&gt;&lt;td&gt;be verbose - print even graph layout&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;-P&lt;i&gt;properyName&lt;/i&gt;=&lt;i&gt;propertyValue&lt;/i&gt;&lt;/td&gt;&lt;td&gt;add definition of property to global graph's property list&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;--cfg &lt;i&gt;filename&lt;/i&gt;&lt;/td&gt;&lt;td&gt;load definitions of properties from specified file&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;--tracking &lt;i&gt;seconds&lt;/i&gt;&lt;/td&gt;&lt;td&gt;how frequently output the processing status&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;--info&lt;/td&gt;&lt;td&gt;print info about Clover library version&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;--plugins &lt;i&gt;filename&lt;/i&gt;&lt;/td&gt;&lt;td&gt;directory where to look for plugins/components&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;--pass &lt;i&gt;password&lt;/i&gt;&lt;/td&gt;&lt;td&gt;password for decrypting of hidden connections passwords&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;--stdin&lt;/td&gt;&lt;td&gt;load graph layout from STDIN&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;--mode&lt;/td&gt;&lt;td&gt;how show data over component {TEXT,HTML,DELIMITER_TEXT}&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;--delimiter&lt;/td&gt;&lt;td&gt;delimiter between two fields&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;--file&lt;/td&gt;&lt;td&gt;file url for output. If no file defined, output is set to System.out&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;--expFilter&lt;/td&gt;&lt;td&gt;filter expression for record filtering&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;--recFrom&lt;/td&gt;&lt;td&gt;from where show records&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;--recCount&lt;/td&gt;&lt;td&gt;how many records should be showed&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;--fields&lt;/td&gt;&lt;td&gt;Show only defined fields. If no fields defined, show all fields&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;--logLevel&lt;/td&gt;&lt;td&gt;Log level for logger {all, info, debug, ..}, default is error log level&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;&lt;b&gt;filename&lt;/b&gt;&lt;/td&gt;&lt;td&gt;filename or URL of the file (even remote) containing graph's layout in XML (this must be the last parameter passed)&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;&lt;b&gt;component id&lt;/b&gt;&lt;/td&gt;&lt;td&gt;over this component will be showed data&lt;/td&gt;&lt;/tr&gt;
- *  &lt;/table&gt;
- *
- *  &lt;h4&gt;Example:&lt;/h4&gt;
- *  &lt;pre&gt;showComponentData ExampleGraph.grf DELIMITED_DATA_READER0:0&lt;/pre&gt;
- *  
- *  &lt;pre&gt;showComponentData --plugins ../cloveretl.engine/plugins --mode TEXT --delimiter &quot;+&quot; --expFilter &quot;1==1&quot; --recFrom 2 --recCount 2 --fields &quot;Field1;Field0&quot; ExampleGraph.grf DELIMITED_DATA_READER0:0&lt;/pre&gt;
- *  
- *  &lt;/pre&gt;&lt;/tt&gt;
- * @author      jausperger
- * @since       2007/02/02
- * @revision    $Revision:  $
- */
-public class showComponentData {
-    private static Log logger = LogFactory.getLog(showComponentData.class);
-
-    //TODO change run graph version
-	private final static String RUN_GRAPH_VERSION = &quot;2.0&quot;;
-	
-    /**
-     * Clover.ETL engine initialization. Should be called only once.
-     * @param pluginsRootDirectory directory path, where plugins specification is located 
-     *        (can be null, then is used constant from Defaults.DEFAULT_PLUGINS_DIRECTORY)
-     * @param password password for encrypting some hidden part of graphs
-     *        &lt;br&gt;i.e. connections passwordss can be encrypted
-     */        int trackingInterval = -1;
-
-    public static void initEngine(String pluginsRootDirectory, String password) {
-        
-        //init password decryptor
-        if(password != null) {
-            Enigma.getInstance().init(password);
-        }
-        
-        //init framework constants
-        Defaults.init();
-
-        //init clover plugins system
-        Plugins.init(pluginsRootDirectory);
-    }
-    
-    
-    /**
-     * Instantiates transformation graph from a given input stream and presets a given properties.
-     * @param inStream
-     * @param properties
-     * @return
-     * @throws XMLConfigurationException
-     * @throws GraphConfigurationException
-     */
-    public static TransformationGraph loadGraph(InputStream inStream, Properties properties) throws XMLConfigurationException, GraphConfigurationException {
-        TransformationGraph graph = new TransformationGraph();
-        TransformationGraphXMLReaderWriter graphReader = new TransformationGraphXMLReaderWriter(graph);
-        if(properties != null) {
-            graph.loadGraphProperties(properties);
-        }
-
-        graphReader.read(inStream);
-        
-        return graph;
-    }
-    
-	/**
-	 *  Description of the Method
-	 *
-	 * @param  args  Description of the Parameter
-	 */
-	public static void main(String args[]) {
-		boolean verbose = false;
-        boolean loadFromSTDIN = false;
-		Properties properties = new Properties();
-        int trackingInterval = -1;
-		String pluginsRootDirectory = null;
-        String password = null;
-        Mode viewMode = Mode.TEXT;
-        String delimiter = null;
-        String fileUrl = null;
-        String filterExpression = null;
-        long recordFrom = -1;
-        long recordCount = -1;
-        String fields = null;
-        String logHost = null;
-		
-		ExtFilter extFilter = null;
-        
-		System.out.println(&quot;***  CloverETL graph component tester ver &quot;+RUN_GRAPH_VERSION+&quot;, (c) 2002-06 D.Pavlis, released under GNU Lesser General Public License  ***&quot;);
-		System.out.println(&quot; Running with framework version: &quot;+JetelVersion.MAJOR_VERSION+&quot;.&quot;+JetelVersion.MINOR_VERSION+&quot; build#&quot;+JetelVersion.BUILD_NUMBER+&quot; compiled &quot;+JetelVersion.LIBRARY_BUILD_DATETIME);
-		System.out.println();
-        
-		if (args.length &lt; 1) {
-			printHelp();
-			System.exit(-1);
-		}
-        
-		Options options = new Options();
-    	options.addOption(new Option(&quot;v&quot;, &quot;verbose&quot;, false, &quot;Verbose mode&quot;));
-    	options.addOption(new Option(&quot;g&quot;, &quot;cfg&quot;, true, &quot;Path to property file&quot;));
-    	options.addOption(new Option(&quot;P&quot;, &quot;propertyDefinition&quot;, true, &quot;Property defined by user&quot;));
-    	options.addOption(new Option(&quot;t&quot;, &quot;tracking&quot;, false, &quot;Tracking intrnal switch&quot;));
-    	options.addOption(new Option(&quot;i&quot;, &quot;info&quot;, false, &quot;Information about program&quot;));
-    	options.addOption(new Option(&quot;n&quot;, &quot;stdin&quot;, false, &quot;Load from stdin switch&quot;));
-    	options.addOption(new Option(&quot;h&quot;, &quot;loghost&quot;, false, &quot;Log host switch&quot;));
-    	options.addOption(new Option(&quot;p&quot;, &quot;plugins&quot;, true, &quot;Path to plugins file.&quot;));
-    	options.addOption(new Option(&quot;s&quot;, &quot;pass&quot;, true, &quot;Password&quot;));
-    	options.addOption(new Option(&quot;m&quot;, &quot;mode&quot;, true, &quot;View mode&quot;));
-    	options.addOption(new Option(&quot;d&quot;, &quot;delimiter&quot;, true, &quot;Delimiter between two fields&quot;));
-    	options.addOption(new Option(&quot;o&quot;, &quot;file&quot;, true, &quot;File url for output. If no file defined, output is set to System.out&quot;));
-    	options.addOption(new Option(&quot;e&quot;, &quot;expFilter&quot;, true, &quot;Filter expression for record filtering&quot;));
-    	options.addOption(new Option(&quot;f&quot;, &quot;recFrom&quot;, true, &quot;From where show records&quot;));
-    	options.addOption(new Option(&quot;c&quot;, &quot;recCount&quot;, true, &quot;Count of records&quot;));
-    	options.addOption(new Option(&quot;l&quot;, &quot;fields&quot;, true, &quot;Show only defined fields. If no fields defined, show all fields&quot;));
-    	options.addOption(new Option(&quot;x&quot;, &quot;logLevel&quot;, true, &quot;Log level for logger {all, info, debug, ..}, default is error log level&quot;));
-
-    	PosixParser optParser = new PosixParser();
-    	CommandLine cmdLine;
-		try {
-			cmdLine = optParser.parse(options, args);
-		} catch (ParseException e) {
-			logger.error(e.getMessage(), e);
-			return;
-		}
-		
-		verbose = cmdLine.hasOption(&quot;v&quot;);
-		loadFromSTDIN = cmdLine.hasOption(&quot;n&quot;);
-		if (cmdLine.hasOption(&quot;h&quot;)) {
-            String[] hostAndPort = logHost.split(&quot;:&quot;);
-            if (hostAndPort[0].length() == 0 || hostAndPort.length &gt; 2) {
-                System.err
-                        .println(&quot;Invalid log destination, i.e. -loghost localhost:4445&quot;);
-                System.exit(-1);
-            }
-            int port = 4445;
-            try {
-                if (hostAndPort.length == 2) {
-                    port = Integer.parseInt(hostAndPort[1]);
-                }
-            } catch (NumberFormatException e) {
-                System.err
-                        .println(&quot;Invalid log destination, i.e. -loghost localhost:4445&quot;);
-                System.exit(-1);
-            }
-            Logger.getRootLogger().addAppender(
-                    new SocketAppender(hostAndPort[0], port));
-		}
-		if (cmdLine.hasOption(&quot;g&quot;)) {
-			InputStream inStream;
-			try {
-				inStream = new BufferedInputStream(new FileInputStream(cmdLine.getOptionValue(&quot;g&quot;)));
-				properties.load(inStream);
-			} catch (NullPointerException e) {
-				logger.error(&quot;cfg file not found: &quot; + e.getMessage(), e);
-				System.exit(-1);
-			} catch (IOException e) {
-				logger.error(e.getMessage(), e);
-				System.exit(-1);
-			}
-		}
-		if (cmdLine.hasOption(&quot;P&quot;)) {
-	    	String a[] = cmdLine.getOptionValue(&quot;P&quot;).split(&quot;;&quot;);
-	    	for (String tmp : a) {
-	    	    properties.setProperty(tmp.substring(0,tmp.indexOf(&quot;=&quot;)),tmp.substring(tmp.indexOf(&quot;=&quot;) +1)); 
-	    	}
-		}
-		if (cmdLine.hasOption(&quot;i&quot;)) {
-		    printInfo();
-		    System.exit(0);
-		}
-		if (cmdLine.hasOption(&quot;t&quot;)) {
-            try {
-                trackingInterval = Integer.parseInt(cmdLine.getOptionValue(&quot;t&quot;));
-            } catch (NumberFormatException ex) {
-                System.err.println(&quot;Invalid tracking parameter: \&quot;&quot;
-                        + cmdLine.getOptionValue(&quot;t&quot;) + &quot;\&quot;&quot;);
-                System.exit(-1);
-            }
-		}
-		if (cmdLine.hasOption(&quot;p&quot;)) {
-			pluginsRootDirectory = cmdLine.getOptionValue(&quot;p&quot;);
-		}
-		if (cmdLine.hasOption(&quot;s&quot;)) {
-			password = cmdLine.getOptionValue(&quot;s&quot;);
-		}
-		if (cmdLine.hasOption(&quot;m&quot;)) {
-			viewMode = Mode.valueModeOf(cmdLine.getOptionValue(&quot;m&quot;));
-	        if (viewMode == null) {
-				System.err.println(&quot;Unknown mode option: &quot;+cmdLine.getOptionValue(&quot;m&quot;));
-				System.exit(-1);
-	        }
-		}
-		if (cmdLine.hasOption(&quot;d&quot;)) {
-			delimiter = cmdLine.getOptionValue(&quot;d&quot;);
-		}
-		if (cmdLine.hasOption(&quot;o&quot;)) {
-			fileUrl = cmdLine.getOptionValue(&quot;o&quot;);
-		}
-		if (cmdLine.hasOption(&quot;e&quot;)) {
-			filterExpression = cmdLine.getOptionValue(&quot;e&quot;);
-		}
-		if (cmdLine.hasOption(&quot;f&quot;)) {
-	    	recordFrom = Long.parseLong(cmdLine.getOptionValue(&quot;f&quot;));
-		}
-		if (cmdLine.hasOption(&quot;c&quot;)) {
-	    	recordCount = Long.parseLong(cmdLine.getOptionValue(&quot;c&quot;));
-		}
-		if (cmdLine.hasOption(&quot;l&quot;)) {
-        	fields = cmdLine.getOptionValue(&quot;l&quot;);
-		}
-		Logger.getRootLogger().setLevel(cmdLine.hasOption(&quot;x&quot;)?Level.toLevel(cmdLine.getOptionValue(&quot;x&quot;)):Level.ERROR);
-		
-        // setup log4j appenders
-        if (logHost != null) {
-            String[] hostAndPort = logHost.split(&quot;:&quot;);
-            if (hostAndPort[0].length() == 0 || hostAndPort.length &gt; 2) {
-                System.err
-                        .println(&quot;Invalid log destination, i.e. -loghost localhost:4445&quot;);
-                System.exit(-1);
-            }
-            int port = 4445;
-            try {
-                if (hostAndPort.length == 2) {
-                    port = Integer.parseInt(hostAndPort[1]);
-                }
-            } catch (NumberFormatException e) {
-                System.err
-                        .println(&quot;Invalid log destination, i.e. -loghost localhost:4445&quot;);
-                System.exit(-1);
-            }
-            Logger.getRootLogger().addAppender(
-                    new SocketAppender(hostAndPort[0], port));
-        }
-        
-        // engine initialization - should be called only once
-        runGraph.initEngine(pluginsRootDirectory, password);
-
-        // prapere input stream with XML graph definition
-        InputStream in = null;
-        if (loadFromSTDIN) {
-            System.out.println(&quot;Graph definition loaded from STDIN&quot;);
-            in = System.in;
-        } else {
-            System.out.println(&quot;Graph definition file: &quot;
-                    + args[args.length - 2]);
-            try {
-                URL fileURL = FileUtils.getFileURL(null, args[args.length - 2]);
-                in = fileURL.openStream();
-            } catch (IOException e) {
-                System.err
-                        .println(&quot;Error - graph definition file can't be read: &quot;
-                                + e.getMessage());
-                System.exit(-1);
-            }
-        }
-        
-        System.out.println(&quot;Component id: &quot; + args[args.length - 1]);
-        String componentID = args[args.length - 1];
-        int pos;
-        int port = 0;
-        if ((pos = componentID.indexOf(':')) != -1) {
-        	port = Integer.parseInt(componentID.substring(pos+1));
-        	componentID = componentID.substring(0, pos);
-        }
-
-        // loading graph from the input stream
-        TransformationGraph graph = null;
-        try {
-            graph = runGraph.loadGraph(in, properties);
-
-            // check graph elements configuration
-            logger.info(&quot;Checking graph configuration...&quot;);
-            try {
-                ConfigurationStatus status = graph.checkConfig(null);
-                status.log();
-            } catch(Exception e) {
-                logger.error(&quot;Checking graph failed! (&quot; + e.getMessage() + &quot;)&quot;);
-            }
-
-            if (!graph.init()) {
-                throw new GraphConfigurationException(
-                        &quot;Graph initialization failed.&quot;);
-            }
-
-            if (verbose) {
-                // this can be called only after graph.init()
-                graph.dumpGraphConfiguration();
-            }
-        } catch (XMLConfigurationException ex) {
-            logger.error(&quot;Error in reading graph from XML !&quot;, ex);
-            if (verbose) {
-                ex.printStackTrace(System.err);
-            }
-            System.exit(-1);
-        } catch (GraphConfigurationException ex) {
-            logger.error(&quot;Error - graph's configuration invalid !&quot;, ex);
-            if (verbose) {
-                ex.printStackTrace(System.err);
-            }
-            System.exit(-1);
-        } catch (RuntimeException ex) {
-            logger.error(&quot;Error during graph initialization !&quot;, ex);
-            if (verbose) {
-                ex.printStackTrace(System.err);
-            }
-            System.exit(-1);
-        }
-        
-
-        //check graph elements configuration
-        ConfigurationStatus status = graph.checkConfig(null);
-        status.log();
-        
-		Map map = graph.getNodes();
-		Node node = (Node) map.get(componentID);
-		if (node == null) {
-			//map = graph.getEdges();
-			//Edge edge = (Edge) map.get(componentID);
-			//if (edge == null) {
-				// error
-				logger.error(&quot;Component Id '&quot;+ componentID +&quot;' not found!&quot;);
-				return;
-			//}
-		}
-		if (!node.isRoot()) {
-			// not implemented
-			System.err.println(&quot;Execution is implemented for root node (root node has only output ports connected)!&quot;);
-			return;
-		}
-
-		// create new graph
-	    TransformationGraph viewGraph = new TransformationGraph();
-		Phase _PHASE_1 = new Phase(1);
-
-	    // add writer component
-		DataRecordMetadata dataRecordMetadata = (DataRecordMetadata) node.getOutMetadata().toArray()[port];
-		Edge edge0 = new Edge(&quot;EDGE0&quot;, dataRecordMetadata);
-		Edge edge1 = null;
-		if (filterExpression != null) {
-			edge1 = new Edge(&quot;EDGE1&quot;, dataRecordMetadata);
-		}
-		Node writer = getWriter(viewMode, dataRecordMetadata, fileUrl, delimiter, recordFrom, recordCount, fields);
-		
-		// add Edges &amp; Nodes &amp; Phases to graph
-		try {
-			viewGraph.addPhase(_PHASE_1);
-			viewGraph.addEdge(edge0);
-			_PHASE_1.addNode(node);
-			_PHASE_1.addNode(writer);
-			
-			if (filterExpression != null) {
-				viewGraph.addEdge(edge1);
-				extFilter = new ExtFilter(&quot;ExtFilter0&quot;);
-				extFilter.setFilterExpression(filterExpression);
-				_PHASE_1.addNode(extFilter);
-			}
-		} catch (GraphConfigurationException e) {
-			e.printStackTrace();
-		}
-
-		// assign ports (input &amp; output)
-		node.addOutputPort(0,edge0);
-		if (filterExpression != null) {
-			extFilter.addInputPort(0,edge0);
-			extFilter.addOutputPort(0,edge1);
-			writer.addInputPort(0,edge1); 
-		} else {
-			writer.addInputPort(0,edge0);
-		}
-
-		if(!viewGraph.init()){
-			System.err.println(&quot;Graph initialization failed !&quot;);
-			return;
-		}
-	    
-        // set tracking interval
-        if (trackingInterval != -1) {
-        	viewGraph.setTrackingInterval(trackingInterval * 1000);
-        }
-
-        //	start all Nodes (each node is one thread)
-		Result result=Result.N_A;
-		try {
-            result = viewGraph.run();
-        } catch (RuntimeException ex) {
-            System.err.println(&quot;Fatal error during graph run !&quot;);
-            System.err.println(ex.getCause().getMessage());
-            if (verbose) {
-                ex.printStackTrace();
-            }
-            System.exit(-1);
-        }
-        switch (result) {
-
-        case FINISHED_OK:
-            // everything O.K.
-            System.out.println(&quot;Execution of graph successful !&quot;);
-            System.exit(0);
-            break;
-        case ABORTED:
-            // execution was ABORTED !!
-            System.err.println(&quot;Execution of graph aborted !&quot;);
-            System.exit(result.code());
-            break;
-        default:
-            System.err.println(&quot;Execution of graph failed !&quot;);
-            System.exit(result.code());
-        }
-
-	}
-    
-	private static Node getWriter(Mode mode, DataRecordMetadata dataRecordMetadata, String fileUrl, String delimiter, long recordFrom, long recordCount, String fields) {
-		if (mode == null) return null;
-		Node writer = null;
-		String[] aFiealds = fields == null ? null : fields.split(&quot;;&quot;);
-		
-		if (mode.equals(Mode.HTML)) {
-			StringBuilder maskBuilder = new StringBuilder();
-			if (aFiealds == null) {
-				maskBuilder.append(&quot;&lt;tr&gt;&quot;);
-				for (int i=0;i&lt;dataRecordMetadata.getNumFields();i++){
-					maskBuilder.append(&quot;&lt;td&gt;$&quot;);
-					maskBuilder.append(dataRecordMetadata.getField(i).getName());
-					maskBuilder.append(&quot;&lt;/td&gt;&quot;);
-				}
-				maskBuilder.append(&quot;&lt;/tr&gt;\n&quot;);
-			} else if (aFiealds.length &gt; 0) {
-				maskBuilder.append(&quot;&lt;tr&gt;&quot;);
-				for (String sfield: aFiealds){
-					if (dataRecordMetadata.getField(sfield) == null) {
-						System.err.println(&quot;Field name '&quot;+ sfield + &quot;' not found.&quot;);
-						System.exit(-1);
-					}
-					maskBuilder.append(&quot;&lt;td&gt;$&quot;);
-					maskBuilder.append(sfield);
-					maskBuilder.append(&quot;&lt;/td&gt;&quot;);
-				}
-				maskBuilder.append(&quot;&lt;/tr&gt;\n&quot;);
-			} else {
-				System.err.println(&quot;No field found.&quot;);
-				System.exit(-1);
-			}
-			
-			StructureWriter structureWriter = new StructureWriter(&quot;STRUCTURE_WRITER0&quot;, fileUrl, null, false, maskBuilder.toString());
-			structureWriter.setRecordFrom(recordFrom);
-			structureWriter.setRecordCount(recordCount);
-			StringBuilder sb = new StringBuilder();
-			
-			sb.append(&quot;&lt;table name=\&quot;&quot; + dataRecordMetadata.getName() + &quot;\&quot; border=1&gt;\n&quot;);
-			sb.append(&quot;&lt;tr&gt;&quot;);
-			if (aFiealds == null ) {
-				for (int i=0;i&lt;dataRecordMetadata.getNumFields();i++){
-					sb.append(&quot;&lt;th&gt;&quot;);
-					sb.append(dataRecordMetadata.getField(i).getName());
-					sb.append(&quot;&lt;/th&gt;&quot;);
-				}
-			} else {
-				for (String sfield: aFiealds){
-					sb.append(&quot;&lt;th&gt;&quot;);
-					sb.append(dataRecordMetadata.getField(sfield).getName());
-					sb.append(&quot;&lt;/th&gt;&quot;);
-				}
-			}
-			sb.append(&quot;&lt;/tr&gt;\n&quot;);
-			structureWriter.setHeader(sb.toString());
-			
-			sb = new StringBuilder();
-			sb.append(&quot;&lt;/table&gt;\n&quot;);
-			structureWriter.setFooter(sb.toString());
-			writer = structureWriter;
-			
-		} else if (mode.equals(Mode.TEXT)) {
-			DataWriter dataWriter = new DataWriter(&quot;DATA_WRITER0&quot;, fileUrl, dataRecordMetadata.getLocaleStr(), false);
-			//TODO agata dodelat selekci na fieldy
-			dataWriter.setRecordFrom(recordFrom);
-			dataWriter.setRecordCount(recordCount);
-			if (delimiter != null) dataWriter.setDataDelimiter(delimiter);
-			writer = dataWriter;
-			
-		} else if (mode.equals(Mode.DELIMITER_TEXT)) {
-			TextWriter dataWriter = new TextWriter(&quot;TEXT_TABLE_WRITER0&quot;, fileUrl, null, false, aFiealds);
-			dataWriter.setRecordFrom(recordFrom);
-			dataWriter.setRecordCount(recordCount);
-			dataWriter.setHeader(true);
-			writer = dataWriter;
-		}
-		return writer;
-	}
-	
-	private static void printHelp() {
-		System.out.println(&quot;Usage: runGraph [-(v|P)] [--(cfg|tracking|info|plugins|pass|loghost|mode|delimiter|file|expFilter|recFrom|recCount|fields|logLevel)] &lt;graph definition file&gt; &lt;component id&gt;&quot;);
-		System.out.println(&quot;Options:&quot;);
-		System.out.println(&quot;-v\t\t\tbe verbose - print even graph layout&quot;);
-		System.out.println(&quot;-P:&lt;key&gt;=&lt;value&gt;\tadd definition of property to global graph's property list&quot;);
-		System.out.println(&quot;--cfg &lt;filename&gt;\t\tload definitions of properties from specified file&quot;);
-		System.out.println(&quot;--tracking &lt;seconds&gt;\thow frequently output the graph processing status&quot;);
-		System.out.println(&quot;--info\t\t\tprint info about Clover library version&quot;);
-        System.out.println(&quot;--plugins\t\tdirectory where to look for plugins/components&quot;);
-        System.out.println(&quot;--pass\t\tpassword for decrypting of hidden connections passwords&quot;);
-        System.out.println(&quot;--stdin\t\tload graph definition from STDIN&quot;);
-        System.out.println(&quot;--loghost\t\tdefine host and port number for socket appender of log4j (log4j library is required); i.e. localhost:4445&quot;);
-        System.out.println(&quot;--mode\t\thow show data over component {TEXT,HTML,DELIMITER_TEXT}&quot;);
-        System.out.println(&quot;--delimiter\t\tdelimiter between two fields&quot;);
-        System.out.println(&quot;--file\t\tfile url for output. If no file defined, output is set to System.out&quot;);
-        System.out.println(&quot;--expFilter\t\tfilter expression for record filtering&quot;);
-        System.out.println(&quot;--recFrom\t\tfrom where show records&quot;);
-        System.out.println(&quot;--recCount\t\thow many records should be showed&quot;);
-        System.out.println(&quot;--fields\t\tShow only defined fields. If no fields defined, show all fields&quot;);
-        System.out.println(&quot;--logLevel\t\tLog level for logger {all, info, debug, ..}, default is error log level&quot;);
-        System.out.println();
-        System.out.println(&quot;Note: &lt;graph definition file&gt; can be either local filename or URL of local/remote file&quot;);
-        System.out.println(&quot;Note: &lt;component id&gt; over this component will be showed data&quot;);
-	}
-
-	private static void printInfo(){
-	    System.out.println(&quot;CloverETL library version &quot;+JetelVersion.MAJOR_VERSION+&quot;.&quot;+JetelVersion.MINOR_VERSION+&quot; build#&quot;+JetelVersion.BUILD_NUMBER+&quot; compiled &quot;+JetelVersion.LIBRARY_BUILD_DATETIME);
-	}
-
-	public enum Mode {
-	    
-	    TEXT,
-	    HTML,
-	    DELIMITER_TEXT;
-
-	    public static Mode valueModeOf(String value){
-	    	if (value.equalsIgnoreCase(TEXT.name())) {
-	    		return TEXT;
-	    	}
-	    	if (value.equalsIgnoreCase(HTML.name())) {
-	    		return HTML;
-	    	}
-	    	if (value.equalsIgnoreCase(DELIMITER_TEXT.name())) {
-	    		return DELIMITER_TEXT;
-	    	}
-	    	return null;
-	    }
-	    
-	}
-	
-}
-

Copied: trunk/cloveretl.engine/src/org/jetel/main/showData.java (from rev 2430, trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java)
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java	2007-02-01 14:47:34 UTC (rev 2430)
+++ trunk/cloveretl.engine/src/org/jetel/main/showData.java	2007-02-06 14:57:04 UTC (rev 2438)
@@ -0,0 +1,639 @@
+/*
+ *  jETeL/Clover - Java based ETL application framework.
+ *  Copyright (C) 2002-03  David Pavlis
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License as published by the Free Software Foundation; either
+ *    version 2.1 of the License, or (at your option) any later version.
+ *    
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
+ *    Lesser General Public License for more details.
+ *    
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+package org.jetel.main;
+
+import java.io.BufferedInputStream;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Method;
+import java.net.URL;
+import java.util.Map;
+import java.util.Properties;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.commons.cli.ParseException;
+import org.apache.commons.cli.PosixParser;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.log4j.Level;
+import org.apache.log4j.Logger;
+import org.apache.log4j.net.SocketAppender;
+import org.jetel.component.ComponentFactory;
+import org.jetel.data.Defaults;
+import org.jetel.exception.ConfigurationStatus;
+import org.jetel.exception.GraphConfigurationException;
+import org.jetel.exception.XMLConfigurationException;
+import org.jetel.graph.Edge;
+import org.jetel.graph.Node;
+import org.jetel.graph.Phase;
+import org.jetel.graph.Result;
+import org.jetel.graph.TransformationGraph;
+import org.jetel.graph.TransformationGraphXMLReaderWriter;
+import org.jetel.metadata.DataRecordMetadata;
+import org.jetel.plugin.Plugins;
+import org.jetel.util.FileUtils;
+import org.jetel.util.JetelVersion;
+import org.jetel.util.crypto.Enigma;
+
+/**
+ *  class for reading and showing data over input components&lt;br&gt;&lt;br&gt;
+ *  The graph layout is read from specified XML file and over component id is written data to output.&lt;br&gt;
+ *  &lt;tt&gt;&lt;pre&gt;
+ *  Program parameters:
+ *  &lt;table&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;-P&lt;i&gt;properyName&lt;/i&gt;=&lt;i&gt;propertyValue&lt;/i&gt;&lt;/td&gt;&lt;td&gt;add definition of property to global graph's property list&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--cfg &lt;i&gt;filename&lt;/i&gt;&lt;/td&gt;&lt;td&gt;load definitions of properties from specified file&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--tracking &lt;i&gt;seconds&lt;/i&gt;&lt;/td&gt;&lt;td&gt;how frequently output the processing status&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--info&lt;/td&gt;&lt;td&gt;print info about Clover library version&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--plugins &lt;i&gt;filename&lt;/i&gt;&lt;/td&gt;&lt;td&gt;directory where to look for plugins/components&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--pass &lt;i&gt;password&lt;/i&gt;&lt;/td&gt;&lt;td&gt;password for decrypting of hidden connections passwords&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--stdin&lt;/td&gt;&lt;td&gt;load graph layout from STDIN&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--mode&lt;/td&gt;&lt;td&gt;how show data over component {TEXT,HTML,TABLE}&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--delimiter&lt;/td&gt;&lt;td&gt;delimiter between two fields&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--file&lt;/td&gt;&lt;td&gt;file url for output. If no file defined, output is set to System.out&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--expFilter&lt;/td&gt;&lt;td&gt;filter expression for record filtering&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--recFrom&lt;/td&gt;&lt;td&gt;from where show records&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--recCount&lt;/td&gt;&lt;td&gt;how many records should be showed&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--fields&lt;/td&gt;&lt;td&gt;Show only defined fields. If no fields defined, show all fields&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--logLevel&lt;/td&gt;&lt;td&gt;Log level for logger {all, info, debug, ..}, default is error log level&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;&lt;b&gt;filename&lt;/b&gt;&lt;/td&gt;&lt;td&gt;filename or URL of the file (even remote) containing graph's layout in XML (this must be the last parameter passed)&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;&lt;b&gt;component id&lt;/b&gt;&lt;/td&gt;&lt;td&gt;over this component will be showed data&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;/table&gt;
+ *
+ *  &lt;h4&gt;Example:&lt;/h4&gt;
+ *  &lt;pre&gt;showData ExampleGraph.grf DELIMITED_DATA_READER0:0&lt;/pre&gt;
+ *  
+ *  &lt;pre&gt;showData --plugins ../cloveretl.engine/plugins --mode TEXT --delimiter &quot;+&quot; --expFilter &quot;1==1&quot; --recFrom 2 --recCount 2 --fields &quot;Field1;Field0&quot; ExampleGraph.grf DELIMITED_DATA_READER0:0&lt;/pre&gt;
+ *  
+ *  &lt;/pre&gt;&lt;/tt&gt;
+ * @author      jausperger
+ * @since       2007/02/02
+ * @revision    $Revision:  $
+ */
+public class showData {
+    private static Log logger = LogFactory.getLog(showData.class);
+
+    /**
+     * Clover.ETL engine initialization. Should be called only once.
+     * @param pluginsRootDirectory directory path, where plugins specification is located 
+     *        (can be null, then is used constant from Defaults.DEFAULT_PLUGINS_DIRECTORY)
+     * @param password password for encrypting some hidden part of graphs
+     *        &lt;br&gt;i.e. connections passwordss can be encrypted
+     */        int trackingInterval = -1;
+
+    public static void initEngine(String pluginsRootDirectory, String password) {
+        
+        //init password decryptor
+        if(password != null) {
+            Enigma.getInstance().init(password);
+        }
+        
+        //init framework constants
+        Defaults.init();
+
+        //init clover plugins system
+        Plugins.init(pluginsRootDirectory);
+    }
+    
+    
+    /**
+     * Instantiates transformation graph from a given input stream and presets a given properties.
+     * @param inStream
+     * @param properties
+     * @return
+     * @throws XMLConfigurationException
+     * @throws GraphConfigurationException
+     */
+    public static TransformationGraph loadGraph(InputStream inStream, Properties properties) throws XMLConfigurationException, GraphConfigurationException {
+        TransformationGraph graph = new TransformationGraph();
+        TransformationGraphXMLReaderWriter graphReader = new TransformationGraphXMLReaderWriter(graph);
+        if(properties != null) {
+            graph.loadGraphProperties(properties);
+        }
+
+        graphReader.read(inStream);
+        
+        return graph;
+    }
+    
+	/**
+	 *  Description of the Method
+	 *
+	 * @param  args  Description of the Parameter
+	 */
+	public static void main(String args[]) {
+        boolean loadFromSTDIN = false;
+		Properties properties = new Properties();
+        int trackingInterval = -1;
+		String pluginsRootDirectory = null;
+        String password = null;
+        Mode viewMode = Mode.TEXT;
+        String delimiter = null;
+        String fileUrl = null;
+        String filterExpression = null;
+        long recordFrom = -1;
+        long recordCount = -1;
+        String fields = null;
+        String logHost = null;
+		
+		Node extFilter = null;
+        
+		/*System.out.println(&quot;***  CloverETL graph component tester ver &quot;+RUN_GRAPH_VERSION+&quot;, (c) 2002-06 D.Pavlis, released under GNU Lesser General Public License  ***&quot;);
+		System.out.println(&quot; Running with framework version: &quot;+JetelVersion.MAJOR_VERSION+&quot;.&quot;+JetelVersion.MINOR_VERSION+&quot; build#&quot;+JetelVersion.BUILD_NUMBER+&quot; compiled &quot;+JetelVersion.LIBRARY_BUILD_DATETIME);
+		System.out.println();
+        */
+		if (args.length &lt; 1) {
+			printHelp();
+			System.exit(-1);
+		}
+        
+		Options options = new Options();
+    	options.addOption(new Option(&quot;g&quot;, &quot;cfg&quot;, true, &quot;Path to property file&quot;));
+    	options.addOption(new Option(&quot;P&quot;, &quot;propertyDefinition&quot;, true, &quot;Property defined by user&quot;));
+    	options.addOption(new Option(&quot;t&quot;, &quot;tracking&quot;, false, &quot;Tracking intrnal switch&quot;));
+    	options.addOption(new Option(&quot;i&quot;, &quot;info&quot;, false, &quot;Information about program&quot;));
+    	options.addOption(new Option(&quot;n&quot;, &quot;stdin&quot;, false, &quot;Load from stdin switch&quot;));
+    	options.addOption(new Option(&quot;h&quot;, &quot;loghost&quot;, false, &quot;Log host switch&quot;));
+    	options.addOption(new Option(&quot;p&quot;, &quot;plugins&quot;, true, &quot;Path to plugins file.&quot;));
+    	options.addOption(new Option(&quot;s&quot;, &quot;pass&quot;, true, &quot;Password&quot;));
+    	options.addOption(new Option(&quot;m&quot;, &quot;mode&quot;, true, &quot;View mode&quot;));
+    	options.addOption(new Option(&quot;d&quot;, &quot;delimiter&quot;, true, &quot;Delimiter between two fields&quot;));
+    	options.addOption(new Option(&quot;o&quot;, &quot;file&quot;, true, &quot;File url for output. If no file defined, output is set to System.out&quot;));
+    	options.addOption(new Option(&quot;e&quot;, &quot;expFilter&quot;, true, &quot;Filter expression for record filtering&quot;));
+    	options.addOption(new Option(&quot;f&quot;, &quot;recFrom&quot;, true, &quot;From where show records&quot;));
+    	options.addOption(new Option(&quot;c&quot;, &quot;recCount&quot;, true, &quot;Count of records&quot;));
+    	options.addOption(new Option(&quot;l&quot;, &quot;fields&quot;, true, &quot;Show only defined fields. If no fields defined, show all fields&quot;));
+    	options.addOption(new Option(&quot;x&quot;, &quot;logLevel&quot;, true, &quot;Log level for logger {all, info, debug, ..}, default is error log level&quot;));
+
+    	PosixParser optParser = new PosixParser();
+    	CommandLine cmdLine;
+		try {
+			cmdLine = optParser.parse(options, args);
+		} catch (ParseException e) {
+			logger.error(e.getMessage(), e);
+			return;
+		}
+		
+		loadFromSTDIN = cmdLine.hasOption(&quot;n&quot;);
+		if (cmdLine.hasOption(&quot;h&quot;)) {
+            String[] hostAndPort = logHost.split(&quot;:&quot;);
+            if (hostAndPort[0].length() == 0 || hostAndPort.length &gt; 2) {
+                System.err
+                        .println(&quot;Invalid log destination, i.e. -loghost localhost:4445&quot;);
+                System.exit(-1);
+            }
+            int port = 4445;
+            try {
+                if (hostAndPort.length == 2) {
+                    port = Integer.parseInt(hostAndPort[1]);
+                }
+            } catch (NumberFormatException e) {
+                System.err
+                        .println(&quot;Invalid log destination, i.e. -loghost localhost:4445&quot;);
+                System.exit(-1);
+            }
+            Logger.getRootLogger().addAppender(
+                    new SocketAppender(hostAndPort[0], port));
+		}
+		if (cmdLine.hasOption(&quot;g&quot;)) {
+			InputStream inStream;
+			try {
+				inStream = new BufferedInputStream(new FileInputStream(cmdLine.getOptionValue(&quot;g&quot;)));
+				properties.load(inStream);
+			} catch (NullPointerException e) {
+				logger.error(&quot;cfg file not found: &quot; + e.getMessage(), e);
+				System.exit(-1);
+			} catch (IOException e) {
+				logger.error(e.getMessage(), e);
+				System.exit(-1);
+			}
+		}
+		if (cmdLine.hasOption(&quot;P&quot;)) {
+	    	String a[] = cmdLine.getOptionValue(&quot;P&quot;).split(&quot;;&quot;);
+	    	for (String tmp : a) {
+	    	    properties.setProperty(tmp.substring(0,tmp.indexOf(&quot;=&quot;)),tmp.substring(tmp.indexOf(&quot;=&quot;) +1)); 
+	    	}
+		}
+		if (cmdLine.hasOption(&quot;i&quot;)) {
+		    printInfo();
+		    System.exit(0);
+		}
+		if (cmdLine.hasOption(&quot;t&quot;)) {
+            try {
+                trackingInterval = Integer.parseInt(cmdLine.getOptionValue(&quot;t&quot;));
+            } catch (NumberFormatException ex) {
+                System.err.println(&quot;Invalid tracking parameter: \&quot;&quot;
+                        + cmdLine.getOptionValue(&quot;t&quot;) + &quot;\&quot;&quot;);
+                System.exit(-1);
+            }
+		}
+		if (cmdLine.hasOption(&quot;p&quot;)) {
+			pluginsRootDirectory = cmdLine.getOptionValue(&quot;p&quot;);
+		}
+		if (cmdLine.hasOption(&quot;s&quot;)) {
+			password = cmdLine.getOptionValue(&quot;s&quot;);
+		}
+		if (cmdLine.hasOption(&quot;m&quot;)) {
+			viewMode = Mode.valueModeOf(cmdLine.getOptionValue(&quot;m&quot;));
+	        if (viewMode == null) {
+				System.err.println(&quot;Unknown mode option: &quot;+cmdLine.getOptionValue(&quot;m&quot;));
+				System.exit(-1);
+	        }
+		}
+		if (cmdLine.hasOption(&quot;d&quot;)) {
+			delimiter = cmdLine.getOptionValue(&quot;d&quot;);
+		}
+		if (cmdLine.hasOption(&quot;o&quot;)) {
+			fileUrl = cmdLine.getOptionValue(&quot;o&quot;);
+		}
+		if (cmdLine.hasOption(&quot;e&quot;)) {
+			filterExpression = cmdLine.getOptionValue(&quot;e&quot;);
+		}
+		if (cmdLine.hasOption(&quot;f&quot;)) {
+	    	recordFrom = Long.parseLong(cmdLine.getOptionValue(&quot;f&quot;));
+		}
+		if (cmdLine.hasOption(&quot;c&quot;)) {
+	    	recordCount = Long.parseLong(cmdLine.getOptionValue(&quot;c&quot;));
+		}
+		if (cmdLine.hasOption(&quot;l&quot;)) {
+        	fields = cmdLine.getOptionValue(&quot;l&quot;);
+		}
+		Logger.getRootLogger().setLevel(cmdLine.hasOption(&quot;x&quot;)?Level.toLevel(cmdLine.getOptionValue(&quot;x&quot;)):Level.ERROR);
+		
+        // setup log4j appenders
+        if (logHost != null) {
+            String[] hostAndPort = logHost.split(&quot;:&quot;);
+            if (hostAndPort[0].length() == 0 || hostAndPort.length &gt; 2) {
+                System.err
+                        .println(&quot;Invalid log destination, i.e. -loghost localhost:4445&quot;);
+                System.exit(-1);
+            }
+            int port = 4445;
+            try {
+                if (hostAndPort.length == 2) {
+                    port = Integer.parseInt(hostAndPort[1]);
+                }
+            } catch (NumberFormatException e) {
+                System.err
+                        .println(&quot;Invalid log destination, i.e. -loghost localhost:4445&quot;);
+                System.exit(-1);
+            }
+            Logger.getRootLogger().addAppender(
+                    new SocketAppender(hostAndPort[0], port));
+        }
+        
+        // engine initialization - should be called only once
+        runGraph.initEngine(pluginsRootDirectory, password);
+
+        // prapere input stream with XML graph definition
+        InputStream in = null;
+        if (loadFromSTDIN) {
+            System.out.println(&quot;Graph definition loaded from STDIN&quot;);
+            in = System.in;
+        } else {
+            System.out.println(&quot;Graph definition file: &quot;
+                    + args[args.length - 2]);
+            try {
+                URL fileURL = FileUtils.getFileURL(null, args[args.length - 2]);
+                in = fileURL.openStream();
+            } catch (IOException e) {
+                System.err
+                        .println(&quot;Error - graph definition file can't be read: &quot;
+                                + e.getMessage());
+                System.exit(-1);
+            }
+        }
+        
+        System.out.println(&quot;Component id: &quot; + args[args.length - 1]);
+        String componentID = args[args.length - 1];
+        int pos;
+        int port = 0;
+        if ((pos = componentID.indexOf(':')) != -1) {
+        	port = Integer.parseInt(componentID.substring(pos+1));
+        	componentID = componentID.substring(0, pos);
+        }
+
+        // loading graph from the input stream
+        TransformationGraph graph = null;
+        try {
+            graph = runGraph.loadGraph(in, properties);
+
+            // check graph elements configuration
+            logger.info(&quot;Checking graph configuration...&quot;);
+            try {
+                ConfigurationStatus status = graph.checkConfig(null);
+                status.log();
+            } catch(Exception e) {
+                logger.error(&quot;Checking graph failed! (&quot; + e.getMessage() + &quot;)&quot;);
+            }
+
+            if (!graph.init()) {
+                throw new GraphConfigurationException(
+                        &quot;Graph initialization failed.&quot;);
+            }
+
+            // this can be called only after graph.init()
+            graph.dumpGraphConfiguration();
+        } catch (XMLConfigurationException ex) {
+            logger.error(&quot;Error in reading graph from XML !&quot;, ex);
+            ex.printStackTrace(System.err);
+            System.exit(-1);
+        } catch (GraphConfigurationException ex) {
+            logger.error(&quot;Error - graph's configuration invalid !&quot;, ex);
+            ex.printStackTrace(System.err);
+            System.exit(-1);
+        } catch (RuntimeException ex) {
+            logger.error(&quot;Error during graph initialization !&quot;, ex);
+            ex.printStackTrace(System.err);
+            System.exit(-1);
+        }
+        
+        //check graph elements configuration
+        ConfigurationStatus status = graph.checkConfig(null);
+        status.log();
+        
+		Map map = graph.getNodes();
+		Node node = (Node) map.get(componentID);
+		if (node == null) {
+			//map = graph.getEdges();
+			//Edge edge = (Edge) map.get(componentID);
+			//if (edge == null) {
+				// error
+				logger.error(&quot;Component Id '&quot;+ componentID +&quot;' not found!&quot;);
+				return;
+			//}
+		}
+		if (!node.isRoot()) {
+			// not implemented
+			System.err.println(&quot;Execution is implemented for root node (root node has only output ports connected)!&quot;);
+			return;
+		}
+
+		// create new graph
+	    TransformationGraph viewGraph = new TransformationGraph();
+		Phase _PHASE_1 = new Phase(1);
+
+	    // add writer component
+		DataRecordMetadata dataRecordMetadata = (DataRecordMetadata) node.getOutMetadata().toArray()[port];
+		Edge edge0 = new Edge(&quot;EDGE0&quot;, dataRecordMetadata);
+		Edge edge1 = null;
+		if (filterExpression != null) {
+			edge1 = new Edge(&quot;EDGE1&quot;, dataRecordMetadata);
+		}
+		Node writer = null;
+		try {
+			writer = getWriter(viewGraph, viewMode, dataRecordMetadata, fileUrl, delimiter, recordFrom, recordCount, fields);
+		} catch (Exception e1) {
+			e1.printStackTrace();
+		}
+		
+		// add Edges &amp; Nodes &amp; Phases to graph
+		try {
+			viewGraph.addPhase(_PHASE_1);
+			viewGraph.addEdge(edge0);
+			_PHASE_1.addNode(node);
+			_PHASE_1.addNode(writer);
+			
+			if (filterExpression != null) {
+				viewGraph.addEdge(edge1);
+				extFilter = ComponentFactory.createComponent(viewGraph, &quot;EXT_FILTER&quot;, new Object[] {&quot;ExtFilter0&quot;}, new Class[] {String.class});//new ExtFilter(&quot;ExtFilter0&quot;);
+				Method method = ComponentFactory.getComponentClass(&quot;EXT_FILTER&quot;).getMethod(&quot;setFilterExpression&quot;, new Class[] {String.class});
+				method.invoke(extFilter, filterExpression);
+				_PHASE_1.addNode(extFilter);
+			}
+		} catch (GraphConfigurationException e) {
+			e.printStackTrace();
+			return;
+		} catch (Exception e) {
+			e.printStackTrace();
+			return;
+		}
+
+		// assign ports (input &amp; output)
+		node.addOutputPort(0,edge0);
+		if (filterExpression != null) {
+			extFilter.addInputPort(0,edge0);
+			extFilter.addOutputPort(0,edge1);
+			writer.addInputPort(0,edge1); 
+		} else {
+			writer.addInputPort(0,edge0);
+		}
+
+		if(!viewGraph.init()){
+			System.err.println(&quot;Graph initialization failed !&quot;);
+			return;
+		}
+	    
+        // set tracking interval
+        if (trackingInterval != -1) {
+        	viewGraph.setTrackingInterval(trackingInterval * 1000);
+        }
+
+        //	start all Nodes (each node is one thread)
+		Result result=Result.N_A;
+		try {
+            result = viewGraph.run();
+        } catch (RuntimeException ex) {
+            System.err.println(&quot;Fatal error during graph run !&quot;);
+            System.err.println(ex.getCause().getMessage());
+            ex.printStackTrace();
+            System.exit(-1);
+        }
+        switch (result) {
+
+        case FINISHED_OK:
+            // everything O.K.
+            System.out.println(&quot;Execution of graph successful !&quot;);
+            System.exit(0);
+            break;
+        case ABORTED:
+            // execution was ABORTED !!
+            System.err.println(&quot;Execution of graph aborted !&quot;);
+            System.exit(result.code());
+            break;
+        default:
+            System.err.println(&quot;Execution of graph failed !&quot;);
+            System.exit(result.code());
+        }
+
+	}
+    
+	/**
+	 * @param mode
+	 * @param dataRecordMetadata
+	 * @param fileUrl
+	 * @param delimiter
+	 * @param recordFrom
+	 * @param recordCount
+	 * @param fields
+	 * @return
+	 * @throws Exception 
+	 */
+	private static Node getWriter(TransformationGraph graph, Mode mode, DataRecordMetadata dataRecordMetadata, String fileUrl, String delimiter, long recordFrom, long recordCount, String fields) throws Exception {
+		if (mode == null) return null;
+		Node writer = null;
+		String[] aFiealds = fields == null ? null : fields.split(&quot;;&quot;);
+		
+		// html formating
+		if (mode.equals(Mode.HTML)) {
+			StringBuilder maskBuilder = new StringBuilder();
+			if (aFiealds == null) {
+				maskBuilder.append(&quot;&lt;tr&gt;&quot;);
+				for (int i=0;i&lt;dataRecordMetadata.getNumFields();i++){
+					maskBuilder.append(&quot;&lt;td&gt;$&quot;);
+					maskBuilder.append(dataRecordMetadata.getField(i).getName());
+					maskBuilder.append(&quot;&lt;/td&gt;&quot;);
+				}
+				maskBuilder.append(&quot;&lt;/tr&gt;\n&quot;);
+			} else if (aFiealds.length &gt; 0) {
+				maskBuilder.append(&quot;&lt;tr&gt;&quot;);
+				for (String sfield: aFiealds){
+					if (dataRecordMetadata.getField(sfield) == null) {
+						System.err.println(&quot;Field name '&quot;+ sfield + &quot;' not found.&quot;);
+						System.exit(-1);
+					}
+					maskBuilder.append(&quot;&lt;td&gt;$&quot;);
+					maskBuilder.append(sfield);
+					maskBuilder.append(&quot;&lt;/td&gt;&quot;);
+				}
+				maskBuilder.append(&quot;&lt;/tr&gt;\n&quot;);
+			} else {
+				System.err.println(&quot;No field found.&quot;);
+				System.exit(-1);
+			}
+			
+			Node structureWriter = ComponentFactory.createComponent(graph, &quot;STRUCTURE_WRITER&quot;, new Object[] {&quot;STRUCTURE_WRITER0&quot;, fileUrl, null, false, maskBuilder.toString()}, new Class[] {String.class, String.class, String.class, boolean.class, String.class});
+			Class cStructureWriter = ComponentFactory.getComponentClass(&quot;STRUCTURE_WRITER&quot;);
+			Method method = cStructureWriter.getMethod(&quot;setRecordFrom&quot;, new Class[] {long.class});
+			method.invoke(structureWriter, recordFrom);
+			method = cStructureWriter.getMethod(&quot;setRecordCount&quot;, new Class[] {long.class});
+			method.invoke(structureWriter, recordCount);
+			StringBuilder sb = new StringBuilder();
+			
+			sb.append(&quot;&lt;table name=\&quot;&quot; + dataRecordMetadata.getName() + &quot;\&quot; border=1&gt;\n&quot;);
+			sb.append(&quot;&lt;thead&gt;\n&lt;tr&gt;&quot;);
+			if (aFiealds == null ) {
+				for (int i=0;i&lt;dataRecordMetadata.getNumFields();i++){
+					sb.append(&quot;&lt;th&gt;&quot;);
+					sb.append(dataRecordMetadata.getField(i).getName());
+					sb.append(&quot;&lt;/th&gt;&quot;);
+				}
+			} else {
+				for (String sfield: aFiealds){
+					sb.append(&quot;&lt;th&gt;&quot;);
+					sb.append(dataRecordMetadata.getField(sfield).getName());
+					sb.append(&quot;&lt;/th&gt;&quot;);
+				}
+			}
+			sb.append(&quot;&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&quot;);
+			method = cStructureWriter.getMethod(&quot;setHeader&quot;, new Class[] {String.class});
+			method.invoke(structureWriter, sb.toString());
+			
+			sb = new StringBuilder();
+			sb.append(&quot;&lt;/tbody&gt;\n&lt;/table&gt;\n&quot;);
+			method = cStructureWriter.getMethod(&quot;setFooter&quot;, new Class[] {String.class});
+			method.invoke(structureWriter, sb.toString());
+			writer = structureWriter;
+			
+		// text formating - delimited or fix lenght
+		} else if (mode.equals(Mode.TEXT)) {
+			Node dataWriter = ComponentFactory.createComponent(graph, &quot;DATA_WRITER&quot;, new Object[] {&quot;DATA_WRITER0&quot;, fileUrl, dataRecordMetadata.getLocaleStr(), false}, new Class[] {String.class, String.class, String.class, boolean.class});
+			//TODO agata dodelat selekci na fieldy
+			Class cDataWriter = ComponentFactory.getComponentClass(&quot;DATA_WRITER&quot;);
+			Method method = cDataWriter.getMethod(&quot;setRecordFrom&quot;, new Class[] {long.class});
+			method.invoke(dataWriter, recordFrom);
+			method = cDataWriter.getMethod(&quot;setRecordCount&quot;, new Class[] {long.class});
+			method.invoke(dataWriter, recordCount);
+			if (delimiter != null) {
+				method = cDataWriter.getMethod(&quot;setDataDelimiter&quot;, new Class[] {String.class});
+				method.invoke(dataWriter, delimiter);
+			}
+			writer = dataWriter;
+			
+		// table formating
+		} else if (mode.equals(Mode.TABLE)) {
+			//TextWriter dataWriter = new TextWriter(&quot;TEXT_TABLE_WRITER0&quot;, fileUrl, null, false, aFiealds);
+			Node textWriter = ComponentFactory.createComponent(graph, &quot;TEXT_TABLE_WRITER&quot;, new Object[] {&quot;TEXT_TABLE_WRITER0&quot;, fileUrl, null, false, aFiealds}, new Class[] {String.class, String.class, String.class, boolean.class, String[].class});
+			Class cDataWriter = ComponentFactory.getComponentClass(&quot;TEXT_TABLE_WRITER&quot;);
+			Method method = cDataWriter.getMethod(&quot;setRecordFrom&quot;, new Class[] {long.class});
+			method.invoke(textWriter, recordFrom);
+			method = cDataWriter.getMethod(&quot;setRecordCount&quot;, new Class[] {long.class});
+			method.invoke(textWriter, recordCount);
+			method = cDataWriter.getMethod(&quot;setHeader&quot;, new Class[] {boolean.class});
+			method.invoke(textWriter, true);
+			writer = textWriter;
+		}
+		return writer;
+	}
+	
+	private static void printHelp() {
+		System.out.println(&quot;Usage: showData [-P] [--(cfg|tracking|info|plugins|pass|loghost|mode|delimiter|file|expFilter|recFrom|recCount|fields|logLevel)] &lt;graph definition file&gt; &lt;component id&gt;&quot;);
+		System.out.println(&quot;Options:&quot;);
+		System.out.println(&quot;-P:&lt;key&gt;=&lt;value&gt;\tadd definition of property to global graph's property list&quot;);
+		System.out.println(&quot;--cfg &lt;filename&gt;\t\tload definitions of properties from specified file&quot;);
+		System.out.println(&quot;--tracking &lt;seconds&gt;\thow frequently output the graph processing status&quot;);
+		System.out.println(&quot;--info\t\t\tprint info about Clover library version&quot;);
+        System.out.println(&quot;--plugins\t\tdirectory where to look for plugins/components&quot;);
+        System.out.println(&quot;--pass\t\tpassword for decrypting of hidden connections passwords&quot;);
+        System.out.println(&quot;--stdin\t\tload graph definition from STDIN&quot;);
+        System.out.println(&quot;--loghost\t\tdefine host and port number for socket appender of log4j (log4j library is required); i.e. localhost:4445&quot;);
+        System.out.println(&quot;--mode\t\thow show data over component {TEXT,HTML,TABLE}&quot;);
+        System.out.println(&quot;--delimiter\t\tdelimiter between two fields&quot;);
+        System.out.println(&quot;--file\t\tfile url for output. If no file defined, output is set to System.out&quot;);
+        System.out.println(&quot;--expFilter\t\tfilter expression for record filtering&quot;);
+        System.out.println(&quot;--recFrom\t\tfrom where show records&quot;);
+        System.out.println(&quot;--recCount\t\thow many records should be showed&quot;);
+        System.out.println(&quot;--fields\t\tShow only defined fields. If no fields defined, show all fields&quot;);
+        System.out.println(&quot;--logLevel\t\tLog level for logger {all, info, debug, ..}, default is error log level&quot;);
+        System.out.println();
+        System.out.println(&quot;Note: &lt;graph definition file&gt; can be either local filename or URL of local/remote file&quot;);
+        System.out.println(&quot;Note: &lt;component id&gt; over this component will be showed data&quot;);
+	}
+
+	private static void printInfo(){
+	    System.out.println(&quot;CloverETL library version &quot;+JetelVersion.MAJOR_VERSION+&quot;.&quot;+JetelVersion.MINOR_VERSION+&quot; build#&quot;+JetelVersion.BUILD_NUMBER+&quot; compiled &quot;+JetelVersion.LIBRARY_BUILD_DATETIME);
+	}
+
+	public enum Mode {
+	    
+	    TEXT,
+	    HTML,
+	    TABLE;
+
+	    public static Mode valueModeOf(String value){
+	    	if (value.equalsIgnoreCase(TEXT.name())) {
+	    		return TEXT;
+	    	}
+	    	if (value.equalsIgnoreCase(HTML.name())) {
+	    		return HTML;
+	    	}
+	    	if (value.equalsIgnoreCase(TABLE.name())) {
+	    		return TABLE;
+	    	}
+	    	return null;
+	    }
+	    
+	}
+	
+}
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000074.html">[Cloveretl-svn-commits] CloverETL repos r2437 -	trunk/cloveretl.engine/test/org/jetel/component
</A></li>
	<LI>Next message: <A HREF="000076.html">[Cloveretl-svn-commits] CloverETL repos r2439 - in trunk:	cloveretl.component cloveretl.engine/plugins/org.jetel.component
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#75">[ date ]</a>
              <a href="thread.html#75">[ thread ]</a>
              <a href="subject.html#75">[ subject ]</a>
              <a href="author.html#75">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cloveretl-svn-commits">More information about the Cloveretl-svn-commits
mailing list</a><br>
</body></html>
