<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cloveretl-svn-commits] CloverETL repos r2430 -	trunk/cloveretl.engine/src/org/jetel/main
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cloveretl-svn-commits/2007-February/index.html" >
   <LINK REL="made" HREF="mailto:cloveretl-svn-commits%40lists.berlios.de?Subject=Re%3A%20%5BCloveretl-svn-commits%5D%20CloverETL%20repos%20r2430%20-%0A%09trunk/cloveretl.engine/src/org/jetel/main&In-Reply-To=%3C200702011447.l11ElbBW002656%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000066.html">
   <LINK REL="Next"  HREF="000068.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cloveretl-svn-commits] CloverETL repos r2430 -	trunk/cloveretl.engine/src/org/jetel/main</H1>
    <B>cloveretl-svn-commits at lists.berlios.de</B> 
    <A HREF="mailto:cloveretl-svn-commits%40lists.berlios.de?Subject=Re%3A%20%5BCloveretl-svn-commits%5D%20CloverETL%20repos%20r2430%20-%0A%09trunk/cloveretl.engine/src/org/jetel/main&In-Reply-To=%3C200702011447.l11ElbBW002656%40sheep.berlios.de%3E"
       TITLE="[Cloveretl-svn-commits] CloverETL repos r2430 -	trunk/cloveretl.engine/src/org/jetel/main">cloveretl-svn-commits at lists.berlios.de
       </A><BR>
    <I>Thu Feb  1 15:47:37 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000066.html">[Cloveretl-svn-commits] CloverETL repos r2429 -	trunk/cloveretl.engine
</A></li>
        <LI>Next message: <A HREF="000068.html">[Cloveretl-svn-commits] CloverETL repos r2431 -	trunk/cloveretl.engine/lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#67">[ date ]</a>
              <a href="thread.html#67">[ thread ]</a>
              <a href="subject.html#67">[ subject ]</a>
              <a href="author.html#67">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ausperger
Date: 2007-02-01 15:47:34 +0100 (Thu, 01 Feb 2007)
New Revision: 2430

Added:
   trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java
Removed:
   trunk/cloveretl.engine/src/org/jetel/main/DataComponentViewer.java
Log:
FIX: dodelani programu

Deleted: trunk/cloveretl.engine/src/org/jetel/main/DataComponentViewer.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/main/DataComponentViewer.java	2007-02-01 14:30:21 UTC (rev 2429)
+++ trunk/cloveretl.engine/src/org/jetel/main/DataComponentViewer.java	2007-02-01 14:47:34 UTC (rev 2430)
@@ -1,500 +0,0 @@
-/*
- *  jETeL/Clover - Java based ETL application framework.
- *  Copyright (C) 2002-03  David Pavlis
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License as published by the Free Software Foundation; either
- *    version 2.1 of the License, or (at your option) any later version.
- *    
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
- *    Lesser General Public License for more details.
- *    
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-package org.jetel.main;
-
-import java.io.BufferedInputStream;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import java.util.StringTokenizer;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.jetel.component.DataWriter;
-import org.jetel.component.ExtFilter;
-import org.jetel.component.StructureWriter;
-import org.jetel.component.TextWriter;
-import org.jetel.data.Defaults;
-import org.jetel.exception.ConfigurationStatus;
-import org.jetel.exception.GraphConfigurationException;
-import org.jetel.exception.XMLConfigurationException;
-import org.jetel.graph.Edge;
-import org.jetel.graph.Node;
-import org.jetel.graph.Phase;
-import org.jetel.graph.Result;
-import org.jetel.graph.TransformationGraph;
-import org.jetel.graph.TransformationGraphXMLReaderWriter;
-import org.jetel.metadata.DataRecordMetadata;
-import org.jetel.plugin.Plugins;
-import org.jetel.util.FileUtils;
-import org.jetel.util.JetelVersion;
-import org.jetel.util.crypto.Enigma;
-
-/**
- *  class for executing transformations described in XML layout file&lt;br&gt;&lt;br&gt;
- *  The graph layout is read from specified XML file and the whole transformation is executed.&lt;br&gt;
- *  &lt;tt&gt;&lt;pre&gt;
- *  Program parameters:
- *  &lt;table&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;-v&lt;/td&gt;&lt;td&gt;be verbose - print even graph layout&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;-P:&lt;i&gt;properyName&lt;/i&gt;=&lt;i&gt;propertyValue&lt;/i&gt;&lt;/td&gt;&lt;td&gt;add definition of property to global graph's property list&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;-cfg &lt;i&gt;filename&lt;/i&gt;&lt;/td&gt;&lt;td&gt;load definitions of properties from specified file&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;-tracking &lt;i&gt;seconds&lt;/i&gt;&lt;/td&gt;&lt;td&gt;how frequently output the processing status&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;-info&lt;/td&gt;&lt;td&gt;print info about Clover library version&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;-plugins &lt;i&gt;filename&lt;/i&gt;&lt;/td&gt;&lt;td&gt;directory where to look for plugins/components&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;-pass &lt;i&gt;password&lt;/i&gt;&lt;/td&gt;&lt;td&gt;password for decrypting of hidden connections passwords&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;-stdin&lt;/td&gt;&lt;td&gt;load graph layout from STDIN&lt;/td&gt;&lt;/tr&gt;
- *  &lt;tr&gt;&lt;td nowrap&gt;&lt;b&gt;filename&lt;/b&gt;&lt;/td&gt;&lt;td&gt;filename or URL of the file (even remote) containing graph's layout in XML (this must be the last parameter passed)&lt;/td&gt;&lt;/tr&gt;
- *  &lt;/table&gt;
- *  &lt;/pre&gt;&lt;/tt&gt;
- * @author      dpavlis
- * @since	2003/09/09
- * @revision    $Revision: 2080 $
- */
-public class DataComponentViewer {
-    private static Log logger = LogFactory.getLog(DataComponentViewer.class);
-
-    //TODO change run graph version
-	private final static String RUN_GRAPH_VERSION = &quot;2.0&quot;;
-	public final static String VERBOSE_SWITCH = &quot;-v&quot;;
-	public final static String PROPERTY_FILE_SWITCH = &quot;-cfg&quot;;
-	public final static String PROPERTY_DEFINITION_SWITCH = &quot;-P:&quot;;
-	public final static String INFO_SWITCH = &quot;-info&quot;;
-    public final static String PLUGINS_SWITCH = &quot;-plugins&quot;;
-    public final static String PASSWORD_SWITCH = &quot;-pass&quot;;
-    public final static String VIEW_MODE = &quot;-mode&quot;;
-    public final static String DELIMITER = &quot;-delimiter&quot;;
-    public final static String OUT_FILE = &quot;-file&quot;;
-	public final static String FILTER_EXPRESSION = &quot;-expFilter&quot;;
-	public final static String RECORD_FROM = &quot;-recFrom&quot;;
-	public final static String RECORD_COUNT = &quot;-recCount&quot;;
-	public final static String FIELDS = &quot;-fields&quot;;
-
-	
-    /**
-     * Clover.ETL engine initialization. Should be called only once.
-     * @param pluginsRootDirectory directory path, where plugins specification is located 
-     *        (can be null, then is used constant from Defaults.DEFAULT_PLUGINS_DIRECTORY)
-     * @param password password for encrypting some hidden part of graphs
-     *        &lt;br&gt;i.e. connections passwordss can be encrypted
-     */
-    public static void initEngine(String pluginsRootDirectory, String password) {
-        
-        //init password decryptor
-        if(password != null) {
-            Enigma.getInstance().init(password);
-        }
-        
-        //init framework constants
-        Defaults.init();
-
-        //init clover plugins system
-        Plugins.init(pluginsRootDirectory);
-      
-    }
-    
-    
-    /**
-     * Instantiates transformation graph from a given input stream and presets a given properties.
-     * @param inStream
-     * @param properties
-     * @return
-     * @throws XMLConfigurationException
-     * @throws GraphConfigurationException
-     */
-    public static TransformationGraph loadGraph(InputStream inStream, Properties properties) throws XMLConfigurationException, GraphConfigurationException {
-        TransformationGraph graph = new TransformationGraph();
-        TransformationGraphXMLReaderWriter graphReader = new TransformationGraphXMLReaderWriter(graph);
-        if(properties != null) {
-            graph.loadGraphProperties(properties);
-        }
-
-        graphReader.read(inStream);
-        
-        if(!graph.init()) {
-            throw new GraphConfigurationException(&quot;Graph initialization failed.&quot;);
-        }
-        
-        return graph;
-    }
-    
-	/**
-	 *  Description of the Method
-	 *
-	 * @param  args  Description of the Parameter
-	 */
-	public static void main(String args[]) {
-		boolean verbose = false;
-		Properties properties = new Properties();
-		String pluginsRootDirectory = null;
-        String password = null;
-        Mode viewMode = Mode.TEXT;
-        String delimiter = null;
-        String fileUrl = null;
-        String filterExpression = null;
-        long recordFrom = -1;
-        long recordCount = -1;
-        String fields = null;
-		
-		ExtFilter extFilter = null;
-        
-		System.out.println(&quot;***  CloverETL graph component tester ver &quot;+RUN_GRAPH_VERSION+&quot;, (c) 2002-06 D.Pavlis, released under GNU Lesser General Public License  ***&quot;);
-		System.out.println(&quot; Running with framework version: &quot;+JetelVersion.MAJOR_VERSION+&quot;.&quot;+JetelVersion.MINOR_VERSION+&quot; build#&quot;+JetelVersion.BUILD_NUMBER+&quot; compiled &quot;+JetelVersion.LIBRARY_BUILD_DATETIME);
-		System.out.println();
-        
-		if (args.length &lt; 1) {
-			printHelp();
-			System.exit(-1);
-		}
-        
-		// process command line arguments
-		for (int i = 0; i &lt; args.length; i++) {
-			if (args[i].startsWith(VERBOSE_SWITCH)) {
-				verbose = true;
-			}else if (args[i].startsWith(PROPERTY_FILE_SWITCH)){
-				i++;
-				try {
-					InputStream inStream = new BufferedInputStream(new FileInputStream(args[i]));
-					properties.load(inStream);
-				} catch (IOException ex) {
-					logger.error(ex.getMessage(), ex);
-					System.exit(-1);
-				}
-			}else if (args[i].startsWith(PROPERTY_DEFINITION_SWITCH)){
-			   	//String[] nameValue=args[i].replaceFirst(PROPERTY_DEFINITION_SWITCH,&quot;&quot;).split(&quot;=&quot;);
-				//properties.setProperty(nameValue[0],nameValue[1]);
-		    	String tmp =  args[i].replaceFirst(PROPERTY_DEFINITION_SWITCH,&quot;&quot;);
-        	    properties.setProperty(tmp.substring(0,tmp.indexOf(&quot;=&quot;)),tmp.substring(tmp.indexOf(&quot;=&quot;) +1)); 
-			}else if (args[i].startsWith(INFO_SWITCH)){
-			    printInfo();
-			    System.exit(0);
-            }else if (args[i].startsWith(PLUGINS_SWITCH)){
-                i++;
-                pluginsRootDirectory = args[i];
-            }else if (args[i].startsWith(PASSWORD_SWITCH)){
-                i++;
-                password = args[i]; 
-            }else if (args[i].startsWith(VIEW_MODE)){
-                i++;
-                viewMode = Mode.valueModeOf(args[i]);
-                if (viewMode == null) {
-    				System.err.println(&quot;Unknown mode option: &quot;+args[i]);
-    				System.exit(-1);
-                }
-            }else if (args[i].startsWith(DELIMITER)){
-            	delimiter = args[i].substring(args[i].indexOf(&quot;=&quot;) + 1);
-            }else if (args[i].startsWith(OUT_FILE)){
-            	fileUrl = args[i].substring(args[i].indexOf(&quot;=&quot;) + 1);
-            }else if (args[i].startsWith(FILTER_EXPRESSION)){
-            	filterExpression = args[i].substring(args[i].indexOf(&quot;=&quot;) + 1);
-            }else if (args[i].startsWith(RECORD_FROM)){
-            	recordFrom = Long.parseLong(args[i].substring(args[i].indexOf(&quot;=&quot;) + 1));
-            }else if (args[i].startsWith(RECORD_COUNT)){
-            	recordCount = Long.parseLong(args[i].substring(args[i].indexOf(&quot;=&quot;) + 1));
-            }else if (args[i].startsWith(FIELDS)){
-            	fields = args[i].substring(args[i].indexOf(&quot;=&quot;) + 1);
-            }else if (args[i].startsWith(&quot;-&quot;)) {
-				System.err.println(&quot;Unknown option: &quot;+args[i]);
-				System.exit(-1);
-			}
-		}
-		
-        //engine initialization - should be called only once
-        DataComponentViewer.initEngine(pluginsRootDirectory, password);
-        
-		//prapere input stream with XML graph definition
-        InputStream in = null;
-        System.out.println(&quot;Graph definition file: &quot; + args[args.length - 2]);
-        URL fileURL = null;
-		try {
-			fileURL = FileUtils.getFileURL(null, args[args.length - 2]);
-		} catch (MalformedURLException e1) {
-            System.err.println(&quot;Error - graph definition file can't be read.&quot;);
-            System.exit(-1);
-		}
-        if(fileURL == null) {
-            System.err.println(&quot;Error - graph definition file can't be read.&quot;);
-            System.exit(-1);
-        }
-        try{
-            in=fileURL.openStream();
-        } catch (IOException e) {
-            System.err.println(&quot;Error - graph definition file can't be read: &quot; + e.getMessage());
-            System.exit(-1);
-        }
-        
-        System.out.println(&quot;Component id: &quot; + args[args.length - 1]);
-        String componentID = args[args.length - 1];
-        int pos;
-        int port = 0;
-        if ((pos = componentID.indexOf(':')) != -1) {
-        	port = Integer.parseInt(componentID.substring(pos+1));
-        	componentID = componentID.substring(0, pos);
-        }
-        
-        //loading graph from the input stream
-        TransformationGraph graph = null;
-        try {
-            graph = DataComponentViewer.loadGraph(in, properties);
-
-            if (verbose) {
-                //this can be called only after graph.init()
-                graph.dumpGraphConfiguration();
-            }
-        }catch(XMLConfigurationException ex){
-            logger.error(&quot;Error in reading graph from XML !&quot;, ex);
-            if (verbose) {
-                ex.printStackTrace(System.err);
-            }
-            System.exit(-1);
-        }catch(GraphConfigurationException ex){
-            logger.error(&quot;Error - graph's configuration invalid !&quot;, ex);
-            if (verbose) {
-                ex.printStackTrace(System.err);
-            }
-            System.exit(-1);
-        } catch (RuntimeException ex) {
-            logger.error(&quot;Error during graph initialization !&quot;, ex);
-            if (verbose) {
-                ex.printStackTrace(System.err);
-            }
-            System.exit(-1);
-        }
-        
-        //check graph elements configuration
-        ConfigurationStatus status = graph.checkConfig(null);
-        status.log();
-        
-		Map map = graph.getNodes();
-		Node node = (Node) map.get(componentID);
-		if (node == null) {
-			//map = graph.getEdges();
-			//Edge edge = (Edge) map.get(componentID);
-			//if (edge == null) {
-				// error
-				System.err.println(&quot;Error&quot;);
-				return;
-			//}
-		}
-		if (!node.isRoot()) {
-			// not implemented
-			System.err.println(&quot;Execution is implemented for root node (has only output ports connected to id)!&quot;);
-			return;
-		}
-
-		// create new graph
-	    TransformationGraph viewGraph = new TransformationGraph();
-		Phase _PHASE_1 = new Phase(1);
-
-	    // add writer component
-		DataRecordMetadata dataRecordMetadata = (DataRecordMetadata) node.getOutMetadata().toArray()[port];
-		Edge edge0 = new Edge(&quot;EDGE0&quot;, dataRecordMetadata);
-		Edge edge1 = null;
-		if (filterExpression != null) {
-			edge1 = new Edge(&quot;EDGE1&quot;, dataRecordMetadata);
-		}
-		Node writer = getWriter(viewMode, dataRecordMetadata, fileUrl, delimiter, recordFrom, recordCount, fields);
-		
-		// add Edges &amp; Nodes &amp; Phases to graph
-		try {
-			viewGraph.addPhase(_PHASE_1);
-			viewGraph.addEdge(edge0);
-			_PHASE_1.addNode(node);
-			_PHASE_1.addNode(writer);
-			
-			if (filterExpression != null) {
-				viewGraph.addEdge(edge1);
-				extFilter = new ExtFilter(&quot;ExtFilter0&quot;);
-				extFilter.setFilterExpression(filterExpression);
-				_PHASE_1.addNode(extFilter);
-			}
-		} catch (GraphConfigurationException e) {
-			e.printStackTrace();
-		}
-
-		// assign ports (input &amp; output)
-		node.addOutputPort(0,edge0);
-		if (filterExpression != null) {
-			extFilter.addInputPort(0,edge0);
-			extFilter.addOutputPort(0,edge1);
-			writer.addInputPort(0,edge1); 
-		} else {
-			writer.addInputPort(0,edge0);
-		}
-
-		if(!viewGraph.init()){
-			System.err.println(&quot;Graph initialization failed !&quot;);
-			return;
-		}
-	    
-		//	start all Nodes (each node is one thread)
-		Result result=Result.N_A;
-		try {
-            result = viewGraph.run();
-		} catch (RuntimeException ex) {
-			System.err.println(&quot;Fatal error during graph run !&quot;);
-			System.err.println(ex.getCause().getMessage());
-			if (verbose) {
-				ex.printStackTrace();
-			}
-			System.exit(-1);
-		}
-		if (result==Result.FINISHED_OK) {
-			// everything O.K.
-			System.out.println(&quot;Execution of graph successful !&quot;);
-			System.exit(0);
-		} else {
-			// something FAILED !!
-			System.err.println(&quot;Execution of graph failed !&quot;);
-			System.exit(result.code());
-		}
-
-	}
-    
-	private static Node getWriter(Mode mode, DataRecordMetadata dataRecordMetadata, String fileUrl, String delimiter, long recordFrom, long recordCount, String fields) {
-		if (mode == null) return null;
-		Node writer = null;
-		String[] aFiealds = fields == null ? null : fields.split(&quot;;&quot;);
-		
-		if (mode.equals(Mode.HTML)) {
-			StringBuilder maskBuilder = new StringBuilder();
-			if (aFiealds == null) {
-				maskBuilder.append(&quot;&lt;tr&gt;&quot;);
-				for (int i=0;i&lt;dataRecordMetadata.getNumFields();i++){
-					maskBuilder.append(&quot;&lt;td&gt;$&quot;);
-					maskBuilder.append(dataRecordMetadata.getField(i).getName());
-					maskBuilder.append(&quot;&lt;/td&gt;&quot;);
-				}
-				maskBuilder.append(&quot;&lt;/tr&gt;\n&quot;);
-			} else if (aFiealds.length &gt; 0) {
-				maskBuilder.append(&quot;&lt;tr&gt;&quot;);
-				for (String sfield: aFiealds){
-					if (dataRecordMetadata.getField(sfield) == null) {
-						System.err.println(&quot;Field name '&quot;+ sfield + &quot;' not found.&quot;);
-						System.exit(-1);
-					}
-					maskBuilder.append(&quot;&lt;td&gt;$&quot;);
-					maskBuilder.append(sfield);
-					maskBuilder.append(&quot;&lt;/td&gt;&quot;);
-				}
-				maskBuilder.append(&quot;&lt;/tr&gt;\n&quot;);
-			} else {
-				System.err.println(&quot;No field found.&quot;);
-				System.exit(-1);
-			}
-			
-			StructureWriter structureWriter = new StructureWriter(&quot;STRUCTURE_WRITER0&quot;, fileUrl, null, false, maskBuilder.toString());
-			structureWriter.setRecordFrom(recordFrom);
-			structureWriter.setRecordCount(recordCount);
-			StringBuilder sb = new StringBuilder();
-			
-			sb.append(&quot;&lt;table name=\&quot;&quot; + dataRecordMetadata.getName() + &quot;\&quot; border=1&gt;\n&quot;);
-			sb.append(&quot;&lt;tr&gt;&quot;);
-			if (aFiealds == null ) {
-				for (int i=0;i&lt;dataRecordMetadata.getNumFields();i++){
-					sb.append(&quot;&lt;th&gt;&quot;);
-					sb.append(dataRecordMetadata.getField(i).getName());
-					sb.append(&quot;&lt;/th&gt;&quot;);
-				}
-			} else {
-				for (String sfield: aFiealds){
-					sb.append(&quot;&lt;th&gt;&quot;);
-					sb.append(dataRecordMetadata.getField(sfield).getName());
-					sb.append(&quot;&lt;/th&gt;&quot;);
-				}
-			}
-			sb.append(&quot;&lt;/tr&gt;\n&quot;);
-			structureWriter.setHeader(sb.toString());
-			
-			sb = new StringBuilder();
-			sb.append(&quot;&lt;/table&gt;\n&quot;);
-			structureWriter.setFooter(sb.toString());
-			
-			writer = structureWriter;
-			
-		} else if (mode.equals(Mode.TEXT)) {
-			DataWriter dataWriter = new DataWriter(&quot;DATA_WRITER0&quot;, fileUrl, dataRecordMetadata.getLocaleStr(), false);
-			//TODO agata dodelat selekci na fieldy
-			dataWriter.setRecordFrom(recordFrom);
-			dataWriter.setRecordCount(recordCount);
-			if (delimiter != null) dataWriter.setDataDelimiter(delimiter);
-			writer = dataWriter;
-			
-		} else if (mode.equals(Mode.DELIMITER_TEXT)) {
-			TextWriter dataWriter = new TextWriter(&quot;TEXT_TABLE_WRITER0&quot;, fileUrl, null, false, aFiealds);
-			dataWriter.setRecordFrom(recordFrom);
-			dataWriter.setRecordCount(recordCount);
-			dataWriter.setHeader(true);
-			
-			writer = dataWriter;
-			/*   +--+--+
-				 |  |  |
-			     +--+--+
-			*/
-		}
-		return writer;
-	}
-	
-	private static void printHelp() {
-		System.out.println(&quot;Usage: runGraph [-(v|cfg|P:|info|plugins|pass)] &lt;graph definition file&gt; &lt;component id&gt;&quot;);
-		System.out.println(&quot;Options:&quot;);
-		System.out.println(&quot;-v\t\t\tbe verbose - print even graph layout&quot;);
-		System.out.println(&quot;-P:&lt;key&gt;=&lt;value&gt;\tadd definition of property to global graph's property list&quot;);
-		System.out.println(&quot;-cfg &lt;filename&gt;\t\tload definitions of properties from specified file&quot;);
-		System.out.println(&quot;-info\t\t\tprint info about Clover library version&quot;);
-        System.out.println(&quot;-plugins\t\tdirectory where to look for plugins/components&quot;);
-        System.out.println(&quot;-pass\t\tpassword for decrypting of hidden connections passwords&quot;);
-        System.out.println();
-        System.out.println(&quot;Note: &lt;graph definition file&gt; can be either local filename or URL of local/remote file&quot;);
-	}
-
-	private static void printInfo(){
-	    System.out.println(&quot;CloverETL library version &quot;+JetelVersion.MAJOR_VERSION+&quot;.&quot;+JetelVersion.MINOR_VERSION+&quot; build#&quot;+JetelVersion.BUILD_NUMBER+&quot; compiled &quot;+JetelVersion.LIBRARY_BUILD_DATETIME);
-	}
-	
-	public enum Mode {
-	    
-	    TEXT,
-	    HTML,
-	    DELIMITER_TEXT;
-
-	    public static Mode valueModeOf(String value){
-	    	if (value.equalsIgnoreCase(TEXT.name())) {
-	    		return TEXT;
-	    	}
-	    	if (value.equalsIgnoreCase(HTML.name())) {
-	    		return HTML;
-	    	}
-	    	if (value.equalsIgnoreCase(DELIMITER_TEXT.name())) {
-	    		return DELIMITER_TEXT;
-	    	}
-	    	return null;
-	    }
-	    
-	}
-	
-}
-

Added: trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java	2007-02-01 14:30:21 UTC (rev 2429)
+++ trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java	2007-02-01 14:47:34 UTC (rev 2430)
@@ -0,0 +1,620 @@
+/*
+ *  jETeL/Clover - Java based ETL application framework.
+ *  Copyright (C) 2002-03  David Pavlis
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License as published by the Free Software Foundation; either
+ *    version 2.1 of the License, or (at your option) any later version.
+ *    
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
+ *    Lesser General Public License for more details.
+ *    
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+package org.jetel.main;
+
+import java.io.BufferedInputStream;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.Map;
+import java.util.Properties;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.commons.cli.ParseException;
+import org.apache.commons.cli.PosixParser;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.log4j.Level;
+import org.apache.log4j.Logger;
+import org.apache.log4j.net.SocketAppender;
+import org.jetel.component.DataWriter;
+import org.jetel.component.ExtFilter;
+import org.jetel.component.StructureWriter;
+import org.jetel.component.TextWriter;
+import org.jetel.data.Defaults;
+import org.jetel.exception.ConfigurationStatus;
+import org.jetel.exception.GraphConfigurationException;
+import org.jetel.exception.XMLConfigurationException;
+import org.jetel.graph.Edge;
+import org.jetel.graph.Node;
+import org.jetel.graph.Phase;
+import org.jetel.graph.Result;
+import org.jetel.graph.TransformationGraph;
+import org.jetel.graph.TransformationGraphXMLReaderWriter;
+import org.jetel.metadata.DataRecordMetadata;
+import org.jetel.plugin.Plugins;
+import org.jetel.util.FileUtils;
+import org.jetel.util.JetelVersion;
+import org.jetel.util.crypto.Enigma;
+
+/**
+ *  class for reading and showing data over input components&lt;br&gt;&lt;br&gt;
+ *  The graph layout is read from specified XML file and over component id is written data to output.&lt;br&gt;
+ *  &lt;tt&gt;&lt;pre&gt;
+ *  Program parameters:
+ *  &lt;table&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;-v&lt;/td&gt;&lt;td&gt;be verbose - print even graph layout&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;-P&lt;i&gt;properyName&lt;/i&gt;=&lt;i&gt;propertyValue&lt;/i&gt;&lt;/td&gt;&lt;td&gt;add definition of property to global graph's property list&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--cfg &lt;i&gt;filename&lt;/i&gt;&lt;/td&gt;&lt;td&gt;load definitions of properties from specified file&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--tracking &lt;i&gt;seconds&lt;/i&gt;&lt;/td&gt;&lt;td&gt;how frequently output the processing status&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--info&lt;/td&gt;&lt;td&gt;print info about Clover library version&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--plugins &lt;i&gt;filename&lt;/i&gt;&lt;/td&gt;&lt;td&gt;directory where to look for plugins/components&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--pass &lt;i&gt;password&lt;/i&gt;&lt;/td&gt;&lt;td&gt;password for decrypting of hidden connections passwords&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--stdin&lt;/td&gt;&lt;td&gt;load graph layout from STDIN&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--mode&lt;/td&gt;&lt;td&gt;how show data over component {TEXT,HTML,DELIMITER_TEXT}&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--delimiter&lt;/td&gt;&lt;td&gt;delimiter between two fields&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--file&lt;/td&gt;&lt;td&gt;file url for output. If no file defined, output is set to System.out&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--expFilter&lt;/td&gt;&lt;td&gt;filter expression for record filtering&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--recFrom&lt;/td&gt;&lt;td&gt;from where show records&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--recCount&lt;/td&gt;&lt;td&gt;how many records should be showed&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--fields&lt;/td&gt;&lt;td&gt;Show only defined fields. If no fields defined, show all fields&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;--logLevel&lt;/td&gt;&lt;td&gt;Log level for logger {all, info, debug, ..}, default is error log level&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;&lt;b&gt;filename&lt;/b&gt;&lt;/td&gt;&lt;td&gt;filename or URL of the file (even remote) containing graph's layout in XML (this must be the last parameter passed)&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;tr&gt;&lt;td nowrap&gt;&lt;b&gt;component id&lt;/b&gt;&lt;/td&gt;&lt;td&gt;over this component will be showed data&lt;/td&gt;&lt;/tr&gt;
+ *  &lt;/table&gt;
+ *
+ *  &lt;h4&gt;Example:&lt;/h4&gt;
+ *  &lt;pre&gt;showComponentData ExampleGraph.grf DELIMITED_DATA_READER0:0&lt;/pre&gt;
+ *  
+ *  &lt;pre&gt;showComponentData --plugins ../cloveretl.engine/plugins --mode TEXT --delimiter &quot;+&quot; --expFilter &quot;1==1&quot; --recFrom 2 --recCount 2 --fields &quot;Field1;Field0&quot; ExampleGraph.grf DELIMITED_DATA_READER0:0&lt;/pre&gt;
+ *  
+ *  &lt;/pre&gt;&lt;/tt&gt;
+ * @author      jausperger
+ * @since       2007/02/02
+ * @revision    $Revision:  $
+ */
+public class showComponentData {
+    private static Log logger = LogFactory.getLog(showComponentData.class);
+
+    //TODO change run graph version
+	private final static String RUN_GRAPH_VERSION = &quot;2.0&quot;;
+	
+    /**
+     * Clover.ETL engine initialization. Should be called only once.
+     * @param pluginsRootDirectory directory path, where plugins specification is located 
+     *        (can be null, then is used constant from Defaults.DEFAULT_PLUGINS_DIRECTORY)
+     * @param password password for encrypting some hidden part of graphs
+     *        &lt;br&gt;i.e. connections passwordss can be encrypted
+     */        int trackingInterval = -1;
+
+    public static void initEngine(String pluginsRootDirectory, String password) {
+        
+        //init password decryptor
+        if(password != null) {
+            Enigma.getInstance().init(password);
+        }
+        
+        //init framework constants
+        Defaults.init();
+
+        //init clover plugins system
+        Plugins.init(pluginsRootDirectory);
+    }
+    
+    
+    /**
+     * Instantiates transformation graph from a given input stream and presets a given properties.
+     * @param inStream
+     * @param properties
+     * @return
+     * @throws XMLConfigurationException
+     * @throws GraphConfigurationException
+     */
+    public static TransformationGraph loadGraph(InputStream inStream, Properties properties) throws XMLConfigurationException, GraphConfigurationException {
+        TransformationGraph graph = new TransformationGraph();
+        TransformationGraphXMLReaderWriter graphReader = new TransformationGraphXMLReaderWriter(graph);
+        if(properties != null) {
+            graph.loadGraphProperties(properties);
+        }
+
+        graphReader.read(inStream);
+        
+        return graph;
+    }
+    
+	/**
+	 *  Description of the Method
+	 *
+	 * @param  args  Description of the Parameter
+	 */
+	public static void main(String args[]) {
+		boolean verbose = false;
+        boolean loadFromSTDIN = false;
+		Properties properties = new Properties();
+        int trackingInterval = -1;
+		String pluginsRootDirectory = null;
+        String password = null;
+        Mode viewMode = Mode.TEXT;
+        String delimiter = null;
+        String fileUrl = null;
+        String filterExpression = null;
+        long recordFrom = -1;
+        long recordCount = -1;
+        String fields = null;
+        String logHost = null;
+		
+		ExtFilter extFilter = null;
+        
+		System.out.println(&quot;***  CloverETL graph component tester ver &quot;+RUN_GRAPH_VERSION+&quot;, (c) 2002-06 D.Pavlis, released under GNU Lesser General Public License  ***&quot;);
+		System.out.println(&quot; Running with framework version: &quot;+JetelVersion.MAJOR_VERSION+&quot;.&quot;+JetelVersion.MINOR_VERSION+&quot; build#&quot;+JetelVersion.BUILD_NUMBER+&quot; compiled &quot;+JetelVersion.LIBRARY_BUILD_DATETIME);
+		System.out.println();
+        
+		if (args.length &lt; 1) {
+			printHelp();
+			System.exit(-1);
+		}
+        
+		Options options = new Options();
+    	options.addOption(new Option(&quot;v&quot;, &quot;verbose&quot;, false, &quot;Verbose mode&quot;));
+    	options.addOption(new Option(&quot;g&quot;, &quot;cfg&quot;, true, &quot;Path to property file&quot;));
+    	options.addOption(new Option(&quot;P&quot;, &quot;propertyDefinition&quot;, true, &quot;Property defined by user&quot;));
+    	options.addOption(new Option(&quot;t&quot;, &quot;tracking&quot;, false, &quot;Tracking intrnal switch&quot;));
+    	options.addOption(new Option(&quot;i&quot;, &quot;info&quot;, false, &quot;Information about program&quot;));
+    	options.addOption(new Option(&quot;n&quot;, &quot;stdin&quot;, false, &quot;Load from stdin switch&quot;));
+    	options.addOption(new Option(&quot;h&quot;, &quot;loghost&quot;, false, &quot;Log host switch&quot;));
+    	options.addOption(new Option(&quot;p&quot;, &quot;plugins&quot;, true, &quot;Path to plugins file.&quot;));
+    	options.addOption(new Option(&quot;s&quot;, &quot;pass&quot;, true, &quot;Password&quot;));
+    	options.addOption(new Option(&quot;m&quot;, &quot;mode&quot;, true, &quot;View mode&quot;));
+    	options.addOption(new Option(&quot;d&quot;, &quot;delimiter&quot;, true, &quot;Delimiter between two fields&quot;));
+    	options.addOption(new Option(&quot;o&quot;, &quot;file&quot;, true, &quot;File url for output. If no file defined, output is set to System.out&quot;));
+    	options.addOption(new Option(&quot;e&quot;, &quot;expFilter&quot;, true, &quot;Filter expression for record filtering&quot;));
+    	options.addOption(new Option(&quot;f&quot;, &quot;recFrom&quot;, true, &quot;From where show records&quot;));
+    	options.addOption(new Option(&quot;c&quot;, &quot;recCount&quot;, true, &quot;Count of records&quot;));
+    	options.addOption(new Option(&quot;l&quot;, &quot;fields&quot;, true, &quot;Show only defined fields. If no fields defined, show all fields&quot;));
+    	options.addOption(new Option(&quot;x&quot;, &quot;logLevel&quot;, true, &quot;Log level for logger {all, info, debug, ..}, default is error log level&quot;));
+
+    	PosixParser optParser = new PosixParser();
+    	CommandLine cmdLine;
+		try {
+			cmdLine = optParser.parse(options, args);
+		} catch (ParseException e) {
+			logger.error(e.getMessage(), e);
+			return;
+		}
+		
+		verbose = cmdLine.hasOption(&quot;v&quot;);
+		loadFromSTDIN = cmdLine.hasOption(&quot;n&quot;);
+		if (cmdLine.hasOption(&quot;h&quot;)) {
+            String[] hostAndPort = logHost.split(&quot;:&quot;);
+            if (hostAndPort[0].length() == 0 || hostAndPort.length &gt; 2) {
+                System.err
+                        .println(&quot;Invalid log destination, i.e. -loghost localhost:4445&quot;);
+                System.exit(-1);
+            }
+            int port = 4445;
+            try {
+                if (hostAndPort.length == 2) {
+                    port = Integer.parseInt(hostAndPort[1]);
+                }
+            } catch (NumberFormatException e) {
+                System.err
+                        .println(&quot;Invalid log destination, i.e. -loghost localhost:4445&quot;);
+                System.exit(-1);
+            }
+            Logger.getRootLogger().addAppender(
+                    new SocketAppender(hostAndPort[0], port));
+		}
+		if (cmdLine.hasOption(&quot;g&quot;)) {
+			InputStream inStream;
+			try {
+				inStream = new BufferedInputStream(new FileInputStream(cmdLine.getOptionValue(&quot;g&quot;)));
+				properties.load(inStream);
+			} catch (NullPointerException e) {
+				logger.error(&quot;cfg file not found: &quot; + e.getMessage(), e);
+				System.exit(-1);
+			} catch (IOException e) {
+				logger.error(e.getMessage(), e);
+				System.exit(-1);
+			}
+		}
+		if (cmdLine.hasOption(&quot;P&quot;)) {
+	    	String a[] = cmdLine.getOptionValue(&quot;P&quot;).split(&quot;;&quot;);
+	    	for (String tmp : a) {
+	    	    properties.setProperty(tmp.substring(0,tmp.indexOf(&quot;=&quot;)),tmp.substring(tmp.indexOf(&quot;=&quot;) +1)); 
+	    	}
+		}
+		if (cmdLine.hasOption(&quot;i&quot;)) {
+		    printInfo();
+		    System.exit(0);
+		}
+		if (cmdLine.hasOption(&quot;t&quot;)) {
+            try {
+                trackingInterval = Integer.parseInt(cmdLine.getOptionValue(&quot;t&quot;));
+            } catch (NumberFormatException ex) {
+                System.err.println(&quot;Invalid tracking parameter: \&quot;&quot;
+                        + cmdLine.getOptionValue(&quot;t&quot;) + &quot;\&quot;&quot;);
+                System.exit(-1);
+            }
+		}
+		if (cmdLine.hasOption(&quot;p&quot;)) {
+			pluginsRootDirectory = cmdLine.getOptionValue(&quot;p&quot;);
+		}
+		if (cmdLine.hasOption(&quot;s&quot;)) {
+			password = cmdLine.getOptionValue(&quot;s&quot;);
+		}
+		if (cmdLine.hasOption(&quot;m&quot;)) {
+			viewMode = Mode.valueModeOf(cmdLine.getOptionValue(&quot;m&quot;));
+	        if (viewMode == null) {
+				System.err.println(&quot;Unknown mode option: &quot;+cmdLine.getOptionValue(&quot;m&quot;));
+				System.exit(-1);
+	        }
+		}
+		if (cmdLine.hasOption(&quot;d&quot;)) {
+			delimiter = cmdLine.getOptionValue(&quot;d&quot;);
+		}
+		if (cmdLine.hasOption(&quot;o&quot;)) {
+			fileUrl = cmdLine.getOptionValue(&quot;o&quot;);
+		}
+		if (cmdLine.hasOption(&quot;e&quot;)) {
+			filterExpression = cmdLine.getOptionValue(&quot;e&quot;);
+		}
+		if (cmdLine.hasOption(&quot;f&quot;)) {
+	    	recordFrom = Long.parseLong(cmdLine.getOptionValue(&quot;f&quot;));
+		}
+		if (cmdLine.hasOption(&quot;c&quot;)) {
+	    	recordCount = Long.parseLong(cmdLine.getOptionValue(&quot;c&quot;));
+		}
+		if (cmdLine.hasOption(&quot;l&quot;)) {
+        	fields = cmdLine.getOptionValue(&quot;l&quot;);
+		}
+		Logger.getRootLogger().setLevel(cmdLine.hasOption(&quot;x&quot;)?Level.toLevel(cmdLine.getOptionValue(&quot;x&quot;)):Level.ERROR);
+		
+        // setup log4j appenders
+        if (logHost != null) {
+            String[] hostAndPort = logHost.split(&quot;:&quot;);
+            if (hostAndPort[0].length() == 0 || hostAndPort.length &gt; 2) {
+                System.err
+                        .println(&quot;Invalid log destination, i.e. -loghost localhost:4445&quot;);
+                System.exit(-1);
+            }
+            int port = 4445;
+            try {
+                if (hostAndPort.length == 2) {
+                    port = Integer.parseInt(hostAndPort[1]);
+                }
+            } catch (NumberFormatException e) {
+                System.err
+                        .println(&quot;Invalid log destination, i.e. -loghost localhost:4445&quot;);
+                System.exit(-1);
+            }
+            Logger.getRootLogger().addAppender(
+                    new SocketAppender(hostAndPort[0], port));
+        }
+        
+        // engine initialization - should be called only once
+        runGraph.initEngine(pluginsRootDirectory, password);
+
+        // prapere input stream with XML graph definition
+        InputStream in = null;
+        if (loadFromSTDIN) {
+            System.out.println(&quot;Graph definition loaded from STDIN&quot;);
+            in = System.in;
+        } else {
+            System.out.println(&quot;Graph definition file: &quot;
+                    + args[args.length - 2]);
+            try {
+                URL fileURL = FileUtils.getFileURL(null, args[args.length - 2]);
+                in = fileURL.openStream();
+            } catch (IOException e) {
+                System.err
+                        .println(&quot;Error - graph definition file can't be read: &quot;
+                                + e.getMessage());
+                System.exit(-1);
+            }
+        }
+        
+        System.out.println(&quot;Component id: &quot; + args[args.length - 1]);
+        String componentID = args[args.length - 1];
+        int pos;
+        int port = 0;
+        if ((pos = componentID.indexOf(':')) != -1) {
+        	port = Integer.parseInt(componentID.substring(pos+1));
+        	componentID = componentID.substring(0, pos);
+        }
+
+        // loading graph from the input stream
+        TransformationGraph graph = null;
+        try {
+            graph = runGraph.loadGraph(in, properties);
+
+            // check graph elements configuration
+            logger.info(&quot;Checking graph configuration...&quot;);
+            try {
+                ConfigurationStatus status = graph.checkConfig(null);
+                status.log();
+            } catch(Exception e) {
+                logger.error(&quot;Checking graph failed! (&quot; + e.getMessage() + &quot;)&quot;);
+            }
+
+            if (!graph.init()) {
+                throw new GraphConfigurationException(
+                        &quot;Graph initialization failed.&quot;);
+            }
+
+            if (verbose) {
+                // this can be called only after graph.init()
+                graph.dumpGraphConfiguration();
+            }
+        } catch (XMLConfigurationException ex) {
+            logger.error(&quot;Error in reading graph from XML !&quot;, ex);
+            if (verbose) {
+                ex.printStackTrace(System.err);
+            }
+            System.exit(-1);
+        } catch (GraphConfigurationException ex) {
+            logger.error(&quot;Error - graph's configuration invalid !&quot;, ex);
+            if (verbose) {
+                ex.printStackTrace(System.err);
+            }
+            System.exit(-1);
+        } catch (RuntimeException ex) {
+            logger.error(&quot;Error during graph initialization !&quot;, ex);
+            if (verbose) {
+                ex.printStackTrace(System.err);
+            }
+            System.exit(-1);
+        }
+        
+
+        //check graph elements configuration
+        ConfigurationStatus status = graph.checkConfig(null);
+        status.log();
+        
+		Map map = graph.getNodes();
+		Node node = (Node) map.get(componentID);
+		if (node == null) {
+			//map = graph.getEdges();
+			//Edge edge = (Edge) map.get(componentID);
+			//if (edge == null) {
+				// error
+				logger.error(&quot;Component Id '&quot;+ componentID +&quot;' not found!&quot;);
+				return;
+			//}
+		}
+		if (!node.isRoot()) {
+			// not implemented
+			System.err.println(&quot;Execution is implemented for root node (root node has only output ports connected)!&quot;);
+			return;
+		}
+
+		// create new graph
+	    TransformationGraph viewGraph = new TransformationGraph();
+		Phase _PHASE_1 = new Phase(1);
+
+	    // add writer component
+		DataRecordMetadata dataRecordMetadata = (DataRecordMetadata) node.getOutMetadata().toArray()[port];
+		Edge edge0 = new Edge(&quot;EDGE0&quot;, dataRecordMetadata);
+		Edge edge1 = null;
+		if (filterExpression != null) {
+			edge1 = new Edge(&quot;EDGE1&quot;, dataRecordMetadata);
+		}
+		Node writer = getWriter(viewMode, dataRecordMetadata, fileUrl, delimiter, recordFrom, recordCount, fields);
+		
+		// add Edges &amp; Nodes &amp; Phases to graph
+		try {
+			viewGraph.addPhase(_PHASE_1);
+			viewGraph.addEdge(edge0);
+			_PHASE_1.addNode(node);
+			_PHASE_1.addNode(writer);
+			
+			if (filterExpression != null) {
+				viewGraph.addEdge(edge1);
+				extFilter = new ExtFilter(&quot;ExtFilter0&quot;);
+				extFilter.setFilterExpression(filterExpression);
+				_PHASE_1.addNode(extFilter);
+			}
+		} catch (GraphConfigurationException e) {
+			e.printStackTrace();
+		}
+
+		// assign ports (input &amp; output)
+		node.addOutputPort(0,edge0);
+		if (filterExpression != null) {
+			extFilter.addInputPort(0,edge0);
+			extFilter.addOutputPort(0,edge1);
+			writer.addInputPort(0,edge1); 
+		} else {
+			writer.addInputPort(0,edge0);
+		}
+
+		if(!viewGraph.init()){
+			System.err.println(&quot;Graph initialization failed !&quot;);
+			return;
+		}
+	    
+        // set tracking interval
+        if (trackingInterval != -1) {
+        	viewGraph.setTrackingInterval(trackingInterval * 1000);
+        }
+
+        //	start all Nodes (each node is one thread)
+		Result result=Result.N_A;
+		try {
+            result = viewGraph.run();
+        } catch (RuntimeException ex) {
+            System.err.println(&quot;Fatal error during graph run !&quot;);
+            System.err.println(ex.getCause().getMessage());
+            if (verbose) {
+                ex.printStackTrace();
+            }
+            System.exit(-1);
+        }
+        switch (result) {
+
+        case FINISHED_OK:
+            // everything O.K.
+            System.out.println(&quot;Execution of graph successful !&quot;);
+            System.exit(0);
+            break;
+        case ABORTED:
+            // execution was ABORTED !!
+            System.err.println(&quot;Execution of graph aborted !&quot;);
+            System.exit(result.code());
+            break;
+        default:
+            System.err.println(&quot;Execution of graph failed !&quot;);
+            System.exit(result.code());
+        }
+
+	}
+    
+	private static Node getWriter(Mode mode, DataRecordMetadata dataRecordMetadata, String fileUrl, String delimiter, long recordFrom, long recordCount, String fields) {
+		if (mode == null) return null;
+		Node writer = null;
+		String[] aFiealds = fields == null ? null : fields.split(&quot;;&quot;);
+		
+		if (mode.equals(Mode.HTML)) {
+			StringBuilder maskBuilder = new StringBuilder();
+			if (aFiealds == null) {
+				maskBuilder.append(&quot;&lt;tr&gt;&quot;);
+				for (int i=0;i&lt;dataRecordMetadata.getNumFields();i++){
+					maskBuilder.append(&quot;&lt;td&gt;$&quot;);
+					maskBuilder.append(dataRecordMetadata.getField(i).getName());
+					maskBuilder.append(&quot;&lt;/td&gt;&quot;);
+				}
+				maskBuilder.append(&quot;&lt;/tr&gt;\n&quot;);
+			} else if (aFiealds.length &gt; 0) {
+				maskBuilder.append(&quot;&lt;tr&gt;&quot;);
+				for (String sfield: aFiealds){
+					if (dataRecordMetadata.getField(sfield) == null) {
+						System.err.println(&quot;Field name '&quot;+ sfield + &quot;' not found.&quot;);
+						System.exit(-1);
+					}
+					maskBuilder.append(&quot;&lt;td&gt;$&quot;);
+					maskBuilder.append(sfield);
+					maskBuilder.append(&quot;&lt;/td&gt;&quot;);
+				}
+				maskBuilder.append(&quot;&lt;/tr&gt;\n&quot;);
+			} else {
+				System.err.println(&quot;No field found.&quot;);
+				System.exit(-1);
+			}
+			
+			StructureWriter structureWriter = new StructureWriter(&quot;STRUCTURE_WRITER0&quot;, fileUrl, null, false, maskBuilder.toString());
+			structureWriter.setRecordFrom(recordFrom);
+			structureWriter.setRecordCount(recordCount);
+			StringBuilder sb = new StringBuilder();
+			
+			sb.append(&quot;&lt;table name=\&quot;&quot; + dataRecordMetadata.getName() + &quot;\&quot; border=1&gt;\n&quot;);
+			sb.append(&quot;&lt;tr&gt;&quot;);
+			if (aFiealds == null ) {
+				for (int i=0;i&lt;dataRecordMetadata.getNumFields();i++){
+					sb.append(&quot;&lt;th&gt;&quot;);
+					sb.append(dataRecordMetadata.getField(i).getName());
+					sb.append(&quot;&lt;/th&gt;&quot;);
+				}
+			} else {
+				for (String sfield: aFiealds){
+					sb.append(&quot;&lt;th&gt;&quot;);
+					sb.append(dataRecordMetadata.getField(sfield).getName());
+					sb.append(&quot;&lt;/th&gt;&quot;);
+				}
+			}
+			sb.append(&quot;&lt;/tr&gt;\n&quot;);
+			structureWriter.setHeader(sb.toString());
+			
+			sb = new StringBuilder();
+			sb.append(&quot;&lt;/table&gt;\n&quot;);
+			structureWriter.setFooter(sb.toString());
+			writer = structureWriter;
+			
+		} else if (mode.equals(Mode.TEXT)) {
+			DataWriter dataWriter = new DataWriter(&quot;DATA_WRITER0&quot;, fileUrl, dataRecordMetadata.getLocaleStr(), false);
+			//TODO agata dodelat selekci na fieldy
+			dataWriter.setRecordFrom(recordFrom);
+			dataWriter.setRecordCount(recordCount);
+			if (delimiter != null) dataWriter.setDataDelimiter(delimiter);
+			writer = dataWriter;
+			
+		} else if (mode.equals(Mode.DELIMITER_TEXT)) {
+			TextWriter dataWriter = new TextWriter(&quot;TEXT_TABLE_WRITER0&quot;, fileUrl, null, false, aFiealds);
+			dataWriter.setRecordFrom(recordFrom);
+			dataWriter.setRecordCount(recordCount);
+			dataWriter.setHeader(true);
+			writer = dataWriter;
+		}
+		return writer;
+	}
+	
+	private static void printHelp() {
+		System.out.println(&quot;Usage: runGraph [-(v|P)] [--(cfg|tracking|info|plugins|pass|loghost|mode|delimiter|file|expFilter|recFrom|recCount|fields|logLevel)] &lt;graph definition file&gt; &lt;component id&gt;&quot;);
+		System.out.println(&quot;Options:&quot;);
+		System.out.println(&quot;-v\t\t\tbe verbose - print even graph layout&quot;);
+		System.out.println(&quot;-P:&lt;key&gt;=&lt;value&gt;\tadd definition of property to global graph's property list&quot;);
+		System.out.println(&quot;--cfg &lt;filename&gt;\t\tload definitions of properties from specified file&quot;);
+		System.out.println(&quot;--tracking &lt;seconds&gt;\thow frequently output the graph processing status&quot;);
+		System.out.println(&quot;--info\t\t\tprint info about Clover library version&quot;);
+        System.out.println(&quot;--plugins\t\tdirectory where to look for plugins/components&quot;);
+        System.out.println(&quot;--pass\t\tpassword for decrypting of hidden connections passwords&quot;);
+        System.out.println(&quot;--stdin\t\tload graph definition from STDIN&quot;);
+        System.out.println(&quot;--loghost\t\tdefine host and port number for socket appender of log4j (log4j library is required); i.e. localhost:4445&quot;);
+        System.out.println(&quot;--mode\t\thow show data over component {TEXT,HTML,DELIMITER_TEXT}&quot;);
+        System.out.println(&quot;--delimiter\t\tdelimiter between two fields&quot;);
+        System.out.println(&quot;--file\t\tfile url for output. If no file defined, output is set to System.out&quot;);
+        System.out.println(&quot;--expFilter\t\tfilter expression for record filtering&quot;);
+        System.out.println(&quot;--recFrom\t\tfrom where show records&quot;);
+        System.out.println(&quot;--recCount\t\thow many records should be showed&quot;);
+        System.out.println(&quot;--fields\t\tShow only defined fields. If no fields defined, show all fields&quot;);
+        System.out.println(&quot;--logLevel\t\tLog level for logger {all, info, debug, ..}, default is error log level&quot;);
+        System.out.println();
+        System.out.println(&quot;Note: &lt;graph definition file&gt; can be either local filename or URL of local/remote file&quot;);
+        System.out.println(&quot;Note: &lt;component id&gt; over this component will be showed data&quot;);
+	}
+
+	private static void printInfo(){
+	    System.out.println(&quot;CloverETL library version &quot;+JetelVersion.MAJOR_VERSION+&quot;.&quot;+JetelVersion.MINOR_VERSION+&quot; build#&quot;+JetelVersion.BUILD_NUMBER+&quot; compiled &quot;+JetelVersion.LIBRARY_BUILD_DATETIME);
+	}
+
+	public enum Mode {
+	    
+	    TEXT,
+	    HTML,
+	    DELIMITER_TEXT;
+
+	    public static Mode valueModeOf(String value){
+	    	if (value.equalsIgnoreCase(TEXT.name())) {
+	    		return TEXT;
+	    	}
+	    	if (value.equalsIgnoreCase(HTML.name())) {
+	    		return HTML;
+	    	}
+	    	if (value.equalsIgnoreCase(DELIMITER_TEXT.name())) {
+	    		return DELIMITER_TEXT;
+	    	}
+	    	return null;
+	    }
+	    
+	}
+	
+}
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000066.html">[Cloveretl-svn-commits] CloverETL repos r2429 -	trunk/cloveretl.engine
</A></li>
	<LI>Next message: <A HREF="000068.html">[Cloveretl-svn-commits] CloverETL repos r2431 -	trunk/cloveretl.engine/lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#67">[ date ]</a>
              <a href="thread.html#67">[ thread ]</a>
              <a href="subject.html#67">[ subject ]</a>
              <a href="author.html#67">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cloveretl-svn-commits">More information about the Cloveretl-svn-commits
mailing list</a><br>
</body></html>
