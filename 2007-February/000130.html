<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cloveretl-svn-commits] CloverETL repos r2493 -	trunk/cloveretl.engine/src/org/jetel/util/dml2clover
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cloveretl-svn-commits/2007-February/index.html" >
   <LINK REL="made" HREF="mailto:cloveretl-svn-commits%40lists.berlios.de?Subject=Re%3A%20%5BCloveretl-svn-commits%5D%20CloverETL%20repos%20r2493%20-%0A%09trunk/cloveretl.engine/src/org/jetel/util/dml2clover&In-Reply-To=%3C200702201357.l1KDvaFD025469%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000129.html">
   <LINK REL="Next"  HREF="000133.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cloveretl-svn-commits] CloverETL repos r2493 -	trunk/cloveretl.engine/src/org/jetel/util/dml2clover</H1>
    <B>cloveretl-svn-commits at lists.berlios.de</B> 
    <A HREF="mailto:cloveretl-svn-commits%40lists.berlios.de?Subject=Re%3A%20%5BCloveretl-svn-commits%5D%20CloverETL%20repos%20r2493%20-%0A%09trunk/cloveretl.engine/src/org/jetel/util/dml2clover&In-Reply-To=%3C200702201357.l1KDvaFD025469%40sheep.berlios.de%3E"
       TITLE="[Cloveretl-svn-commits] CloverETL repos r2493 -	trunk/cloveretl.engine/src/org/jetel/util/dml2clover">cloveretl-svn-commits at lists.berlios.de
       </A><BR>
    <I>Tue Feb 20 14:57:36 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000129.html">[Cloveretl-svn-commits] CloverETL repos r2492 - in	trunk/cloveretl.engine/src/org/jetel/util: . dml2clover
</A></li>
        <LI>Next message: <A HREF="000133.html">[Cloveretl-svn-commits] CloverETL repos r2494 - in	trunk/cloveretl.engine/src/org/jetel/util: . ddl2clover
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#130">[ date ]</a>
              <a href="thread.html#130">[ thread ]</a>
              <a href="subject.html#130">[ subject ]</a>
              <a href="author.html#130">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jausperger
Date: 2007-02-20 14:57:34 +0100 (Tue, 20 Feb 2007)
New Revision: 2493

Added:
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2Clover.java
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverConstants.java
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverTokenManager.java
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/ParseException.java
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/SimpleCharStream.java
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/Token.java
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/TokenMgrError.java
Log:
INIT: create metadata from create statement

Added: trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2Clover.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2Clover.java	2007-02-20 13:36:20 UTC (rev 2492)
+++ trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2Clover.java	2007-02-20 13:57:34 UTC (rev 2493)
@@ -0,0 +1,881 @@
+/* Generated By:JavaCC: Do not edit this line. DML2Clover.java */
+package org.jetel.util.dml2clover;
+
+import java.util.*;
+import java.io.*;
+import org.jetel.metadata.*;
+import java.math.*;
+
+public class DML2Clover implements DML2CloverConstants {
+
+        /**
+		 * The class parses sql script containing only create statements. Output is a DataRecordMetadata List.
+		 */
+
+        private List&lt;DataRecordMetadata&gt; list = new LinkedList&lt;DataRecordMetadata&gt;();
+        private String fieldDelimiter;
+        private String recordDelimiter;
+
+        private static final Long booleanLenght = Long.valueOf(5); // false / true
+        private static final Long byteLenght = Long.valueOf(String.valueOf(Byte.MIN_VALUE).length());
+        private static final Long integerLenght = Long.valueOf(String.valueOf(Integer.MIN_VALUE).length());
+        private static final Long longLenght = Long.valueOf(String.valueOf(Long.MIN_VALUE).length());
+        private static final Long floatLenght = Long.valueOf(String.valueOf(7));
+        private static final Long doubleLenght = Long.valueOf(String.valueOf(15));
+        private static final Long dateLenght = Long.valueOf(10); // &quot;10.10.2007&quot;
+        private static final Long dateTimeLenght = Long.valueOf(24); // &quot;10.10.2007 23:10:10.111&quot;
+
+        public static void main(String args[]) throws ParseException, FileNotFoundException {
+                DML2Clover parser = new DML2Clover(new FileInputStream(new File(&quot;text.txt&quot;)));
+                parser.getDataRecordMetadataList(&quot;;&quot;, &quot;\n&quot;);
+                parser.testPrint(parser.list);
+                System.out.println(&quot;Ok&quot;);
+        }
+
+        public List&lt;DataRecordMetadata&gt; getDataRecordMetadataList() throws ParseException {
+                return getDataRecordMetadataList(null, null);
+        }
+
+        public List&lt;DataRecordMetadata&gt; getDataRecordMetadataList(String fieldDelimiter, String recordDelimiter) throws ParseException {
+                this.fieldDelimiter = fieldDelimiter;
+                this.recordDelimiter = recordDelimiter;
+                while (!isEOF()) {
+                        list.add(createTableStatement());
+                }
+                return list;
+        }
+
+        private void testPrint(List&lt;DataRecordMetadata&gt; list) {
+                DataRecordMetadataXMLReaderWriter writer = new DataRecordMetadataXMLReaderWriter();
+                for (DataRecordMetadata dataRecordMetadata : list) {
+                        writer.write(dataRecordMetadata, System.out);
+                        System.out.println();
+                }
+        }
+
+/*******************************************************************
+ * The SQL syntatic grammar starts here
+ *******************************************************************/
+  final public DataRecordMetadata createTableStatement() throws ParseException {
+        DataRecordMetadata dataRecordMetadata;
+        List&lt;DataFieldMetadata&gt; list;
+    jj_consume_token(CREATE);
+    switch (jj_nt.kind) {
+    case GLOBAL:
+    case LOCAL:
+    case TEMPORARY:
+      tableScope();
+      break;
+    default:
+      jj_la1[0] = jj_gen;
+      ;
+    }
+    jj_consume_token(TABLE);
+    if (jj_2_1(2)) {
+      jj_consume_token(IDENTIFIER);
+      jj_consume_token(DOT);
+    } else {
+      ;
+    }
+                                                                           dataRecordMetadata = new DataRecordMetadata(identifier());
+                        list = tableElementList();
+                        for (DataFieldMetadata field : list) {
+                                dataRecordMetadata.addField(field);
+                        }
+    switch (jj_nt.kind) {
+    case ON:
+      jj_consume_token(ON);
+      jj_consume_token(COMMIT);
+      switch (jj_nt.kind) {
+      case DELETE:
+      case PRESERVE:
+        switch (jj_nt.kind) {
+        case PRESERVE:
+          jj_consume_token(PRESERVE);
+          break;
+        case DELETE:
+          jj_consume_token(DELETE);
+          break;
+        default:
+          jj_la1[1] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+      default:
+        jj_la1[2] = jj_gen;
+        ;
+      }
+      jj_consume_token(ROWS);
+      break;
+    default:
+      jj_la1[3] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+                if (fieldDelimiter != null &amp;&amp; recordDelimiter != null) {
+                        dataRecordMetadata.setRecType(DataRecordMetadata.DELIMITED_RECORD);
+                } else if (fieldDelimiter == null &amp;&amp; recordDelimiter == null) {
+                        dataRecordMetadata.setRecType(DataRecordMetadata.FIXEDLEN_RECORD);
+                }
+          {if (true) return dataRecordMetadata;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+  final public List&lt;DataFieldMetadata&gt; tableElementList() throws ParseException {
+        List&lt;DataFieldMetadata&gt; list = new LinkedList&lt;DataFieldMetadata&gt;();
+        DataFieldMetadata ret;
+    jj_consume_token(OPENPAREN);
+    ret = tableElement();
+                ret.setDelimiter(fieldDelimiter);
+                list.add(ret);
+    label_1:
+    while (true) {
+      switch (jj_nt.kind) {
+      case COMA:
+        ;
+        break;
+      default:
+        jj_la1[4] = jj_gen;
+        break label_1;
+      }
+      jj_consume_token(COMA);
+      ret = tableElement();
+                ret.setDelimiter(fieldDelimiter);
+                list.add(ret);
+    }
+         ret.setDelimiter(recordDelimiter);
+    jj_consume_token(CLOSEPAREN);
+          {if (true) return list;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+  final public void tableScope() throws ParseException {
+    switch (jj_nt.kind) {
+    case GLOBAL:
+    case LOCAL:
+      switch (jj_nt.kind) {
+      case GLOBAL:
+        jj_consume_token(GLOBAL);
+        break;
+      case LOCAL:
+        jj_consume_token(LOCAL);
+        break;
+      default:
+        jj_la1[5] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[6] = jj_gen;
+      ;
+    }
+    jj_consume_token(TEMPORARY);
+  }
+
+  final public boolean isEOF() throws ParseException {
+        boolean isEof = false;
+    switch (jj_nt.kind) {
+    case 0:
+      jj_consume_token(0);
+      isEof = t();
+      break;
+    default:
+      jj_la1[7] = jj_gen;
+      ;
+    }
+         {if (true) return isEof;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+  final public boolean t() throws ParseException {
+         {if (true) return true;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public void columnConstraintDefinition() throws ParseException {
+    switch (jj_nt.kind) {
+    case NOT:
+      jj_consume_token(NOT);
+      jj_consume_token(NULL);
+      break;
+    case UNIQUE:
+      jj_consume_token(UNIQUE);
+      break;
+    case PRIMARY:
+      jj_consume_token(PRIMARY);
+      jj_consume_token(KEY);
+      break;
+    case REFERENCES:
+      jj_consume_token(REFERENCES);
+      tableName();
+      jj_consume_token(OPENPAREN);
+      identifierList();
+      jj_consume_token(CLOSEPAREN);
+      break;
+    default:
+      jj_la1[8] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+//+
+  final public DataFieldMetadata columnDefinition() throws ParseException {
+        DataFieldMetadata dataFieldMetadata;
+        String name;
+        DataType type;
+        Object value = null;
+    name = columnName();
+    type = dataType();
+    switch (jj_nt.kind) {
+    case DEFAULT_:
+      jj_consume_token(DEFAULT_);
+      value = defaultValue();
+      break;
+    default:
+      jj_la1[9] = jj_gen;
+      ;
+    }
+    switch (jj_nt.kind) {
+    case NOT:
+    case PRIMARY:
+    case REFERENCES:
+    case UNIQUE:
+      columnConstraintDefinition();
+      break;
+    default:
+      jj_la1[10] = jj_gen;
+      ;
+    }
+          if (type.length == null) {
+                dataFieldMetadata = new DataFieldMetadata(name, type.type, null);
+          } else {
+                //dataFieldMetadata = new DataFieldMetadata(name, type.type, type.length.shortValue());
+                dataFieldMetadata = new DataFieldMetadata(name, type.type, type.length.shortValue());
+          }
+          dataFieldMetadata.setDefaultValue(value);
+          {if (true) return dataFieldMetadata;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+  final public DataFieldMetadata tableElement() throws ParseException {
+        DataFieldMetadata ret = null;
+    ret = columnDefinition();
+          {if (true) return ret;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public String columnName() throws ParseException {
+        String ret;
+    if (jj_2_2(2)) {
+      identifier();
+      jj_consume_token(DOT);
+    } else {
+      ;
+    }
+    ret = identifier();
+          {if (true) return ret;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+TODO dodelat dalsi typu jako DATE, VARCHAR,...
+  final public DataType dataType() throws ParseException {
+        char type;
+        Long temp;
+        Long lenght = null;
+        Long scale = null;
+    switch (jj_nt.kind) {
+    case BOOLEAN:
+      jj_consume_token(BOOLEAN);
+                            type = DataFieldMetadata.INTEGER_FIELD;             lenght = integerLenght;
+      break;
+    case BLOB:
+      jj_consume_token(BLOB);
+                         type = DataFieldMetadata.BYTE_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                    lenght = temp;
+        break;
+      default:
+        jj_la1[11] = jj_gen;
+        ;
+      }
+      break;
+    case CHAR:
+      jj_consume_token(CHAR);
+                         type = DataFieldMetadata.STRING_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                    lenght = temp;
+        break;
+      default:
+        jj_la1[12] = jj_gen;
+        ;
+      }
+      break;
+    case CHARACTER:
+      jj_consume_token(CHARACTER);
+                              type = DataFieldMetadata.STRING_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                            lenght = temp;
+        break;
+      default:
+        jj_la1[13] = jj_gen;
+        ;
+      }
+      break;
+    case CLOB:
+      jj_consume_token(CLOB);
+                         type = DataFieldMetadata.BYTE_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                    lenght = temp;
+        break;
+      default:
+        jj_la1[14] = jj_gen;
+        ;
+      }
+      break;
+    case DATE:
+      jj_consume_token(DATE);
+                         type = DataFieldMetadata.DATE_FIELD;                   lenght = dateLenght;
+      break;
+    case DATETIME:
+      jj_consume_token(DATETIME);
+                             type = DataFieldMetadata.DATE_FIELD;           lenght = dateTimeLenght;
+      break;
+    case DEC:
+      jj_consume_token(DEC);
+                        type = DataFieldMetadata.DECIMAL_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        switch (jj_nt.kind) {
+        case COMA:
+          jj_consume_token(COMA);
+          scale = integerLiteral();
+          break;
+        default:
+          jj_la1[15] = jj_gen;
+          ;
+        }
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                                                        lenght = temp;
+        break;
+      default:
+        jj_la1[16] = jj_gen;
+        ;
+      }
+      break;
+    case DECIMAL:
+      jj_consume_token(DECIMAL);
+                            type = DataFieldMetadata.DECIMAL_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        switch (jj_nt.kind) {
+        case COMA:
+          jj_consume_token(COMA);
+          scale = integerLiteral();
+          break;
+        default:
+          jj_la1[17] = jj_gen;
+          ;
+        }
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                                                lenght = temp;
+        break;
+      default:
+        jj_la1[18] = jj_gen;
+        ;
+      }
+      break;
+    case FLOAT:
+      jj_consume_token(FLOAT);
+                          type = DataFieldMetadata.NUMERIC_FIELD;               lenght = floatLenght;
+      break;
+    case INT:
+      jj_consume_token(INT);
+                        type = DataFieldMetadata.INTEGER_FIELD;                 lenght = integerLenght;
+      break;
+    case INTEGER:
+      jj_consume_token(INTEGER);
+                            type = DataFieldMetadata.INTEGER_FIELD;     lenght = integerLenght;
+      break;
+    case SMALLINT:
+      jj_consume_token(SMALLINT);
+                             type = DataFieldMetadata.INTEGER_FIELD;    lenght = integerLenght;
+      break;
+    case TIMESTAMP:
+      jj_consume_token(TIMESTAMP);
+                              type = DataFieldMetadata.DATE_FIELD;              lenght = dateTimeLenght;
+      break;
+    case NUMERIC:
+      jj_consume_token(NUMERIC);
+                            type = DataFieldMetadata.DECIMAL_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        switch (jj_nt.kind) {
+        case COMA:
+          jj_consume_token(COMA);
+          scale = integerLiteral();
+          break;
+        default:
+          jj_la1[19] = jj_gen;
+          ;
+        }
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                                                lenght = temp;
+        break;
+      default:
+        jj_la1[20] = jj_gen;
+        ;
+      }
+      break;
+    case VARCHAR:
+      jj_consume_token(VARCHAR);
+                            type = DataFieldMetadata.STRING_FIELD;
+      jj_consume_token(OPENPAREN);
+      temp = integerLiteral();
+      jj_consume_token(CLOSEPAREN);
+                                                                                                                           lenght = temp;
+      break;
+    case VARCHAR2:
+      jj_consume_token(VARCHAR2);
+                             type = DataFieldMetadata.STRING_FIELD;
+      jj_consume_token(OPENPAREN);
+      temp = integerLiteral();
+      jj_consume_token(CLOSEPAREN);
+                                                                                                                           lenght = temp;
+      break;
+    default:
+      jj_la1[21] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+          {if (true) return new DataType(type, lenght, scale);}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public Object defaultValue() throws ParseException {
+        Object ret;
+    switch (jj_nt.kind) {
+    case STRING_LITERAL:
+    case INTEGER_LITERAL:
+    case FLOAT_LITERAL:
+      ret = literal();
+      break;
+    case NULL:
+      ret = nullLiteral();
+      break;
+    default:
+      jj_la1[22] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+          {if (true) return ret;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public BigDecimal floatLiteral() throws ParseException {
+    jj_consume_token(FLOAT_LITERAL);
+                          {if (true) return new BigDecimal(token.image);}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public String identifier() throws ParseException {
+    jj_consume_token(IDENTIFIER);
+          {if (true) return token.image;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public void identifierList() throws ParseException {
+    identifier();
+    label_2:
+    while (true) {
+      switch (jj_nt.kind) {
+      case COMA:
+        ;
+        break;
+      default:
+        jj_la1[23] = jj_gen;
+        break label_2;
+      }
+      jj_consume_token(COMA);
+      identifier();
+    }
+  }
+
+//+
+  final public Object literal() throws ParseException {
+        Object ret;
+    switch (jj_nt.kind) {
+    case INTEGER_LITERAL:
+      ret = integerLiteral();
+      break;
+    case FLOAT_LITERAL:
+      ret = floatLiteral();
+      break;
+    case STRING_LITERAL:
+      ret = stringLiteral();
+      break;
+    default:
+      jj_la1[24] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+          {if (true) return ret;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public Long integerLiteral() throws ParseException {
+    jj_consume_token(INTEGER_LITERAL);
+                            {if (true) return new Long(token.image);}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public Object nullLiteral() throws ParseException {
+    jj_consume_token(NULL);
+                 {if (true) return null;}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public String stringLiteral() throws ParseException {
+    jj_consume_token(STRING_LITERAL);
+                String value = token.image.intern();
+                {if (true) return value.substring(1, value.length() - 1);}
+    throw new Error(&quot;Missing return statement in function&quot;);
+  }
+
+//+
+  final public void tableName() throws ParseException {
+    jj_consume_token(IDENTIFIER);
+  }
+
+  final private boolean jj_2_1(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_1(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(0, xla); }
+  }
+
+  final private boolean jj_2_2(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_2(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(1, xla); }
+  }
+
+  final private boolean jj_3R_3() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    return false;
+  }
+
+  final private boolean jj_3_2() {
+    if (jj_3R_3()) return true;
+    if (jj_scan_token(DOT)) return true;
+    return false;
+  }
+
+  final private boolean jj_3_1() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    if (jj_scan_token(DOT)) return true;
+    return false;
+  }
+
+  public DML2CloverTokenManager token_source;
+  SimpleCharStream jj_input_stream;
+  public Token token, jj_nt;
+  private Token jj_scanpos, jj_lastpos;
+  private int jj_la;
+  public boolean lookingAhead = false;
+  private boolean jj_semLA;
+  private int jj_gen;
+  final private int[] jj_la1 = new int[25];
+  static private int[] jj_la1_0;
+  static private int[] jj_la1_1;
+  static {
+      jj_la1_0();
+      jj_la1_1();
+   }
+   private static void jj_la1_0() {
+      jj_la1_0 = new int[] {0x44000000,0x1000000,0x1000000,0x0,0x0,0x44000000,0x44000000,0x1,0x80000000,0x800000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1a79f000,0x0,0x0,0x0,};
+   }
+   private static void jj_la1_1() {
+      jj_la1_1 = new int[] {0x800,0x10,0x10,0x8,0x800000,0x0,0x0,0x0,0x1060,0x0,0x1060,0x2000000,0x2000000,0x2000000,0x2000000,0x800000,0x2000000,0x800000,0x2000000,0x800000,0x2000000,0x6504,0x38001,0x800000,0x38000,};
+   }
+  final private JJCalls[] jj_2_rtns = new JJCalls[2];
+  private boolean jj_rescan = false;
+  private int jj_gc = 0;
+
+  public DML2Clover(java.io.InputStream stream) {
+     this(stream, null);
+  }
+  public DML2Clover(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source = new DML2CloverTokenManager(jj_input_stream);
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public void ReInit(java.io.InputStream stream) {
+     ReInit(stream, null);
+  }
+  public void ReInit(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public DML2Clover(java.io.Reader stream) {
+    jj_input_stream = new SimpleCharStream(stream, 1, 1);
+    token_source = new DML2CloverTokenManager(jj_input_stream);
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public void ReInit(java.io.Reader stream) {
+    jj_input_stream.ReInit(stream, 1, 1);
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public DML2Clover(DML2CloverTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public void ReInit(DML2CloverTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i &lt; 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  final private Token jj_consume_token(int kind) throws ParseException {
+    Token oldToken = token;
+    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
+    else jj_nt = jj_nt.next = token_source.getNextToken();
+    if (token.kind == kind) {
+      jj_gen++;
+      if (++jj_gc &gt; 100) {
+        jj_gc = 0;
+        for (int i = 0; i &lt; jj_2_rtns.length; i++) {
+          JJCalls c = jj_2_rtns[i];
+          while (c != null) {
+            if (c.gen &lt; jj_gen) c.first = null;
+            c = c.next;
+          }
+        }
+      }
+      return token;
+    }
+    jj_nt = token;
+    token = oldToken;
+    jj_kind = kind;
+    throw generateParseException();
+  }
+
+  static private final class LookaheadSuccess extends java.lang.Error { }
+  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
+  final private boolean jj_scan_token(int kind) {
+    if (jj_scanpos == jj_lastpos) {
+      jj_la--;
+      if (jj_scanpos.next == null) {
+        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
+      } else {
+        jj_lastpos = jj_scanpos = jj_scanpos.next;
+      }
+    } else {
+      jj_scanpos = jj_scanpos.next;
+    }
+    if (jj_rescan) {
+      int i = 0; Token tok = token;
+      while (tok != null &amp;&amp; tok != jj_scanpos) { i++; tok = tok.next; }
+      if (tok != null) jj_add_error_token(kind, i);
+    }
+    if (jj_scanpos.kind != kind) return true;
+    if (jj_la == 0 &amp;&amp; jj_scanpos == jj_lastpos) throw jj_ls;
+    return false;
+  }
+
+  final public Token getNextToken() {
+    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
+    else jj_nt = jj_nt.next = token_source.getNextToken();
+    jj_gen++;
+    return token;
+  }
+
+  final public Token getToken(int index) {
+    Token t = lookingAhead ? jj_scanpos : token;
+    for (int i = 0; i &lt; index; i++) {
+      if (t.next != null) t = t.next;
+      else t = t.next = token_source.getNextToken();
+    }
+    return t;
+  }
+
+  private java.util.Vector&lt;int[]&gt; jj_expentries = new java.util.Vector&lt;int[]&gt;();
+  private int[] jj_expentry;
+  private int jj_kind = -1;
+  private int[] jj_lasttokens = new int[100];
+  private int jj_endpos;
+
+  private void jj_add_error_token(int kind, int pos) {
+    if (pos &gt;= 100) return;
+    if (pos == jj_endpos + 1) {
+      jj_lasttokens[jj_endpos++] = kind;
+    } else if (jj_endpos != 0) {
+      jj_expentry = new int[jj_endpos];
+      for (int i = 0; i &lt; jj_endpos; i++) {
+        jj_expentry[i] = jj_lasttokens[i];
+      }
+      boolean exists = false;
+      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
+        int[] oldentry = (int[])(e.nextElement());
+        if (oldentry.length == jj_expentry.length) {
+          exists = true;
+          for (int i = 0; i &lt; jj_expentry.length; i++) {
+            if (oldentry[i] != jj_expentry[i]) {
+              exists = false;
+              break;
+            }
+          }
+          if (exists) break;
+        }
+      }
+      if (!exists) jj_expentries.addElement(jj_expentry);
+      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
+    }
+  }
+
+  public ParseException generateParseException() {
+    jj_expentries.removeAllElements();
+    boolean[] la1tokens = new boolean[59];
+    for (int i = 0; i &lt; 59; i++) {
+      la1tokens[i] = false;
+    }
+    if (jj_kind &gt;= 0) {
+      la1tokens[jj_kind] = true;
+      jj_kind = -1;
+    }
+    for (int i = 0; i &lt; 25; i++) {
+      if (jj_la1[i] == jj_gen) {
+        for (int j = 0; j &lt; 32; j++) {
+          if ((jj_la1_0[i] &amp; (1&lt;&lt;j)) != 0) {
+            la1tokens[j] = true;
+          }
+          if ((jj_la1_1[i] &amp; (1&lt;&lt;j)) != 0) {
+            la1tokens[32+j] = true;
+          }
+        }
+      }
+    }
+    for (int i = 0; i &lt; 59; i++) {
+      if (la1tokens[i]) {
+        jj_expentry = new int[1];
+        jj_expentry[0] = i;
+        jj_expentries.addElement(jj_expentry);
+      }
+    }
+    jj_endpos = 0;
+    jj_rescan_token();
+    jj_add_error_token(0, 0);
+    int[][] exptokseq = new int[jj_expentries.size()][];
+    for (int i = 0; i &lt; jj_expentries.size(); i++) {
+      exptokseq[i] = (int[])jj_expentries.elementAt(i);
+    }
+    return new ParseException(token, exptokseq, tokenImage);
+  }
+
+  final public void enable_tracing() {
+  }
+
+  final public void disable_tracing() {
+  }
+
+  final private void jj_rescan_token() {
+    jj_rescan = true;
+    for (int i = 0; i &lt; 2; i++) {
+    try {
+      JJCalls p = jj_2_rtns[i];
+      do {
+        if (p.gen &gt; jj_gen) {
+          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
+          switch (i) {
+            case 0: jj_3_1(); break;
+            case 1: jj_3_2(); break;
+          }
+        }
+        p = p.next;
+      } while (p != null);
+      } catch(LookaheadSuccess ls) { }
+    }
+    jj_rescan = false;
+  }
+
+  final private void jj_save(int index, int xla) {
+    JJCalls p = jj_2_rtns[index];
+    while (p.gen &gt; jj_gen) {
+      if (p.next == null) { p = p.next = new JJCalls(); break; }
+      p = p.next;
+    }
+    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
+  }
+
+  static final class JJCalls {
+    int gen;
+    Token first;
+    int arg;
+    JJCalls next;
+  }
+
+}

Added: trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverConstants.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverConstants.java	2007-02-20 13:36:20 UTC (rev 2492)
+++ trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverConstants.java	2007-02-20 13:57:34 UTC (rev 2493)
@@ -0,0 +1,121 @@
+/* Generated By:JavaCC: Do not edit this line. DML2CloverConstants.java */
+package org.jetel.util.dml2clover;
+
+public interface DML2CloverConstants {
+
+  int EOF = 0;
+  int BOOLEAN = 12;
+  int BLOB = 13;
+  int CHAR = 14;
+  int CHARACTER = 15;
+  int CLOB = 16;
+  int COMMIT = 17;
+  int CREATE = 18;
+  int DATE = 19;
+  int DATETIME = 20;
+  int DEC = 21;
+  int DECIMAL = 22;
+  int DEFAULT_ = 23;
+  int DELETE = 24;
+  int FLOAT = 25;
+  int GLOBAL = 26;
+  int INT = 27;
+  int INTEGER = 28;
+  int KEY = 29;
+  int LOCAL = 30;
+  int NOT = 31;
+  int NULL = 32;
+  int NUMBER = 33;
+  int NUMERIC = 34;
+  int ON = 35;
+  int PRESERVE = 36;
+  int PRIMARY = 37;
+  int REFERENCES = 38;
+  int ROWS = 39;
+  int SMALLINT = 40;
+  int TABLE = 41;
+  int TIMESTAMP = 42;
+  int TEMPORARY = 43;
+  int UNIQUE = 44;
+  int VARCHAR = 45;
+  int VARCHAR2 = 46;
+  int STRING_LITERAL = 47;
+  int INTEGER_LITERAL = 48;
+  int FLOAT_LITERAL = 49;
+  int EXP = 50;
+  int IDENTIFIER = 51;
+  int LETTER = 52;
+  int DIGIT = 53;
+  int CLOSEPAREN = 54;
+  int COMA = 55;
+  int DOT = 56;
+  int OPENPAREN = 57;
+  int SEMICOLON = 58;
+
+  int DEFAULT = 0;
+  int WithinComment = 1;
+  int WithinLineComment = 2;
+
+  String[] tokenImage = {
+    &quot;&lt;EOF&gt;&quot;,
+    &quot;\&quot; \&quot;&quot;,
+    &quot;\&quot;\\t\&quot;&quot;,
+    &quot;\&quot;\\n\&quot;&quot;,
+    &quot;\&quot;\\r\&quot;&quot;,
+    &quot;\&quot;\\n\\r\&quot;&quot;,
+    &quot;\&quot;/*\&quot;&quot;,
+    &quot;\&quot;*/\&quot;&quot;,
+    &quot;&lt;token of kind 8&gt;&quot;,
+    &quot;\&quot;//\&quot;&quot;,
+    &quot;\&quot;\\n\&quot;&quot;,
+    &quot;&lt;token of kind 11&gt;&quot;,
+    &quot;\&quot;boolean\&quot;&quot;,
+    &quot;\&quot;blob\&quot;&quot;,
+    &quot;\&quot;char\&quot;&quot;,
+    &quot;\&quot;character\&quot;&quot;,
+    &quot;\&quot;clob\&quot;&quot;,
+    &quot;\&quot;commit\&quot;&quot;,
+    &quot;\&quot;create\&quot;&quot;,
+    &quot;\&quot;date\&quot;&quot;,
+    &quot;\&quot;datetime\&quot;&quot;,
+    &quot;\&quot;dec\&quot;&quot;,
+    &quot;\&quot;decimal\&quot;&quot;,
+    &quot;\&quot;default\&quot;&quot;,
+    &quot;\&quot;delete\&quot;&quot;,
+    &quot;\&quot;float\&quot;&quot;,
+    &quot;\&quot;global\&quot;&quot;,
+    &quot;\&quot;int\&quot;&quot;,
+    &quot;\&quot;integer\&quot;&quot;,
+    &quot;\&quot;key\&quot;&quot;,
+    &quot;\&quot;local\&quot;&quot;,
+    &quot;\&quot;not\&quot;&quot;,
+    &quot;\&quot;null\&quot;&quot;,
+    &quot;\&quot;number\&quot;&quot;,
+    &quot;\&quot;numeric\&quot;&quot;,
+    &quot;\&quot;on\&quot;&quot;,
+    &quot;\&quot;preserve\&quot;&quot;,
+    &quot;\&quot;primary\&quot;&quot;,
+    &quot;\&quot;references\&quot;&quot;,
+    &quot;\&quot;rows\&quot;&quot;,
+    &quot;\&quot;smallint\&quot;&quot;,
+    &quot;\&quot;table\&quot;&quot;,
+    &quot;\&quot;timestamp\&quot;&quot;,
+    &quot;\&quot;TEMPORARY\&quot;&quot;,
+    &quot;\&quot;unique\&quot;&quot;,
+    &quot;\&quot;varchar\&quot;&quot;,
+    &quot;\&quot;varchar2\&quot;&quot;,
+    &quot;&lt;STRING_LITERAL&gt;&quot;,
+    &quot;&lt;INTEGER_LITERAL&gt;&quot;,
+    &quot;&lt;FLOAT_LITERAL&gt;&quot;,
+    &quot;&lt;EXP&gt;&quot;,
+    &quot;&lt;IDENTIFIER&gt;&quot;,
+    &quot;&lt;LETTER&gt;&quot;,
+    &quot;&lt;DIGIT&gt;&quot;,
+    &quot;\&quot;)\&quot;&quot;,
+    &quot;\&quot;,\&quot;&quot;,
+    &quot;\&quot;.\&quot;&quot;,
+    &quot;\&quot;(\&quot;&quot;,
+    &quot;\&quot;;\&quot;&quot;,
+  };
+
+}

Added: trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverTokenManager.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverTokenManager.java	2007-02-20 13:36:20 UTC (rev 2492)
+++ trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverTokenManager.java	2007-02-20 13:57:34 UTC (rev 2493)
@@ -0,0 +1,1197 @@
+/* Generated By:JavaCC: Do not edit this line. DML2CloverTokenManager.java */
+package org.jetel.util.dml2clover;
+import java.util.*;
+import java.io.*;
+import org.jetel.metadata.*;
+import java.math.*;
+
+public class DML2CloverTokenManager implements DML2CloverConstants
+{
+  public  java.io.PrintStream debugStream = System.out;
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_0(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 &amp; 0x7ffffffff000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            return 25;
+         }
+         if ((active0 &amp; 0x100000000000000L) != 0L)
+            return 7;
+         return -1;
+      case 1:
+         if ((active0 &amp; 0x7ff7fffff000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 1;
+            return 25;
+         }
+         if ((active0 &amp; 0x800000000L) != 0L)
+            return 25;
+         return -1;
+      case 2:
+         if ((active0 &amp; 0x7ff7479ff000L) != 0L)
+         {
+            if (jjmatchedPos != 2)
+            {
+               jjmatchedKind = 51;
+               jjmatchedPos = 2;
+            }
+            return 25;
+         }
+         if ((active0 &amp; 0xb8600000L) != 0L)
+            return 25;
+         return -1;
+      case 3:
+         if ((active0 &amp; 0x7f7657c61000L) != 0L)
+         {
+            if (jjmatchedPos != 3)
+            {
+               jjmatchedKind = 51;
+               jjmatchedPos = 3;
+            }
+            return 25;
+         }
+         if ((active0 &amp; 0x810019e000L) != 0L)
+            return 25;
+         return -1;
+      case 4:
+         if ((active0 &amp; 0x20042000000L) != 0L)
+            return 25;
+         if ((active0 &amp; 0x7d7615d69000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 4;
+            return 25;
+         }
+         return -1;
+      case 5:
+         if ((active0 &amp; 0x6d7410d09000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 5;
+            return 25;
+         }
+         if ((active0 &amp; 0x100205060000L) != 0L)
+            return 25;
+         return -1;
+      case 6:
+         if ((active0 &amp; 0xd5000108000L) != 0L)
+         {
+            if (jjmatchedPos != 6)
+            {
+               jjmatchedKind = 51;
+               jjmatchedPos = 6;
+            }
+            return 25;
+         }
+         if ((active0 &amp; 0x602410c01000L) != 0L)
+            return 25;
+         return -1;
+      case 7:
+         if ((active0 &amp; 0x400000000000L) != 0L)
+            return 24;
+         if ((active0 &amp; 0x11000100000L) != 0L)
+            return 25;
+         if ((active0 &amp; 0xc4000008000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 7;
+            return 25;
+         }
+         return -1;
+      case 8:
+         if ((active0 &amp; 0x4000000000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 8;
+            return 25;
+         }
+         if ((active0 &amp; 0xc0000008000L) != 0L)
+            return 25;
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_0(int pos, long active0)
+{
+   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
+}
+private final int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private final int jjStartNfaWithStates_0(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_0(state, pos + 1);
+}
+private final int jjMoveStringLiteralDfa0_0()
+{
+   switch(curChar)
+   {
+      case 10:
+         jjmatchedKind = 3;
+         return jjMoveStringLiteralDfa1_0(0x20L);
+      case 40:
+         return jjStopAtPos(0, 57);
+      case 41:
+         return jjStopAtPos(0, 54);
+      case 44:
+         return jjStopAtPos(0, 55);
+      case 46:
+         return jjStartNfaWithStates_0(0, 56, 7);
+      case 47:
+         return jjMoveStringLiteralDfa1_0(0x240L);
+      case 59:
+         return jjStopAtPos(0, 58);
+      case 66:
+      case 98:
+         return jjMoveStringLiteralDfa1_0(0x3000L);
+      case 67:
+      case 99:
+         return jjMoveStringLiteralDfa1_0(0x7c000L);
+      case 68:
+      case 100:
+         return jjMoveStringLiteralDfa1_0(0x1f80000L);
+      case 70:
+      case 102:
+         return jjMoveStringLiteralDfa1_0(0x2000000L);
+      case 71:
+      case 103:
+         return jjMoveStringLiteralDfa1_0(0x4000000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa1_0(0x18000000L);
+      case 75:
+      case 107:
+         return jjMoveStringLiteralDfa1_0(0x20000000L);
+      case 76:
+      case 108:
+         return jjMoveStringLiteralDfa1_0(0x40000000L);
+      case 78:
+      case 110:
+         return jjMoveStringLiteralDfa1_0(0x780000000L);
+      case 79:
+      case 111:
+         return jjMoveStringLiteralDfa1_0(0x800000000L);
+      case 80:
+      case 112:
+         return jjMoveStringLiteralDfa1_0(0x3000000000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa1_0(0xc000000000L);
+      case 83:
+      case 115:
+         return jjMoveStringLiteralDfa1_0(0x10000000000L);
+      case 84:
+      case 116:
+         return jjMoveStringLiteralDfa1_0(0xe0000000000L);
+      case 85:
+      case 117:
+         return jjMoveStringLiteralDfa1_0(0x100000000000L);
+      case 86:
+      case 118:
+         return jjMoveStringLiteralDfa1_0(0x600000000000L);
+      default :
+         return jjMoveNfa_0(0, 0);
+   }
+}
+private final int jjMoveStringLiteralDfa1_0(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 13:
+         if ((active0 &amp; 0x20L) != 0L)
+            return jjStopAtPos(1, 5);
+         break;
+      case 42:
+         if ((active0 &amp; 0x40L) != 0L)
+            return jjStopAtPos(1, 6);
+         break;
+      case 47:
+         if ((active0 &amp; 0x200L) != 0L)
+            return jjStopAtPos(1, 9);
+         break;
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa2_0(active0, 0x620000180000L);
+      case 69:
+      case 101:
+         return jjMoveStringLiteralDfa2_0(active0, 0x84021e00000L);
+      case 72:
+      case 104:
+         return jjMoveStringLiteralDfa2_0(active0, 0xc000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa2_0(active0, 0x40000000000L);
+      case 76:
+      case 108:
+         return jjMoveStringLiteralDfa2_0(active0, 0x6012000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa2_0(active0, 0x10000000000L);
+      case 78:
+      case 110:
+         if ((active0 &amp; 0x800000000L) != 0L)
+            return jjStartNfaWithStates_0(1, 35, 25);
+         return jjMoveStringLiteralDfa2_0(active0, 0x100018000000L);
+      case 79:
+      case 111:
+         return jjMoveStringLiteralDfa2_0(active0, 0x80c0021000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa2_0(active0, 0x3000040000L);
+      case 85:
+      case 117:
+         return jjMoveStringLiteralDfa2_0(active0, 0x700000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(0, active0);
+}
+private final int jjMoveStringLiteralDfa2_0(long old0, long active0)
+{
+   if (((active0 &amp;= old0)) == 0L)
+      return jjStartNfa_0(0, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(1, active0);
+      return 2;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa3_0(active0, 0x1000000c000L);
+      case 66:
+      case 98:
+         return jjMoveStringLiteralDfa3_0(active0, 0x20000000000L);
+      case 67:
+      case 99:
+         if ((active0 &amp; 0x200000L) != 0L)
+         {
+            jjmatchedKind = 21;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x40400000L);
+      case 69:
+      case 101:
+         return jjMoveStringLiteralDfa3_0(active0, 0x1000040000L);
+      case 70:
+      case 102:
+         return jjMoveStringLiteralDfa3_0(active0, 0x4000800000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa3_0(active0, 0x102000000000L);
+      case 76:
+      case 108:
+         return jjMoveStringLiteralDfa3_0(active0, 0x101000000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa3_0(active0, 0xc0600020000L);
+      case 79:
+      case 111:
+         return jjMoveStringLiteralDfa3_0(active0, 0x6013000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa3_0(active0, 0x600000000000L);
+      case 84:
+      case 116:
+         if ((active0 &amp; 0x8000000L) != 0L)
+         {
+            jjmatchedKind = 27;
+            jjmatchedPos = 2;
+         }
+         else if ((active0 &amp; 0x80000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 31, 25);
+         return jjMoveStringLiteralDfa3_0(active0, 0x10180000L);
+      case 87:
+      case 119:
+         return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L);
+      case 89:
+      case 121:
+         if ((active0 &amp; 0x20000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 29, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(1, active0);
+}
+private final int jjMoveStringLiteralDfa3_0(long old0, long active0)
+{
+   if (((active0 &amp;= old0)) == 0L)
+      return jjStartNfa_0(1, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(2, active0);
+      return 3;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa4_0(active0, 0x42840000L);
+      case 66:
+      case 98:
+         if ((active0 &amp; 0x2000L) != 0L)
+            return jjStartNfaWithStates_0(3, 13, 25);
+         else if ((active0 &amp; 0x10000L) != 0L)
+            return jjStartNfaWithStates_0(3, 16, 25);
+         return jjMoveStringLiteralDfa4_0(active0, 0x204000000L);
+      case 67:
+      case 99:
+         return jjMoveStringLiteralDfa4_0(active0, 0x600000000000L);
+      case 69:
+      case 101:
+         if ((active0 &amp; 0x80000L) != 0L)
+         {
+            jjmatchedKind = 19;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x44411100000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa4_0(active0, 0x400000L);
+      case 76:
+      case 108:
+         if ((active0 &amp; 0x100000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 32, 25);
+         return jjMoveStringLiteralDfa4_0(active0, 0x30000001000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa4_0(active0, 0x2000020000L);
+      case 80:
+      case 112:
+         return jjMoveStringLiteralDfa4_0(active0, 0x80000000000L);
+      case 81:
+      case 113:
+         return jjMoveStringLiteralDfa4_0(active0, 0x100000000000L);
+      case 82:
+      case 114:
+         if ((active0 &amp; 0x4000L) != 0L)
+         {
+            jjmatchedKind = 14;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x8000L);
+      case 83:
+      case 115:
+         if ((active0 &amp; 0x8000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 39, 25);
+         return jjMoveStringLiteralDfa4_0(active0, 0x1000000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(2, active0);
+}
+private final int jjMoveStringLiteralDfa4_0(long old0, long active0)
+{
+   if (((active0 &amp;= old0)) == 0L)
+      return jjStartNfa_0(2, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(3, active0);
+      return 4;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa5_0(active0, 0x2004008000L);
+      case 69:
+      case 101:
+         if ((active0 &amp; 0x20000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 41, 25);
+         return jjMoveStringLiteralDfa5_0(active0, 0x1200001000L);
+      case 71:
+      case 103:
+         return jjMoveStringLiteralDfa5_0(active0, 0x10000000L);
+      case 72:
+      case 104:
+         return jjMoveStringLiteralDfa5_0(active0, 0x600000000000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa5_0(active0, 0x20000L);
+      case 76:
+      case 108:
+         if ((active0 &amp; 0x40000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 30, 25);
+         return jjMoveStringLiteralDfa5_0(active0, 0x10000000000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa5_0(active0, 0x400000L);
+      case 79:
+      case 111:
+         return jjMoveStringLiteralDfa5_0(active0, 0x80000000000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa5_0(active0, 0x4400000000L);
+      case 83:
+      case 115:
+         return jjMoveStringLiteralDfa5_0(active0, 0x40000000000L);
+      case 84:
+      case 116:
+         if ((active0 &amp; 0x2000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 25, 25);
+         return jjMoveStringLiteralDfa5_0(active0, 0x1140000L);
+      case 85:
+      case 117:
+         return jjMoveStringLiteralDfa5_0(active0, 0x100000800000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(3, active0);
+}
+private final int jjMoveStringLiteralDfa5_0(long old0, long active0)
+{
+   if (((active0 &amp;= old0)) == 0L)
+      return jjStartNfa_0(3, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(4, active0);
+      return 5;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa6_0(active0, 0x600000401000L);
+      case 67:
+      case 99:
+         return jjMoveStringLiteralDfa6_0(active0, 0x8000L);
+      case 69:
+      case 101:
+         if ((active0 &amp; 0x40000L) != 0L)
+            return jjStartNfaWithStates_0(5, 18, 25);
+         else if ((active0 &amp; 0x1000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 24, 25);
+         else if ((active0 &amp; 0x100000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 44, 25);
+         return jjMoveStringLiteralDfa6_0(active0, 0x4010000000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa6_0(active0, 0x10400100000L);
+      case 76:
+      case 108:
+         if ((active0 &amp; 0x4000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 26, 25);
+         return jjMoveStringLiteralDfa6_0(active0, 0x800000L);
+      case 82:
+      case 114:
+         if ((active0 &amp; 0x200000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 33, 25);
+         return jjMoveStringLiteralDfa6_0(active0, 0x83000000000L);
+      case 84:
+      case 116:
+         if ((active0 &amp; 0x20000L) != 0L)
+            return jjStartNfaWithStates_0(5, 17, 25);
+         return jjMoveStringLiteralDfa6_0(active0, 0x40000000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(4, active0);
+}
+private final int jjMoveStringLiteralDfa6_0(long old0, long active0)
+{
+   if (((active0 &amp;= old0)) == 0L)
+      return jjStartNfa_0(4, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(5, active0);
+      return 6;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa7_0(active0, 0xc0000000000L);
+      case 67:
+      case 99:
+         if ((active0 &amp; 0x400000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 34, 25);
+         break;
+      case 76:
+      case 108:
+         if ((active0 &amp; 0x400000L) != 0L)
+            return jjStartNfaWithStates_0(6, 22, 25);
+         break;
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa7_0(active0, 0x100000L);
+      case 78:
+      case 110:
+         if ((active0 &amp; 0x1000L) != 0L)
+            return jjStartNfaWithStates_0(6, 12, 25);
+         return jjMoveStringLiteralDfa7_0(active0, 0x14000000000L);
+      case 82:
+      case 114:
+         if ((active0 &amp; 0x10000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 28, 25);
+         else if ((active0 &amp; 0x200000000000L) != 0L)
+         {
+            jjmatchedKind = 45;
+            jjmatchedPos = 6;
+         }
+         return jjMoveStringLiteralDfa7_0(active0, 0x400000000000L);
+      case 84:
+      case 116:
+         if ((active0 &amp; 0x800000L) != 0L)
+            return jjStartNfaWithStates_0(6, 23, 25);
+         return jjMoveStringLiteralDfa7_0(active0, 0x8000L);
+      case 86:
+      case 118:
+         return jjMoveStringLiteralDfa7_0(active0, 0x1000000000L);
+      case 89:
+      case 121:
+         if ((active0 &amp; 0x2000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 37, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(5, active0);
+}
+private final int jjMoveStringLiteralDfa7_0(long old0, long active0)
+{
+   if (((active0 &amp;= old0)) == 0L)
+      return jjStartNfa_0(5, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(6, active0);
+      return 7;
+   }
+   switch(curChar)
+   {
+      case 50:
+         if ((active0 &amp; 0x400000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 46, 24);
+         break;
+      case 67:
+      case 99:
+         return jjMoveStringLiteralDfa8_0(active0, 0x4000000000L);
+      case 69:
+      case 101:
+         if ((active0 &amp; 0x100000L) != 0L)
+            return jjStartNfaWithStates_0(7, 20, 25);
+         else if ((active0 &amp; 0x1000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 36, 25);
+         return jjMoveStringLiteralDfa8_0(active0, 0x8000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa8_0(active0, 0x40000000000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa8_0(active0, 0x80000000000L);
+      case 84:
+      case 116:
+         if ((active0 &amp; 0x10000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 40, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(6, active0);
+}
+private final int jjMoveStringLiteralDfa8_0(long old0, long active0)
+{
+   if (((active0 &amp;= old0)) == 0L)
+      return jjStartNfa_0(6, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(7, active0);
+      return 8;
+   }
+   switch(curChar)
+   {
+      case 69:
+      case 101:
+         return jjMoveStringLiteralDfa9_0(active0, 0x4000000000L);
+      case 80:
+      case 112:
+         if ((active0 &amp; 0x40000000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 42, 25);
+         break;
+      case 82:
+      case 114:
+         if ((active0 &amp; 0x8000L) != 0L)
+            return jjStartNfaWithStates_0(8, 15, 25);
+         break;
+      case 89:
+      case 121:
+         if ((active0 &amp; 0x80000000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 43, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(7, active0);
+}
+private final int jjMoveStringLiteralDfa9_0(long old0, long active0)
+{
+   if (((active0 &amp;= old0)) == 0L)
+      return jjStartNfa_0(7, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(8, active0);
+      return 9;
+   }
+   switch(curChar)
+   {
+      case 83:
+      case 115:
+         if ((active0 &amp; 0x4000000000L) != 0L)
+            return jjStartNfaWithStates_0(9, 38, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(8, active0);
+}
+private final void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private final void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private final void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+private final void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+private final void jjCheckNAddStates(int start)
+{
+   jjCheckNAdd(jjnextStates[start]);
+   jjCheckNAdd(jjnextStates[start + 1]);
+}
+static final long[] jjbitVec0 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+private final int jjMoveNfa_0(int startState, int curPos)
+{
+   int[] nextStates;
+   int startsAt = 0;
+   jjnewStateCnt = 25;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int j, kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar &lt; 64)
+      {
+         long l = 1L &lt;&lt; curChar;
+         MatchLoop: do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x3ff000000000000L &amp; l) != 0L)
+                  {
+                     if (kind &gt; 48)
+                        kind = 48;
+                     jjCheckNAddStates(0, 4);
+                  }
+                  else if (curChar == 46)
+                     jjCheckNAdd(7);
+                  else if (curChar == 39)
+                     jjCheckNAddStates(5, 7);
+                  break;
+               case 25:
+               case 24:
+                  if ((0x3ff001800000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 51)
+                     kind = 51;
+                  jjCheckNAdd(24);
+                  break;
+               case 1:
+                  if ((0xffffff7fffffffffL &amp; l) != 0L)
+                     jjCheckNAddStates(5, 7);
+                  break;
+               case 2:
+                  if (curChar == 39)
+                     jjCheckNAddStates(8, 10);
+                  break;
+               case 3:
+                  if (curChar == 39)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  break;
+               case 4:
+                  if ((0xffffff7fffffffffL &amp; l) != 0L)
+                     jjCheckNAddStates(8, 10);
+                  break;
+               case 5:
+                  if (curChar == 39 &amp;&amp; kind &gt; 47)
+                     kind = 47;
+                  break;
+               case 6:
+                  if (curChar == 46)
+                     jjCheckNAdd(7);
+                  break;
+               case 7:
+                  if ((0x3ff000000000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 49)
+                     kind = 49;
+                  jjCheckNAddTwoStates(7, 8);
+                  break;
+               case 9:
+                  if ((0x280000000000L &amp; l) != 0L)
+                     jjCheckNAdd(10);
+                  break;
+               case 10:
+                  if ((0x3ff000000000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 49)
+                     kind = 49;
+                  jjCheckNAdd(10);
+                  break;
+               case 11:
+                  if ((0x3ff000000000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 48)
+                     kind = 48;
+                  jjCheckNAddStates(0, 4);
+                  break;
+               case 12:
+                  if ((0x3ff000000000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 48)
+                     kind = 48;
+                  jjCheckNAdd(12);
+                  break;
+               case 13:
+                  if ((0x3ff000000000000L &amp; l) != 0L)
+                     jjCheckNAddTwoStates(13, 14);
+                  break;
+               case 14:
+                  if (curChar == 46)
+                     jjCheckNAdd(15);
+                  break;
+               case 15:
+                  if ((0x3ff000000000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 49)
+                     kind = 49;
+                  jjCheckNAddTwoStates(15, 16);
+                  break;
+               case 17:
+                  if ((0x280000000000L &amp; l) != 0L)
+                     jjCheckNAdd(18);
+                  break;
+               case 18:
+                  if ((0x3ff000000000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 49)
+                     kind = 49;
+                  jjCheckNAdd(18);
+                  break;
+               case 19:
+                  if ((0x3ff000000000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 49)
+                     kind = 49;
+                  jjCheckNAddTwoStates(19, 20);
+                  break;
+               case 21:
+                  if ((0x280000000000L &amp; l) != 0L)
+                     jjCheckNAdd(22);
+                  break;
+               case 22:
+                  if ((0x3ff000000000000L &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 49)
+                     kind = 49;
+                  jjCheckNAdd(22);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar &lt; 128)
+      {
+         long l = 1L &lt;&lt; (curChar &amp; 077);
+         MatchLoop: do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 23:
+                  if ((0x7fffffe07fffffeL &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 51)
+                     kind = 51;
+                  jjCheckNAddTwoStates(23, 24);
+                  break;
+               case 25:
+                  if ((0x7fffffe87fffffeL &amp; l) != 0L)
+                  {
+                     if (kind &gt; 51)
+                        kind = 51;
+                     jjCheckNAdd(24);
+                  }
+                  if ((0x7fffffe07fffffeL &amp; l) != 0L)
+                  {
+                     if (kind &gt; 51)
+                        kind = 51;
+                     jjCheckNAddTwoStates(23, 24);
+                  }
+                  break;
+               case 1:
+                  jjCheckNAddStates(5, 7);
+                  break;
+               case 4:
+                  jjCheckNAddStates(8, 10);
+                  break;
+               case 8:
+                  if ((0x2000000020L &amp; l) != 0L)
+                     jjAddStates(11, 12);
+                  break;
+               case 16:
+                  if ((0x2000000020L &amp; l) != 0L)
+                     jjAddStates(13, 14);
+                  break;
+               case 20:
+                  if ((0x2000000020L &amp; l) != 0L)
+                     jjAddStates(15, 16);
+                  break;
+               case 24:
+                  if ((0x7fffffe87fffffeL &amp; l) == 0L)
+                     break;
+                  if (kind &gt; 51)
+                     kind = 51;
+                  jjCheckNAdd(24);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int i2 = (curChar &amp; 0xff) &gt;&gt; 6;
+         long l2 = 1L &lt;&lt; (curChar &amp; 077);
+         MatchLoop: do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 1:
+                  if ((jjbitVec0[i2] &amp; l2) != 0L)
+                     jjCheckNAddStates(5, 7);
+                  break;
+               case 4:
+                  if ((jjbitVec0[i2] &amp; l2) != 0L)
+                     jjCheckNAddStates(8, 10);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 25 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private final int jjMoveStringLiteralDfa0_2()
+{
+   switch(curChar)
+   {
+      case 10:
+         return jjStopAtPos(0, 10);
+      default :
+         return 1;
+   }
+}
+private final int jjMoveStringLiteralDfa0_1()
+{
+   switch(curChar)
+   {
+      case 42:
+         return jjMoveStringLiteralDfa1_1(0x80L);
+      default :
+         return 1;
+   }
+}
+private final int jjMoveStringLiteralDfa1_1(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 47:
+         if ((active0 &amp; 0x80L) != 0L)
+            return jjStopAtPos(1, 7);
+         break;
+      default :
+         return 2;
+   }
+   return 2;
+}
+static final int[] jjnextStates = {
+   12, 13, 14, 19, 20, 1, 3, 5, 3, 4, 5, 9, 10, 17, 18, 21, 
+   22, 
+};
+public static final String[] jjstrLiteralImages = {
+&quot;&quot;, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, &quot;\51&quot;, 
+&quot;\54&quot;, &quot;\56&quot;, &quot;\50&quot;, &quot;\73&quot;, };
+public static final String[] lexStateNames = {
+   &quot;DEFAULT&quot;, 
+   &quot;WithinComment&quot;, 
+   &quot;WithinLineComment&quot;, 
+};
+public static final int[] jjnewLexState = {
+   -1, -1, -1, -1, -1, -1, 1, 0, -1, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+};
+static final long[] jjtoToken = {
+   0x7fbfffffffff001L, 
+};
+static final long[] jjtoSkip = {
+   0x6feL, 
+};
+static final long[] jjtoSpecial = {
+   0x6c0L, 
+};
+static final long[] jjtoMore = {
+   0x900L, 
+};
+protected SimpleCharStream input_stream;
+private final int[] jjrounds = new int[25];
+private final int[] jjstateSet = new int[50];
+StringBuffer image;
+int jjimageLen;
+int lengthOfMatch;
+protected char curChar;
+public DML2CloverTokenManager(SimpleCharStream stream){
+   if (SimpleCharStream.staticFlag)
+      throw new Error(&quot;ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.&quot;);
+   input_stream = stream;
+}
+public DML2CloverTokenManager(SimpleCharStream stream, int lexState){
+   this(stream);
+   SwitchTo(lexState);
+}
+public void ReInit(SimpleCharStream stream)
+{
+   jjmatchedPos = jjnewStateCnt = 0;
+   curLexState = defaultLexState;
+   input_stream = stream;
+   ReInitRounds();
+}
+private final void ReInitRounds()
+{
+   int i;
+   jjround = 0x80000001;
+   for (i = 25; i-- &gt; 0;)
+      jjrounds[i] = 0x80000000;
+}
+public void ReInit(SimpleCharStream stream, int lexState)
+{
+   ReInit(stream);
+   SwitchTo(lexState);
+}
+public void SwitchTo(int lexState)
+{
+   if (lexState &gt;= 3 || lexState &lt; 0)
+      throw new TokenMgrError(&quot;Error: Ignoring invalid lexical state : &quot; + lexState + &quot;. State unchanged.&quot;, TokenMgrError.INVALID_LEXICAL_STATE);
+   else
+      curLexState = lexState;
+}
+
+protected Token jjFillToken()
+{
+   Token t = Token.newToken(jjmatchedKind);
+   t.kind = jjmatchedKind;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   t.image = (im == null) ? input_stream.GetImage() : im;
+   t.beginLine = input_stream.getBeginLine();
+   t.beginColumn = input_stream.getBeginColumn();
+   t.endLine = input_stream.getEndLine();
+   t.endColumn = input_stream.getEndColumn();
+   return t;
+}
+
+int curLexState = 0;
+int defaultLexState = 0;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+public Token getNextToken() 
+{
+  int kind;
+  Token specialToken = null;
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {   
+   try   
+   {     
+      curChar = input_stream.BeginToken();
+   }     
+   catch(java.io.IOException e)
+   {        
+      jjmatchedKind = 0;
+      matchedToken = jjFillToken();
+      matchedToken.specialToken = specialToken;
+      return matchedToken;
+   }
+   image = null;
+   jjimageLen = 0;
+
+   for (;;)
+   {
+     switch(curLexState)
+     {
+       case 0:
+         try { input_stream.backup(0);
+            while (curChar &lt;= 32 &amp;&amp; (0x100002200L &amp; (1L &lt;&lt; curChar)) != 0L)
+               curChar = input_stream.BeginToken();
+         }
+         catch (java.io.IOException e1) { continue EOFLoop; }
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_0();
+         break;
+       case 1:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_1();
+         if (jjmatchedPos == 0 &amp;&amp; jjmatchedKind &gt; 8)
+         {
+            jjmatchedKind = 8;
+         }
+         break;
+       case 2:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_2();
+         if (jjmatchedPos == 0 &amp;&amp; jjmatchedKind &gt; 11)
+         {
+            jjmatchedKind = 11;
+         }
+         break;
+     }
+     if (jjmatchedKind != 0x7fffffff)
+     {
+        if (jjmatchedPos + 1 &lt; curPos)
+           input_stream.backup(curPos - jjmatchedPos - 1);
+        if ((jjtoToken[jjmatchedKind &gt;&gt; 6] &amp; (1L &lt;&lt; (jjmatchedKind &amp; 077))) != 0L)
+        {
+           matchedToken = jjFillToken();
+           matchedToken.specialToken = specialToken;
+       if (jjnewLexState[jjmatchedKind] != -1)
+         curLexState = jjnewLexState[jjmatchedKind];
+           return matchedToken;
+        }
+        else if ((jjtoSkip[jjmatchedKind &gt;&gt; 6] &amp; (1L &lt;&lt; (jjmatchedKind &amp; 077))) != 0L)
+        {
+           if ((jjtoSpecial[jjmatchedKind &gt;&gt; 6] &amp; (1L &lt;&lt; (jjmatchedKind &amp; 077))) != 0L)
+           {
+              matchedToken = jjFillToken();
+              if (specialToken == null)
+                 specialToken = matchedToken;
+              else
+              {
+                 matchedToken.specialToken = specialToken;
+                 specialToken = (specialToken.next = matchedToken);
+              }
+              SkipLexicalActions(matchedToken);
+           }
+           else 
+              SkipLexicalActions(null);
+         if (jjnewLexState[jjmatchedKind] != -1)
+           curLexState = jjnewLexState[jjmatchedKind];
+           continue EOFLoop;
+        }
+        jjimageLen += jjmatchedPos + 1;
+      if (jjnewLexState[jjmatchedKind] != -1)
+        curLexState = jjnewLexState[jjmatchedKind];
+        curPos = 0;
+        jjmatchedKind = 0x7fffffff;
+        try {
+           curChar = input_stream.readChar();
+           continue;
+        }
+        catch (java.io.IOException e1) { }
+     }
+     int error_line = input_stream.getEndLine();
+     int error_column = input_stream.getEndColumn();
+     String error_after = null;
+     boolean EOFSeen = false;
+     try { input_stream.readChar(); input_stream.backup(1); }
+     catch (java.io.IOException e1) {
+        EOFSeen = true;
+        error_after = curPos &lt;= 1 ? &quot;&quot; : input_stream.GetImage();
+        if (curChar == '\n' || curChar == '\r') {
+           error_line++;
+           error_column = 0;
+        }
+        else
+           error_column++;
+     }
+     if (!EOFSeen) {
+        input_stream.backup(1);
+        error_after = curPos &lt;= 1 ? &quot;&quot; : input_stream.GetImage();
+     }
+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+   }
+  }
+}
+
+void SkipLexicalActions(Token matchedToken)
+{
+   switch(jjmatchedKind)
+   {
+      default :
+         break;
+   }
+}
+}

Added: trunk/cloveretl.engine/src/org/jetel/util/dml2clover/ParseException.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/ParseException.java	2007-02-20 13:36:20 UTC (rev 2492)
+++ trunk/cloveretl.engine/src/org/jetel/util/dml2clover/ParseException.java	2007-02-20 13:57:34 UTC (rev 2493)
@@ -0,0 +1,192 @@
+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */
+package org.jetel.util.dml2clover;
+
+/**
+ * This exception is thrown when parse errors are encountered.
+ * You can explicitly create objects of this exception type by
+ * calling the method generateParseException in the generated
+ * parser.
+ *
+ * You can modify this class to customize your error reporting
+ * mechanisms so long as you retain the public fields.
+ */
+public class ParseException extends Exception {
+
+  /**
+   * This constructor is used by the method &quot;generateParseException&quot;
+   * in the generated parser.  Calling this constructor generates
+   * a new object of this type with the fields &quot;currentToken&quot;,
+   * &quot;expectedTokenSequences&quot;, and &quot;tokenImage&quot; set.  The boolean
+   * flag &quot;specialConstructor&quot; is also set to true to indicate that
+   * this constructor was used to create this object.
+   * This constructor calls its super class with the empty string
+   * to force the &quot;toString&quot; method of parent class &quot;Throwable&quot; to
+   * print the error message in the form:
+   *     ParseException: &lt;result of getMessage&gt;
+   */
+  public ParseException(Token currentTokenVal,
+                        int[][] expectedTokenSequencesVal,
+                        String[] tokenImageVal
+                       )
+  {
+    super(&quot;&quot;);
+    specialConstructor = true;
+    currentToken = currentTokenVal;
+    expectedTokenSequences = expectedTokenSequencesVal;
+    tokenImage = tokenImageVal;
+  }
+
+  /**
+   * The following constructors are for use by you for whatever
+   * purpose you can think of.  Constructing the exception in this
+   * manner makes the exception behave in the normal way - i.e., as
+   * documented in the class &quot;Throwable&quot;.  The fields &quot;errorToken&quot;,
+   * &quot;expectedTokenSequences&quot;, and &quot;tokenImage&quot; do not contain
+   * relevant information.  The JavaCC generated code does not use
+   * these constructors.
+   */
+
+  public ParseException() {
+    super();
+    specialConstructor = false;
+  }
+
+  public ParseException(String message) {
+    super(message);
+    specialConstructor = false;
+  }
+
+  /**
+   * This variable determines which constructor was used to create
+   * this object and thereby affects the semantics of the
+   * &quot;getMessage&quot; method (see below).
+   */
+  protected boolean specialConstructor;
+
+  /**
+   * This is the last token that has been consumed successfully.  If
+   * this object has been created due to a parse error, the token
+   * followng this token will (therefore) be the first error token.
+   */
+  public Token currentToken;
+
+  /**
+   * Each entry in this array is an array of integers.  Each array
+   * of integers represents a sequence of tokens (by their ordinal
+   * values) that is expected at this point of the parse.
+   */
+  public int[][] expectedTokenSequences;
+
+  /**
+   * This is a reference to the &quot;tokenImage&quot; array of the generated
+   * parser within which the parse error occurred.  This array is
+   * defined in the generated ...Constants interface.
+   */
+  public String[] tokenImage;
+
+  /**
+   * This method has the standard behavior when this object has been
+   * created using the standard constructors.  Otherwise, it uses
+   * &quot;currentToken&quot; and &quot;expectedTokenSequences&quot; to generate a parse
+   * error message and returns it.  If this object has been created
+   * due to a parse error, and you do not catch it (it gets thrown
+   * from the parser), then this method is called during the printing
+   * of the final stack trace, and hence the correct error message
+   * gets displayed.
+   */
+  public String getMessage() {
+    if (!specialConstructor) {
+      return super.getMessage();
+    }
+    StringBuffer expected = new StringBuffer();
+    int maxSize = 0;
+    for (int i = 0; i &lt; expectedTokenSequences.length; i++) {
+      if (maxSize &lt; expectedTokenSequences[i].length) {
+        maxSize = expectedTokenSequences[i].length;
+      }
+      for (int j = 0; j &lt; expectedTokenSequences[i].length; j++) {
+        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(&quot; &quot;);
+      }
+      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
+        expected.append(&quot;...&quot;);
+      }
+      expected.append(eol).append(&quot;    &quot;);
+    }
+    String retval = &quot;Encountered \&quot;&quot;;
+    Token tok = currentToken.next;
+    for (int i = 0; i &lt; maxSize; i++) {
+      if (i != 0) retval += &quot; &quot;;
+      if (tok.kind == 0) {
+        retval += tokenImage[0];
+        break;
+      }
+      retval += add_escapes(tok.image);
+      tok = tok.next; 
+    }
+    retval += &quot;\&quot; at line &quot; + currentToken.next.beginLine + &quot;, column &quot; + currentToken.next.beginColumn;
+    retval += &quot;.&quot; + eol;
+    if (expectedTokenSequences.length == 1) {
+      retval += &quot;Was expecting:&quot; + eol + &quot;    &quot;;
+    } else {
+      retval += &quot;Was expecting one of:&quot; + eol + &quot;    &quot;;
+    }
+    retval += expected.toString();
+    return retval;
+  }
+
+  /**
+   * The end of line string for this machine.
+   */
+  protected String eol = System.getProperty(&quot;line.separator&quot;, &quot;\n&quot;);
+ 
+  /**
+   * Used to convert raw characters to their escaped version
+   * when these raw version cannot be used as part of an ASCII
+   * string literal.
+   */
+  protected String add_escapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i &lt; str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append(&quot;\\b&quot;);
+              continue;
+           case '\t':
+              retval.append(&quot;\\t&quot;);
+              continue;
+           case '\n':
+              retval.append(&quot;\\n&quot;);
+              continue;
+           case '\f':
+              retval.append(&quot;\\f&quot;);
+              continue;
+           case '\r':
+              retval.append(&quot;\\r&quot;);
+              continue;
+           case '\&quot;':
+              retval.append(&quot;\\\&quot;&quot;);
+              continue;
+           case '\'':
+              retval.append(&quot;\\\'&quot;);
+              continue;
+           case '\\':
+              retval.append(&quot;\\\\&quot;);
+              continue;
+           default:
+              if ((ch = str.charAt(i)) &lt; 0x20 || ch &gt; 0x7e) {
+                 String s = &quot;0000&quot; + Integer.toString(ch, 16);
+                 retval.append(&quot;\\u&quot; + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+}

Added: trunk/cloveretl.engine/src/org/jetel/util/dml2clover/SimpleCharStream.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/SimpleCharStream.java	2007-02-20 13:36:20 UTC (rev 2492)
+++ trunk/cloveretl.engine/src/org/jetel/util/dml2clover/SimpleCharStream.java	2007-02-20 13:57:34 UTC (rev 2493)
@@ -0,0 +1,439 @@
+/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.0 */
+package org.jetel.util.dml2clover;
+
+/**
+ * An implementation of interface CharStream, where the stream is assumed to
+ * contain only ASCII characters (without unicode processing).
+ */
+
+public class SimpleCharStream
+{
+  public static final boolean staticFlag = false;
+  int bufsize;
+  int available;
+  int tokenBegin;
+  public int bufpos = -1;
+  protected int bufline[];
+  protected int bufcolumn[];
+
+  protected int column = 0;
+  protected int line = 1;
+
+  protected boolean prevCharIsCR = false;
+  protected boolean prevCharIsLF = false;
+
+  protected java.io.Reader inputStream;
+
+  protected char[] buffer;
+  protected int maxNextCharInd = 0;
+  protected int inBuf = 0;
+  protected int tabSize = 8;
+
+  protected void setTabSize(int i) { tabSize = i; }
+  protected int getTabSize(int i) { return tabSize; }
+
+
+  protected void ExpandBuff(boolean wrapAround)
+  {
+     char[] newbuffer = new char[bufsize + 2048];
+     int newbufline[] = new int[bufsize + 2048];
+     int newbufcolumn[] = new int[bufsize + 2048];
+
+     try
+     {
+        if (wrapAround)
+        {
+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+           System.arraycopy(buffer, 0, newbuffer,
+                                             bufsize - tokenBegin, bufpos);
+           buffer = newbuffer;
+
+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
+           bufline = newbufline;
+
+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
+           bufcolumn = newbufcolumn;
+
+           maxNextCharInd = (bufpos += (bufsize - tokenBegin));
+        }
+        else
+        {
+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+           buffer = newbuffer;
+
+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+           bufline = newbufline;
+
+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+           bufcolumn = newbufcolumn;
+
+           maxNextCharInd = (bufpos -= tokenBegin);
+        }
+     }
+     catch (Throwable t)
+     {
+        throw new Error(t.getMessage());
+     }
+
+
+     bufsize += 2048;
+     available = bufsize;
+     tokenBegin = 0;
+  }
+
+  protected void FillBuff() throws java.io.IOException
+  {
+     if (maxNextCharInd == available)
+     {
+        if (available == bufsize)
+        {
+           if (tokenBegin &gt; 2048)
+           {
+              bufpos = maxNextCharInd = 0;
+              available = tokenBegin;
+           }
+           else if (tokenBegin &lt; 0)
+              bufpos = maxNextCharInd = 0;
+           else
+              ExpandBuff(false);
+        }
+        else if (available &gt; tokenBegin)
+           available = bufsize;
+        else if ((tokenBegin - available) &lt; 2048)
+           ExpandBuff(true);
+        else
+           available = tokenBegin;
+     }
+
+     int i;
+     try {
+        if ((i = inputStream.read(buffer, maxNextCharInd,
+                                    available - maxNextCharInd)) == -1)
+        {
+           inputStream.close();
+           throw new java.io.IOException();
+        }
+        else
+           maxNextCharInd += i;
+        return;
+     }
+     catch(java.io.IOException e) {
+        --bufpos;
+        backup(0);
+        if (tokenBegin == -1)
+           tokenBegin = bufpos;
+        throw e;
+     }
+  }
+
+  public char BeginToken() throws java.io.IOException
+  {
+     tokenBegin = -1;
+     char c = readChar();
+     tokenBegin = bufpos;
+
+     return c;
+  }
+
+  protected void UpdateLineColumn(char c)
+  {
+     column++;
+
+     if (prevCharIsLF)
+     {
+        prevCharIsLF = false;
+        line += (column = 1);
+     }
+     else if (prevCharIsCR)
+     {
+        prevCharIsCR = false;
+        if (c == '\n')
+        {
+           prevCharIsLF = true;
+        }
+        else
+           line += (column = 1);
+     }
+
+     switch (c)
+     {
+        case '\r' :
+           prevCharIsCR = true;
+           break;
+        case '\n' :
+           prevCharIsLF = true;
+           break;
+        case '\t' :
+           column--;
+           column += (tabSize - (column % tabSize));
+           break;
+        default :
+           break;
+     }
+
+     bufline[bufpos] = line;
+     bufcolumn[bufpos] = column;
+  }
+
+  public char readChar() throws java.io.IOException
+  {
+     if (inBuf &gt; 0)
+     {
+        --inBuf;
+
+        if (++bufpos == bufsize)
+           bufpos = 0;
+
+        return buffer[bufpos];
+     }
+
+     if (++bufpos &gt;= maxNextCharInd)
+        FillBuff();
+
+     char c = buffer[bufpos];
+
+     UpdateLineColumn(c);
+     return (c);
+  }
+
+  /**
+   * @deprecated 
+   * @see #getEndColumn
+   */
+
+  public int getColumn() {
+     return bufcolumn[bufpos];
+  }
+
+  /**
+   * @deprecated 
+   * @see #getEndLine
+   */
+
+  public int getLine() {
+     return bufline[bufpos];
+  }
+
+  public int getEndColumn() {
+     return bufcolumn[bufpos];
+  }
+
+  public int getEndLine() {
+     return bufline[bufpos];
+  }
+
+  public int getBeginColumn() {
+     return bufcolumn[tokenBegin];
+  }
+
+  public int getBeginLine() {
+     return bufline[tokenBegin];
+  }
+
+  public void backup(int amount) {
+
+    inBuf += amount;
+    if ((bufpos -= amount) &lt; 0)
+       bufpos += bufsize;
+  }
+
+  public SimpleCharStream(java.io.Reader dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    available = bufsize = buffersize;
+    buffer = new char[buffersize];
+    bufline = new int[buffersize];
+    bufcolumn = new int[buffersize];
+  }
+
+  public SimpleCharStream(java.io.Reader dstream, int startline,
+                          int startcolumn)
+  {
+     this(dstream, startline, startcolumn, 4096);
+  }
+
+  public SimpleCharStream(java.io.Reader dstream)
+  {
+     this(dstream, 1, 1, 4096);
+  }
+  public void ReInit(java.io.Reader dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    if (buffer == null || buffersize != buffer.length)
+    {
+      available = bufsize = buffersize;
+      buffer = new char[buffersize];
+      bufline = new int[buffersize];
+      bufcolumn = new int[buffersize];
+    }
+    prevCharIsLF = prevCharIsCR = false;
+    tokenBegin = inBuf = maxNextCharInd = 0;
+    bufpos = -1;
+  }
+
+  public void ReInit(java.io.Reader dstream, int startline,
+                     int startcolumn)
+  {
+     ReInit(dstream, startline, startcolumn, 4096);
+  }
+
+  public void ReInit(java.io.Reader dstream)
+  {
+     ReInit(dstream, 1, 1, 4096);
+  }
+  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+     this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+  public SimpleCharStream(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+     this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+  }
+
+  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
+                          int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+     this(dstream, encoding, startline, startcolumn, 4096);
+  }
+
+  public SimpleCharStream(java.io.InputStream dstream, int startline,
+                          int startcolumn)
+  {
+     this(dstream, startline, startcolumn, 4096);
+  }
+
+  public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+     this(dstream, encoding, 1, 1, 4096);
+  }
+
+  public SimpleCharStream(java.io.InputStream dstream)
+  {
+     this(dstream, 1, 1, 4096);
+  }
+
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+                          int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+  public void ReInit(java.io.InputStream dstream, int startline,
+                          int startcolumn, int buffersize)
+  {
+     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+  }
+
+  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(dstream, encoding, 1, 1, 4096);
+  }
+
+  public void ReInit(java.io.InputStream dstream)
+  {
+     ReInit(dstream, 1, 1, 4096);
+  }
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+                     int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(dstream, encoding, startline, startcolumn, 4096);
+  }
+  public void ReInit(java.io.InputStream dstream, int startline,
+                     int startcolumn)
+  {
+     ReInit(dstream, startline, startcolumn, 4096);
+  }
+  public String GetImage()
+  {
+     if (bufpos &gt;= tokenBegin)
+        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
+     else
+        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
+                              new String(buffer, 0, bufpos + 1);
+  }
+
+  public char[] GetSuffix(int len)
+  {
+     char[] ret = new char[len];
+
+     if ((bufpos + 1) &gt;= len)
+        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
+     else
+     {
+        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
+                                                          len - bufpos - 1);
+        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
+     }
+
+     return ret;
+  }
+
+  public void Done()
+  {
+     buffer = null;
+     bufline = null;
+     bufcolumn = null;
+  }
+
+  /**
+   * Method to adjust line and column numbers for the start of a token.
+   */
+  public void adjustBeginLineColumn(int newLine, int newCol)
+  {
+     int start = tokenBegin;
+     int len;
+
+     if (bufpos &gt;= tokenBegin)
+     {
+        len = bufpos - tokenBegin + inBuf + 1;
+     }
+     else
+     {
+        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
+     }
+
+     int i = 0, j = 0, k = 0;
+     int nextColDiff = 0, columnDiff = 0;
+
+     while (i &lt; len &amp;&amp;
+            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
+     {
+        bufline[j] = newLine;
+        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
+        bufcolumn[j] = newCol + columnDiff;
+        columnDiff = nextColDiff;
+        i++;
+     } 
+
+     if (i &lt; len)
+     {
+        bufline[j] = newLine++;
+        bufcolumn[j] = newCol + columnDiff;
+
+        while (i++ &lt; len)
+        {
+           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
+              bufline[j] = newLine++;
+           else
+              bufline[j] = newLine;
+        }
+     }
+
+     line = bufline[j];
+     column = bufcolumn[j];
+  }
+
+}

Added: trunk/cloveretl.engine/src/org/jetel/util/dml2clover/Token.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/Token.java	2007-02-20 13:36:20 UTC (rev 2492)
+++ trunk/cloveretl.engine/src/org/jetel/util/dml2clover/Token.java	2007-02-20 13:57:34 UTC (rev 2493)
@@ -0,0 +1,81 @@
+/* Generated By:JavaCC: Do not edit this line. Token.java Version 3.0 */
+package org.jetel.util.dml2clover;
+
+/**
+ * Describes the input token stream.
+ */
+
+public class Token {
+
+  /**
+   * An integer that describes the kind of this token.  This numbering
+   * system is determined by JavaCCParser, and a table of these numbers is
+   * stored in the file ...Constants.java.
+   */
+  public int kind;
+
+  /**
+   * beginLine and beginColumn describe the position of the first character
+   * of this token; endLine and endColumn describe the position of the
+   * last character of this token.
+   */
+  public int beginLine, beginColumn, endLine, endColumn;
+
+  /**
+   * The string image of the token.
+   */
+  public String image;
+
+  /**
+   * A reference to the next regular (non-special) token from the input
+   * stream.  If this is the last token from the input stream, or if the
+   * token manager has not read tokens beyond this one, this field is
+   * set to null.  This is true only if this token is also a regular
+   * token.  Otherwise, see below for a description of the contents of
+   * this field.
+   */
+  public Token next;
+
+  /**
+   * This field is used to access special tokens that occur prior to this
+   * token, but after the immediately preceding regular (non-special) token.
+   * If there are no such special tokens, this field is set to null.
+   * When there are more than one such special token, this field refers
+   * to the last of these special tokens, which in turn refers to the next
+   * previous special token through its specialToken field, and so on
+   * until the first special token (whose specialToken field is null).
+   * The next fields of special tokens refer to other special tokens that
+   * immediately follow it (without an intervening regular token).  If there
+   * is no such token, this field is null.
+   */
+  public Token specialToken;
+
+  /**
+   * Returns the image.
+   */
+  public String toString()
+  {
+     return image;
+  }
+
+  /**
+   * Returns a new Token object, by default. However, if you want, you
+   * can create and return subclass objects based on the value of ofKind.
+   * Simply add the cases to the switch for all those special cases.
+   * For example, if you have a subclass of Token called IDToken that
+   * you want to create if ofKind is ID, simlpy add something like :
+   *
+   *    case MyParserConstants.ID : return new IDToken();
+   *
+   * to the following switch statement. Then you can cast matchedToken
+   * variable to the appropriate type and use it in your lexical actions.
+   */
+  public static final Token newToken(int ofKind)
+  {
+     switch(ofKind)
+     {
+       default : return new Token();
+     }
+  }
+
+}

Added: trunk/cloveretl.engine/src/org/jetel/util/dml2clover/TokenMgrError.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/TokenMgrError.java	2007-02-20 13:36:20 UTC (rev 2492)
+++ trunk/cloveretl.engine/src/org/jetel/util/dml2clover/TokenMgrError.java	2007-02-20 13:57:34 UTC (rev 2493)
@@ -0,0 +1,133 @@
+/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 3.0 */
+package org.jetel.util.dml2clover;
+
+public class TokenMgrError extends Error
+{
+   /*
+    * Ordinals for various reasons why an Error of this type can be thrown.
+    */
+
+   /**
+    * Lexical error occured.
+    */
+   static final int LEXICAL_ERROR = 0;
+
+   /**
+    * An attempt wass made to create a second instance of a static token manager.
+    */
+   static final int STATIC_LEXER_ERROR = 1;
+
+   /**
+    * Tried to change to an invalid lexical state.
+    */
+   static final int INVALID_LEXICAL_STATE = 2;
+
+   /**
+    * Detected (and bailed out of) an infinite loop in the token manager.
+    */
+   static final int LOOP_DETECTED = 3;
+
+   /**
+    * Indicates the reason why the exception is thrown. It will have
+    * one of the above 4 values.
+    */
+   int errorCode;
+
+   /**
+    * Replaces unprintable characters by their espaced (or unicode escaped)
+    * equivalents in the given string
+    */
+   protected static final String addEscapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i &lt; str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append(&quot;\\b&quot;);
+              continue;
+           case '\t':
+              retval.append(&quot;\\t&quot;);
+              continue;
+           case '\n':
+              retval.append(&quot;\\n&quot;);
+              continue;
+           case '\f':
+              retval.append(&quot;\\f&quot;);
+              continue;
+           case '\r':
+              retval.append(&quot;\\r&quot;);
+              continue;
+           case '\&quot;':
+              retval.append(&quot;\\\&quot;&quot;);
+              continue;
+           case '\'':
+              retval.append(&quot;\\\'&quot;);
+              continue;
+           case '\\':
+              retval.append(&quot;\\\\&quot;);
+              continue;
+           default:
+              if ((ch = str.charAt(i)) &lt; 0x20 || ch &gt; 0x7e) {
+                 String s = &quot;0000&quot; + Integer.toString(ch, 16);
+                 retval.append(&quot;\\u&quot; + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+   /**
+    * Returns a detailed message for the Error when it is thrown by the
+    * token manager to indicate a lexical error.
+    * Parameters : 
+    *    EOFSeen     : indicates if EOF caused the lexicl error
+    *    curLexState : lexical state in which this error occured
+    *    errorLine   : line number when the error occured
+    *    errorColumn : column number when the error occured
+    *    errorAfter  : prefix that was seen before this error occured
+    *    curchar     : the offending character
+    * Note: You can customize the lexical error message by modifying this method.
+    */
+   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
+      return(&quot;Lexical error at line &quot; +
+           errorLine + &quot;, column &quot; +
+           errorColumn + &quot;.  Encountered: &quot; +
+           (EOFSeen ? &quot;&lt;EOF&gt; &quot; : (&quot;\&quot;&quot; + addEscapes(String.valueOf(curChar)) + &quot;\&quot;&quot;) + &quot; (&quot; + (int)curChar + &quot;), &quot;) +
+           &quot;after : \&quot;&quot; + addEscapes(errorAfter) + &quot;\&quot;&quot;);
+   }
+
+   /**
+    * You can also modify the body of this method to customize your error messages.
+    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
+    * of end-users concern, so you can return something like : 
+    *
+    *     &quot;Internal Error : Please file a bug report .... &quot;
+    *
+    * from this method for such cases in the release version of your parser.
+    */
+   public String getMessage() {
+      return super.getMessage();
+   }
+
+   /*
+    * Constructors of various flavors follow.
+    */
+
+   public TokenMgrError() {
+   }
+
+   public TokenMgrError(String message, int reason) {
+      super(message);
+      errorCode = reason;
+   }
+
+   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
+      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
+   }
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000129.html">[Cloveretl-svn-commits] CloverETL repos r2492 - in	trunk/cloveretl.engine/src/org/jetel/util: . dml2clover
</A></li>
	<LI>Next message: <A HREF="000133.html">[Cloveretl-svn-commits] CloverETL repos r2494 - in	trunk/cloveretl.engine/src/org/jetel/util: . ddl2clover
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#130">[ date ]</a>
              <a href="thread.html#130">[ thread ]</a>
              <a href="subject.html#130">[ subject ]</a>
              <a href="author.html#130">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cloveretl-svn-commits">More information about the Cloveretl-svn-commits
mailing list</a><br>
</body></html>
