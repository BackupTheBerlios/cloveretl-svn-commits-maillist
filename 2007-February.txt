From cloveretl-svn-commits at lists.berlios.de  Thu Feb  1 11:21:00 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 1 Feb 2007 11:21:00 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2422 -
	trunk/cloveretl.component/src/org/jetel/component
Message-ID: <200702011021.l11AL0nP027276@sheep.berlios.de>

Author: agad
Date: 2007-02-01 11:20:59 +0100 (Thu, 01 Feb 2007)
New Revision: 2422

Modified:
   trunk/cloveretl.component/src/org/jetel/component/DataReader.java
   trunk/cloveretl.component/src/org/jetel/component/DelimitedDataReader.java
   trunk/cloveretl.component/src/org/jetel/component/FixLenDataReader.java
Log:
MINOR:comments updated

Modified: trunk/cloveretl.component/src/org/jetel/component/DataReader.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DataReader.java	2007-01-31 14:40:33 UTC (rev 2421)
+++ trunk/cloveretl.component/src/org/jetel/component/DataReader.java	2007-02-01 10:20:59 UTC (rev 2422)
@@ -77,6 +77,8 @@
  *  <tr><td><b>dataPolicy</b></td><td>specifies how to handle misformatted or incorrect data.  'Strict' (default value) aborts processing, 'Controlled' logs the entire record while processing continues, and 'Lenient' attempts to set incorrect data to default values while processing continues.</td>
  *  <tr><td><b>skipLeadingBlanks</b><br><i>optional</i></td><td>specifies whether leading blanks at each fixlen field should be skipped. Default value is TRUE.<br>
  *  <i>Note: if this option is ON (TRUE), then field composed of all blanks/spaces is transformed to NULL (zero length string).</i></td>
+ *  <tr><td><b>trim</b><br><i>optional</i></td><td>specifies whether to trim strings before setting them to data fields.
+ *  When not set, strings are trimmed depending on "trim" attribute of metadata.</td>
  *  <tr><td><b>skipFirstLine</b></td><td>specifies whether first record/line should be skipped. Default value is FALSE. If record delimiter is specified than skip one record else first line of flat file.</td>
  *  <tr><td><b>skipRows</b></td><td>specifies how many records/rows should be skipped from the source file; good for handling files where first rows is a header not a real data. Dafault is 0.</td>
  *  <tr><td><b>numRecords</b></td><td>max number of parsed records</td>

Modified: trunk/cloveretl.component/src/org/jetel/component/DelimitedDataReader.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DelimitedDataReader.java	2007-01-31 14:40:33 UTC (rev 2421)
+++ trunk/cloveretl.component/src/org/jetel/component/DelimitedDataReader.java	2007-02-01 10:20:59 UTC (rev 2422)
@@ -70,6 +70,8 @@
  *  <tr><td><b>skipFirstLine</b></td><td>specifies whether first record/line should be skipped. Default value is FALSE. If record delimiter is specified than skip one record else first line of flat file.</td>
  *  <tr><td><b>skipRows</b><br><i>optional</i></td><td>specifies how many records/rows should be skipped from the source file. Good for handling files where first rows is a header not a real data. Dafault is 0.</td>
  *  <tr><td><b>numRecords</b></td><td>max number of parsed records</td>
+ *  <tr><td><b>trim</b><br><i>optional</i></td><td>specifies whether to trim strings before setting them to data fields.
+ *  When not set, strings are trimmed depending on "trim" attribute of metadata.</td>
  *  </tr>
  *  </table>
  *

Modified: trunk/cloveretl.component/src/org/jetel/component/FixLenDataReader.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/FixLenDataReader.java	2007-01-31 14:40:33 UTC (rev 2421)
+++ trunk/cloveretl.component/src/org/jetel/component/FixLenDataReader.java	2007-02-01 10:20:59 UTC (rev 2422)
@@ -83,6 +83,8 @@
  *  Default is true. It doesn't have any effect in byte mode.</td>
  *  <tr><td><b>skipTrailingBlanks</b></td><td>Values true/false. Sets on/off skipping of trailing blanks in fields.
  *  Default is true. It doesn't have any effect in byte mode.</td>
+ *  <tr><td><b>trim</b><br><i>optional</i></td><td>specifies whether to trim strings before setting them to data fields.
+ *  When not set, strings are trimmed depending on "trim" attribute of metadata.</td>
  *  <tr><td><b>enableIncomplete</b></td><td>Values true/false. Sets on/off support for incomplete records. 
  *  Default is true. It doesn't have any effect in byte mode.</td>
  *  <tr><td><b>skipEmpty</b></td><td>Values true/false. Specifies whether empty records are to be ignored. 



From cloveretl-svn-commits at lists.berlios.de  Thu Feb  1 11:26:41 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 1 Feb 2007 11:26:41 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2423 -
	trunk/cloveretl.engine/src/org/jetel/data/parser
Message-ID: <200702011026.l11AQfR8028441@sheep.berlios.de>

Author: agad
Date: 2007-02-01 11:26:41 +0100 (Thu, 01 Feb 2007)
New Revision: 2423

Modified:
   trunk/cloveretl.engine/src/org/jetel/data/parser/DataParser.java
   trunk/cloveretl.engine/src/org/jetel/data/parser/DelimitedDataParser.java
Log:
MINOR:removed enum BOOLEXt

Modified: trunk/cloveretl.engine/src/org/jetel/data/parser/DataParser.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/parser/DataParser.java	2007-02-01 10:20:59 UTC (rev 2422)
+++ trunk/cloveretl.engine/src/org/jetel/data/parser/DataParser.java	2007-02-01 10:26:41 UTC (rev 2423)
@@ -56,12 +56,6 @@
  */
 public class DataParser implements Parser {
 	
-	public enum BoolExt{
-		TRUE,
-		FALSE,
-		NOT_SET;
-	}
-
 	private IParserExceptionHandler exceptionHandler;
 
 	private DataRecordMetadata metadata;

Modified: trunk/cloveretl.engine/src/org/jetel/data/parser/DelimitedDataParser.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/parser/DelimitedDataParser.java	2007-02-01 10:20:59 UTC (rev 2422)
+++ trunk/cloveretl.engine/src/org/jetel/data/parser/DelimitedDataParser.java	2007-02-01 10:26:41 UTC (rev 2423)
@@ -35,7 +35,6 @@
 import org.apache.commons.logging.LogFactory;
 import org.jetel.data.DataRecord;
 import org.jetel.data.Defaults;
-import org.jetel.data.parser.DataParser.BoolExt;
 import org.jetel.exception.BadDataFormatException;
 import org.jetel.exception.ComponentNotReadyException;
 import org.jetel.exception.IParserExceptionHandler;



From cloveretl-svn-commits at lists.berlios.de  Thu Feb  1 15:13:08 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 1 Feb 2007 15:13:08 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2424 -
	branches/cloveretl.engine.rel-2-0-4/cloveretl.engine/docs
Message-ID: <200702011413.l11ED8oP030396@sheep.berlios.de>

Author: otasanek
Date: 2007-02-01 15:13:07 +0100 (Thu, 01 Feb 2007)
New Revision: 2424

Modified:
   branches/cloveretl.engine.rel-2-0-4/cloveretl.engine/docs/HISTORY.txt
Log:
UPDATE: update HISTORY.txt file.

Modified: branches/cloveretl.engine.rel-2-0-4/cloveretl.engine/docs/HISTORY.txt
===================================================================
--- branches/cloveretl.engine.rel-2-0-4/cloveretl.engine/docs/HISTORY.txt	2007-02-01 10:26:41 UTC (rev 2423)
+++ branches/cloveretl.engine.rel-2-0-4/cloveretl.engine/docs/HISTORY.txt	2007-02-01 14:13:07 UTC (rev 2424)
@@ -1,7 +1,14 @@
 *******************************************************************************
                           CLOVER ETL - HISTORY of RELEASES
 *******************************************************************************
+REL 2-0-4
+---------
+Release in particular repairing bugs from 2.0.3 version.
 
+Changes/bug fixes:
++ fix in transform language for optional assigning 
++ Clover data writer was fixed for incoming empty record set
+
 REL 2-0-3
 ---------
 Release in particular repairing bugs from 2.0.2 version.



From cloveretl-svn-commits at lists.berlios.de  Thu Feb  1 15:13:43 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 1 Feb 2007 15:13:43 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2425 -
	branches/cloveretl.engine.rel-2-0-4/cloveretl.engine
Message-ID: <200702011413.l11EDhSs030503@sheep.berlios.de>

Author: otasanek
Date: 2007-02-01 15:13:42 +0100 (Thu, 01 Feb 2007)
New Revision: 2425

Added:
   branches/cloveretl.engine.rel-2-0-4/cloveretl.engine/run.bat
   branches/cloveretl.engine.rel-2-0-4/cloveretl.engine/run.sh
Log:
INIT: added new "run scripts".

Added: branches/cloveretl.engine.rel-2-0-4/cloveretl.engine/run.bat
===================================================================
--- branches/cloveretl.engine.rel-2-0-4/cloveretl.engine/run.bat	2007-02-01 14:13:07 UTC (rev 2424)
+++ branches/cloveretl.engine.rel-2-0-4/cloveretl.engine/run.bat	2007-02-01 14:13:42 UTC (rev 2425)
@@ -0,0 +1,22 @@
+ at echo off
+
+rem ********************************
+rem usage - run.bat <graph_name.grf>
+rem ********************************
+
+rem ***** set this before using script *****
+set JAVA_HOME=c:\Program Files (x86)\Java\jdk1.5.0_04
+set ENGINE_PATH=.
+set LIB_PATH=.\lib
+set TRANSFORM_PATH=.
+rem ****************************************
+
+set ENGINE_JAR=%ENGINE_PATH%\cloveretl.engine.jar
+set COMMONS_LOGGING_JAR=%LIB_PATH%\commons-logging.jar
+set JAVOLUTION_JAR=%LIB_PATH%\javolution.jar
+set JMS_JAR=%LIB_PATH%\jms.jar
+set JXL_JAR=%LIB_PATH%\jxl.jar
+set LOG4J_JAR=%LIB_PATH%\log4j-1.2.12.zip
+set POI_JAR=%LIB_PATH%\poi-2.5.1.jar
+
+java -cp "%TRANSFORM_PATH%;%ENGINE_JAR%;%COMMONS_LOGGING_JAR%;%JAVOLUTION_JAR%;%JMS_JAR%;%JXL_JAR%;%LOG4J_JAR%;%POI_JAR%;%JAVA_HOME%\lib\tools.jar" org.jetel.main.runGraph %1

Added: branches/cloveretl.engine.rel-2-0-4/cloveretl.engine/run.sh
===================================================================
--- branches/cloveretl.engine.rel-2-0-4/cloveretl.engine/run.sh	2007-02-01 14:13:07 UTC (rev 2424)
+++ branches/cloveretl.engine.rel-2-0-4/cloveretl.engine/run.sh	2007-02-01 14:13:42 UTC (rev 2425)
@@ -0,0 +1,19 @@
+#!/bin/sh
+
+# ************************************
+# usage - run.bat <graph_name.grf>
+
+# ***** set this before using script *****
+JAVA_HOME="/opt/jdk1.5"
+ENGINE_PATH="."
+LIBS_PATH="./lib"
+TRANSFORM_PATH="."
+# ****************************************
+
+ENGINE_JAR="$ENGINE_PATH/cloveretl.engine.jar"
+
+for i in $LIBS_PATH/*.jar $LIBS_PATH/*.zip; do
+JARS="$JARS:$i"
+done;
+
+java -classpath "$TRANSFORM_PATH:$ENGINE_JAR:$JARS:$JAVA_HOME/lib/tools.jar" org.jetel.main.runGraph $1



From cloveretl-svn-commits at lists.berlios.de  Thu Feb  1 15:20:39 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 1 Feb 2007 15:20:39 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2426 -
	branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/docs
Message-ID: <200702011420.l11EKdNi031708@sheep.berlios.de>

Author: otasanek
Date: 2007-02-01 15:20:38 +0100 (Thu, 01 Feb 2007)
New Revision: 2426

Modified:
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/docs/HISTORY.txt
Log:
UPDATE: update HISTORY.txt file.

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/docs/HISTORY.txt
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/docs/HISTORY.txt	2007-02-01 14:13:42 UTC (rev 2425)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/docs/HISTORY.txt	2007-02-01 14:20:38 UTC (rev 2426)
@@ -30,6 +30,24 @@
 + Added new data field type cbyte (compressed byte array)
 + All join components are ready to satisfy more slave input data streams
 
+REL 2-0-4
+---------
+Release in particular repairing bugs from 2.0.3 version.
+
+Changes/bug fixes:
++ fix in transform language for optional assigning 
++ Clover data writer was fixed for incoming empty record set
+
+REL 2-0-3
+---------
+Release in particular repairing bugs from 2.0.2 version.
+
+Changes/bug fixes:
++ all factories for pluginable graph elements (ComponentFactory, ConnectionFactory, ...)
+  now are able to create instances by passing constructor parameters
++ all components with record transformation class (Reformat, HashJoin, ...)
+  have a new contructor for direct supplying RecordTransform class
+
 REL 2-0-2
 ---------
 Release in particular repairing bugs from 2.0.1 version.



From cloveretl-svn-commits at lists.berlios.de  Thu Feb  1 15:21:06 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 1 Feb 2007 15:21:06 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2427 -
	branches/cloveretl.engine.rel-2-1-0/cloveretl.engine
Message-ID: <200702011421.l11EL6BF031796@sheep.berlios.de>

Author: otasanek
Date: 2007-02-01 15:21:04 +0100 (Thu, 01 Feb 2007)
New Revision: 2427

Added:
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/run.bat
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/run.sh
Log:
INIT: added new "run scripts".

Added: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/run.bat
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/run.bat	2007-02-01 14:20:38 UTC (rev 2426)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/run.bat	2007-02-01 14:21:04 UTC (rev 2427)
@@ -0,0 +1,22 @@
+ at echo off
+
+rem ********************************
+rem usage - run.bat <graph_name.grf>
+rem ********************************
+
+rem ***** set this before using script *****
+set JAVA_HOME=c:\Program Files (x86)\Java\jdk1.5.0_04
+set ENGINE_PATH=.
+set LIB_PATH=.\lib
+set TRANSFORM_PATH=.
+rem ****************************************
+
+set ENGINE_JAR=%ENGINE_PATH%\cloveretl.engine.jar
+set COMMONS_LOGGING_JAR=%LIB_PATH%\commons-logging.jar
+set JAVOLUTION_JAR=%LIB_PATH%\javolution.jar
+set JMS_JAR=%LIB_PATH%\jms.jar
+set JXL_JAR=%LIB_PATH%\jxl.jar
+set LOG4J_JAR=%LIB_PATH%\log4j-1.2.12.zip
+set POI_JAR=%LIB_PATH%\poi-2.5.1.jar
+
+java -cp "%TRANSFORM_PATH%;%ENGINE_JAR%;%COMMONS_LOGGING_JAR%;%JAVOLUTION_JAR%;%JMS_JAR%;%JXL_JAR%;%LOG4J_JAR%;%POI_JAR%;%JAVA_HOME%\lib\tools.jar" org.jetel.main.runGraph %1

Added: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/run.sh
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/run.sh	2007-02-01 14:20:38 UTC (rev 2426)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/run.sh	2007-02-01 14:21:04 UTC (rev 2427)
@@ -0,0 +1,19 @@
+#!/bin/sh
+
+# ************************************
+# usage - run.bat <graph_name.grf>
+
+# ***** set this before using script *****
+JAVA_HOME="/opt/jdk1.5"
+ENGINE_PATH="."
+LIBS_PATH="./lib"
+TRANSFORM_PATH="."
+# ****************************************
+
+ENGINE_JAR="$ENGINE_PATH/cloveretl.engine.jar"
+
+for i in $LIBS_PATH/*.jar $LIBS_PATH/*.zip; do
+JARS="$JARS:$i"
+done;
+
+java -classpath "$TRANSFORM_PATH:$ENGINE_JAR:$JARS:$JAVA_HOME/lib/tools.jar" org.jetel.main.runGraph $1



From cloveretl-svn-commits at lists.berlios.de  Thu Feb  1 15:29:56 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 1 Feb 2007 15:29:56 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2428 -
	trunk/cloveretl.engine/docs
Message-ID: <200702011429.l11ETu5w000338@sheep.berlios.de>

Author: otasanek
Date: 2007-02-01 15:29:56 +0100 (Thu, 01 Feb 2007)
New Revision: 2428

Modified:
   trunk/cloveretl.engine/docs/HISTORY.txt
Log:
UPDATE: update HISTORY.txt file.

Modified: trunk/cloveretl.engine/docs/HISTORY.txt
===================================================================
--- trunk/cloveretl.engine/docs/HISTORY.txt	2007-02-01 14:21:04 UTC (rev 2427)
+++ trunk/cloveretl.engine/docs/HISTORY.txt	2007-02-01 14:29:56 UTC (rev 2428)
@@ -30,6 +30,24 @@
 + Added new data field type cbyte (compressed byte array)
 + All join components are ready to satisfy more slave input data streams
 
+REL 2-0-4
+---------
+Release in particular repairing bugs from 2.0.3 version.
+
+Changes/bug fixes:
++ fix in transform language for optional assigning 
++ Clover data writer was fixed for incoming empty record set
+
+REL 2-0-3
+---------
+Release in particular repairing bugs from 2.0.2 version.
+
+Changes/bug fixes:
++ all factories for pluginable graph elements (ComponentFactory, ConnectionFactory, ...)
+  now are able to create instances by passing constructor parameters
++ all components with record transformation class (Reformat, HashJoin, ...)
+  have a new contructor for direct supplying RecordTransform class
+
 REL 2-0-2
 ---------
 Release in particular repairing bugs from 2.0.1 version.



From cloveretl-svn-commits at lists.berlios.de  Thu Feb  1 15:30:24 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 1 Feb 2007 15:30:24 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2429 -
	trunk/cloveretl.engine
Message-ID: <200702011430.l11EUOHO000480@sheep.berlios.de>

Author: otasanek
Date: 2007-02-01 15:30:21 +0100 (Thu, 01 Feb 2007)
New Revision: 2429

Added:
   trunk/cloveretl.engine/run.bat
   trunk/cloveretl.engine/run.sh
Log:
INIT: added new "run scripts".

Added: trunk/cloveretl.engine/run.bat
===================================================================
--- trunk/cloveretl.engine/run.bat	2007-02-01 14:29:56 UTC (rev 2428)
+++ trunk/cloveretl.engine/run.bat	2007-02-01 14:30:21 UTC (rev 2429)
@@ -0,0 +1,22 @@
+ at echo off
+
+rem ********************************
+rem usage - run.bat <graph_name.grf>
+rem ********************************
+
+rem ***** set this before using script *****
+set JAVA_HOME=c:\Program Files (x86)\Java\jdk1.5.0_04
+set ENGINE_PATH=.
+set LIB_PATH=.\lib
+set TRANSFORM_PATH=.
+rem ****************************************
+
+set ENGINE_JAR=%ENGINE_PATH%\cloveretl.engine.jar
+set COMMONS_LOGGING_JAR=%LIB_PATH%\commons-logging.jar
+set JAVOLUTION_JAR=%LIB_PATH%\javolution.jar
+set JMS_JAR=%LIB_PATH%\jms.jar
+set JXL_JAR=%LIB_PATH%\jxl.jar
+set LOG4J_JAR=%LIB_PATH%\log4j-1.2.12.zip
+set POI_JAR=%LIB_PATH%\poi-2.5.1.jar
+
+java -cp "%TRANSFORM_PATH%;%ENGINE_JAR%;%COMMONS_LOGGING_JAR%;%JAVOLUTION_JAR%;%JMS_JAR%;%JXL_JAR%;%LOG4J_JAR%;%POI_JAR%;%JAVA_HOME%\lib\tools.jar" org.jetel.main.runGraph %1

Added: trunk/cloveretl.engine/run.sh
===================================================================
--- trunk/cloveretl.engine/run.sh	2007-02-01 14:29:56 UTC (rev 2428)
+++ trunk/cloveretl.engine/run.sh	2007-02-01 14:30:21 UTC (rev 2429)
@@ -0,0 +1,19 @@
+#!/bin/sh
+
+# ************************************
+# usage - run.bat <graph_name.grf>
+
+# ***** set this before using script *****
+JAVA_HOME="/opt/jdk1.5"
+ENGINE_PATH="."
+LIBS_PATH="./lib"
+TRANSFORM_PATH="."
+# ****************************************
+
+ENGINE_JAR="$ENGINE_PATH/cloveretl.engine.jar"
+
+for i in $LIBS_PATH/*.jar $LIBS_PATH/*.zip; do
+JARS="$JARS:$i"
+done;
+
+java -classpath "$TRANSFORM_PATH:$ENGINE_JAR:$JARS:$JAVA_HOME/lib/tools.jar" org.jetel.main.runGraph $1



From cloveretl-svn-commits at lists.berlios.de  Thu Feb  1 15:47:37 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 1 Feb 2007 15:47:37 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2430 -
	trunk/cloveretl.engine/src/org/jetel/main
Message-ID: <200702011447.l11ElbBW002656@sheep.berlios.de>

Author: ausperger
Date: 2007-02-01 15:47:34 +0100 (Thu, 01 Feb 2007)
New Revision: 2430

Added:
   trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java
Removed:
   trunk/cloveretl.engine/src/org/jetel/main/DataComponentViewer.java
Log:
FIX: dodelani programu

Deleted: trunk/cloveretl.engine/src/org/jetel/main/DataComponentViewer.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/main/DataComponentViewer.java	2007-02-01 14:30:21 UTC (rev 2429)
+++ trunk/cloveretl.engine/src/org/jetel/main/DataComponentViewer.java	2007-02-01 14:47:34 UTC (rev 2430)
@@ -1,500 +0,0 @@
-/*
- *  jETeL/Clover - Java based ETL application framework.
- *  Copyright (C) 2002-03  David Pavlis
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License as published by the Free Software Foundation; either
- *    version 2.1 of the License, or (at your option) any later version.
- *    
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
- *    Lesser General Public License for more details.
- *    
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-package org.jetel.main;
-
-import java.io.BufferedInputStream;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import java.util.StringTokenizer;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.jetel.component.DataWriter;
-import org.jetel.component.ExtFilter;
-import org.jetel.component.StructureWriter;
-import org.jetel.component.TextWriter;
-import org.jetel.data.Defaults;
-import org.jetel.exception.ConfigurationStatus;
-import org.jetel.exception.GraphConfigurationException;
-import org.jetel.exception.XMLConfigurationException;
-import org.jetel.graph.Edge;
-import org.jetel.graph.Node;
-import org.jetel.graph.Phase;
-import org.jetel.graph.Result;
-import org.jetel.graph.TransformationGraph;
-import org.jetel.graph.TransformationGraphXMLReaderWriter;
-import org.jetel.metadata.DataRecordMetadata;
-import org.jetel.plugin.Plugins;
-import org.jetel.util.FileUtils;
-import org.jetel.util.JetelVersion;
-import org.jetel.util.crypto.Enigma;
-
-/**
- *  class for executing transformations described in XML layout file<br><br>
- *  The graph layout is read from specified XML file and the whole transformation is executed.<br>
- *  <tt><pre>
- *  Program parameters:
- *  <table>
- *  <tr><td nowrap>-v</td><td>be verbose - print even graph layout</td></tr>
- *  <tr><td nowrap>-P:<i>properyName</i>=<i>propertyValue</i></td><td>add definition of property to global graph's property list</td></tr>
- *  <tr><td nowrap>-cfg <i>filename</i></td><td>load definitions of properties from specified file</td></tr>
- *  <tr><td nowrap>-tracking <i>seconds</i></td><td>how frequently output the processing status</td></tr>
- *  <tr><td nowrap>-info</td><td>print info about Clover library version</td></tr>
- *  <tr><td nowrap>-plugins <i>filename</i></td><td>directory where to look for plugins/components</td></tr>
- *  <tr><td nowrap>-pass <i>password</i></td><td>password for decrypting of hidden connections passwords</td></tr>
- *  <tr><td nowrap>-stdin</td><td>load graph layout from STDIN</td></tr>
- *  <tr><td nowrap><b>filename</b></td><td>filename or URL of the file (even remote) containing graph's layout in XML (this must be the last parameter passed)</td></tr>
- *  </table>
- *  </pre></tt>
- * @author      dpavlis
- * @since	2003/09/09
- * @revision    $Revision: 2080 $
- */
-public class DataComponentViewer {
-    private static Log logger = LogFactory.getLog(DataComponentViewer.class);
-
-    //TODO change run graph version
-	private final static String RUN_GRAPH_VERSION = "2.0";
-	public final static String VERBOSE_SWITCH = "-v";
-	public final static String PROPERTY_FILE_SWITCH = "-cfg";
-	public final static String PROPERTY_DEFINITION_SWITCH = "-P:";
-	public final static String INFO_SWITCH = "-info";
-    public final static String PLUGINS_SWITCH = "-plugins";
-    public final static String PASSWORD_SWITCH = "-pass";
-    public final static String VIEW_MODE = "-mode";
-    public final static String DELIMITER = "-delimiter";
-    public final static String OUT_FILE = "-file";
-	public final static String FILTER_EXPRESSION = "-expFilter";
-	public final static String RECORD_FROM = "-recFrom";
-	public final static String RECORD_COUNT = "-recCount";
-	public final static String FIELDS = "-fields";
-
-	
-    /**
-     * Clover.ETL engine initialization. Should be called only once.
-     * @param pluginsRootDirectory directory path, where plugins specification is located 
-     *        (can be null, then is used constant from Defaults.DEFAULT_PLUGINS_DIRECTORY)
-     * @param password password for encrypting some hidden part of graphs
-     *        <br>i.e. connections passwordss can be encrypted
-     */
-    public static void initEngine(String pluginsRootDirectory, String password) {
-        
-        //init password decryptor
-        if(password != null) {
-            Enigma.getInstance().init(password);
-        }
-        
-        //init framework constants
-        Defaults.init();
-
-        //init clover plugins system
-        Plugins.init(pluginsRootDirectory);
-      
-    }
-    
-    
-    /**
-     * Instantiates transformation graph from a given input stream and presets a given properties.
-     * @param inStream
-     * @param properties
-     * @return
-     * @throws XMLConfigurationException
-     * @throws GraphConfigurationException
-     */
-    public static TransformationGraph loadGraph(InputStream inStream, Properties properties) throws XMLConfigurationException, GraphConfigurationException {
-        TransformationGraph graph = new TransformationGraph();
-        TransformationGraphXMLReaderWriter graphReader = new TransformationGraphXMLReaderWriter(graph);
-        if(properties != null) {
-            graph.loadGraphProperties(properties);
-        }
-
-        graphReader.read(inStream);
-        
-        if(!graph.init()) {
-            throw new GraphConfigurationException("Graph initialization failed.");
-        }
-        
-        return graph;
-    }
-    
-	/**
-	 *  Description of the Method
-	 *
-	 * @param  args  Description of the Parameter
-	 */
-	public static void main(String args[]) {
-		boolean verbose = false;
-		Properties properties = new Properties();
-		String pluginsRootDirectory = null;
-        String password = null;
-        Mode viewMode = Mode.TEXT;
-        String delimiter = null;
-        String fileUrl = null;
-        String filterExpression = null;
-        long recordFrom = -1;
-        long recordCount = -1;
-        String fields = null;
-		
-		ExtFilter extFilter = null;
-        
-		System.out.println("***  CloverETL graph component tester ver "+RUN_GRAPH_VERSION+", (c) 2002-06 D.Pavlis, released under GNU Lesser General Public License  ***");
-		System.out.println(" Running with framework version: "+JetelVersion.MAJOR_VERSION+"."+JetelVersion.MINOR_VERSION+" build#"+JetelVersion.BUILD_NUMBER+" compiled "+JetelVersion.LIBRARY_BUILD_DATETIME);
-		System.out.println();
-        
-		if (args.length < 1) {
-			printHelp();
-			System.exit(-1);
-		}
-        
-		// process command line arguments
-		for (int i = 0; i < args.length; i++) {
-			if (args[i].startsWith(VERBOSE_SWITCH)) {
-				verbose = true;
-			}else if (args[i].startsWith(PROPERTY_FILE_SWITCH)){
-				i++;
-				try {
-					InputStream inStream = new BufferedInputStream(new FileInputStream(args[i]));
-					properties.load(inStream);
-				} catch (IOException ex) {
-					logger.error(ex.getMessage(), ex);
-					System.exit(-1);
-				}
-			}else if (args[i].startsWith(PROPERTY_DEFINITION_SWITCH)){
-			   	//String[] nameValue=args[i].replaceFirst(PROPERTY_DEFINITION_SWITCH,"").split("=");
-				//properties.setProperty(nameValue[0],nameValue[1]);
-		    	String tmp =  args[i].replaceFirst(PROPERTY_DEFINITION_SWITCH,"");
-        	    properties.setProperty(tmp.substring(0,tmp.indexOf("=")),tmp.substring(tmp.indexOf("=") +1)); 
-			}else if (args[i].startsWith(INFO_SWITCH)){
-			    printInfo();
-			    System.exit(0);
-            }else if (args[i].startsWith(PLUGINS_SWITCH)){
-                i++;
-                pluginsRootDirectory = args[i];
-            }else if (args[i].startsWith(PASSWORD_SWITCH)){
-                i++;
-                password = args[i]; 
-            }else if (args[i].startsWith(VIEW_MODE)){
-                i++;
-                viewMode = Mode.valueModeOf(args[i]);
-                if (viewMode == null) {
-    				System.err.println("Unknown mode option: "+args[i]);
-    				System.exit(-1);
-                }
-            }else if (args[i].startsWith(DELIMITER)){
-            	delimiter = args[i].substring(args[i].indexOf("=") + 1);
-            }else if (args[i].startsWith(OUT_FILE)){
-            	fileUrl = args[i].substring(args[i].indexOf("=") + 1);
-            }else if (args[i].startsWith(FILTER_EXPRESSION)){
-            	filterExpression = args[i].substring(args[i].indexOf("=") + 1);
-            }else if (args[i].startsWith(RECORD_FROM)){
-            	recordFrom = Long.parseLong(args[i].substring(args[i].indexOf("=") + 1));
-            }else if (args[i].startsWith(RECORD_COUNT)){
-            	recordCount = Long.parseLong(args[i].substring(args[i].indexOf("=") + 1));
-            }else if (args[i].startsWith(FIELDS)){
-            	fields = args[i].substring(args[i].indexOf("=") + 1);
-            }else if (args[i].startsWith("-")) {
-				System.err.println("Unknown option: "+args[i]);
-				System.exit(-1);
-			}
-		}
-		
-        //engine initialization - should be called only once
-        DataComponentViewer.initEngine(pluginsRootDirectory, password);
-        
-		//prapere input stream with XML graph definition
-        InputStream in = null;
-        System.out.println("Graph definition file: " + args[args.length - 2]);
-        URL fileURL = null;
-		try {
-			fileURL = FileUtils.getFileURL(null, args[args.length - 2]);
-		} catch (MalformedURLException e1) {
-            System.err.println("Error - graph definition file can't be read.");
-            System.exit(-1);
-		}
-        if(fileURL == null) {
-            System.err.println("Error - graph definition file can't be read.");
-            System.exit(-1);
-        }
-        try{
-            in=fileURL.openStream();
-        } catch (IOException e) {
-            System.err.println("Error - graph definition file can't be read: " + e.getMessage());
-            System.exit(-1);
-        }
-        
-        System.out.println("Component id: " + args[args.length - 1]);
-        String componentID = args[args.length - 1];
-        int pos;
-        int port = 0;
-        if ((pos = componentID.indexOf(':')) != -1) {
-        	port = Integer.parseInt(componentID.substring(pos+1));
-        	componentID = componentID.substring(0, pos);
-        }
-        
-        //loading graph from the input stream
-        TransformationGraph graph = null;
-        try {
-            graph = DataComponentViewer.loadGraph(in, properties);
-
-            if (verbose) {
-                //this can be called only after graph.init()
-                graph.dumpGraphConfiguration();
-            }
-        }catch(XMLConfigurationException ex){
-            logger.error("Error in reading graph from XML !", ex);
-            if (verbose) {
-                ex.printStackTrace(System.err);
-            }
-            System.exit(-1);
-        }catch(GraphConfigurationException ex){
-            logger.error("Error - graph's configuration invalid !", ex);
-            if (verbose) {
-                ex.printStackTrace(System.err);
-            }
-            System.exit(-1);
-        } catch (RuntimeException ex) {
-            logger.error("Error during graph initialization !", ex);
-            if (verbose) {
-                ex.printStackTrace(System.err);
-            }
-            System.exit(-1);
-        }
-        
-        //check graph elements configuration
-        ConfigurationStatus status = graph.checkConfig(null);
-        status.log();
-        
-		Map map = graph.getNodes();
-		Node node = (Node) map.get(componentID);
-		if (node == null) {
-			//map = graph.getEdges();
-			//Edge edge = (Edge) map.get(componentID);
-			//if (edge == null) {
-				// error
-				System.err.println("Error");
-				return;
-			//}
-		}
-		if (!node.isRoot()) {
-			// not implemented
-			System.err.println("Execution is implemented for root node (has only output ports connected to id)!");
-			return;
-		}
-
-		// create new graph
-	    TransformationGraph viewGraph = new TransformationGraph();
-		Phase _PHASE_1 = new Phase(1);
-
-	    // add writer component
-		DataRecordMetadata dataRecordMetadata = (DataRecordMetadata) node.getOutMetadata().toArray()[port];
-		Edge edge0 = new Edge("EDGE0", dataRecordMetadata);
-		Edge edge1 = null;
-		if (filterExpression != null) {
-			edge1 = new Edge("EDGE1", dataRecordMetadata);
-		}
-		Node writer = getWriter(viewMode, dataRecordMetadata, fileUrl, delimiter, recordFrom, recordCount, fields);
-		
-		// add Edges & Nodes & Phases to graph
-		try {
-			viewGraph.addPhase(_PHASE_1);
-			viewGraph.addEdge(edge0);
-			_PHASE_1.addNode(node);
-			_PHASE_1.addNode(writer);
-			
-			if (filterExpression != null) {
-				viewGraph.addEdge(edge1);
-				extFilter = new ExtFilter("ExtFilter0");
-				extFilter.setFilterExpression(filterExpression);
-				_PHASE_1.addNode(extFilter);
-			}
-		} catch (GraphConfigurationException e) {
-			e.printStackTrace();
-		}
-
-		// assign ports (input & output)
-		node.addOutputPort(0,edge0);
-		if (filterExpression != null) {
-			extFilter.addInputPort(0,edge0);
-			extFilter.addOutputPort(0,edge1);
-			writer.addInputPort(0,edge1); 
-		} else {
-			writer.addInputPort(0,edge0);
-		}
-
-		if(!viewGraph.init()){
-			System.err.println("Graph initialization failed !");
-			return;
-		}
-	    
-		//	start all Nodes (each node is one thread)
-		Result result=Result.N_A;
-		try {
-            result = viewGraph.run();
-		} catch (RuntimeException ex) {
-			System.err.println("Fatal error during graph run !");
-			System.err.println(ex.getCause().getMessage());
-			if (verbose) {
-				ex.printStackTrace();
-			}
-			System.exit(-1);
-		}
-		if (result==Result.FINISHED_OK) {
-			// everything O.K.
-			System.out.println("Execution of graph successful !");
-			System.exit(0);
-		} else {
-			// something FAILED !!
-			System.err.println("Execution of graph failed !");
-			System.exit(result.code());
-		}
-
-	}
-    
-	private static Node getWriter(Mode mode, DataRecordMetadata dataRecordMetadata, String fileUrl, String delimiter, long recordFrom, long recordCount, String fields) {
-		if (mode == null) return null;
-		Node writer = null;
-		String[] aFiealds = fields == null ? null : fields.split(";");
-		
-		if (mode.equals(Mode.HTML)) {
-			StringBuilder maskBuilder = new StringBuilder();
-			if (aFiealds == null) {
-				maskBuilder.append("<tr>");
-				for (int i=0;i<dataRecordMetadata.getNumFields();i++){
-					maskBuilder.append("<td>$");
-					maskBuilder.append(dataRecordMetadata.getField(i).getName());
-					maskBuilder.append("</td>");
-				}
-				maskBuilder.append("</tr>\n");
-			} else if (aFiealds.length > 0) {
-				maskBuilder.append("<tr>");
-				for (String sfield: aFiealds){
-					if (dataRecordMetadata.getField(sfield) == null) {
-						System.err.println("Field name '"+ sfield + "' not found.");
-						System.exit(-1);
-					}
-					maskBuilder.append("<td>$");
-					maskBuilder.append(sfield);
-					maskBuilder.append("</td>");
-				}
-				maskBuilder.append("</tr>\n");
-			} else {
-				System.err.println("No field found.");
-				System.exit(-1);
-			}
-			
-			StructureWriter structureWriter = new StructureWriter("STRUCTURE_WRITER0", fileUrl, null, false, maskBuilder.toString());
-			structureWriter.setRecordFrom(recordFrom);
-			structureWriter.setRecordCount(recordCount);
-			StringBuilder sb = new StringBuilder();
-			
-			sb.append("<table name=\"" + dataRecordMetadata.getName() + "\" border=1>\n");
-			sb.append("<tr>");
-			if (aFiealds == null ) {
-				for (int i=0;i<dataRecordMetadata.getNumFields();i++){
-					sb.append("<th>");
-					sb.append(dataRecordMetadata.getField(i).getName());
-					sb.append("</th>");
-				}
-			} else {
-				for (String sfield: aFiealds){
-					sb.append("<th>");
-					sb.append(dataRecordMetadata.getField(sfield).getName());
-					sb.append("</th>");
-				}
-			}
-			sb.append("</tr>\n");
-			structureWriter.setHeader(sb.toString());
-			
-			sb = new StringBuilder();
-			sb.append("</table>\n");
-			structureWriter.setFooter(sb.toString());
-			
-			writer = structureWriter;
-			
-		} else if (mode.equals(Mode.TEXT)) {
-			DataWriter dataWriter = new DataWriter("DATA_WRITER0", fileUrl, dataRecordMetadata.getLocaleStr(), false);
-			//TODO agata dodelat selekci na fieldy
-			dataWriter.setRecordFrom(recordFrom);
-			dataWriter.setRecordCount(recordCount);
-			if (delimiter != null) dataWriter.setDataDelimiter(delimiter);
-			writer = dataWriter;
-			
-		} else if (mode.equals(Mode.DELIMITER_TEXT)) {
-			TextWriter dataWriter = new TextWriter("TEXT_TABLE_WRITER0", fileUrl, null, false, aFiealds);
-			dataWriter.setRecordFrom(recordFrom);
-			dataWriter.setRecordCount(recordCount);
-			dataWriter.setHeader(true);
-			
-			writer = dataWriter;
-			/*   +--+--+
-				 |  |  |
-			     +--+--+
-			*/
-		}
-		return writer;
-	}
-	
-	private static void printHelp() {
-		System.out.println("Usage: runGraph [-(v|cfg|P:|info|plugins|pass)] <graph definition file> <component id>");
-		System.out.println("Options:");
-		System.out.println("-v\t\t\tbe verbose - print even graph layout");
-		System.out.println("-P:<key>=<value>\tadd definition of property to global graph's property list");
-		System.out.println("-cfg <filename>\t\tload definitions of properties from specified file");
-		System.out.println("-info\t\t\tprint info about Clover library version");
-        System.out.println("-plugins\t\tdirectory where to look for plugins/components");
-        System.out.println("-pass\t\tpassword for decrypting of hidden connections passwords");
-        System.out.println();
-        System.out.println("Note: <graph definition file> can be either local filename or URL of local/remote file");
-	}
-
-	private static void printInfo(){
-	    System.out.println("CloverETL library version "+JetelVersion.MAJOR_VERSION+"."+JetelVersion.MINOR_VERSION+" build#"+JetelVersion.BUILD_NUMBER+" compiled "+JetelVersion.LIBRARY_BUILD_DATETIME);
-	}
-	
-	public enum Mode {
-	    
-	    TEXT,
-	    HTML,
-	    DELIMITER_TEXT;
-
-	    public static Mode valueModeOf(String value){
-	    	if (value.equalsIgnoreCase(TEXT.name())) {
-	    		return TEXT;
-	    	}
-	    	if (value.equalsIgnoreCase(HTML.name())) {
-	    		return HTML;
-	    	}
-	    	if (value.equalsIgnoreCase(DELIMITER_TEXT.name())) {
-	    		return DELIMITER_TEXT;
-	    	}
-	    	return null;
-	    }
-	    
-	}
-	
-}
-

Added: trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java	2007-02-01 14:30:21 UTC (rev 2429)
+++ trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java	2007-02-01 14:47:34 UTC (rev 2430)
@@ -0,0 +1,620 @@
+/*
+ *  jETeL/Clover - Java based ETL application framework.
+ *  Copyright (C) 2002-03  David Pavlis
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License as published by the Free Software Foundation; either
+ *    version 2.1 of the License, or (at your option) any later version.
+ *    
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
+ *    Lesser General Public License for more details.
+ *    
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+package org.jetel.main;
+
+import java.io.BufferedInputStream;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.Map;
+import java.util.Properties;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.commons.cli.ParseException;
+import org.apache.commons.cli.PosixParser;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.log4j.Level;
+import org.apache.log4j.Logger;
+import org.apache.log4j.net.SocketAppender;
+import org.jetel.component.DataWriter;
+import org.jetel.component.ExtFilter;
+import org.jetel.component.StructureWriter;
+import org.jetel.component.TextWriter;
+import org.jetel.data.Defaults;
+import org.jetel.exception.ConfigurationStatus;
+import org.jetel.exception.GraphConfigurationException;
+import org.jetel.exception.XMLConfigurationException;
+import org.jetel.graph.Edge;
+import org.jetel.graph.Node;
+import org.jetel.graph.Phase;
+import org.jetel.graph.Result;
+import org.jetel.graph.TransformationGraph;
+import org.jetel.graph.TransformationGraphXMLReaderWriter;
+import org.jetel.metadata.DataRecordMetadata;
+import org.jetel.plugin.Plugins;
+import org.jetel.util.FileUtils;
+import org.jetel.util.JetelVersion;
+import org.jetel.util.crypto.Enigma;
+
+/**
+ *  class for reading and showing data over input components<br><br>
+ *  The graph layout is read from specified XML file and over component id is written data to output.<br>
+ *  <tt><pre>
+ *  Program parameters:
+ *  <table>
+ *  <tr><td nowrap>-v</td><td>be verbose - print even graph layout</td></tr>
+ *  <tr><td nowrap>-P<i>properyName</i>=<i>propertyValue</i></td><td>add definition of property to global graph's property list</td></tr>
+ *  <tr><td nowrap>--cfg <i>filename</i></td><td>load definitions of properties from specified file</td></tr>
+ *  <tr><td nowrap>--tracking <i>seconds</i></td><td>how frequently output the processing status</td></tr>
+ *  <tr><td nowrap>--info</td><td>print info about Clover library version</td></tr>
+ *  <tr><td nowrap>--plugins <i>filename</i></td><td>directory where to look for plugins/components</td></tr>
+ *  <tr><td nowrap>--pass <i>password</i></td><td>password for decrypting of hidden connections passwords</td></tr>
+ *  <tr><td nowrap>--stdin</td><td>load graph layout from STDIN</td></tr>
+ *  <tr><td nowrap>--mode</td><td>how show data over component {TEXT,HTML,DELIMITER_TEXT}</td></tr>
+ *  <tr><td nowrap>--delimiter</td><td>delimiter between two fields</td></tr>
+ *  <tr><td nowrap>--file</td><td>file url for output. If no file defined, output is set to System.out</td></tr>
+ *  <tr><td nowrap>--expFilter</td><td>filter expression for record filtering</td></tr>
+ *  <tr><td nowrap>--recFrom</td><td>from where show records</td></tr>
+ *  <tr><td nowrap>--recCount</td><td>how many records should be showed</td></tr>
+ *  <tr><td nowrap>--fields</td><td>Show only defined fields. If no fields defined, show all fields</td></tr>
+ *  <tr><td nowrap>--logLevel</td><td>Log level for logger {all, info, debug, ..}, default is error log level</td></tr>
+ *  <tr><td nowrap><b>filename</b></td><td>filename or URL of the file (even remote) containing graph's layout in XML (this must be the last parameter passed)</td></tr>
+ *  <tr><td nowrap><b>component id</b></td><td>over this component will be showed data</td></tr>
+ *  </table>
+ *
+ *  <h4>Example:</h4>
+ *  <pre>showComponentData ExampleGraph.grf DELIMITED_DATA_READER0:0</pre>
+ *  
+ *  <pre>showComponentData --plugins ../cloveretl.engine/plugins --mode TEXT --delimiter "+" --expFilter "1==1" --recFrom 2 --recCount 2 --fields "Field1;Field0" ExampleGraph.grf DELIMITED_DATA_READER0:0</pre>
+ *  
+ *  </pre></tt>
+ * @author      jausperger
+ * @since       2007/02/02
+ * @revision    $Revision:  $
+ */
+public class showComponentData {
+    private static Log logger = LogFactory.getLog(showComponentData.class);
+
+    //TODO change run graph version
+	private final static String RUN_GRAPH_VERSION = "2.0";
+	
+    /**
+     * Clover.ETL engine initialization. Should be called only once.
+     * @param pluginsRootDirectory directory path, where plugins specification is located 
+     *        (can be null, then is used constant from Defaults.DEFAULT_PLUGINS_DIRECTORY)
+     * @param password password for encrypting some hidden part of graphs
+     *        <br>i.e. connections passwordss can be encrypted
+     */        int trackingInterval = -1;
+
+    public static void initEngine(String pluginsRootDirectory, String password) {
+        
+        //init password decryptor
+        if(password != null) {
+            Enigma.getInstance().init(password);
+        }
+        
+        //init framework constants
+        Defaults.init();
+
+        //init clover plugins system
+        Plugins.init(pluginsRootDirectory);
+    }
+    
+    
+    /**
+     * Instantiates transformation graph from a given input stream and presets a given properties.
+     * @param inStream
+     * @param properties
+     * @return
+     * @throws XMLConfigurationException
+     * @throws GraphConfigurationException
+     */
+    public static TransformationGraph loadGraph(InputStream inStream, Properties properties) throws XMLConfigurationException, GraphConfigurationException {
+        TransformationGraph graph = new TransformationGraph();
+        TransformationGraphXMLReaderWriter graphReader = new TransformationGraphXMLReaderWriter(graph);
+        if(properties != null) {
+            graph.loadGraphProperties(properties);
+        }
+
+        graphReader.read(inStream);
+        
+        return graph;
+    }
+    
+	/**
+	 *  Description of the Method
+	 *
+	 * @param  args  Description of the Parameter
+	 */
+	public static void main(String args[]) {
+		boolean verbose = false;
+        boolean loadFromSTDIN = false;
+		Properties properties = new Properties();
+        int trackingInterval = -1;
+		String pluginsRootDirectory = null;
+        String password = null;
+        Mode viewMode = Mode.TEXT;
+        String delimiter = null;
+        String fileUrl = null;
+        String filterExpression = null;
+        long recordFrom = -1;
+        long recordCount = -1;
+        String fields = null;
+        String logHost = null;
+		
+		ExtFilter extFilter = null;
+        
+		System.out.println("***  CloverETL graph component tester ver "+RUN_GRAPH_VERSION+", (c) 2002-06 D.Pavlis, released under GNU Lesser General Public License  ***");
+		System.out.println(" Running with framework version: "+JetelVersion.MAJOR_VERSION+"."+JetelVersion.MINOR_VERSION+" build#"+JetelVersion.BUILD_NUMBER+" compiled "+JetelVersion.LIBRARY_BUILD_DATETIME);
+		System.out.println();
+        
+		if (args.length < 1) {
+			printHelp();
+			System.exit(-1);
+		}
+        
+		Options options = new Options();
+    	options.addOption(new Option("v", "verbose", false, "Verbose mode"));
+    	options.addOption(new Option("g", "cfg", true, "Path to property file"));
+    	options.addOption(new Option("P", "propertyDefinition", true, "Property defined by user"));
+    	options.addOption(new Option("t", "tracking", false, "Tracking intrnal switch"));
+    	options.addOption(new Option("i", "info", false, "Information about program"));
+    	options.addOption(new Option("n", "stdin", false, "Load from stdin switch"));
+    	options.addOption(new Option("h", "loghost", false, "Log host switch"));
+    	options.addOption(new Option("p", "plugins", true, "Path to plugins file."));
+    	options.addOption(new Option("s", "pass", true, "Password"));
+    	options.addOption(new Option("m", "mode", true, "View mode"));
+    	options.addOption(new Option("d", "delimiter", true, "Delimiter between two fields"));
+    	options.addOption(new Option("o", "file", true, "File url for output. If no file defined, output is set to System.out"));
+    	options.addOption(new Option("e", "expFilter", true, "Filter expression for record filtering"));
+    	options.addOption(new Option("f", "recFrom", true, "From where show records"));
+    	options.addOption(new Option("c", "recCount", true, "Count of records"));
+    	options.addOption(new Option("l", "fields", true, "Show only defined fields. If no fields defined, show all fields"));
+    	options.addOption(new Option("x", "logLevel", true, "Log level for logger {all, info, debug, ..}, default is error log level"));
+
+    	PosixParser optParser = new PosixParser();
+    	CommandLine cmdLine;
+		try {
+			cmdLine = optParser.parse(options, args);
+		} catch (ParseException e) {
+			logger.error(e.getMessage(), e);
+			return;
+		}
+		
+		verbose = cmdLine.hasOption("v");
+		loadFromSTDIN = cmdLine.hasOption("n");
+		if (cmdLine.hasOption("h")) {
+            String[] hostAndPort = logHost.split(":");
+            if (hostAndPort[0].length() == 0 || hostAndPort.length > 2) {
+                System.err
+                        .println("Invalid log destination, i.e. -loghost localhost:4445");
+                System.exit(-1);
+            }
+            int port = 4445;
+            try {
+                if (hostAndPort.length == 2) {
+                    port = Integer.parseInt(hostAndPort[1]);
+                }
+            } catch (NumberFormatException e) {
+                System.err
+                        .println("Invalid log destination, i.e. -loghost localhost:4445");
+                System.exit(-1);
+            }
+            Logger.getRootLogger().addAppender(
+                    new SocketAppender(hostAndPort[0], port));
+		}
+		if (cmdLine.hasOption("g")) {
+			InputStream inStream;
+			try {
+				inStream = new BufferedInputStream(new FileInputStream(cmdLine.getOptionValue("g")));
+				properties.load(inStream);
+			} catch (NullPointerException e) {
+				logger.error("cfg file not found: " + e.getMessage(), e);
+				System.exit(-1);
+			} catch (IOException e) {
+				logger.error(e.getMessage(), e);
+				System.exit(-1);
+			}
+		}
+		if (cmdLine.hasOption("P")) {
+	    	String a[] = cmdLine.getOptionValue("P").split(";");
+	    	for (String tmp : a) {
+	    	    properties.setProperty(tmp.substring(0,tmp.indexOf("=")),tmp.substring(tmp.indexOf("=") +1)); 
+	    	}
+		}
+		if (cmdLine.hasOption("i")) {
+		    printInfo();
+		    System.exit(0);
+		}
+		if (cmdLine.hasOption("t")) {
+            try {
+                trackingInterval = Integer.parseInt(cmdLine.getOptionValue("t"));
+            } catch (NumberFormatException ex) {
+                System.err.println("Invalid tracking parameter: \""
+                        + cmdLine.getOptionValue("t") + "\"");
+                System.exit(-1);
+            }
+		}
+		if (cmdLine.hasOption("p")) {
+			pluginsRootDirectory = cmdLine.getOptionValue("p");
+		}
+		if (cmdLine.hasOption("s")) {
+			password = cmdLine.getOptionValue("s");
+		}
+		if (cmdLine.hasOption("m")) {
+			viewMode = Mode.valueModeOf(cmdLine.getOptionValue("m"));
+	        if (viewMode == null) {
+				System.err.println("Unknown mode option: "+cmdLine.getOptionValue("m"));
+				System.exit(-1);
+	        }
+		}
+		if (cmdLine.hasOption("d")) {
+			delimiter = cmdLine.getOptionValue("d");
+		}
+		if (cmdLine.hasOption("o")) {
+			fileUrl = cmdLine.getOptionValue("o");
+		}
+		if (cmdLine.hasOption("e")) {
+			filterExpression = cmdLine.getOptionValue("e");
+		}
+		if (cmdLine.hasOption("f")) {
+	    	recordFrom = Long.parseLong(cmdLine.getOptionValue("f"));
+		}
+		if (cmdLine.hasOption("c")) {
+	    	recordCount = Long.parseLong(cmdLine.getOptionValue("c"));
+		}
+		if (cmdLine.hasOption("l")) {
+        	fields = cmdLine.getOptionValue("l");
+		}
+		Logger.getRootLogger().setLevel(cmdLine.hasOption("x")?Level.toLevel(cmdLine.getOptionValue("x")):Level.ERROR);
+		
+        // setup log4j appenders
+        if (logHost != null) {
+            String[] hostAndPort = logHost.split(":");
+            if (hostAndPort[0].length() == 0 || hostAndPort.length > 2) {
+                System.err
+                        .println("Invalid log destination, i.e. -loghost localhost:4445");
+                System.exit(-1);
+            }
+            int port = 4445;
+            try {
+                if (hostAndPort.length == 2) {
+                    port = Integer.parseInt(hostAndPort[1]);
+                }
+            } catch (NumberFormatException e) {
+                System.err
+                        .println("Invalid log destination, i.e. -loghost localhost:4445");
+                System.exit(-1);
+            }
+            Logger.getRootLogger().addAppender(
+                    new SocketAppender(hostAndPort[0], port));
+        }
+        
+        // engine initialization - should be called only once
+        runGraph.initEngine(pluginsRootDirectory, password);
+
+        // prapere input stream with XML graph definition
+        InputStream in = null;
+        if (loadFromSTDIN) {
+            System.out.println("Graph definition loaded from STDIN");
+            in = System.in;
+        } else {
+            System.out.println("Graph definition file: "
+                    + args[args.length - 2]);
+            try {
+                URL fileURL = FileUtils.getFileURL(null, args[args.length - 2]);
+                in = fileURL.openStream();
+            } catch (IOException e) {
+                System.err
+                        .println("Error - graph definition file can't be read: "
+                                + e.getMessage());
+                System.exit(-1);
+            }
+        }
+        
+        System.out.println("Component id: " + args[args.length - 1]);
+        String componentID = args[args.length - 1];
+        int pos;
+        int port = 0;
+        if ((pos = componentID.indexOf(':')) != -1) {
+        	port = Integer.parseInt(componentID.substring(pos+1));
+        	componentID = componentID.substring(0, pos);
+        }
+
+        // loading graph from the input stream
+        TransformationGraph graph = null;
+        try {
+            graph = runGraph.loadGraph(in, properties);
+
+            // check graph elements configuration
+            logger.info("Checking graph configuration...");
+            try {
+                ConfigurationStatus status = graph.checkConfig(null);
+                status.log();
+            } catch(Exception e) {
+                logger.error("Checking graph failed! (" + e.getMessage() + ")");
+            }
+
+            if (!graph.init()) {
+                throw new GraphConfigurationException(
+                        "Graph initialization failed.");
+            }
+
+            if (verbose) {
+                // this can be called only after graph.init()
+                graph.dumpGraphConfiguration();
+            }
+        } catch (XMLConfigurationException ex) {
+            logger.error("Error in reading graph from XML !", ex);
+            if (verbose) {
+                ex.printStackTrace(System.err);
+            }
+            System.exit(-1);
+        } catch (GraphConfigurationException ex) {
+            logger.error("Error - graph's configuration invalid !", ex);
+            if (verbose) {
+                ex.printStackTrace(System.err);
+            }
+            System.exit(-1);
+        } catch (RuntimeException ex) {
+            logger.error("Error during graph initialization !", ex);
+            if (verbose) {
+                ex.printStackTrace(System.err);
+            }
+            System.exit(-1);
+        }
+        
+
+        //check graph elements configuration
+        ConfigurationStatus status = graph.checkConfig(null);
+        status.log();
+        
+		Map map = graph.getNodes();
+		Node node = (Node) map.get(componentID);
+		if (node == null) {
+			//map = graph.getEdges();
+			//Edge edge = (Edge) map.get(componentID);
+			//if (edge == null) {
+				// error
+				logger.error("Component Id '"+ componentID +"' not found!");
+				return;
+			//}
+		}
+		if (!node.isRoot()) {
+			// not implemented
+			System.err.println("Execution is implemented for root node (root node has only output ports connected)!");
+			return;
+		}
+
+		// create new graph
+	    TransformationGraph viewGraph = new TransformationGraph();
+		Phase _PHASE_1 = new Phase(1);
+
+	    // add writer component
+		DataRecordMetadata dataRecordMetadata = (DataRecordMetadata) node.getOutMetadata().toArray()[port];
+		Edge edge0 = new Edge("EDGE0", dataRecordMetadata);
+		Edge edge1 = null;
+		if (filterExpression != null) {
+			edge1 = new Edge("EDGE1", dataRecordMetadata);
+		}
+		Node writer = getWriter(viewMode, dataRecordMetadata, fileUrl, delimiter, recordFrom, recordCount, fields);
+		
+		// add Edges & Nodes & Phases to graph
+		try {
+			viewGraph.addPhase(_PHASE_1);
+			viewGraph.addEdge(edge0);
+			_PHASE_1.addNode(node);
+			_PHASE_1.addNode(writer);
+			
+			if (filterExpression != null) {
+				viewGraph.addEdge(edge1);
+				extFilter = new ExtFilter("ExtFilter0");
+				extFilter.setFilterExpression(filterExpression);
+				_PHASE_1.addNode(extFilter);
+			}
+		} catch (GraphConfigurationException e) {
+			e.printStackTrace();
+		}
+
+		// assign ports (input & output)
+		node.addOutputPort(0,edge0);
+		if (filterExpression != null) {
+			extFilter.addInputPort(0,edge0);
+			extFilter.addOutputPort(0,edge1);
+			writer.addInputPort(0,edge1); 
+		} else {
+			writer.addInputPort(0,edge0);
+		}
+
+		if(!viewGraph.init()){
+			System.err.println("Graph initialization failed !");
+			return;
+		}
+	    
+        // set tracking interval
+        if (trackingInterval != -1) {
+        	viewGraph.setTrackingInterval(trackingInterval * 1000);
+        }
+
+        //	start all Nodes (each node is one thread)
+		Result result=Result.N_A;
+		try {
+            result = viewGraph.run();
+        } catch (RuntimeException ex) {
+            System.err.println("Fatal error during graph run !");
+            System.err.println(ex.getCause().getMessage());
+            if (verbose) {
+                ex.printStackTrace();
+            }
+            System.exit(-1);
+        }
+        switch (result) {
+
+        case FINISHED_OK:
+            // everything O.K.
+            System.out.println("Execution of graph successful !");
+            System.exit(0);
+            break;
+        case ABORTED:
+            // execution was ABORTED !!
+            System.err.println("Execution of graph aborted !");
+            System.exit(result.code());
+            break;
+        default:
+            System.err.println("Execution of graph failed !");
+            System.exit(result.code());
+        }
+
+	}
+    
+	private static Node getWriter(Mode mode, DataRecordMetadata dataRecordMetadata, String fileUrl, String delimiter, long recordFrom, long recordCount, String fields) {
+		if (mode == null) return null;
+		Node writer = null;
+		String[] aFiealds = fields == null ? null : fields.split(";");
+		
+		if (mode.equals(Mode.HTML)) {
+			StringBuilder maskBuilder = new StringBuilder();
+			if (aFiealds == null) {
+				maskBuilder.append("<tr>");
+				for (int i=0;i<dataRecordMetadata.getNumFields();i++){
+					maskBuilder.append("<td>$");
+					maskBuilder.append(dataRecordMetadata.getField(i).getName());
+					maskBuilder.append("</td>");
+				}
+				maskBuilder.append("</tr>\n");
+			} else if (aFiealds.length > 0) {
+				maskBuilder.append("<tr>");
+				for (String sfield: aFiealds){
+					if (dataRecordMetadata.getField(sfield) == null) {
+						System.err.println("Field name '"+ sfield + "' not found.");
+						System.exit(-1);
+					}
+					maskBuilder.append("<td>$");
+					maskBuilder.append(sfield);
+					maskBuilder.append("</td>");
+				}
+				maskBuilder.append("</tr>\n");
+			} else {
+				System.err.println("No field found.");
+				System.exit(-1);
+			}
+			
+			StructureWriter structureWriter = new StructureWriter("STRUCTURE_WRITER0", fileUrl, null, false, maskBuilder.toString());
+			structureWriter.setRecordFrom(recordFrom);
+			structureWriter.setRecordCount(recordCount);
+			StringBuilder sb = new StringBuilder();
+			
+			sb.append("<table name=\"" + dataRecordMetadata.getName() + "\" border=1>\n");
+			sb.append("<tr>");
+			if (aFiealds == null ) {
+				for (int i=0;i<dataRecordMetadata.getNumFields();i++){
+					sb.append("<th>");
+					sb.append(dataRecordMetadata.getField(i).getName());
+					sb.append("</th>");
+				}
+			} else {
+				for (String sfield: aFiealds){
+					sb.append("<th>");
+					sb.append(dataRecordMetadata.getField(sfield).getName());
+					sb.append("</th>");
+				}
+			}
+			sb.append("</tr>\n");
+			structureWriter.setHeader(sb.toString());
+			
+			sb = new StringBuilder();
+			sb.append("</table>\n");
+			structureWriter.setFooter(sb.toString());
+			writer = structureWriter;
+			
+		} else if (mode.equals(Mode.TEXT)) {
+			DataWriter dataWriter = new DataWriter("DATA_WRITER0", fileUrl, dataRecordMetadata.getLocaleStr(), false);
+			//TODO agata dodelat selekci na fieldy
+			dataWriter.setRecordFrom(recordFrom);
+			dataWriter.setRecordCount(recordCount);
+			if (delimiter != null) dataWriter.setDataDelimiter(delimiter);
+			writer = dataWriter;
+			
+		} else if (mode.equals(Mode.DELIMITER_TEXT)) {
+			TextWriter dataWriter = new TextWriter("TEXT_TABLE_WRITER0", fileUrl, null, false, aFiealds);
+			dataWriter.setRecordFrom(recordFrom);
+			dataWriter.setRecordCount(recordCount);
+			dataWriter.setHeader(true);
+			writer = dataWriter;
+		}
+		return writer;
+	}
+	
+	private static void printHelp() {
+		System.out.println("Usage: runGraph [-(v|P)] [--(cfg|tracking|info|plugins|pass|loghost|mode|delimiter|file|expFilter|recFrom|recCount|fields|logLevel)] <graph definition file> <component id>");
+		System.out.println("Options:");
+		System.out.println("-v\t\t\tbe verbose - print even graph layout");
+		System.out.println("-P:<key>=<value>\tadd definition of property to global graph's property list");
+		System.out.println("--cfg <filename>\t\tload definitions of properties from specified file");
+		System.out.println("--tracking <seconds>\thow frequently output the graph processing status");
+		System.out.println("--info\t\t\tprint info about Clover library version");
+        System.out.println("--plugins\t\tdirectory where to look for plugins/components");
+        System.out.println("--pass\t\tpassword for decrypting of hidden connections passwords");
+        System.out.println("--stdin\t\tload graph definition from STDIN");
+        System.out.println("--loghost\t\tdefine host and port number for socket appender of log4j (log4j library is required); i.e. localhost:4445");
+        System.out.println("--mode\t\thow show data over component {TEXT,HTML,DELIMITER_TEXT}");
+        System.out.println("--delimiter\t\tdelimiter between two fields");
+        System.out.println("--file\t\tfile url for output. If no file defined, output is set to System.out");
+        System.out.println("--expFilter\t\tfilter expression for record filtering");
+        System.out.println("--recFrom\t\tfrom where show records");
+        System.out.println("--recCount\t\thow many records should be showed");
+        System.out.println("--fields\t\tShow only defined fields. If no fields defined, show all fields");
+        System.out.println("--logLevel\t\tLog level for logger {all, info, debug, ..}, default is error log level");
+        System.out.println();
+        System.out.println("Note: <graph definition file> can be either local filename or URL of local/remote file");
+        System.out.println("Note: <component id> over this component will be showed data");
+	}
+
+	private static void printInfo(){
+	    System.out.println("CloverETL library version "+JetelVersion.MAJOR_VERSION+"."+JetelVersion.MINOR_VERSION+" build#"+JetelVersion.BUILD_NUMBER+" compiled "+JetelVersion.LIBRARY_BUILD_DATETIME);
+	}
+
+	public enum Mode {
+	    
+	    TEXT,
+	    HTML,
+	    DELIMITER_TEXT;
+
+	    public static Mode valueModeOf(String value){
+	    	if (value.equalsIgnoreCase(TEXT.name())) {
+	    		return TEXT;
+	    	}
+	    	if (value.equalsIgnoreCase(HTML.name())) {
+	    		return HTML;
+	    	}
+	    	if (value.equalsIgnoreCase(DELIMITER_TEXT.name())) {
+	    		return DELIMITER_TEXT;
+	    	}
+	    	return null;
+	    }
+	    
+	}
+	
+}
+



From cloveretl-svn-commits at lists.berlios.de  Thu Feb  1 15:53:00 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 1 Feb 2007 15:53:00 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2431 -
	trunk/cloveretl.engine/lib
Message-ID: <200702011453.l11Er0VC003315@sheep.berlios.de>

Author: ausperger
Date: 2007-02-01 15:52:58 +0100 (Thu, 01 Feb 2007)
New Revision: 2431

Added:
   trunk/cloveretl.engine/lib/commons-cli-1.0.jar
Log:
FIX: jar to showComponentData

Added: trunk/cloveretl.engine/lib/commons-cli-1.0.jar
===================================================================
(Binary files differ)


Property changes on: trunk/cloveretl.engine/lib/commons-cli-1.0.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From cloveretl-svn-commits at lists.berlios.de  Mon Feb  5 16:00:03 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Mon, 5 Feb 2007 16:00:03 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2432 -
	trunk/cloveretl.lookup/src/org/jetel/lookup
Message-ID: <200702051500.l15F03N2005820@sheep.berlios.de>

Author: otasanek
Date: 2007-02-05 16:00:02 +0100 (Mon, 05 Feb 2007)
New Revision: 2432

Modified:
   trunk/cloveretl.lookup/src/org/jetel/lookup/SimpleLookupTable.java
Log:
FIX: SimpleLookupTable.fromXML() doesn't call parser.init() and use FileUtils and contextURL for file file path resolving.

Modified: trunk/cloveretl.lookup/src/org/jetel/lookup/SimpleLookupTable.java
===================================================================
--- trunk/cloveretl.lookup/src/org/jetel/lookup/SimpleLookupTable.java	2007-02-01 14:52:58 UTC (rev 2431)
+++ trunk/cloveretl.lookup/src/org/jetel/lookup/SimpleLookupTable.java	2007-02-05 15:00:02 UTC (rev 2432)
@@ -43,6 +43,7 @@
 import org.jetel.metadata.DataFieldMetadata;
 import org.jetel.metadata.DataRecordMetadata;
 import org.jetel.util.ComponentXMLAttributes;
+import org.jetel.util.FileUtils;
 import org.w3c.dom.Element;
 
 /**
@@ -76,12 +77,12 @@
     
 	protected DataRecordMetadata metadata;
 	protected Parser dataParser;
-	protected Map lookupTable;
+	protected Map<HashKey, DataRecord> lookupTable;
 	protected RecordKey indexKey;
 	protected HashKey lookupKey;
 	protected int numFound;
 	protected DataRecord lookupData;
-	protected int tableInitialSize=0;
+	protected int tableInitialSize=DEFAULT_INITIAL_CAPACITY;
 	
 	/**
 	* Default capacity of HashMap when standard constructor is used.
@@ -111,13 +112,13 @@
 	/**
 	 *Constructor for the SimpleLookupTable object.
 	 *
-	 * @param  parser     Reference to parser which should be used for parsing input data
+	 * @param  parser     Reference to not-initialized parser which should be used for parsing input data
 	 * @param  metadata   Metadata describing input data
 	 * @param  keys       Names of fields which comprise indexKey to lookup table
 	 * @param  mapObject  Object implementing Map interface. It will be used to hold indexKey->data pairs
 	 * @since             May 2, 2002
 	 */
-	public SimpleLookupTable(String id, DataRecordMetadata metadata, String[] keys, Parser parser, Map mapObject) {
+	public SimpleLookupTable(String id, DataRecordMetadata metadata, String[] keys, Parser parser, Map<HashKey, DataRecord> mapObject) {
         super(id);
 		this.dataParser = parser;
 		this.metadata = metadata;
@@ -158,7 +159,7 @@
 	}
 	
 	protected DataRecord get(){
-	    DataRecord data=(DataRecord)lookupTable.get(lookupKey);
+	    DataRecord data = lookupTable.get(lookupKey);
 	    numFound= (data!=null ? 1 : 0);
 	    return data;
 	}
@@ -176,23 +177,20 @@
 	    record.init();
 		
 	    if (lookupTable==null){
-	        if (tableInitialSize>0){
-	            lookupTable = new HashMap(tableInitialSize);
-	        }else{
-	            lookupTable = new HashMap(DEFAULT_INITIAL_CAPACITY);
-	        }
+	        lookupTable = new HashMap<HashKey, DataRecord>(tableInitialSize);
 	    }
+        
 		/* populate the lookupTable (Map) with data
          * if provided dataParser is not null, otherwise it is assumed that the lookup
          * table will be populated later by calling put() method
          */
         
         if (dataParser != null) {
+            dataParser.init(metadata);
             try {
                 while (dataParser.getNext(record) != null) {
                     DataRecord storeRecord = record.duplicate();
-                    lookupTable.put(new HashKey(indexKey, storeRecord),
-                            storeRecord);
+                    lookupTable.put(new HashKey(indexKey, storeRecord), storeRecord);
                 }
             } catch (JetelException e) {
                 throw new ComponentNotReadyException(this, e.getMessage(), e);
@@ -235,9 +233,8 @@
             } else {
                 parser = new FixLenCharDataParser(xattribs.getString(XML_CHARSET, Defaults.DataParser.DEFAULT_CHARSET_DECODER));
             }
-            parser.init(metadata);
             if (xattribs.exists(XML_FILE_URL)) {
-            	parser.setDataSource(new FileInputStream(xattribs.getString(XML_FILE_URL)));
+            	parser.setDataSource(FileUtils.getReadableChannel(graph.getProjectURL(), xattribs.getString(XML_FILE_URL)));
             }else{
             	parser = null;
             }



From cloveretl-svn-commits at lists.berlios.de  Mon Feb  5 16:05:18 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Mon, 5 Feb 2007 16:05:18 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2433 -
	branches/cloveretl.engine.rel-2-1-0/cloveretl.lookup/src/org/jetel/lookup
Message-ID: <200702051505.l15F5IZl007289@sheep.berlios.de>

Author: otasanek
Date: 2007-02-05 16:05:17 +0100 (Mon, 05 Feb 2007)
New Revision: 2433

Modified:
   branches/cloveretl.engine.rel-2-1-0/cloveretl.lookup/src/org/jetel/lookup/SimpleLookupTable.java
Log:
FIX: SimpleLookupTable.fromXML() doesn't call parser.init() and use FileUtils and contextURL for file file path resolving.

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.lookup/src/org/jetel/lookup/SimpleLookupTable.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.lookup/src/org/jetel/lookup/SimpleLookupTable.java	2007-02-05 15:00:02 UTC (rev 2432)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.lookup/src/org/jetel/lookup/SimpleLookupTable.java	2007-02-05 15:05:17 UTC (rev 2433)
@@ -43,6 +43,7 @@
 import org.jetel.metadata.DataFieldMetadata;
 import org.jetel.metadata.DataRecordMetadata;
 import org.jetel.util.ComponentXMLAttributes;
+import org.jetel.util.FileUtils;
 import org.w3c.dom.Element;
 
 /**
@@ -76,12 +77,12 @@
     
 	protected DataRecordMetadata metadata;
 	protected Parser dataParser;
-	protected Map lookupTable;
+	protected Map<HashKey, DataRecord> lookupTable;
 	protected RecordKey indexKey;
 	protected HashKey lookupKey;
 	protected int numFound;
 	protected DataRecord lookupData;
-	protected int tableInitialSize=0;
+	protected int tableInitialSize=DEFAULT_INITIAL_CAPACITY;
 	
 	/**
 	* Default capacity of HashMap when standard constructor is used.
@@ -111,13 +112,13 @@
 	/**
 	 *Constructor for the SimpleLookupTable object.
 	 *
-	 * @param  parser     Reference to parser which should be used for parsing input data
+	 * @param  parser     Reference to not-initialized parser which should be used for parsing input data
 	 * @param  metadata   Metadata describing input data
 	 * @param  keys       Names of fields which comprise indexKey to lookup table
 	 * @param  mapObject  Object implementing Map interface. It will be used to hold indexKey->data pairs
 	 * @since             May 2, 2002
 	 */
-	public SimpleLookupTable(String id, DataRecordMetadata metadata, String[] keys, Parser parser, Map mapObject) {
+	public SimpleLookupTable(String id, DataRecordMetadata metadata, String[] keys, Parser parser, Map<HashKey, DataRecord> mapObject) {
         super(id);
 		this.dataParser = parser;
 		this.metadata = metadata;
@@ -158,7 +159,7 @@
 	}
 	
 	protected DataRecord get(){
-	    DataRecord data=(DataRecord)lookupTable.get(lookupKey);
+	    DataRecord data = lookupTable.get(lookupKey);
 	    numFound= (data!=null ? 1 : 0);
 	    return data;
 	}
@@ -176,23 +177,20 @@
 	    record.init();
 		
 	    if (lookupTable==null){
-	        if (tableInitialSize>0){
-	            lookupTable = new HashMap(tableInitialSize);
-	        }else{
-	            lookupTable = new HashMap(DEFAULT_INITIAL_CAPACITY);
-	        }
+	        lookupTable = new HashMap<HashKey, DataRecord>(tableInitialSize);
 	    }
+        
 		/* populate the lookupTable (Map) with data
          * if provided dataParser is not null, otherwise it is assumed that the lookup
          * table will be populated later by calling put() method
          */
         
         if (dataParser != null) {
+            dataParser.init(metadata);
             try {
                 while (dataParser.getNext(record) != null) {
                     DataRecord storeRecord = record.duplicate();
-                    lookupTable.put(new HashKey(indexKey, storeRecord),
-                            storeRecord);
+                    lookupTable.put(new HashKey(indexKey, storeRecord), storeRecord);
                 }
             } catch (JetelException e) {
                 throw new ComponentNotReadyException(this, e.getMessage(), e);
@@ -235,9 +233,8 @@
             } else {
                 parser = new FixLenCharDataParser(xattribs.getString(XML_CHARSET, Defaults.DataParser.DEFAULT_CHARSET_DECODER));
             }
-            parser.init(metadata);
             if (xattribs.exists(XML_FILE_URL)) {
-            	parser.setDataSource(new FileInputStream(xattribs.getString(XML_FILE_URL)));
+            	parser.setDataSource(FileUtils.getReadableChannel(graph.getProjectURL(), xattribs.getString(XML_FILE_URL)));
             }else{
             	parser = null;
             }



From cloveretl-svn-commits at lists.berlios.de  Tue Feb  6 12:12:36 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 6 Feb 2007 12:12:36 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2434 -
	trunk/cloveretl.engine/src/org/jetel/component
Message-ID: <200702061112.l16BCaJC021038@sheep.berlios.de>

Author: agad
Date: 2007-02-06 12:12:33 +0100 (Tue, 06 Feb 2007)
New Revision: 2434

Modified:
   trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java
Log:
UPDATE:new implementation with usage Rule class and its descendants

Modified: trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java	2007-02-05 15:05:17 UTC (rev 2433)
+++ trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java	2007-02-06 11:12:33 UTC (rev 2434)
@@ -20,17 +20,10 @@
 
 package org.jetel.component;
 
-import java.text.DateFormat;
-import java.text.DecimalFormat;
-import java.text.DecimalFormatSymbols;
-import java.text.Format;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
-import java.util.Locale;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Map.Entry;
@@ -39,11 +32,9 @@
 
 import org.apache.commons.logging.Log;
 import org.jetel.data.DataField;
+import org.jetel.data.DataFieldFactory;
 import org.jetel.data.DataRecord;
-import org.jetel.data.Defaults;
-import org.jetel.data.primitive.DecimalFactory;
 import org.jetel.data.primitive.Numeric;
-import org.jetel.data.primitive.NumericFormat;
 import org.jetel.data.sequence.Sequence;
 import org.jetel.exception.BadDataFormatException;
 import org.jetel.exception.ComponentNotReadyException;
@@ -53,7 +44,6 @@
 import org.jetel.metadata.DataFieldMetadata;
 import org.jetel.metadata.DataRecordMetadata;
 import org.jetel.util.StringUtils;
-import org.jetel.util.TypedProperties;
 import org.jetel.util.WcardPattern;
 
 /**
@@ -247,13 +237,11 @@
 	/**
 	 * Map "rules" stores rules given by user in following form:
 	 * key: patternOut
-	 * value: ruleType:ruleString, where ruleType is one of: Rule.FIELD, Rule.CONSTANT,
-	 * 	Rule.SEQUENCE, Rule.PARAMETER, and ruleString can be patternIn, constant, sequence ID
-	 * 	(optionally with method) or parameter name 
+	 * value: proper descendant of Rule class
 	 */
-	protected Map<String, String> rules = new LinkedHashMap<String, String>();
+	protected Map<String, Rule> rules = new LinkedHashMap<String, Rule>();
 	protected Rule[][] transformMapArray;//rules from "rules" map translated for concrete metadata
-	protected int[][] order;//order for assigning output fields (importent if assigning sequence values)
+	protected int[][] order;//order for assigning output fields (important if assigning sequence values)
 	
 	protected static final int REC_NO = 0;
 	protected static final int FIELD_NO = 1;
@@ -269,11 +257,8 @@
 	protected final static String FIELD_OPCODE_REGEX = "\\$\\{in\\.(.*)\\}";
 	protected final static Pattern FIELD_PATTERN = Pattern.compile(FIELD_OPCODE_REGEX);
 	
-	private	 int ruleType;
-	private String ruleString;
-	private String sequenceID;
+	private Object value;
 
-
 	/**
 	 * @param logger
 	 */
@@ -288,7 +273,7 @@
 	 * @param patternIn input field's pattern
 	 */
 	public void addFieldToFieldRule(String patternOut, String patternIn) {
-		rules.put(patternOut, String.valueOf(Rule.FIELD) + COLON + patternIn);
+		rules.put(patternOut, new FieldRule(patternIn));
 	}
 
 	/**
@@ -364,11 +349,8 @@
 	 * @param patternOut output fields' pattern
 	 * @param value value to assign (can be string representation of any type)
 	 */
-	public void addConstantToFieldRule(String patternOut, String value){
-		if (value == null) {
-			value = "null";
-		}
-		rules.put(patternOut, String.valueOf(Rule.CONSTANT) + COLON + value);
+	public void addConstantToFieldRule(String patternOut, String source){
+		rules.put(patternOut, new ConstantRule(source));
 	}
 	
 	/**
@@ -378,7 +360,7 @@
 	 * @param value value to assign
 	 */
 	public void addConstantToFieldRule(String patternOut, int value){
-		rules.put(patternOut, String.valueOf(Rule.CONSTANT) + COLON + value);
+		rules.put(patternOut, new ConstantRule(value));
 	}
 	
 	/**
@@ -388,7 +370,7 @@
 	 * @param value value to assign
 	 */
 	public void addConstantToFieldRule(String patternOut, long value){
-		rules.put(patternOut, String.valueOf(Rule.CONSTANT) + COLON + value);
+		rules.put(patternOut, new ConstantRule(value));
 	}
 
 	/**
@@ -398,7 +380,7 @@
 	 * @param value value to assign
 	 */
 	public void addConstantToFieldRule(String patternOut, double value){
-		rules.put(patternOut,String.valueOf(Rule.CONSTANT) + COLON + value);
+		rules.put(patternOut, new ConstantRule(value));
 	}
 
 	/**
@@ -408,12 +390,7 @@
 	 * @param value value to assign
 	 */
 	public void addConstantToFieldRule(String patternOut, Date value){
-		if (value == null) {
-			rules.put(patternOut, "null");
-		}else{
-			rules.put(patternOut, String.valueOf(Rule.CONSTANT) + COLON + 
-						SimpleDateFormat.getDateInstance().format(value));
-		}
+		rules.put(patternOut,  new ConstantRule(value));
 	}
 
 	/**
@@ -423,11 +400,7 @@
 	 * @param value value to assign
 	 */
 	public void addConstantToFieldRule(String patternOut, Numeric value){
-		if (value == null) {
-			rules.put(patternOut, "null");
-		}else{
-			rules.put(patternOut, String.valueOf(Rule.CONSTANT) + COLON + value);
-		}
+		rules.put(patternOut,  new ConstantRule(value));
 	}
 
 	/**
@@ -435,10 +408,10 @@
 	 * 
 	 * @param recNo output record's number
 	 * @param fieldNo output record's field number
-	 * @param value value value to assign (can be string representation of any type)
+	 * @param source value value to assign (can be string representation of any type)
 	 */
-	public void addConstantToFieldRule(int recNo, int fieldNo, String value){
-		addConstantToFieldRule(String.valueOf(recNo) + DOT + fieldNo, value);
+	public void addConstantToFieldRule(int recNo, int fieldNo, String source){
+		addConstantToFieldRule(String.valueOf(recNo) + DOT + fieldNo, source);
 	}
 
 	/**
@@ -501,10 +474,10 @@
 	 * 
 	 * @param recNo output record's number
 	 * @param fieldNo output record's field name
-	 * @param value value value to assign (can be string representation of any type)
+	 * @param source value value to assign (can be string representation of any type)
 	 */
-	public void addConstantToFieldRule(int recNo, String field, String value){
-		addConstantToFieldRule(String.valueOf(recNo) + DOT + field, value);
+	public void addConstantToFieldRule(int recNo, String field, String source){
+		addConstantToFieldRule(String.valueOf(recNo) + DOT + field, source);
 	}
 
 	/**
@@ -566,10 +539,10 @@
 	 * Mathod for adding constant assigning to output fields from 0th output record rule
 	 * 
 	 * @param fieldNo output record's field number
-	 * @param value value value to assign (can be string representation of any type)
+	 * @param source value value to assign (can be string representation of any type)
 	 */
-	public void addConstantToFieldRule(int fieldNo, String value){
-		addConstantToFieldRule(0, fieldNo, value);
+	public void addConstantToFieldRule(int fieldNo, String source){
+		addConstantToFieldRule(0, fieldNo, source);
 	}
 
 	/**
@@ -634,7 +607,7 @@
 		String sequenceString = sequence.startsWith("${") ? 
 				sequence.substring(sequence.indexOf(DOT)+1, sequence.length() -1) 
 				: sequence;
-		rules.put(patternOut, String.valueOf(Rule.SEQUENCE) + COLON + sequenceString);
+		rules.put(patternOut, new SequenceRule(sequenceString));
 	}
 	
 	/**
@@ -682,7 +655,7 @@
 	 * @param sequence sequence for getting value
 	 */
 	public void addSequenceToFieldRule(String patternOut, Sequence sequence){
-		addSequenceToFieldRule(patternOut, sequence.getId());
+		rules.put(patternOut, new SequenceRule(sequence));
 	}
 	
 	/**
@@ -693,7 +666,7 @@
 	 * @param sequence sequence for getting value
 	 */
 	public void addSequenceToFieldRule(int recNo, int fieldNo, Sequence sequence){
-		addSequenceToFieldRule(String.valueOf(recNo) + DOT + fieldNo, sequence.getId());
+		addSequenceToFieldRule(String.valueOf(recNo) + DOT + fieldNo, sequence);
 	}
 	
 	/**
@@ -704,7 +677,7 @@
 	 * @param sequence sequence for getting value
 	 */
 	public void addSequenceToFieldRule(int recNo, String field, Sequence sequence){
-		addSequenceToFieldRule(String.valueOf(recNo) + DOT + field, sequence.getId());
+		addSequenceToFieldRule(String.valueOf(recNo) + DOT + field, sequence);
 	}
 	
 	/**
@@ -714,7 +687,7 @@
 	 * @param sequence sequence for getting value
 	 */
 	public void addSequenceToFieldRule(int fieldNo, Sequence sequence){
-		addSequenceToFieldRule(0,fieldNo, sequence.getId());
+		addSequenceToFieldRule(0,fieldNo, sequence);
 	}
 
 	/**
@@ -727,7 +700,7 @@
 		if (parameterName.indexOf(DOT) > -1 ) {
 			parameterName = parameterName.substring(parameterName.indexOf(DOT) + 1, parameterName.length() -1);
 		}
-		rules.put(patternOut, String.valueOf(Rule.PARAMETER) + COLON + parameterName);
+		rules.put(patternOut, new ParameterRule(parameterName));
 	}
 
 	/**
@@ -797,7 +770,7 @@
 	 * @param patternOut output field pattern for deleting rule
 	 */
 	public void deleteRule(String patternOut){
-		rules.put(patternOut, String.valueOf(Rule.DELETE) + COLON + patternOut);
+		rules.put(patternOut, new DeleteRule());
 	}
 	
 	/**
@@ -808,7 +781,7 @@
 	 */
 	public void deleteRule(int outRecNo, int outFieldNo){
 		String patternOut = String.valueOf(outRecNo) + DOT + outFieldNo;
-		rules.put(patternOut, String.valueOf(Rule.DELETE) + COLON + patternOut);
+		rules.put(patternOut, new DeleteRule());
 	}
 	
 	/**
@@ -819,7 +792,7 @@
 	 */
 	public void deleteRule(int outRecNo, String outField){
 		String patternOut = String.valueOf(outRecNo) + DOT + outField;
-		rules.put(patternOut, String.valueOf(Rule.DELETE) + COLON + patternOut);
+		rules.put(patternOut, new DeleteRule());
 	}
 
 	/**
@@ -829,7 +802,7 @@
 	 */
 	public void deleteRule(int outFieldNo){
 		String patternOut = String.valueOf(0) + DOT + outFieldNo;
-		rules.put(patternOut, String.valueOf(Rule.DELETE) + COLON + patternOut);
+		rules.put(patternOut, new DeleteRule());
 	}
 	
 	public void finished() {
@@ -873,16 +846,16 @@
 		//map storing transformation for concrete output fields
 		//key is in form: recNumber.fieldNumber 
 		Map<String, Rule> transformMap = new LinkedHashMap<String, Rule>();
-		Entry<String, String> rulesEntry;
+		Entry<String, Rule> rulesEntry;
 		Rule rule;
-		int type;
 		String field;
-		String ruleString;
+		String ruleString = null;
 		String[] outFields = new String[0];
 		String[] inFields;
 		//iteration over each user given rule
-		for (Iterator<Entry<String, String>> iterator = rules.entrySet().iterator();iterator.hasNext();){
+		for (Iterator<Entry<String, Rule>> iterator = rules.entrySet().iterator();iterator.hasNext();){
 			rulesEntry = iterator.next();
+			rule = rulesEntry.getValue();
 			//find output fields pattern
 			field = resolveField(rulesEntry.getKey());
 			if (field == null){
@@ -900,19 +873,15 @@
 				
 			}
 			inFields = new String[0];
-			//find type: Rule.FIELD, Rule.CONSTANT,	Rule.SEQUENCE, Rule.PARAMETER
-			type = Integer.parseInt(rulesEntry.getValue().substring(0, rulesEntry.getValue().indexOf(COLON)));
-			//find rule: patternIn, constant, sequence ID (optionally with method) or parameter name
-			ruleString = rulesEntry.getValue().substring(rulesEntry.getValue().indexOf(COLON)+1);
-			if (type == Rule.DELETE){
+			if (rulesEntry.getValue() instanceof DeleteRule){
 				for (int i = 0; i < outFields.length; i++) {
 					rule = transformMap.remove(outFields[i]);
 				}		
 				continue;
 			}
-			if (type == Rule.FIELD) {
+			if (rulesEntry.getValue() instanceof FieldRule) {
 				//find input fields from pattern
-				ruleString = resolveField(ruleString);
+				ruleString = resolveField(rule.getSource());
 				if (ruleString == null){
 					errorMessage = "Wrong pattern for output fields: " + ruleString;
 					logger.error(errorMessage);
@@ -927,9 +896,10 @@
 					
 				}
 			}
-			if (type == Rule.FIELD && inFields.length > 1){
+			if (rulesEntry.getValue() instanceof FieldRule && inFields.length > 1){
 				//find mapping by names
-				if (putMappingByNames(transformMap,outFields,inFields, rulesEntry.getKey() + "=" + rulesEntry.getValue().substring(2)) == 0) {
+				if (putMappingByNames(transformMap, outFields, inFields,
+						rule.getSource()) == 0) {
 					errorMessage = "Not found any field for mapping by names due to rule:\n" + 
 					field + " - output fields pattern\n" + 
 					ruleString + " - input fields pattern";
@@ -937,17 +907,23 @@
 					throw new ComponentNotReadyException(errorMessage);
 				}
 			}else{//for each output field the same rule
-				//for each output field from pattern put rule to map
+				//for each output field from pattern, put rule to map
+				Rule rule1;
 				for (int i=0;i<outFields.length;i++){
 					field = outFields[i];
 					//check if there is just any rule for given output field
-					rule = transformMap.remove(getRecNo(field) + DOT + getFieldNo(field));
-					if (type == Rule.FIELD) {
-						ruleString = inFields[0];
-					}
-					rule = validateRule(getRecNo(field),getFieldNo(field),type,
-							ruleString, rulesEntry.getKey() + "=" + rulesEntry.getValue().substring(2));
-					transformMap.put(outFields[i], rule);
+					transformMap.remove(getRecNo(field) + DOT + getFieldNo(field));
+					rule1 = rule.duplicate();
+//					if (rule1 instanceof FieldRule){
+//						((FieldRule)rule1).setFieldParams(inFields[0]);
+//					}
+					rule1.setGraph(getGraph());
+					rule1.setProperties(parameters);
+					rule1.setLogger(logger);
+					//prepare rule for concrete data field
+					rule1.init(sourceMetadata, targetMetadata,getRecNo(field),
+							getFieldNo(field),fieldPolicy);
+					transformMap.put(field, rule1);
 				}
 			}
 		}
@@ -965,403 +941,8 @@
 		return true;
 	}
 	
-	/**
-	 * This method checks if given rule can be applied to given output field
-	 * 
-	 * @param recNo output record number
-	 * @param fieldNo output record's field number
-	 * @param ruleType type of rule (Rule.FIELD, Rule.CONSTANT,	Rule.SEQUENCE, Rule.PARAMETER)
-	 * @param ruleString
-	 * @return rule with correct parameters
-	 * @throws ComponentNotReadyException
-	 */
-	protected Rule validateRule(int recNo, int fieldNo, int ruleType,String ruleString,
-			String ruleSource) throws ComponentNotReadyException {
-		char fieldType = targetMetadata[recNo].getFieldType(fieldNo);
-		switch (ruleType) {
-		case Rule.PARAMETER:
-			String parameterValue;
-			if (ruleString.startsWith("${")){//get graph parameter
-				parameterValue = getGraph().getGraphProperties().getProperty(
-						ruleString.substring(2, ruleString.lastIndexOf('}')));
-			}else if (ruleString.startsWith(String.valueOf(PARAMETER_CHAR))){
-				//get parameter from node properties
-				parameterValue = parameters.getProperty((ruleString));
-			}else{
-				//try to find parameter with given name in node properties
-				parameterValue = parameters.getProperty(PARAMETER_CHAR + ruleString);
-				if (parameterValue == null ){
-					//try to find parameter with given name among graph parameters 
-					parameterValue = getGraph().getGraphProperties().getProperty(ruleString);
-				}
-				if (parameterValue == null){
-					errorMessage = "Not found parameter: " + ruleString;
-					if (!(targetMetadata[recNo].getField(fieldNo).isNullable() || 
-							targetMetadata[recNo].getField(fieldNo).isDefaultValue())){
-						logger.error(errorMessage);
-						throw new ComponentNotReadyException(errorMessage);
-					}else{
-						logger.warn(errorMessage);
-					}
-				}
-			}
-			//check if parameter value can be set to given field
-			StringBuilder correctParameterValue = new StringBuilder(
-					parameterValue == null ? "null" : parameterValue); 
-			if ((fieldType != DataFieldMetadata.BYTE_FIELD || 
-					fieldType != DataFieldMetadata.BYTE_FIELD_COMPRESSED ||
-					fieldType != DataFieldMetadata.STRING_FIELD ) &&
-					parameterValue != null) {
-				checkConstant(recNo, fieldNo, correctParameterValue);
-			}
-			//change parameter rule to constant rule with parameter value
-			return new Rule(Rule.CONSTANT,correctParameterValue.toString(), ruleSource);
-		case Rule.CONSTANT:
-			if (ruleString.equals("null") && !(targetMetadata[recNo].getField(fieldNo).isNullable() || 
-							targetMetadata[recNo].getField(fieldNo).isDefaultValue())){
-				errorMessage = "Null value not allowed to record: " + targetMetadata[recNo].getName() 
-				+ " , field: " + targetMetadata[recNo].getField(fieldNo).getName();
-				logger.error(errorMessage);
-				throw new ComponentNotReadyException(errorMessage);
-			}
-			//check if constant can be set to given field
-			StringBuilder correctConstant = new StringBuilder(ruleString);
-			if ((fieldType != DataFieldMetadata.BYTE_FIELD ||
-					fieldType != DataFieldMetadata.BYTE_FIELD_COMPRESSED ||
-					fieldType != DataFieldMetadata.STRING_FIELD ) &&
-					ruleString != null) {
-				if (checkConstant(recNo, fieldNo, correctConstant)) {
-					ruleString = correctConstant.toString();
-				}
-			}
-			break;
-		case Rule.SEQUENCE:
-			sequenceID = ruleString.indexOf(DOT) == -1 ? ruleString
-					: ruleString.substring(0, ruleString.indexOf(DOT));
-			Sequence sequence = getGraph().getSequence(sequenceID );
-			if (sequence == null){
-				logger.warn("There is no sequence \"" + sequenceID + "\" in graph");
-				if (!(targetMetadata[recNo].getField(fieldNo).isNullable() || 
-							targetMetadata[recNo].getField(fieldNo).isDefaultValue())){
-					errorMessage = "Null value not allowed to record: " + targetMetadata[recNo].getName() 
-					+ " , field: " + targetMetadata[recNo].getField(fieldNo).getName();
-					logger.error(errorMessage);
-					throw new ComponentNotReadyException(errorMessage);
-				}
-			}
-			//check sequence method
-			String method = ruleString.indexOf(DOT) > -1 ? 
-					ruleString.substring(ruleString.indexOf(DOT) +1) : "nextValueInt()";
-			char methodType = DataFieldMetadata.UNKNOWN_FIELD;
-			if (method.toLowerCase().startsWith("currentvaluestring") || 
-					method.toLowerCase().startsWith("currentstring") || 
-					method.toLowerCase().startsWith("nextvaluestring") || 
-					method.toLowerCase().startsWith("nextstring")){
-				methodType = DataFieldMetadata.STRING_FIELD;
-			}
-			if (method.toLowerCase().startsWith("currentvalueint") || 
-					method.toLowerCase().startsWith("currentint") || 
-					method.toLowerCase().startsWith("nextvalueint") || 
-					method.toLowerCase().startsWith("nextint")){
-				methodType = DataFieldMetadata.INTEGER_FIELD;
-			}
-			if (method.toLowerCase().startsWith("currentvaluelong") || 
-					method.toLowerCase().startsWith("currentlong") || 
-					method.toLowerCase().startsWith("nextvaluelong") || 
-					method.toLowerCase().startsWith("nextlong")){
-				methodType = DataFieldMetadata.LONG_FIELD;
-			}
-			if (methodType == DataFieldMetadata.UNKNOWN_FIELD){
-				errorMessage = "Unknown sequence method: " + method;
-				logger.error(errorMessage);
-				throw new ComponentNotReadyException(errorMessage);
-			}
-			//check if value from sequence can be set to given field
-			if (!checkTypes(fieldType, null, methodType, null)){
-				if (fieldPolicy == PolicyType.STRICT) {
-					errorMessage = "Sequence method:" + ruleString + " does not " +
-							"match field type:\n"+ targetMetadata[recNo].getName() + 
-							DOT + targetMetadata[recNo].getField(fieldNo).getName() + 
-							" type - " + targetMetadata[recNo].getField(fieldNo).getTypeAsString() + 
-							getDecimalParams(targetMetadata[recNo].getField(fieldNo));
-					logger.error(errorMessage);
-					throw new ComponentNotReadyException(errorMessage);
-				}
-				if (fieldPolicy == PolicyType.CONTROLLED){
-					errorMessage = "Sequence method:" + ruleString + " does not " +
-					"match field type:\n"+ targetMetadata[recNo].getName() + 
-					DOT + targetMetadata[recNo].getField(fieldNo).getName() + 
-					" type - " + targetMetadata[recNo].getField(fieldNo).getTypeAsString() + 
-					getDecimalParams(targetMetadata[recNo].getField(fieldNo));
-					logger.error(errorMessage);
-					throw new ComponentNotReadyException(errorMessage);
-				}
-			}
-			break;
-		case Rule.FIELD:
-			//check input and output fields types
-			if (!checkTypes(recNo, fieldNo, getRecNo(ruleString), getFieldNo(ruleString))){
-				if (fieldPolicy == PolicyType.STRICT) {
-					errorMessage = "Output field type does not match input field " +
-							"type:\n" +targetMetadata[recNo].getName() + DOT + 
-							targetMetadata[recNo].getField(fieldNo).getName() + 
-							" type - " + targetMetadata[recNo].getField(fieldNo).getTypeAsString() + 
-							getDecimalParams(targetMetadata[recNo].getField(fieldNo)) + "\n" +
-							sourceMetadata[getRecNo(ruleString)].getName() + DOT +
-							sourceMetadata[getRecNo(ruleString)].getField(getFieldNo(ruleString)).getName() +
-							" type - " + sourceMetadata[getRecNo(ruleString)].getField(getFieldNo(ruleString)).getTypeAsString() +
-							getDecimalParams(sourceMetadata[getRecNo(ruleString)].getField(getFieldNo(ruleString)));
-					logger.error(errorMessage);
-					throw new ComponentNotReadyException(errorMessage);
-				}
-				if (fieldPolicy == PolicyType.CONTROLLED){
-					errorMessage = "Output field type is not compatible with input field " +
-					"type:\n" +targetMetadata[recNo].getName() + DOT + 
-					targetMetadata[recNo].getField(fieldNo).getName() + 
-					" type - " + targetMetadata[recNo].getField(fieldNo).getTypeAsString() + 
-					getDecimalParams(targetMetadata[recNo].getField(fieldNo)) + "\n" +
-					sourceMetadata[getRecNo(ruleString)].getName() + DOT +
-					sourceMetadata[getRecNo(ruleString)].getField(getFieldNo(ruleString)).getName() +
-					" type - " + sourceMetadata[getRecNo(ruleString)].getField(getFieldNo(ruleString)).getTypeAsString() +
-					getDecimalParams(sourceMetadata[getRecNo(ruleString)].getField(getFieldNo(ruleString)));
-					logger.error(errorMessage);
-					throw new ComponentNotReadyException(errorMessage);
-				}
-			}
-		}
-		return new Rule(ruleType,ruleString, ruleSource);
-	}
 	
 	/**
-	 * This method checks if data field of type "inType" is subtype of data field
-	 *  of type "outType". If types are DECIMAL can be check decimal parameters 
-	 *  (LENGTH and SCALE)
-	 * 
-	 * @param outType type to be supertype
-	 * @param outTypeDecimalParams if outType=DataFieldMetadata.DECIMAL_FIELD
-	 * 	represents LENGTH and SCALE
-	 * @param inType type to be subtype
-	 * @param inTypeDEcimalParams if inType=DataFieldMetadata.DECIMAL_FIELD
-	 * 	represents LENGTH and SCALE
-	 * @return "true" if inType is subtype of outType, "false" in other cases
-	 */
-	private boolean checkTypes(char outType, int[] outTypeDecimalParams,
-			char inType, int[] inTypeDEcimalParams){
-		boolean checkTypes;
-		if (outType == inType){
-			//if DECIMAL type check LENGTH and SCALE 
-			if (outType == DataFieldMetadata.DECIMAL_FIELD ){
-				checkTypes = inTypeDEcimalParams[0] <= outTypeDecimalParams[0] && 
-				inTypeDEcimalParams[1] <= outTypeDecimalParams[1];
-			}else{
-				checkTypes = true;
-			}
-		}else {
-			checkTypes = false;
-		}
-		DataFieldMetadata outField = new DataFieldMetadata("out",outType,(short)1);
-		if (outTypeDecimalParams != null){
-			TypedProperties properties = new TypedProperties();
-			properties.put(DataFieldMetadata.LENGTH_ATTR, outTypeDecimalParams[0]);
-			properties.put(DataFieldMetadata.SCALE_ATTR, outTypeDecimalParams[1]);
-			outField.setFieldProperties(properties);
-		}
-		DataFieldMetadata inField = new DataFieldMetadata("out",inType,(short)1);
-		if (inTypeDEcimalParams != null){
-			TypedProperties properties = new TypedProperties();
-			properties.put(DataFieldMetadata.LENGTH_ATTR, inTypeDEcimalParams[0]);
-			properties.put(DataFieldMetadata.SCALE_ATTR, inTypeDEcimalParams[1]);
-			inField.setFieldProperties(properties);
-		}
-		if (fieldPolicy == PolicyType.STRICT && !checkTypes){
-			return false;
-		}else if (fieldPolicy == PolicyType.CONTROLLED && !inField.isSubtype(outField)){
-			return false;
-		}
-		return true;
-	}
-	
-	/**
-	 * This method checks if input field is subtype of output type
-	 * 
-	 * @param outRecNo output record number
-	 * @param outFieldNo output record's field number
-	 * @param inRecNo input record number
-	 * @param inFieldNo input record's field number
-	 * @return "true" if input field is subtype of output field, "false" in other cases
-	 */
-	private boolean checkTypes(int outRecNo, int outFieldNo, int inRecNo, int inFieldNo){
-		DataFieldMetadata outField = targetMetadata[outRecNo].getField(outFieldNo);
-		DataFieldMetadata inField = sourceMetadata[inRecNo].getField(inFieldNo);
-		boolean checkTypes;
-		//check if both fields are of type DECIMAL, if yes inField must be subtype of outField
-		if (outField.getType() == inField.getType()){
-			if (outField.getType() == DataFieldMetadata.DECIMAL_FIELD ){
-				checkTypes = inField.isSubtype(outField);
-			}else{
-				checkTypes = true;
-			}
-		}else {
-			checkTypes = false;
-		}
-		if (fieldPolicy == PolicyType.STRICT && !checkTypes){
-			return false;
-		}else if (fieldPolicy == PolicyType.CONTROLLED && !inField.isSubtype(outField)){
-			return false;
-		}
-		return true;
-	}
-	
-	/**
-	 * Check if constant can be set to given fields. In some cases the method can 
-	 * 	change constant string representation to proper form
-	 * 
-	 * @param recNo output record number
-	 * @param fieldNo output record's field number
-	 * @param constant string representation of constatnt to be checked
-	 * @return "true" if constant can be set to given field. In some cases string
-	 * 	representation of constant can be changed
-	 * @throws ComponentNotReadyException
-	 */
-	private boolean checkConstant(int recNo, int fieldNo, StringBuilder constant) throws ComponentNotReadyException{
-		char type = targetMetadata[recNo].getFieldType(fieldNo);
-		Object value;
-		Format format = null; 
-		//field format string
-        String formatString = targetMetadata[recNo].getField(fieldNo).getFormatStr();
-        Locale locale;
-        // handle field locale
-        if (targetMetadata[recNo].getField(fieldNo).getLocaleStr() != null) {
-            String[] localeLC = targetMetadata[recNo].getField(fieldNo).getLocaleStr()
-            			.split(Defaults.DEFAULT_LOCALE_STR_DELIMITER_REGEX);
-            if (localeLC.length > 1) {
-                locale = new Locale(localeLC[0], localeLC[1]);
-            } else {
-                locale = new Locale(localeLC[0]);
-            }
-        } else {
-            locale = null;
-        }
-		switch (type) {
-		case DataFieldMetadata.DATE_FIELD:
-		case DataFieldMetadata.DATETIME_FIELD:
-			//get date format from locale and format string
-            if ((formatString != null) && (formatString.length() != 0)) {
-                if (locale != null) {
-                    format = new SimpleDateFormat(formatString, locale);
-                } else {
-                    format = new SimpleDateFormat(formatString);
-                }
-                ((DateFormat)format).setLenient(false);
-            } else if (locale != null) {
-            	format = DateFormat.getDateInstance(DateFormat.DEFAULT, locale);
-            	((DateFormat)format).setLenient(false);
-            }else{
-            	format = DateFormat.getDateInstance();
-            	((DateFormat)format).setLenient(false);
-             }
-            try{//parse constant string representation
-            	value = ((SimpleDateFormat)format).parse(constant.toString());
-            }catch(ParseException e){
-            	try {//value could be formatted in method addConstantToFieldRule(String patternOut, Date value)
-                	value = (DateFormat.getDateInstance()).parse(constant.toString());
-                	constant.setLength(0);
-                	//format constatnt with proper format
-                	constant.append(((SimpleDateFormat)format).format((Date)value));
-            	}catch(ParseException e1){
-					errorMessage = e1.getLocalizedMessage() + " to record: " + targetMetadata[recNo].getName() 
-					+ " , field: " + targetMetadata[recNo].getField(fieldNo).getName() + 
-					". Expected pattern: " + ((SimpleDateFormat)format).toPattern();
-					logger.error(errorMessage);
-					throw new ComponentNotReadyException(e);
-            	}
-            }
-			break;
-		case DataFieldMetadata.DECIMAL_FIELD:
-			//get numeric format from locale and format string
-            if ((formatString != null) && (formatString.length() != 0)) {
-                if (locale != null) {
-                    format = new NumericFormat(formatString, new DecimalFormatSymbols(locale));
-                } else {
-                    format = new NumericFormat(formatString);
-                }
-            } else if (locale != null) {
-            	format = new NumericFormat(locale);
-            }else{
-            	format = new NumericFormat();
-            }
-            try{//parse constant string representation
-            	value = DecimalFactory.getDecimal(constant.toString(), (NumericFormat)format);
-            }catch(NullPointerException e){//Can't get BigDecimal from string, try get Number
-               	try {
-                	value = (DecimalFormat.getInstance()).parse(constant.toString());
-                	constant.setLength(0);
-                	//format constatnt with proper format
-                	constant.append(((NumericFormat)format).format(value));
-               	}catch(ParseException e1){
-					errorMessage = e1.getLocalizedMessage() + " to record: " + targetMetadata[recNo].getName() 
-					+ " , field: " + targetMetadata[recNo].getField(fieldNo).getName() +
-					". Expected pattern: " + ((NumericFormat)format).toPattern();
-					logger.error(errorMessage);
-					throw new ComponentNotReadyException(e);
-               	}
-            }
-			break;
-		case DataFieldMetadata.INTEGER_FIELD:
-		case DataFieldMetadata.LONG_FIELD:
-		case DataFieldMetadata.NUMERIC_FIELD:
-			//get decimal format from locale and format string
-            if ((formatString != null) && (formatString.length() != 0)) {
-                if (locale != null) {
-                    format = new DecimalFormat(formatString, new DecimalFormatSymbols(locale));
-                } else {
-                    format = new DecimalFormat(formatString);
-                }
-            } else if (locale != null) {
-            	format = DecimalFormat.getInstance(locale);
-            }else{
-            	format = DecimalFormat.getInstance();
-            }
-            try{//parse constant string representation
-            	value = ((DecimalFormat)format).parse(constant.toString());
-            }catch(ParseException e){
-				try{//value could be formatted in one of method addConstantToFieldRule
-					value = new Long(constant.toString());
-				}catch(NumberFormatException eL){
-					try{
-						value = new Double(constant.toString());
-					}catch(NumberFormatException eD){
-						errorMessage = eD.getLocalizedMessage() + " to record: " + targetMetadata[recNo].getName() 
-						+ " , field: " + targetMetadata[recNo].getField(fieldNo).getName() +
-						". Expected pattern: " + ((DecimalFormat)format).toPattern();
-						logger.error(errorMessage);
-						throw new ComponentNotReadyException(e);
-					}
-				}
-				constant.setLength(0);
-               	constant.append(((DecimalFormat)format).format((Number)value));
-            }
-            if (type == DataFieldMetadata.LONG_FIELD || 
-            		type == DataFieldMetadata.INTEGER_FIELD && 
-            		!(value instanceof Long)){
-				errorMessage = constant + " is not Long type to record: " + targetMetadata[recNo].getName() 
-				+ " , field: " + targetMetadata[recNo].getField(fieldNo).getName();
-				logger.error(errorMessage);
-				throw new ComponentNotReadyException(errorMessage);
-           }
-            if (type == DataFieldMetadata.INTEGER_FIELD && 
-            		((Long)value > Integer.MAX_VALUE || (Long)value < Integer.MIN_VALUE )){
-				errorMessage = constant + " not in range to record: " + targetMetadata[recNo].getName() 
-				+ " , field: " + targetMetadata[recNo].getField(fieldNo).getName();
-				logger.error(errorMessage);
-				throw new ComponentNotReadyException(errorMessage);
-           }
-			break;
-		}
-		return true;
-	}
-	
-	/**
 	 * Method, which puts mapping rules to map. First it tries to find fields with
 	 * 	identical names in corresponding input and output metadata. If not all 
 	 * 	output fields were found it tries to find them in other input records. If
@@ -1393,7 +974,7 @@
 	 * @return number of mappings put to transform map
 	 */
 	protected int putMappingByNames(Map<String, Rule> transformMap, 
-			String[] outFields, String[] inFields, String rule){
+			String[] outFields, String[] inFields, String rule) throws ComponentNotReadyException{
 		int count = 0;
 		String[][] outFieldsName = new String[targetMetadata.length][maxNumFields(targetMetadata)];
 		for (int i = 0; i < outFields.length; i++) {
@@ -1489,9 +1070,10 @@
 	 * @return true if mapping was put into map, false in other case
 	 */
 	protected boolean putMapping(int outRecNo,int outFieldNo,int inRecNo, int inFieldNo, 
-			String ruleString, Map<String, Rule> transformMap){
+			String ruleString, Map<String, Rule> transformMap) throws ComponentNotReadyException{
 		Rule rule;
-		if (!checkTypes(outRecNo, outFieldNo, inRecNo, inFieldNo)){
+		if (!Rule.checkTypes(targetMetadata[outRecNo].getField(outFieldNo),
+				sourceMetadata[inRecNo].getField(inFieldNo),fieldPolicy)){
 			if (fieldPolicy == PolicyType.STRICT){
 				logger.warn("Found fields with the same names but other types: ");
 				logger.warn(targetMetadata[outRecNo].getName() + DOT + 
@@ -1516,14 +1098,11 @@
 			}
 			return false;
 		}else{//map fields
-			rule = transformMap.remove(String.valueOf(outRecNo) + DOT	+ outFieldNo);
-			if (rule == null) {
-				rule = new Rule(Rule.FIELD, String.valueOf(inRecNo)
-						+ DOT + inFieldNo, ruleString);
-			} else {
-				rule.setType(Rule.FIELD);
-				rule.setValue(String.valueOf(inRecNo) + DOT + inFieldNo, ruleString);
-			}
+			transformMap.remove(String.valueOf(outRecNo) + DOT	+ outFieldNo);
+			rule = new FieldRule(ruleString);
+			rule.setLogger(logger);
+			((FieldRule)rule).setFieldParams(String.valueOf(inRecNo) + DOT	+ inFieldNo);
+			rule.init(sourceMetadata, targetMetadata, outRecNo, outFieldNo, fieldPolicy);
 			transformMap.put(String.valueOf(outRecNo) + DOT + outFieldNo, rule);
 			return true;
 		}
@@ -1536,7 +1115,8 @@
 	 * @param metadata
 	 * @return list of fields matching given metadata
 	 */
-	protected ArrayList<String> findFields(String pattern,DataRecordMetadata[] metadata){
+	public static ArrayList<String> findFields(String pattern,
+			DataRecordMetadata[] metadata){
 		ArrayList<String> list = new ArrayList<String>();
 		String recordNoString = pattern.substring(0,pattern.indexOf(DOT));
 		String fieldNoString = pattern.substring(pattern.indexOf(DOT)+1);
@@ -1594,55 +1174,33 @@
 			throws TransformException {
 		//array "order" stores coordinates of output fields in order they will be assigned
 		for (int i = 0; i < order.length; i++) {
-			ruleType = transformMapArray[order[i][REC_NO]][order[i][FIELD_NO]].getType();
-			ruleString = transformMapArray[order[i][REC_NO]][order[i][FIELD_NO]].getValue();
-			switch (ruleType) {
-			case Rule.FIELD:
-				try {
-						target[order[i][REC_NO]].getField(order[i][FIELD_NO]).setValue(
-								transformMapArray[order[i][REC_NO]][order[i][FIELD_NO]].getValue(sources));
-					} catch (BadDataFormatException e) {
-						errorMessage = "Can't set value from field " + 
-							sourceMetadata[getRecNo(transformMapArray[order[i][REC_NO]][order[i][FIELD_NO]].getValue())].getName() + 
-							DOT + targetMetadata[getRecNo(transformMapArray[order[i][REC_NO]][order[i][FIELD_NO]].getValue())].getField(getFieldNo(transformMapArray[order[i][REC_NO]][order[i][FIELD_NO]].getValue())).getName() + 
-							" to field " + targetMetadata[order[i][REC_NO]].getName() + 
-							DOT + targetMetadata[order[i][REC_NO]].getField(order[i][FIELD_NO]).getName() +
-							"\n Genarated by " + transformMapArray[order[i][REC_NO]][order[i][FIELD_NO]].getSource();
-						logger.error(errorMessage);
-						throw new TransformException(errorMessage, e, order[i][REC_NO],order[i][FIELD_NO]);
+			value = transformMapArray[order[i][REC_NO]][order[i][FIELD_NO]]
+					.getValue(sources);
+			try {
+				target[order[i][REC_NO]].getField(order[i][FIELD_NO]).setValue(value);
+			} catch (BadDataFormatException e) {
+				//we can try to change value to String and set to output field
+				if (fieldPolicy != PolicyType.STRICT) {
+					try{
+						target[order[i][REC_NO]].getField(order[i][FIELD_NO])
+								.fromString(value.toString());
+					}catch(BadDataFormatException e1){
+						errorMessage = "TransformException caused by source: " + transformMapArray[order[i][REC_NO]][order[i][FIELD_NO]].getSource();
+						logger.error(errorMessage,e1);
+						throw new TransformException(errorMessage, e1,
+								order[i][REC_NO],order[i][FIELD_NO]);
+					}catch (NullPointerException e1) {
+						errorMessage = "Null value not allowed";
+						logger.error(errorMessage,e1);
+						throw new TransformException(errorMessage, e1,
+								order[i][REC_NO],order[i][FIELD_NO]);
 					}
-				break;
-			case Rule.SEQUENCE:
-				//ruleString can be only sequence ID or with method eg. sequenceID.getNextLongValue()
-				sequenceID = ruleString.indexOf(DOT) == -1 ? ruleString
-						: ruleString.substring(0, ruleString.indexOf(DOT));
-				try {
-						target[order[i][REC_NO]].getField(order[i][FIELD_NO]).fromString(
-								transformMapArray[order[i][REC_NO]][order[i][FIELD_NO]]
-										.getValue(getGraph().getSequence(sequenceID)).toString());
-					} catch (BadDataFormatException e) {
-						errorMessage = "Can't set value from sequence " + sequenceID + 
-							" to field " + targetMetadata[order[i][REC_NO]].getName() + 
-							DOT + targetMetadata[order[i][REC_NO]].getField(order[i][FIELD_NO]).getName() +
-							"\n Genarated by " + transformMapArray[order[i][REC_NO]][order[i][FIELD_NO]].getSource();
-						logger.error(errorMessage);
-						throw new TransformException(errorMessage, e, order[i][REC_NO],order[i][FIELD_NO]);
-					}
-				break;
-			case Rule.PARAMETER://in method init changed to constant
-				break;
-			default:// constant
-					try {
-						target[order[i][REC_NO]].getField(order[i][FIELD_NO]).fromString(ruleString);
-					} catch (BadDataFormatException e) {
-						errorMessage = "Can't set value " + ruleString + 
-						" to field " + targetMetadata[order[i][REC_NO]].getName() + 
-						DOT + targetMetadata[order[i][REC_NO]].getField(order[i][FIELD_NO]).getName() +
-						"\n Genarated by " + transformMapArray[order[i][REC_NO]][order[i][FIELD_NO]].getSource();
-					logger.error(errorMessage);
-					throw new TransformException(errorMessage, e, order[i][REC_NO],order[i][FIELD_NO]);
-					}
-				break;
+				}else{
+					errorMessage = "TransformException caused by source: " + transformMapArray[order[i][REC_NO]][order[i][FIELD_NO]].getSource();
+					logger.error(errorMessage,e);
+					throw new TransformException(errorMessage, e,
+							order[i][REC_NO],order[i][FIELD_NO]);
+				}
 			}
 		}
 		return true;
@@ -1654,7 +1212,7 @@
 	 * @param pattern
 	 * @return pattern in format record.field of null if it is not possible
 	 */
-	protected static String resolveField(String pattern){
+	public static String resolveField(String pattern){
 		String[] parts = pattern.split("\\.");
 		switch (parts.length) {
 		case 2:
@@ -1680,11 +1238,11 @@
 	 */
 	public ArrayList<String> getRules() {
 		ArrayList<String> list = new ArrayList<String>();
-		Entry<String, String> entry;
-		for (Iterator<Entry<String, String>> iterator = rules.entrySet().iterator();iterator.hasNext();) {
+		Entry<String, Rule> entry;
+		for (Iterator<Entry<String, Rule>> iterator = rules.entrySet().iterator();iterator.hasNext();) {
 			entry = iterator.next();
-			list.add(getRuleTypeAsString(Integer.valueOf(entry.getValue().substring(0, 1))) + 
-					":" + entry.getKey() + "=" + entry.getValue().substring(2));
+			list.add(entry.getValue().getType() + ":" + entry.getKey() + "=" + 
+					entry.getValue().getSource());
 		}
 		return list;
 	}
@@ -1696,41 +1254,16 @@
 	 */
 	public ArrayList<String> getResolvedRules() {
 		ArrayList<String> list = new ArrayList<String>();
-		StringBuilder ruleString = new StringBuilder();
-		int recordNumber;
-		int fieldNumber;
+		String value;
 		for (int recNo = 0;recNo < transformMapArray.length; recNo++){
 			for (int fieldNo=0;fieldNo < transformMapArray[0].length; fieldNo++){
 				if (transformMapArray[recNo][fieldNo] != null) {
-					ruleString.setLength(0);
-					switch (transformMapArray[recNo][fieldNo].getType()) {
-					case Rule.FIELD:
-						recordNumber = getRecNo(transformMapArray[recNo][fieldNo].getValue());
-						fieldNumber = getFieldNo(transformMapArray[recNo][fieldNo].getValue());
-						ruleString.append(sourceMetadata[recordNumber].getName());
-						ruleString.append(DOT);
-						ruleString.append(sourceMetadata[recordNumber].getField(fieldNumber).getName());
-						break;
-					case Rule.PARAMETER:
-						if (transformMapArray[recNo][fieldNo].getValue().startsWith("$")) {
-							ruleString.append(transformMapArray[recNo][fieldNo].getValue());
-						}else{
-							ruleString.append("Parameter: ");
-							ruleString.append(transformMapArray[recNo][fieldNo].getValue());
-						}
-						break;
-					case Rule.SEQUENCE:
-						ruleString.append("${seq.");
-						ruleString.append(transformMapArray[recNo][fieldNo].getValue());
-						ruleString.append("}");
-						break;
-					default:
-						ruleString.append(transformMapArray[recNo][fieldNo].getValue());
-						break;
-					}
+					value = transformMapArray[recNo][fieldNo].getCanonicalSource() != null 
+					? transformMapArray[recNo][fieldNo].getCanonicalSource().toString() 
+							: "null";
 					list.add(targetMetadata[recNo].getName() + DOT + 
 							targetMetadata[recNo].getField(fieldNo).getName() + "="
-							+ ruleString);
+							+ value);
 				}				
 			}
 		}
@@ -1764,11 +1297,13 @@
 		String[] inFields = findFields("*.*", sourceMetadata).toArray(new String[0]);
 		Rule rule;
 		int index;
+		String field;
 		for (int recNo = 0;recNo < transformMapArray.length; recNo++){
 			for (int fieldNo=0;fieldNo < transformMapArray[0].length; fieldNo++){
 				rule = transformMapArray[recNo][fieldNo];
-				if (rule != null && rule.getType() == Rule.FIELD) {
-					index = StringUtils.findString(rule.getValue(), inFields);
+				if (rule != null && rule instanceof FieldRule) {
+					field = (String)rule.getCanonicalSource();
+					index = StringUtils.findString(field, inFields);
 					if (index != -1) {
 						inFields[index] = null;
 					}
@@ -1796,7 +1331,7 @@
 		if (rule == null) {
 			return null;
 		}
-		return getRuleTypeAsString(rule.getType()) + COLON + rule.getValue();
+		return (rule.getType()) + COLON + rule.getCanonicalSource();
 	}
 	
 	/**
@@ -1812,9 +1347,9 @@
 		for (int recNo = 0;recNo < transformMapArray.length; recNo++){
 			for (int fieldNo=0;fieldNo < transformMapArray[0].length; fieldNo++){
 				rule = transformMapArray[recNo][fieldNo];
-				if (rule != null && rule.getType() == Rule.FIELD) {
-					if (getRecNo(rule.getValue()) == inRecNo && 
-							getFieldNo(rule.getValue()) == inFieldNo){
+				if (rule != null && rule instanceof FieldRule) {
+					if (getRecNo((String)rule.getCanonicalSource()) == inRecNo && 
+							getFieldNo((String)rule.getCanonicalSource()) == inFieldNo){
 						list.add(new Integer[]{recNo, fieldNo});
 					}
 				}
@@ -1853,7 +1388,7 @@
 	 * @param recField recNo.FieldNo
 	 * @return record number
 	 */
-	private Integer getRecNo(String recField){
+	public static Integer getRecNo(String recField){
 		return Integer.valueOf(recField.substring(0, recField.indexOf(DOT)));
 	}
 	
@@ -1863,7 +1398,7 @@
 	 * @param recField
 	 * @return field number
 	 */
-	private Integer getFieldNo(String recField){
+	public static Integer getFieldNo(String recField){
 		return Integer.valueOf(recField.substring(recField.indexOf(DOT) + 1));
 	}
 	
@@ -1873,7 +1408,7 @@
 	 * @param field
 	 * @return string (LENGTH,SCALE)
 	 */
-	private String getDecimalParams(DataFieldMetadata field){
+	public static String getDecimalParams(DataFieldMetadata field){
 		if (field.getType() != DataFieldMetadata.DECIMAL_FIELD){
 			return "";
 		}
@@ -1885,125 +1420,621 @@
 		params.append(')');
 		return params.toString();
 	}
-	
-	private String getRuleTypeAsString(int type){
-		switch (type) {
-		case Rule.CONSTANT:
-			return Rule.CONSTANT_RULE;
-		case Rule.FIELD:
-			return Rule.FIELD_RULE;
-		case Rule.PARAMETER:
-			return Rule.PARAMETER_RULE;
-		case Rule.SEQUENCE:
-			return Rule.SEQUENCE_RULE;
-		case Rule.DELETE:
-			return Rule.DELETE_RULE;
-		default:
-			return "UNKNOWN_RULE";
-		}
-	}
+}	
 
 	/**
 	 *Private class for storing transformation rules
 	 */
-	private class Rule {
+	 abstract class Rule {
 		
-		//Types of rule
-		final static int FIELD = 0;
-		final static int CONSTANT = 1;
-		final static int SEQUENCE = 2;
-		final static int PARAMETER = 3;
-		final static int DELETE = 9;
-		
-		final static String FIELD_RULE = "FIELD_RULE";
-		final static String CONSTANT_RULE = "CONSTANT_RULE";
-		final static String SEQUENCE_RULE = "SEQUENCE_RULE";
-		final static String PARAMETER_RULE = "PARAMETER_RULE";
-		final static String DELETE_RULE = "DELETE_RULE";
-		
-		int type;
-		String value;
+		Object value;
 		String source;
+		String errorMessage;
+		Log logger;
+		TransformationGraph graph;
+		Properties parameters;
 		
-		Rule(int type, String value, String source){
-			this.type = type;
-			this.value = value;
+		Rule(String source){
 			this.source = source;
 		}
 		
+		Rule(Object value){
+			this.value = value;
+		}
+		
 		String getSource() {
 			return source;
 		}
+		
+		public void setLogger(Log logger) {
+			this.logger = logger;
+		}
+		
+		public void setGraph(TransformationGraph graph){
+			this.graph = graph; 
+		}
+		
+		public void setProperties(Properties parameters){
+			this.parameters = parameters;
+		}
+		
+		abstract Rule duplicate();
+		
+		abstract String getType();
+		
+		abstract Object getCanonicalSource();
 
-		String getValue(){
-			return value;
+		/**
+		 * Gets value for setting to data field
+		 * 
+		 * @param sources source data record (used only in Field rule)
+		 * @return value to be set to data field
+		 */
+		abstract Object getValue(DataRecord[] sources);
+		
+		/**
+		 * Prepares rule (source, value and check if value can be got) for 
+		 * getting values in transform method of CustomizedRecordTransform class
+		 * 
+		 * @param sourceMetadata
+		 * @param targetMetadata
+		 * @param recNo output metadata number (from targetMetadata) 
+		 * @param fieldNo output field number
+		 * @param policy field policy 
+		 * @throws ComponentNotReadyException
+		 */
+		abstract void init(DataRecordMetadata[] sourceMetadata, DataRecordMetadata[] targetMetadata, 
+				int recNo, int fieldNo, PolicyType policy)
+				throws ComponentNotReadyException;
+		/**
+		 * This method checks if input field is subtype of output type
+		 * 
+		 * @param outRecNo output record number
+		 * @param outFieldNo output record's field number
+		 * @param inRecNo input record number
+		 * @param inFieldNo input record's field number
+		 * @return "true" if input field is subtype of output field, "false" in other cases
+		 */
+		public static boolean checkTypes(DataFieldMetadata outField, DataFieldMetadata inField,
+				PolicyType policy){
+			boolean checkTypes;
+			//check if both fields are of type DECIMAL, if yes inField must be subtype of outField
+			if (outField.getType() == inField.getType()){
+				if (outField.getType() == DataFieldMetadata.DECIMAL_FIELD ){
+					checkTypes = inField.isSubtype(outField);
+				}else{
+					checkTypes = true;
+				}
+			}else {
+				checkTypes = false;
+			}
+			if (policy == PolicyType.STRICT && !checkTypes){
+				return false;
+			}else if (policy == PolicyType.CONTROLLED && !inField.isSubtype(outField)){
+				return false;
+			}
+			return true;
 		}
+	}
+	
+	/**
+	 * Descendent of Rule class for storing field's mapping rule
+	 */
+	class FieldRule extends Rule {
 		
-		void setValue(String value, String source){
-			this.value = value;
-			this.source = source;
+		String fieldParams;//"recNo.fieldNo" = "resolved source" - it have to be set by setFieldParams method 
+	
+		FieldRule(String source) {
+			super(source);
 		}
 		
-		int getType() {
-			return type;
+		@Override
+		void init(DataRecordMetadata[] sourceMetadata, DataRecordMetadata[] targetMetadata, 
+				int recNo, int fieldNo, PolicyType policy) throws ComponentNotReadyException {
+			if (fieldParams == null){
+				//try find ONE field in source metadata matching source
+				fieldParams = CustomizedRecordTransform.resolveField(source);
+				ArrayList<String> tmp = 
+					CustomizedRecordTransform.findFields(fieldParams, sourceMetadata);
+				if (tmp.size() != 1){
+					throw new ComponentNotReadyException("Field parameters are " +
+							"not set and can't be resolved from source: " + source);
+				}
+				fieldParams = tmp.get(0);
+			}
+			//check input and output fields types
+			if (!checkTypes(targetMetadata[recNo].getField(fieldNo),
+				sourceMetadata[CustomizedRecordTransform.getRecNo(fieldParams)]
+						.getField(CustomizedRecordTransform
+								.getFieldNo(fieldParams)), policy)) {
+				if (policy == PolicyType.STRICT) {
+					errorMessage = "Output field type does not match input field "
+						+ "type:\n"
+						+ targetMetadata[recNo].getName()
+						+ CustomizedRecordTransform.DOT
+						+ targetMetadata[recNo].getField(fieldNo).getName()
+						+ " type - "
+						+ targetMetadata[recNo].getField(fieldNo)
+								.getTypeAsString()
+						+ CustomizedRecordTransform
+								.getDecimalParams(targetMetadata[recNo]
+										.getField(fieldNo))
+						+ "\n"
+						+ sourceMetadata[CustomizedRecordTransform
+								.getRecNo(fieldParams)].getName()
+						+ CustomizedRecordTransform.DOT
+						+ sourceMetadata[CustomizedRecordTransform
+								.getRecNo(fieldParams)].getField(
+								CustomizedRecordTransform
+										.getFieldNo(fieldParams)).getName()
+						+ " type - "
+						+ sourceMetadata[CustomizedRecordTransform
+								.getRecNo(fieldParams)].getField(
+								CustomizedRecordTransform
+										.getFieldNo(fieldParams))
+								.getTypeAsString()
+						+ CustomizedRecordTransform
+								.getDecimalParams(sourceMetadata[CustomizedRecordTransform
+										.getRecNo(fieldParams)]
+										.getField(CustomizedRecordTransform
+												.getFieldNo(fieldParams)));
+					logger.error(errorMessage);
+					throw new ComponentNotReadyException(errorMessage);
+				}
+				if (policy == PolicyType.CONTROLLED){
+					errorMessage = "Output field type is not compatible with input field "
+						+ "type:\n"
+						+ targetMetadata[recNo].getName()
+						+ CustomizedRecordTransform.DOT
+						+ targetMetadata[recNo].getField(fieldNo).getName()
+						+ " type - "
+						+ targetMetadata[recNo].getField(fieldNo)
+								.getTypeAsString()
+						+ CustomizedRecordTransform
+								.getDecimalParams(targetMetadata[recNo]
+										.getField(fieldNo))
+						+ "\n"
+						+ sourceMetadata[CustomizedRecordTransform
+								.getRecNo(fieldParams)].getName()
+						+ CustomizedRecordTransform.DOT
+						+ sourceMetadata[CustomizedRecordTransform
+								.getRecNo(fieldParams)].getField(
+								CustomizedRecordTransform
+										.getFieldNo(fieldParams)).getName()
+						+ " type - "
+						+ sourceMetadata[CustomizedRecordTransform
+								.getRecNo(fieldParams)].getField(
+								CustomizedRecordTransform
+										.getFieldNo(fieldParams))
+								.getTypeAsString()
+						+ CustomizedRecordTransform
+								.getDecimalParams(sourceMetadata[CustomizedRecordTransform
+										.getRecNo(fieldParams)]
+										.getField(CustomizedRecordTransform
+												.getFieldNo(fieldParams)));
+					logger.error(errorMessage);
+					throw new ComponentNotReadyException(errorMessage);
+				}
+			}
 		}
+		
+		public void setFieldParams(String fieldParams) {
+			this.fieldParams = fieldParams;
+		}
 
-		void setType(int type) {
-			this.type = type;
+		@Override
+		Object getCanonicalSource() {
+			return fieldParams;
 		}
 
-		/**
-		 * When rule type is FIELD it means that "value" is in form recNo.fieldNo,
-		 * 	where <i> recNo</i> and <i>fieldNo</i> are integers. This method gets 
-		 *  proper data field from proper record
+		@Override
+		String getType() {
+			return "FIELD_RULE";
+		}
+
+		/* 
+		 * (non-Javadoc)
+		 * @see org.jetel.component.Rule#getValue(org.jetel.data.DataRecord[])
 		 * 
-		 * @param records
-		 * @return proper data field from proper record
 		 */
-		DataField getValue(DataRecord[] records){
-			int dotIndex = value.indexOf(CustomizedRecordTransform.DOT);
-			int recNo = dotIndex > -1 ? Integer.parseInt(value.substring(0, dotIndex)) : 0;
-			int fieldNo = dotIndex > -1 ? Integer.parseInt(value.substring(dotIndex + 1)) : Integer.parseInt(value); 
-			return records[recNo].getField(fieldNo);
+		Object getValue(DataRecord[] sources){
+			int dotIndex = fieldParams.indexOf(CustomizedRecordTransform.DOT);
+			int recNo = dotIndex > -1 ? Integer.parseInt(fieldParams.substring(0, dotIndex)) : 0;
+			int fieldNo = dotIndex > -1 ? Integer.parseInt(fieldParams.substring(dotIndex + 1)) : Integer.parseInt(fieldParams); 
+			return sources[recNo].getField(fieldNo).getValue();
 		}
 		
-		/**
-		 * When rule type is SEQUENCE it means that "value" stores sequence Id 
-		 * 	optionally with method name. If method name is lacking there is used
-		 * 	nextValueInt() method. This method gets proper value from sequence.
-		 * 
-		 * @param sequence
-		 * @return value from sequence
-		 * @throws TransformException 
+		@Override
+		Rule duplicate() {
+			return new FieldRule(source);
+		}
+	}
+	
+
+	/**
+	 * Descendent of Rule class for storing sequence rule
+	 */
+	class SequenceRule extends Rule{
+		
+		String method;// sequence Id with one of squence method used for
+						// getting value from sequence eg.:
+						// seq1.nextValueString()
+		
+		SequenceRule(String source) {
+			super(source);
+		}
+		
+		SequenceRule(Object value){
+			super(value);
+			if (!(value instanceof Sequence)){
+				throw new IllegalArgumentException("Sequence rule doesn't accept " + value.getClass().getName() + " argument");
+			}
+			source = ((Sequence)value).getId();
+		}
+		
+		@Override
+		Rule duplicate() {
+			if (value != null) {
+				return new SequenceRule(value);
+			}else{
+				return new SequenceRule(source);
+			}
+		}
+		
+		@Override
+		String getType() {
+			return "SEQUENCE_RULE";
+		}
+
+		@Override
+		Object getCanonicalSource() {
+			return method;
+		}
+		
+		@Override
+		void init(DataRecordMetadata[] sourceMetadata,
+			DataRecordMetadata[] targetMetadata, int recNo, int fieldNo,
+			PolicyType policy) throws ComponentNotReadyException {
+		//prepare sequence and method
+		String sequenceID = source.indexOf(CustomizedRecordTransform.DOT) == -1 ? source
+				: source.substring(0, source.indexOf(CustomizedRecordTransform.DOT));
+		if (value == null) {
+			value = graph.getSequence(sequenceID);
+		}
+		if (value == null) {
+			logger.warn("There is no sequence \"" + sequenceID + "\" in graph");
+			if (!(targetMetadata[recNo].getField(fieldNo).isNullable() || targetMetadata[recNo]
+					.getField(fieldNo).isDefaultValue())) {
+				errorMessage = "Null value not allowed to record: "
+						+ targetMetadata[recNo].getName() + " , field: "
+						+ targetMetadata[recNo].getField(fieldNo).getName();
+				logger.error(errorMessage);
+				throw new ComponentNotReadyException(errorMessage);
+			}else{
+				method = "null";
+				return;
+			}
+		}
+		// check sequence method
+		String method = source.indexOf(CustomizedRecordTransform.DOT) > -1 ? source
+				.substring(source.indexOf(CustomizedRecordTransform.DOT) + 1)
+				: null;
+		char methodType = DataFieldMetadata.UNKNOWN_FIELD;
+		if (method != null) {
+			this.method = method;
+			if (method.toLowerCase().startsWith("currentvaluestring")
+					|| method.toLowerCase().startsWith("currentstring")
+					|| method.toLowerCase().startsWith("nextvaluestring")
+					|| method.toLowerCase().startsWith("nextstring")) {
+				methodType = DataFieldMetadata.STRING_FIELD;
+			}
+			if (method.toLowerCase().startsWith("currentvalueint")
+					|| method.toLowerCase().startsWith("currentint")
+					|| method.toLowerCase().startsWith("nextvalueint")
+					|| method.toLowerCase().startsWith("nextint")) {
+				methodType = DataFieldMetadata.INTEGER_FIELD;
+			}
+			if (method.toLowerCase().startsWith("currentvaluelong")
+					|| method.toLowerCase().startsWith("currentlong")
+					|| method.toLowerCase().startsWith("nextvaluelong")
+					|| method.toLowerCase().startsWith("nextlong")) {
+				methodType = DataFieldMetadata.LONG_FIELD;
+			}
+		} else {//method is not given, prepare the best
+			switch (targetMetadata[recNo].getField(fieldNo).getType()) {
+			case DataFieldMetadata.BYTE_FIELD:
+			case DataFieldMetadata.BYTE_FIELD_COMPRESSED:
+			case DataFieldMetadata.STRING_FIELD:
+				this.method = sequenceID + CustomizedRecordTransform.DOT
+						+ "nextValueString()";
+				methodType = DataFieldMetadata.STRING_FIELD;
+				break;
+			case DataFieldMetadata.DECIMAL_FIELD:
+			case DataFieldMetadata.LONG_FIELD:
+			case DataFieldMetadata.NUMERIC_FIELD:
+				this.method = sequenceID + CustomizedRecordTransform.DOT
+						+ "nextValueLong()";
+				methodType = DataFieldMetadata.LONG_FIELD;
+				break;
+			case DataFieldMetadata.INTEGER_FIELD:
+				this.method = sequenceID + CustomizedRecordTransform.DOT
+						+ "nextValueInt()";
+				methodType = DataFieldMetadata.INTEGER_FIELD;
+				break;
+			default:
+				errorMessage = "Can't set sequence to data field of type: "
+						+ targetMetadata[recNo].getField(fieldNo).getTypeAsString();
+				logger.error(errorMessage);
+				throw new ComponentNotReadyException(errorMessage);
+			}
+			DataFieldMetadata tmp;
+			if (methodType == DataFieldMetadata.UNKNOWN_FIELD) {
+				errorMessage = "Unknown sequence method: " + method;
+				logger.error(errorMessage);
+				throw new ComponentNotReadyException(errorMessage);
+			} else {
+				tmp = new DataFieldMetadata("tmp", methodType, ";");
+			}
+			// check if value from sequence can be set to given field
+			if (!checkTypes(targetMetadata[recNo].getField(fieldNo), tmp, policy)) {
+				if (policy == PolicyType.STRICT) {
+					errorMessage = "Sequence method:"
+							+ this.method
+							+ " does not "
+							+ "match field type:\n"
+							+ targetMetadata[recNo].getName()
+							+ CustomizedRecordTransform.DOT
+							+ targetMetadata[recNo].getField(fieldNo).getName()
+							+ " type - "
+							+ targetMetadata[recNo].getField(fieldNo)
+									.getTypeAsString()
+							+ CustomizedRecordTransform
+									.getDecimalParams(targetMetadata[recNo]
+											.getField(fieldNo));
+					logger.error(errorMessage);
+					throw new ComponentNotReadyException(errorMessage);
+				}
+				if (policy == PolicyType.CONTROLLED) {
+					errorMessage = "Sequence method:"
+							+ this.method
+							+ " does not "
+							+ "match field type:\n"
+							+ targetMetadata[recNo].getName()
+							+ CustomizedRecordTransform.DOT
+							+ targetMetadata[recNo].getField(fieldNo).getName()
+							+ " type - "
+							+ targetMetadata[recNo].getField(fieldNo)
+									.getTypeAsString()
+							+ CustomizedRecordTransform
+									.getDecimalParams(targetMetadata[recNo]
+											.getField(fieldNo));
+					logger.error(errorMessage);
+					throw new ComponentNotReadyException(errorMessage);
+				}
+			}
+		}
+	}
+		
+		/* (non-Javadoc)
+		 * @see org.jetel.component.Rule#getValue(org.jetel.data.DataRecord[])
 		 */
-		Object getValue(Sequence sequence){
-			if (sequence == null){
+		Object getValue(DataRecord[] sources){
+			if (value == null) {
 				return null;
 			}
-			int dotIndex = value.indexOf(CustomizedRecordTransform.DOT);
-			String method = dotIndex > -1 ? value.substring(dotIndex +1) : "nextValueInt()";
+			int dotIndex = method.indexOf(CustomizedRecordTransform.DOT);
+			String method = this.method.substring(dotIndex +1);
 			if (method.toLowerCase().startsWith("currentvaluestring") || method.toLowerCase().startsWith("currentstring")){
-				return sequence.currentValueString();
+				return ((Sequence)value).currentValueString();
 			}
 			if (method.toLowerCase().startsWith("nextvaluestring") || method.toLowerCase().startsWith("nextstring")){
-				return sequence.nextValueString();
+				return ((Sequence)value).nextValueString();
 			}
 			if (method.toLowerCase().startsWith("currentvalueint") || method.toLowerCase().startsWith("currentint")){
-				return sequence.currentValueInt();
+				return ((Sequence)value).currentValueInt();
 			}
 			if (method.toLowerCase().startsWith("nextvalueint") || method.toLowerCase().startsWith("nextint")){
-				return sequence.nextValueInt();
+				return ((Sequence)value).nextValueInt();
 			}
 			if (method.toLowerCase().startsWith("currentvaluelong") || method.toLowerCase().startsWith("currentlong")){
-				return sequence.currentValueLong();
+				return ((Sequence)value).currentValueLong();
 			}
 			if (method.toLowerCase().startsWith("nextvaluelong") || method.toLowerCase().startsWith("nextlong")){
-				return sequence.nextValueLong();
+				return ((Sequence)value).nextValueLong();
 			}
 			//in method validateRule checked, that has to be one of method above
 			return null;
 		}
+
+				
+	}
+	
+	/**
+	 * Descendent of Rule class for storing constant rule
+	 */
+	class ConstantRule extends Rule{
+
+		/**
+		 * Constructor for setting constant as string
+		 * 
+		 * @param source
+		 */
+		ConstantRule(String source) {
+			super(source);
+		}
 		
+		/**
+		 * Constructor for setting constant as expected Object (due to data field type)
+		 * 
+		 * @param value
+		 */
+		ConstantRule(Object value) {
+			super(value);
+		}
+		
+		@Override
+		Rule duplicate() {
+			if (value != null) {
+				return new ConstantRule(value);
+			}else{
+				return new ConstantRule(source);
+			}
+		}
+		
+		@Override
+		String getType() {
+			return "CONSTANT_RULE";
+		}
+
+		@Override
+		Object getCanonicalSource() {
+			return source != null ? source : value;
+		}
+		
+		@Override
+		Object getValue(DataRecord[] sources) {
+			return value;
+		}
+
+		@Override
+		void init(DataRecordMetadata[] sourceMetadata,
+			DataRecordMetadata[] targetMetadata, int recNo, int fieldNo,
+			PolicyType policy) throws ComponentNotReadyException {
+			//used temporary data field for checking constant
+			DataField tmp = DataFieldFactory.createDataField(
+					targetMetadata[recNo].getField(fieldNo), true);
+			if (source != null) {
+				try {
+					tmp.fromString(source);
+					value = tmp.getValue();
+				}catch(BadDataFormatException e){
+					errorMessage = e.getLocalizedMessage();
+					logger.error(errorMessage);
+					throw new ComponentNotReadyException(errorMessage);
+				}
+			}else{
+				try{
+					tmp.setValue(value);
+					source = tmp.toString();
+				}catch(BadDataFormatException e){
+					errorMessage = e.getLocalizedMessage();
+					logger.error(errorMessage);
+					throw new ComponentNotReadyException(errorMessage);
+				}
+			}
+		}
+		
 	}
+	
+	/**
+	 * Descendent of Rule class for storing parameter rule
+	 */
+	class ParameterRule extends Rule{
 
-}
+		ParameterRule( String source) {
+			super(source);
+		}
+		
+		@Override
+		Rule duplicate() {
+			return new ParameterRule(source);
+		}
+		
+		@Override
+		String getType() {
+			return "PARAMETER_RULE";
+		}
+
+		@Override
+		Object getCanonicalSource() {
+			return source;
+		}
+		
+		@Override
+		Object getValue(DataRecord[] sources) {
+			return value;
+		}
+		
+		@Override
+		void init(DataRecordMetadata[] sourceMetadata, DataRecordMetadata[] targetMetadata, 
+				int recNo, int fieldNo, PolicyType policy) throws ComponentNotReadyException {
+			//get parameter value 
+			String paramValue;
+			if (source.startsWith("${")) {// get graph parameter
+				paramValue = graph.getGraphProperties().getProperty(
+					source.substring(2, source.lastIndexOf('}')));
+			} else if (source.startsWith(String.valueOf(CustomizedRecordTransform.PARAMETER_CHAR))) {
+				// get parameter from node properties
+				paramValue = parameters.getProperty((source));
+			} else {
+				// try to find parameter with given name in node properties
+				paramValue = parameters.getProperty(CustomizedRecordTransform.PARAMETER_CHAR 
+						+ source);
+				if (paramValue == null) {
+					// try to find parameter with given name among graph parameters
+					paramValue = graph.getGraphProperties().getProperty(source);
+				}
+				if (paramValue == null) {
+					errorMessage = "Not found parameter: " + source;
+					if (!(targetMetadata[recNo].getField(fieldNo).isNullable() || targetMetadata[recNo]
+							.getField(fieldNo).isDefaultValue())) {
+						logger.error(errorMessage);
+						throw new ComponentNotReadyException(errorMessage);
+					} else {
+						logger.warn(errorMessage);
+					}
+				}
+			}
+			//use temporary field to check if the value can be set to given data field
+			DataField tmp = DataFieldFactory.createDataField(
+					targetMetadata[recNo].getField(fieldNo), true);
+			try{
+				tmp.fromString(paramValue);
+				value = tmp.getValue();
+			}catch(BadDataFormatException e){
+				errorMessage = e.getLocalizedMessage();
+				logger.error(errorMessage);
+				throw new ComponentNotReadyException(errorMessage);
+			}
+		}
+
+	}
+	
+	/**
+	 * Degenerated descendent of Rule class for marking fields for deleting 
+	 * previous rule
+	 */
+	class DeleteRule extends Rule{
+		
+		DeleteRule(){
+			super(null);
+		}
+		
+		@Override
+		Rule duplicate() {
+			return new DeleteRule();
+		}
+		
+		@Override
+		String getType() {
+			return "DELETE_RULE";
+		}
+
+		@Override
+		Object getCanonicalSource() {
+			return null;
+		}
+		
+		@Override
+		Object getValue(DataRecord[] sources) {
+			return null;
+		}
+		
+		@Override
+		void init(DataRecordMetadata[] sourceMetadata, DataRecordMetadata[] targetMetadata, 
+				int recNo, int fieldNo, PolicyType policy) throws ComponentNotReadyException {
+			//do nothing
+		}
+		
+	}
+



From cloveretl-svn-commits at lists.berlios.de  Tue Feb  6 12:13:28 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 6 Feb 2007 12:13:28 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2435 -
	trunk/cloveretl.engine/src/org/jetel/data
Message-ID: <200702061113.l16BDS4p021104@sheep.berlios.de>

Author: agad
Date: 2007-02-06 12:13:27 +0100 (Tue, 06 Feb 2007)
New Revision: 2435

Modified:
   trunk/cloveretl.engine/src/org/jetel/data/ByteDataField.java
Log:
FIX:ByteDataField.setValue works better when gets null value

Modified: trunk/cloveretl.engine/src/org/jetel/data/ByteDataField.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/ByteDataField.java	2007-02-06 11:12:33 UTC (rev 2434)
+++ trunk/cloveretl.engine/src/org/jetel/data/ByteDataField.java	2007-02-06 11:13:27 UTC (rev 2435)
@@ -151,6 +151,8 @@
                 result[i++] = b.byteValue();
             }
             setValue(result);
+        }else if (value instanceof DataField){
+        	setValue((DataField)value);
 		}else {
 		    throw new BadDataFormatException("Not a byte/byte_array " + value.getClass().getName());
 		}



From cloveretl-svn-commits at lists.berlios.de  Tue Feb  6 12:14:19 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 6 Feb 2007 12:14:19 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2436 -
	trunk/cloveretl.engine/src/org/jetel/exception
Message-ID: <200702061114.l16BEJ29021189@sheep.berlios.de>

Author: agad
Date: 2007-02-06 12:14:19 +0100 (Tue, 06 Feb 2007)
New Revision: 2436

Modified:
   trunk/cloveretl.engine/src/org/jetel/exception/TransformException.java
Log:
UPDATE:TransformException - implemented method getMessage

Modified: trunk/cloveretl.engine/src/org/jetel/exception/TransformException.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/exception/TransformException.java	2007-02-06 11:13:27 UTC (rev 2435)
+++ trunk/cloveretl.engine/src/org/jetel/exception/TransformException.java	2007-02-06 11:14:19 UTC (rev 2436)
@@ -81,6 +81,16 @@
 		this.recNo = recNo;
 	}
 
-
+	@Override
+	public String getMessage() {
+		StringBuilder msg = new StringBuilder();
+		msg.append("Record number: ");
+		msg.append(recNo);
+		msg.append(", field number: ");
+		msg.append(fieldNo);
+		msg.append(". Message: ");
+		msg.append(super.getMessage());
+		return msg.toString();
+	}
     
 }



From cloveretl-svn-commits at lists.berlios.de  Tue Feb  6 12:16:37 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 6 Feb 2007 12:16:37 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2437 -
	trunk/cloveretl.engine/test/org/jetel/component
Message-ID: <200702061116.l16BGbDR021475@sheep.berlios.de>

Author: agad
Date: 2007-02-06 12:16:36 +0100 (Tue, 06 Feb 2007)
New Revision: 2437

Modified:
   trunk/cloveretl.engine/test/org/jetel/component/CustomizedRecordTransformTest.java
Log:
UPDATE: small changes

Modified: trunk/cloveretl.engine/test/org/jetel/component/CustomizedRecordTransformTest.java
===================================================================
--- trunk/cloveretl.engine/test/org/jetel/component/CustomizedRecordTransformTest.java	2007-02-06 11:14:19 UTC (rev 2436)
+++ trunk/cloveretl.engine/test/org/jetel/component/CustomizedRecordTransformTest.java	2007-02-06 11:16:36 UTC (rev 2437)
@@ -125,6 +125,10 @@
 	
 	public void test_fieldToField() {
 		System.out.println("Field to field test:");
+		System.out.println(record.getMetadata().getName() + ":\n" + record.toString());
+		System.out.println(record1.getMetadata().getName() + ":\n" + record1.toString());
+		System.out.println(out.getMetadata().getName() + ":\n" + out.toString());
+		System.out.println(out1.getMetadata().getName() + ":\n" + out1.toString());
 //		transform.setFieldPolicy(PolicyType.CONTROLLED);
 //		transform.setFieldPolicy(PolicyType.STRICT);
 		transform.addFieldToFieldRule("0.1", "0.1");
@@ -185,13 +189,9 @@
 		try {
 			transform.transform(new DataRecord[]{record, record1}, new DataRecord[]{out,out1});
 		} catch (TransformException e) {
-			e.printStackTrace();
-			System.out.println("Record number: " + e.getRecNo() + " , field number " + e.getFieldNo());
+			System.out.println(e.getMessage());
+//			System.out.println("Record number: " + e.getRecNo() + " , field number " + e.getFieldNo());
 		}
-		System.out.println(record.getMetadata().getName() + ":\n" + record.toString());
-		System.out.println(record1.getMetadata().getName() + ":\n" + record1.toString());
-		System.out.println(out.getMetadata().getName() + ":\n" + out.toString());
-		System.out.println(out1.getMetadata().getName() + ":\n" + out1.toString());
 		assertEquals(out.getField(0).toString(), record1.getField(3).getValue().toString());
 //		assertEquals(out.getField(1).getValue(), record.getField(1).getValue());
 		assertEquals(out.getField(2).getValue().toString(), record.getField(2).getValue().toString());
@@ -271,13 +271,17 @@
 
 	public void test_sequenceToField(){
 		System.out.println("Sequence to field test:");
+		System.out.println(record.toString());
+		System.out.println(record1.toString());
+		System.out.println(out.toString());
+		System.out.println(out1.toString());
 		transform.addSequenceToFieldRule("*.Age", graph.getSequence("ID"));
 		transform.addSequenceToFieldRule(4, "ID");
 		transform.addSequenceToFieldRule("${1.Na*}", "ID.currentValueString()");
 		transform.addSequenceToFieldRule(1, 2, "${seq.ID.nextValueString()}");
 		transform.addSequenceToFieldRule(0, "Name", "id");
 		transform.addRule("out.City", "${seq.ID.nextString}");
-		transform.addSequenceToFieldRule("out.Born", graph.getSequence("ID"));
+//		transform.addSequenceToFieldRule("out.Born", graph.getSequence("ID"));
 		transform.deleteRule("${o*.Value}");
 		try {
 			transform.init(null, new DataRecordMetadata[]{metadata, metadata1}, 
@@ -324,10 +328,6 @@
 		assertEquals(out1.getField(0).getValue().toString(), "2");
 		assertEquals(out1.getField(2).getValue().toString(), "3");
 		assertEquals(out.getField(2).getValue().toString(), "4");
-		System.out.println(record.toString());
-		System.out.println(record1.toString());
-		System.out.println(out.toString());
-		System.out.println(out1.toString());
 	}
 	
 	public void test_parameterToField(){



From cloveretl-svn-commits at lists.berlios.de  Tue Feb  6 15:57:05 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 6 Feb 2007 15:57:05 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2438 - in trunk:
	cloveretl.component/src/org/jetel/component
	cloveretl.engine/src/org/jetel/component
	cloveretl.engine/src/org/jetel/main
Message-ID: <200702061457.l16Ev50O017565@sheep.berlios.de>

Author: ausperger
Date: 2007-02-06 15:57:04 +0100 (Tue, 06 Feb 2007)
New Revision: 2438

Added:
   trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java
   trunk/cloveretl.engine/src/org/jetel/main/showData.java
Removed:
   trunk/cloveretl.component/src/org/jetel/component/TextWriter.java
   trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java
Modified:
   trunk/cloveretl.engine/src/org/jetel/component/ComponentFactory.java
Log:
FIX: showData - removing dependencies, making comments,..

Copied: trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java (from rev 2422, trunk/cloveretl.component/src/org/jetel/component/TextWriter.java)
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/TextWriter.java	2007-02-01 10:20:59 UTC (rev 2422)
+++ trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java	2007-02-06 14:57:04 UTC (rev 2438)
@@ -0,0 +1,279 @@
+
+/*
+*    jETeL/Clover - Java based ETL application framework.
+*    Copyright (C) 2005-06  Javlin Consulting <info at javlinconsulting.cz>
+*    
+*    This library is free software; you can redistribute it and/or
+*    modify it under the terms of the GNU Lesser General Public
+*    License as published by the Free Software Foundation; either
+*    version 2.1 of the License, or (at your option) any later version.
+*    
+*    This library is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
+*    Lesser General Public License for more details.
+*    
+*    You should have received a copy of the GNU Lesser General Public
+*    License along with this library; if not, write to the Free Software
+*    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*
+*/
+
+package org.jetel.component;
+
+import java.io.IOException;
+import java.nio.channels.Channels;
+import java.nio.channels.WritableByteChannel;
+
+import org.jetel.data.DataRecord;
+import org.jetel.data.Defaults;
+import org.jetel.data.formatter.TextTableFormatter;
+import org.jetel.exception.ComponentNotReadyException;
+import org.jetel.exception.ConfigurationProblem;
+import org.jetel.exception.ConfigurationStatus;
+import org.jetel.graph.InputPort;
+import org.jetel.graph.Node;
+import org.jetel.graph.Result;
+import org.jetel.graph.TransformationGraph;
+import org.jetel.util.ComponentXMLAttributes;
+import org.jetel.util.FileUtils;
+import org.jetel.util.StringUtils;
+import org.jetel.util.SynchronizeUtils;
+import org.w3c.dom.Element;
+
+/**
+ *  <h3>TextTableWriter Component</h3>
+ *
+ * <!-- All records from input port [0] are formatted to table and written to specified file or on screen-->
+ * 
+ * <table border="1">
+ *  <th>Component:</th>
+ * <tr><td><h4><i>Name:</i></h4></td>
+ * <td>TextTableWriter</td></tr>
+ * <tr><td><h4><i>Category:</i></h4></td>
+ * <td></td></tr>
+ * <tr><td><h4><i>Description:</i></h4></td>
+ * <td>All records from input port [0] are formatted to table and written to specified file or on screen.</td></tr>
+ * <tr><td><h4><i>Inputs:</i></h4></td>
+ * <td>[0]- input records</td></tr>
+ * <tr><td><h4><i>Outputs:</i></h4></td>
+ * <td></td></tr>
+ * <tr><td><h4><i>Comment:</i></h4></td>
+ * <td>This component uses java.nio.* classes.</td></tr>
+ * </table>
+ *  <br>  
+ *  <table border="1">
+ *  <th>XML attributes:</th>
+ *  <tr><td><b>type</b></td><td>"STRUCTURE_WRITER"</td></tr>
+ *  <tr><td><b>id</b></td><td>component identification</td>
+ *  <tr><td><b>fileURL</b></td><td>Output files mask.
+ *  Use wildcard '#' to specify where to insert sequential number of file. Number of consecutive wildcards specifies
+ *  minimal length of the number. Name without wildcard specifies only one file.</td>
+ *  <tr><td><b>charset</b></td><td>character encoding of the output file (if not specified, then ISO-8859-1 is used)</td>
+ *  <tr><td><b>append</b></td><td>whether to append data at the end if output file exists or replace it (values: true/false)</td>
+ *  </tr>
+ *  </table>  
+ *
+ * <h4>Example:</h4>
+ * <pre>&lt;Node append="true" fileURL="${WORKSPACE}/output/structured_customers.txt"
+ *  id="TEXT_TABLE_WRITER0" type="TEXT_TABLE_WRITER"&gt;
+ * &lt;/Node&gt;
+ * 
+ * 
+ * @author ausperger; 
+ * (c) JavlinConsulting s.r.o.
+ *  www.javlinconsulting.cz
+ *
+ * @since Feb 6, 2007
+ *
+ */
+public class TextTableWriter extends Node {
+
+	public static final String XML_APPEND_ATTRIBUTE = "append";
+	public static final String XML_FILEURL_ATTRIBUTE = "fileURL";
+	public static final String XML_CHARSET_ATTRIBUTE = "charset";
+	public static final String XML_MASK_ATTRIBUTE = "mask";
+	public static final String XML_HEADER_ATTRIBUTE = "header";
+	public static final String XML_RECORD_FROM_ATTRIBUTE = "recordFrom";
+	public static final String XML_RECORD_COUNT_ATTRIBUTE = "recordCount";
+
+	private String fileURL;
+	private boolean appendData;
+	private TextTableFormatter formatter;
+	private boolean header = true;
+	private WritableByteChannel writer;
+	private String charset;
+	private long recordFrom = -1;
+	private long recordCount = -1;
+	
+	public final static String COMPONENT_TYPE = "TEXT_TABLE_WRITER";
+	private final static int READ_FROM_PORT = 0;
+
+	/**
+	 * Constructor
+	 * 
+	 * @param id
+	 * @param fileURL
+	 * @param charset
+	 * @param appendData
+	 * @param mask
+	 */
+	public TextTableWriter(String id, String fileURL, String charset, 
+			boolean appendData, String[] fields) {
+		super(id);
+		this.fileURL = fileURL;
+		this.appendData = appendData;
+		this.charset = charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER;
+		formatter = charset == null ? new TextTableFormatter() : 
+			new TextTableFormatter(charset);
+		formatter.setMask(fields);
+	}
+
+	/* (non-Javadoc)
+	 * @see org.jetel.graph.Node#getType()
+	 */
+	@Override
+	public String getType() {
+		return COMPONENT_TYPE;
+	}
+
+	@Override
+	public Result execute() throws Exception {
+		//write header
+		InputPort inPort = getInputPort(READ_FROM_PORT);
+		DataRecord record = new DataRecord(inPort.getMetadata());
+		long iRec = 0;
+		long recordTo = recordCount < 0 ? Long.MAX_VALUE : (recordFrom < 0 ? recordCount+1 : recordFrom + recordCount);
+		record.init();
+		//write records
+		try {
+			while (record != null && runIt) {
+				iRec++;
+				record = inPort.readRecord(record);
+				if (recordFrom > iRec || recordTo <= iRec) continue;
+				if (record != null) {
+					formatter.write(record);
+				}
+				SynchronizeUtils.cloverYield();
+			}
+			formatter.eof();
+		} catch (Exception e) {
+			throw e;
+		}finally{
+			//close output
+			writer.close();
+		}
+        return runIt ? Result.FINISHED_OK : Result.ABORTED;
+	}
+
+	@Override
+	public void free() {
+		super.free();
+		formatter.close();
+	}
+	/* (non-Javadoc)
+	 * @see org.jetel.graph.GraphElement#checkConfig()
+	 */
+    @Override
+    public ConfigurationStatus checkConfig(ConfigurationStatus status) {
+		super.checkConfig(status);
+		 
+		checkInputPorts(status, 1, 1);
+        checkOutputPorts(status, 0, 0);
+
+        try {
+            init();
+            free();
+        } catch (ComponentNotReadyException e) {
+            ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
+            if(!StringUtils.isEmpty(e.getAttributeName())) {
+                problem.setAttributeName(e.getAttributeName());
+            }
+            status.add(problem);
+        }
+        
+        return status;
+    }
+	
+	/* (non-Javadoc)
+	 * @see org.jetel.graph.GraphElement#init()
+	 */
+	@Override
+	public void init() throws ComponentNotReadyException {
+		super.init();
+		// based on file mask, create/open output file
+		try {
+			writer = fileURL == null ? Channels.newChannel(System.out) : FileUtils.getWritableChannel(getGraph().getProjectURL(), fileURL, appendData);
+			formatter.init(getInputPort(READ_FROM_PORT).getMetadata());
+            formatter.setDataTarget(writer);
+            formatter.setHeader(header);
+		} catch (IOException ex) {
+			throw new ComponentNotReadyException(getId() + "IOError: " + ex.getMessage());
+		}
+	}
+
+	/* (non-Javadoc)
+	 * @see org.jetel.graph.Node#fromXML(org.jetel.graph.TransformationGraph, org.w3c.dom.Element)
+	 */
+	public static Node fromXML(TransformationGraph graph, Element nodeXML) {
+		ComponentXMLAttributes xattribs=new ComponentXMLAttributes(nodeXML, graph);
+		TextTableWriter aDataWriter = null;
+		
+		try{
+			String fields = xattribs.getString(XML_MASK_ATTRIBUTE,null);
+			String[] aFields = fields == null ? null : fields.split(";");
+			aDataWriter = new TextTableWriter(xattribs.getString(Node.XML_ID_ATTRIBUTE),
+									xattribs.getString(XML_FILEURL_ATTRIBUTE),
+									xattribs.getString(XML_CHARSET_ATTRIBUTE,null),
+									xattribs.getBoolean(XML_APPEND_ATTRIBUTE, false),
+									aFields);
+			if (xattribs.exists(XML_HEADER_ATTRIBUTE)){
+				aDataWriter.setHeader(Boolean.parseBoolean(xattribs.getString(XML_HEADER_ATTRIBUTE)));
+			}
+			if (xattribs.exists(XML_RECORD_FROM_ATTRIBUTE)){
+				aDataWriter.setRecordFrom(Long.parseLong(xattribs.getString(XML_RECORD_FROM_ATTRIBUTE)));
+			}
+			if (xattribs.exists(XML_RECORD_COUNT_ATTRIBUTE)){
+				aDataWriter.setRecordCount(Long.parseLong(xattribs.getString(XML_RECORD_COUNT_ATTRIBUTE)));
+			}
+		}catch(Exception ex){
+			System.err.println(COMPONENT_TYPE + ":" + xattribs.getString(Node.XML_ID_ATTRIBUTE,"unknown ID") + ":" + ex.getMessage());
+			return null;
+		}
+		
+		return aDataWriter;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.jetel.graph.Node#toXML(org.w3c.dom.Element)
+	 */
+	public void toXML(org.w3c.dom.Element xmlElement) {
+		super.toXML(xmlElement);
+		xmlElement.setAttribute(XML_FILEURL_ATTRIBUTE,this.fileURL);
+		String charSet = this.formatter.getCharsetName();
+		if (charSet != null) {
+			xmlElement.setAttribute(XML_CHARSET_ATTRIBUTE, this.formatter.getCharsetName());
+		}
+		xmlElement.setAttribute(XML_APPEND_ATTRIBUTE, String.valueOf(this.appendData));
+		xmlElement.setAttribute(XML_HEADER_ATTRIBUTE,String.valueOf(header));
+		if (recordFrom != -1){
+			xmlElement.setAttribute(XML_RECORD_FROM_ATTRIBUTE, String.valueOf(recordFrom));
+		}
+		if (recordCount != -1){
+			xmlElement.setAttribute(XML_RECORD_COUNT_ATTRIBUTE,String.valueOf(recordCount));
+		}
+	}
+	
+	public void setHeader(boolean header) {
+		this.header = header;
+	}
+
+	public void setRecordFrom(long recordFrom) {
+		this.recordFrom = recordFrom;
+	}
+
+	public void setRecordCount(long recordCount) {
+		this.recordCount = recordCount;
+	}
+
+}

Deleted: trunk/cloveretl.component/src/org/jetel/component/TextWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/TextWriter.java	2007-02-06 11:16:36 UTC (rev 2437)
+++ trunk/cloveretl.component/src/org/jetel/component/TextWriter.java	2007-02-06 14:57:04 UTC (rev 2438)
@@ -1,297 +0,0 @@
-
-/*
-*    jETeL/Clover - Java based ETL application framework.
-*    Copyright (C) 2005-06  Javlin Consulting <info at javlinconsulting.cz>
-*    
-*    This library is free software; you can redistribute it and/or
-*    modify it under the terms of the GNU Lesser General Public
-*    License as published by the Free Software Foundation; either
-*    version 2.1 of the License, or (at your option) any later version.
-*    
-*    This library is distributed in the hope that it will be useful,
-*    but WITHOUT ANY WARRANTY; without even the implied warranty of
-*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
-*    Lesser General Public License for more details.
-*    
-*    You should have received a copy of the GNU Lesser General Public
-*    License along with this library; if not, write to the Free Software
-*    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*
-*/
-
-package org.jetel.component;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.Channels;
-import java.nio.channels.WritableByteChannel;
-
-import org.jetel.data.DataRecord;
-import org.jetel.data.Defaults;
-import org.jetel.data.formatter.TextTableFormatter;
-import org.jetel.exception.ComponentNotReadyException;
-import org.jetel.exception.ConfigurationProblem;
-import org.jetel.exception.ConfigurationStatus;
-import org.jetel.graph.InputPort;
-import org.jetel.graph.Node;
-import org.jetel.graph.Result;
-import org.jetel.graph.TransformationGraph;
-import org.jetel.util.ByteBufferUtils;
-import org.jetel.util.ComponentXMLAttributes;
-import org.jetel.util.FileUtils;
-import org.jetel.util.StringUtils;
-import org.jetel.util.SynchronizeUtils;
-import org.w3c.dom.Element;
-
-/**
- *  <h3>StructureWriter Component</h3>
- *
- * <!-- All records from input port [0] are formatted due to given mask and written to specified file -->
- * 
- * <table border="1">
- *  <th>Component:</th>
- * <tr><td><h4><i>Name:</i></h4></td>
- * <td>StructureWriter</td></tr>
- * <tr><td><h4><i>Category:</i></h4></td>
- * <td></td></tr>
- * <tr><td><h4><i>Description:</i></h4></td>
- * <td>All records from input port [0] are formatted due to given mask and written to specified file.
- * Records can be preceded by some text (header) or be trailed by a text (footer)</td></tr>
- * <tr><td><h4><i>Inputs:</i></h4></td>
- * <td>[0]- input records</td></tr>
- * <tr><td><h4><i>Outputs:</i></h4></td>
- * <td></td></tr>
- * <tr><td><h4><i>Comment:</i></h4></td>
- * <td>This component uses java.nio.* classes.</td></tr>
- * </table>
- *  <br>  
- *  <table border="1">
- *  <th>XML attributes:</th>
- *  <tr><td><b>type</b></td><td>"STRUCTURE_WRITER"</td></tr>
- *  <tr><td><b>id</b></td><td>component identification</td>
- *  <tr><td><b>fileURL</b></td><td>Output files mask.
- *  Use wildcard '#' to specify where to insert sequential number of file. Number of consecutive wildcards specifies
- *  minimal length of the number. Name without wildcard specifies only one file.</td>
- *  <tr><td><b>charset</b></td><td>character encoding of the output file (if not specified, then ISO-8859-1 is used)</td>
- *  <tr><td><b>append</b></td><td>whether to append data at the end if output file exists or replace it (values: true/false)</td>
- *  <tr><td><b>mask</b></td><td>template for formating records. Every occurrence 
- *  of $fieldName will be replaced by value of the fieldName. The rest of text will
- *  be unchanged. If not given there is used default mask:
- *  &lt; recordName field1=$field1 field2=$field2 ... fieldn=$fieldn /&gt;
- *  where field1 ,.., fieldn are record's fields from metadata</td>
- *  <tr><td><b>header</b></td><td>text to write before records</td>
- *  <tr><td><b>footer</b></td><td>text to write after records</td>
- *  </tr>
- *  </table>  
- *
- * <h4>Example:</h4>
- * <pre>&lt;Node append="true" fileURL="${WORKSPACE}/output/structured_customers.txt"
- *  id="STRUCTURE_WRITER0" type="STRUCTURE_WRITER"&gt;
- * &lt;attr name="header"&gt;dir = ${WORKSPACE}&lt;/attr&gt;
- * &lt;attr name="mask"&gt;
- * &lt;Customer id=$customer_id&gt;
- * 	&lt;last name = $lname&gt;
- *	&lt;first name = $fname&gt;
- * &lt;/Customer&gt;
- * &lt;/attr&gt;
- * &lt;attr name="footer"&gt;end of file&lt;/attr&gt;
- * &lt;/Node&gt;
- * 
- * 
- * @author avackova (agata.vackova at javlinconsulting.cz) ; 
- * (c) JavlinConsulting s.r.o.
- *  www.javlinconsulting.cz
- *
- * @since Oct 30, 2006
- *
- */
-public class TextWriter extends Node {
-
-	public static final String XML_APPEND_ATTRIBUTE = "append";
-	public static final String XML_FILEURL_ATTRIBUTE = "fileURL";
-	public static final String XML_CHARSET_ATTRIBUTE = "charset";
-	public static final String XML_MASK_ATTRIBUTE = "mask";
-	public static final String XML_HEADER_ATTRIBUTE = "header";
-	public static final String XML_RECORD_FROM_ATTRIBUTE = "recordFrom";
-	public static final String XML_RECORD_COUNT_ATTRIBUTE = "recordCount";
-
-	private String fileURL;
-	private boolean appendData;
-	private TextTableFormatter formatter;
-	private boolean header = true;
-	private WritableByteChannel writer;
-	private String charset;
-	private long recordFrom = -1;
-	private long recordCount = -1;
-	
-	public final static String COMPONENT_TYPE = "STRUCTURE_WRITER";
-	private final static int READ_FROM_PORT = 0;
-
-	/**
-	 * Constructor
-	 * 
-	 * @param id
-	 * @param fileURL
-	 * @param charset
-	 * @param appendData
-	 * @param mask
-	 */
-	public TextWriter(String id, String fileURL, String charset, 
-			boolean appendData, String[] fields) {
-		super(id);
-		this.fileURL = fileURL;
-		this.appendData = appendData;
-		this.charset = charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER;
-		formatter = charset == null ? new TextTableFormatter() : 
-			new TextTableFormatter(charset);
-		formatter.setMask(fields);
-	}
-
-	/* (non-Javadoc)
-	 * @see org.jetel.graph.Node#getType()
-	 */
-	@Override
-	public String getType() {
-		return COMPONENT_TYPE;
-	}
-
-	@Override
-	public Result execute() throws Exception {
-		//write header
-		InputPort inPort = getInputPort(READ_FROM_PORT);
-		DataRecord record = new DataRecord(inPort.getMetadata());
-		long iRec = 0;
-		long recordTo = recordCount < 0 ? Long.MAX_VALUE : (recordFrom < 0 ? recordCount+1 : recordFrom + recordCount);
-		record.init();
-		//write records
-		try {
-			while (record != null && runIt) {
-				iRec++;
-				record = inPort.readRecord(record);
-				if (recordFrom > iRec || recordTo <= iRec) continue;
-				if (record != null) {
-					formatter.write(record);
-				}
-				SynchronizeUtils.cloverYield();
-			}
-			formatter.eof();
-		} catch (Exception e) {
-			throw e;
-		}finally{
-			//close output
-			writer.close();
-		}
-        return runIt ? Result.FINISHED_OK : Result.ABORTED;
-	}
-
-	@Override
-	public void free() {
-		super.free();
-		formatter.close();
-	}
-	/* (non-Javadoc)
-	 * @see org.jetel.graph.GraphElement#checkConfig()
-	 */
-    @Override
-    public ConfigurationStatus checkConfig(ConfigurationStatus status) {
-		super.checkConfig(status);
-		 
-		checkInputPorts(status, 1, 1);
-        checkOutputPorts(status, 0, 0);
-
-        try {
-            init();
-            free();
-        } catch (ComponentNotReadyException e) {
-            ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
-            if(!StringUtils.isEmpty(e.getAttributeName())) {
-                problem.setAttributeName(e.getAttributeName());
-            }
-            status.add(problem);
-        }
-        
-        return status;
-    }
-	
-	/* (non-Javadoc)
-	 * @see org.jetel.graph.GraphElement#init()
-	 */
-	@Override
-	public void init() throws ComponentNotReadyException {
-		super.init();
-		// based on file mask, create/open output file
-		try {
-			writer = fileURL == null ? Channels.newChannel(System.out) : FileUtils.getWritableChannel(getGraph().getProjectURL(), fileURL, appendData);
-			formatter.init(getInputPort(READ_FROM_PORT).getMetadata());
-            formatter.setDataTarget(writer);
-            formatter.setHeader(header);
-		} catch (IOException ex) {
-			throw new ComponentNotReadyException(getId() + "IOError: " + ex.getMessage());
-		}
-	}
-
-	/* (non-Javadoc)
-	 * @see org.jetel.graph.Node#fromXML(org.jetel.graph.TransformationGraph, org.w3c.dom.Element)
-	 */
-	public static Node fromXML(TransformationGraph graph, Element nodeXML) {
-		ComponentXMLAttributes xattribs=new ComponentXMLAttributes(nodeXML, graph);
-		TextWriter aDataWriter = null;
-		
-		try{
-			String fields = xattribs.getString(XML_MASK_ATTRIBUTE,null);
-			String[] aFields = fields == null ? null : fields.split(";");
-			aDataWriter = new TextWriter(xattribs.getString(Node.XML_ID_ATTRIBUTE),
-									xattribs.getString(XML_FILEURL_ATTRIBUTE),
-									xattribs.getString(XML_CHARSET_ATTRIBUTE,null),
-									xattribs.getBoolean(XML_APPEND_ATTRIBUTE, false),
-									aFields);
-			if (xattribs.exists(XML_HEADER_ATTRIBUTE)){
-				aDataWriter.setHeader(Boolean.parseBoolean(xattribs.getString(XML_HEADER_ATTRIBUTE)));
-			}
-			if (xattribs.exists(XML_RECORD_FROM_ATTRIBUTE)){
-				aDataWriter.setRecordFrom(Long.parseLong(xattribs.getString(XML_RECORD_FROM_ATTRIBUTE)));
-			}
-			if (xattribs.exists(XML_RECORD_COUNT_ATTRIBUTE)){
-				aDataWriter.setRecordCount(Long.parseLong(xattribs.getString(XML_RECORD_COUNT_ATTRIBUTE)));
-			}
-		}catch(Exception ex){
-			System.err.println(COMPONENT_TYPE + ":" + xattribs.getString(Node.XML_ID_ATTRIBUTE,"unknown ID") + ":" + ex.getMessage());
-			return null;
-		}
-		
-		return aDataWriter;
-	}
-
-	/* (non-Javadoc)
-	 * @see org.jetel.graph.Node#toXML(org.w3c.dom.Element)
-	 */
-	public void toXML(org.w3c.dom.Element xmlElement) {
-		super.toXML(xmlElement);
-		xmlElement.setAttribute(XML_FILEURL_ATTRIBUTE,this.fileURL);
-		String charSet = this.formatter.getCharsetName();
-		if (charSet != null) {
-			xmlElement.setAttribute(XML_CHARSET_ATTRIBUTE, this.formatter.getCharsetName());
-		}
-		xmlElement.setAttribute(XML_APPEND_ATTRIBUTE, String.valueOf(this.appendData));
-		xmlElement.setAttribute(XML_HEADER_ATTRIBUTE,String.valueOf(header));
-		if (recordFrom != -1){
-			xmlElement.setAttribute(XML_RECORD_FROM_ATTRIBUTE, String.valueOf(recordFrom));
-		}
-		if (recordCount != -1){
-			xmlElement.setAttribute(XML_RECORD_COUNT_ATTRIBUTE,String.valueOf(recordCount));
-		}
-	}
-	
-	public void setHeader(boolean header) {
-		this.header = header;
-	}
-
-	public void setRecordFrom(long recordFrom) {
-		this.recordFrom = recordFrom;
-	}
-
-	public void setRecordCount(long recordCount) {
-		this.recordCount = recordCount;
-	}
-
-}

Modified: trunk/cloveretl.engine/src/org/jetel/component/ComponentFactory.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/component/ComponentFactory.java	2007-02-06 11:16:36 UTC (rev 2437)
+++ trunk/cloveretl.engine/src/org/jetel/component/ComponentFactory.java	2007-02-06 14:57:04 UTC (rev 2438)
@@ -85,7 +85,7 @@
      * @param componentType
      * @return class from the given component type
      */
-    private final static Class getComponentClass(String componentType) {
+    public final static Class getComponentClass(String componentType) {
         String className = null;
         ComponentDescription componentDescription = (ComponentDescription) componentMap.get(componentType);
         

Deleted: trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java	2007-02-06 11:16:36 UTC (rev 2437)
+++ trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java	2007-02-06 14:57:04 UTC (rev 2438)
@@ -1,620 +0,0 @@
-/*
- *  jETeL/Clover - Java based ETL application framework.
- *  Copyright (C) 2002-03  David Pavlis
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License as published by the Free Software Foundation; either
- *    version 2.1 of the License, or (at your option) any later version.
- *    
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
- *    Lesser General Public License for more details.
- *    
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-package org.jetel.main;
-
-import java.io.BufferedInputStream;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URL;
-import java.util.Map;
-import java.util.Properties;
-
-import org.apache.commons.cli.CommandLine;
-import org.apache.commons.cli.Option;
-import org.apache.commons.cli.Options;
-import org.apache.commons.cli.ParseException;
-import org.apache.commons.cli.PosixParser;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.log4j.Level;
-import org.apache.log4j.Logger;
-import org.apache.log4j.net.SocketAppender;
-import org.jetel.component.DataWriter;
-import org.jetel.component.ExtFilter;
-import org.jetel.component.StructureWriter;
-import org.jetel.component.TextWriter;
-import org.jetel.data.Defaults;
-import org.jetel.exception.ConfigurationStatus;
-import org.jetel.exception.GraphConfigurationException;
-import org.jetel.exception.XMLConfigurationException;
-import org.jetel.graph.Edge;
-import org.jetel.graph.Node;
-import org.jetel.graph.Phase;
-import org.jetel.graph.Result;
-import org.jetel.graph.TransformationGraph;
-import org.jetel.graph.TransformationGraphXMLReaderWriter;
-import org.jetel.metadata.DataRecordMetadata;
-import org.jetel.plugin.Plugins;
-import org.jetel.util.FileUtils;
-import org.jetel.util.JetelVersion;
-import org.jetel.util.crypto.Enigma;
-
-/**
- *  class for reading and showing data over input components<br><br>
- *  The graph layout is read from specified XML file and over component id is written data to output.<br>
- *  <tt><pre>
- *  Program parameters:
- *  <table>
- *  <tr><td nowrap>-v</td><td>be verbose - print even graph layout</td></tr>
- *  <tr><td nowrap>-P<i>properyName</i>=<i>propertyValue</i></td><td>add definition of property to global graph's property list</td></tr>
- *  <tr><td nowrap>--cfg <i>filename</i></td><td>load definitions of properties from specified file</td></tr>
- *  <tr><td nowrap>--tracking <i>seconds</i></td><td>how frequently output the processing status</td></tr>
- *  <tr><td nowrap>--info</td><td>print info about Clover library version</td></tr>
- *  <tr><td nowrap>--plugins <i>filename</i></td><td>directory where to look for plugins/components</td></tr>
- *  <tr><td nowrap>--pass <i>password</i></td><td>password for decrypting of hidden connections passwords</td></tr>
- *  <tr><td nowrap>--stdin</td><td>load graph layout from STDIN</td></tr>
- *  <tr><td nowrap>--mode</td><td>how show data over component {TEXT,HTML,DELIMITER_TEXT}</td></tr>
- *  <tr><td nowrap>--delimiter</td><td>delimiter between two fields</td></tr>
- *  <tr><td nowrap>--file</td><td>file url for output. If no file defined, output is set to System.out</td></tr>
- *  <tr><td nowrap>--expFilter</td><td>filter expression for record filtering</td></tr>
- *  <tr><td nowrap>--recFrom</td><td>from where show records</td></tr>
- *  <tr><td nowrap>--recCount</td><td>how many records should be showed</td></tr>
- *  <tr><td nowrap>--fields</td><td>Show only defined fields. If no fields defined, show all fields</td></tr>
- *  <tr><td nowrap>--logLevel</td><td>Log level for logger {all, info, debug, ..}, default is error log level</td></tr>
- *  <tr><td nowrap><b>filename</b></td><td>filename or URL of the file (even remote) containing graph's layout in XML (this must be the last parameter passed)</td></tr>
- *  <tr><td nowrap><b>component id</b></td><td>over this component will be showed data</td></tr>
- *  </table>
- *
- *  <h4>Example:</h4>
- *  <pre>showComponentData ExampleGraph.grf DELIMITED_DATA_READER0:0</pre>
- *  
- *  <pre>showComponentData --plugins ../cloveretl.engine/plugins --mode TEXT --delimiter "+" --expFilter "1==1" --recFrom 2 --recCount 2 --fields "Field1;Field0" ExampleGraph.grf DELIMITED_DATA_READER0:0</pre>
- *  
- *  </pre></tt>
- * @author      jausperger
- * @since       2007/02/02
- * @revision    $Revision:  $
- */
-public class showComponentData {
-    private static Log logger = LogFactory.getLog(showComponentData.class);
-
-    //TODO change run graph version
-	private final static String RUN_GRAPH_VERSION = "2.0";
-	
-    /**
-     * Clover.ETL engine initialization. Should be called only once.
-     * @param pluginsRootDirectory directory path, where plugins specification is located 
-     *        (can be null, then is used constant from Defaults.DEFAULT_PLUGINS_DIRECTORY)
-     * @param password password for encrypting some hidden part of graphs
-     *        <br>i.e. connections passwordss can be encrypted
-     */        int trackingInterval = -1;
-
-    public static void initEngine(String pluginsRootDirectory, String password) {
-        
-        //init password decryptor
-        if(password != null) {
-            Enigma.getInstance().init(password);
-        }
-        
-        //init framework constants
-        Defaults.init();
-
-        //init clover plugins system
-        Plugins.init(pluginsRootDirectory);
-    }
-    
-    
-    /**
-     * Instantiates transformation graph from a given input stream and presets a given properties.
-     * @param inStream
-     * @param properties
-     * @return
-     * @throws XMLConfigurationException
-     * @throws GraphConfigurationException
-     */
-    public static TransformationGraph loadGraph(InputStream inStream, Properties properties) throws XMLConfigurationException, GraphConfigurationException {
-        TransformationGraph graph = new TransformationGraph();
-        TransformationGraphXMLReaderWriter graphReader = new TransformationGraphXMLReaderWriter(graph);
-        if(properties != null) {
-            graph.loadGraphProperties(properties);
-        }
-
-        graphReader.read(inStream);
-        
-        return graph;
-    }
-    
-	/**
-	 *  Description of the Method
-	 *
-	 * @param  args  Description of the Parameter
-	 */
-	public static void main(String args[]) {
-		boolean verbose = false;
-        boolean loadFromSTDIN = false;
-		Properties properties = new Properties();
-        int trackingInterval = -1;
-		String pluginsRootDirectory = null;
-        String password = null;
-        Mode viewMode = Mode.TEXT;
-        String delimiter = null;
-        String fileUrl = null;
-        String filterExpression = null;
-        long recordFrom = -1;
-        long recordCount = -1;
-        String fields = null;
-        String logHost = null;
-		
-		ExtFilter extFilter = null;
-        
-		System.out.println("***  CloverETL graph component tester ver "+RUN_GRAPH_VERSION+", (c) 2002-06 D.Pavlis, released under GNU Lesser General Public License  ***");
-		System.out.println(" Running with framework version: "+JetelVersion.MAJOR_VERSION+"."+JetelVersion.MINOR_VERSION+" build#"+JetelVersion.BUILD_NUMBER+" compiled "+JetelVersion.LIBRARY_BUILD_DATETIME);
-		System.out.println();
-        
-		if (args.length < 1) {
-			printHelp();
-			System.exit(-1);
-		}
-        
-		Options options = new Options();
-    	options.addOption(new Option("v", "verbose", false, "Verbose mode"));
-    	options.addOption(new Option("g", "cfg", true, "Path to property file"));
-    	options.addOption(new Option("P", "propertyDefinition", true, "Property defined by user"));
-    	options.addOption(new Option("t", "tracking", false, "Tracking intrnal switch"));
-    	options.addOption(new Option("i", "info", false, "Information about program"));
-    	options.addOption(new Option("n", "stdin", false, "Load from stdin switch"));
-    	options.addOption(new Option("h", "loghost", false, "Log host switch"));
-    	options.addOption(new Option("p", "plugins", true, "Path to plugins file."));
-    	options.addOption(new Option("s", "pass", true, "Password"));
-    	options.addOption(new Option("m", "mode", true, "View mode"));
-    	options.addOption(new Option("d", "delimiter", true, "Delimiter between two fields"));
-    	options.addOption(new Option("o", "file", true, "File url for output. If no file defined, output is set to System.out"));
-    	options.addOption(new Option("e", "expFilter", true, "Filter expression for record filtering"));
-    	options.addOption(new Option("f", "recFrom", true, "From where show records"));
-    	options.addOption(new Option("c", "recCount", true, "Count of records"));
-    	options.addOption(new Option("l", "fields", true, "Show only defined fields. If no fields defined, show all fields"));
-    	options.addOption(new Option("x", "logLevel", true, "Log level for logger {all, info, debug, ..}, default is error log level"));
-
-    	PosixParser optParser = new PosixParser();
-    	CommandLine cmdLine;
-		try {
-			cmdLine = optParser.parse(options, args);
-		} catch (ParseException e) {
-			logger.error(e.getMessage(), e);
-			return;
-		}
-		
-		verbose = cmdLine.hasOption("v");
-		loadFromSTDIN = cmdLine.hasOption("n");
-		if (cmdLine.hasOption("h")) {
-            String[] hostAndPort = logHost.split(":");
-            if (hostAndPort[0].length() == 0 || hostAndPort.length > 2) {
-                System.err
-                        .println("Invalid log destination, i.e. -loghost localhost:4445");
-                System.exit(-1);
-            }
-            int port = 4445;
-            try {
-                if (hostAndPort.length == 2) {
-                    port = Integer.parseInt(hostAndPort[1]);
-                }
-            } catch (NumberFormatException e) {
-                System.err
-                        .println("Invalid log destination, i.e. -loghost localhost:4445");
-                System.exit(-1);
-            }
-            Logger.getRootLogger().addAppender(
-                    new SocketAppender(hostAndPort[0], port));
-		}
-		if (cmdLine.hasOption("g")) {
-			InputStream inStream;
-			try {
-				inStream = new BufferedInputStream(new FileInputStream(cmdLine.getOptionValue("g")));
-				properties.load(inStream);
-			} catch (NullPointerException e) {
-				logger.error("cfg file not found: " + e.getMessage(), e);
-				System.exit(-1);
-			} catch (IOException e) {
-				logger.error(e.getMessage(), e);
-				System.exit(-1);
-			}
-		}
-		if (cmdLine.hasOption("P")) {
-	    	String a[] = cmdLine.getOptionValue("P").split(";");
-	    	for (String tmp : a) {
-	    	    properties.setProperty(tmp.substring(0,tmp.indexOf("=")),tmp.substring(tmp.indexOf("=") +1)); 
-	    	}
-		}
-		if (cmdLine.hasOption("i")) {
-		    printInfo();
-		    System.exit(0);
-		}
-		if (cmdLine.hasOption("t")) {
-            try {
-                trackingInterval = Integer.parseInt(cmdLine.getOptionValue("t"));
-            } catch (NumberFormatException ex) {
-                System.err.println("Invalid tracking parameter: \""
-                        + cmdLine.getOptionValue("t") + "\"");
-                System.exit(-1);
-            }
-		}
-		if (cmdLine.hasOption("p")) {
-			pluginsRootDirectory = cmdLine.getOptionValue("p");
-		}
-		if (cmdLine.hasOption("s")) {
-			password = cmdLine.getOptionValue("s");
-		}
-		if (cmdLine.hasOption("m")) {
-			viewMode = Mode.valueModeOf(cmdLine.getOptionValue("m"));
-	        if (viewMode == null) {
-				System.err.println("Unknown mode option: "+cmdLine.getOptionValue("m"));
-				System.exit(-1);
-	        }
-		}
-		if (cmdLine.hasOption("d")) {
-			delimiter = cmdLine.getOptionValue("d");
-		}
-		if (cmdLine.hasOption("o")) {
-			fileUrl = cmdLine.getOptionValue("o");
-		}
-		if (cmdLine.hasOption("e")) {
-			filterExpression = cmdLine.getOptionValue("e");
-		}
-		if (cmdLine.hasOption("f")) {
-	    	recordFrom = Long.parseLong(cmdLine.getOptionValue("f"));
-		}
-		if (cmdLine.hasOption("c")) {
-	    	recordCount = Long.parseLong(cmdLine.getOptionValue("c"));
-		}
-		if (cmdLine.hasOption("l")) {
-        	fields = cmdLine.getOptionValue("l");
-		}
-		Logger.getRootLogger().setLevel(cmdLine.hasOption("x")?Level.toLevel(cmdLine.getOptionValue("x")):Level.ERROR);
-		
-        // setup log4j appenders
-        if (logHost != null) {
-            String[] hostAndPort = logHost.split(":");
-            if (hostAndPort[0].length() == 0 || hostAndPort.length > 2) {
-                System.err
-                        .println("Invalid log destination, i.e. -loghost localhost:4445");
-                System.exit(-1);
-            }
-            int port = 4445;
-            try {
-                if (hostAndPort.length == 2) {
-                    port = Integer.parseInt(hostAndPort[1]);
-                }
-            } catch (NumberFormatException e) {
-                System.err
-                        .println("Invalid log destination, i.e. -loghost localhost:4445");
-                System.exit(-1);
-            }
-            Logger.getRootLogger().addAppender(
-                    new SocketAppender(hostAndPort[0], port));
-        }
-        
-        // engine initialization - should be called only once
-        runGraph.initEngine(pluginsRootDirectory, password);
-
-        // prapere input stream with XML graph definition
-        InputStream in = null;
-        if (loadFromSTDIN) {
-            System.out.println("Graph definition loaded from STDIN");
-            in = System.in;
-        } else {
-            System.out.println("Graph definition file: "
-                    + args[args.length - 2]);
-            try {
-                URL fileURL = FileUtils.getFileURL(null, args[args.length - 2]);
-                in = fileURL.openStream();
-            } catch (IOException e) {
-                System.err
-                        .println("Error - graph definition file can't be read: "
-                                + e.getMessage());
-                System.exit(-1);
-            }
-        }
-        
-        System.out.println("Component id: " + args[args.length - 1]);
-        String componentID = args[args.length - 1];
-        int pos;
-        int port = 0;
-        if ((pos = componentID.indexOf(':')) != -1) {
-        	port = Integer.parseInt(componentID.substring(pos+1));
-        	componentID = componentID.substring(0, pos);
-        }
-
-        // loading graph from the input stream
-        TransformationGraph graph = null;
-        try {
-            graph = runGraph.loadGraph(in, properties);
-
-            // check graph elements configuration
-            logger.info("Checking graph configuration...");
-            try {
-                ConfigurationStatus status = graph.checkConfig(null);
-                status.log();
-            } catch(Exception e) {
-                logger.error("Checking graph failed! (" + e.getMessage() + ")");
-            }
-
-            if (!graph.init()) {
-                throw new GraphConfigurationException(
-                        "Graph initialization failed.");
-            }
-
-            if (verbose) {
-                // this can be called only after graph.init()
-                graph.dumpGraphConfiguration();
-            }
-        } catch (XMLConfigurationException ex) {
-            logger.error("Error in reading graph from XML !", ex);
-            if (verbose) {
-                ex.printStackTrace(System.err);
-            }
-            System.exit(-1);
-        } catch (GraphConfigurationException ex) {
-            logger.error("Error - graph's configuration invalid !", ex);
-            if (verbose) {
-                ex.printStackTrace(System.err);
-            }
-            System.exit(-1);
-        } catch (RuntimeException ex) {
-            logger.error("Error during graph initialization !", ex);
-            if (verbose) {
-                ex.printStackTrace(System.err);
-            }
-            System.exit(-1);
-        }
-        
-
-        //check graph elements configuration
-        ConfigurationStatus status = graph.checkConfig(null);
-        status.log();
-        
-		Map map = graph.getNodes();
-		Node node = (Node) map.get(componentID);
-		if (node == null) {
-			//map = graph.getEdges();
-			//Edge edge = (Edge) map.get(componentID);
-			//if (edge == null) {
-				// error
-				logger.error("Component Id '"+ componentID +"' not found!");
-				return;
-			//}
-		}
-		if (!node.isRoot()) {
-			// not implemented
-			System.err.println("Execution is implemented for root node (root node has only output ports connected)!");
-			return;
-		}
-
-		// create new graph
-	    TransformationGraph viewGraph = new TransformationGraph();
-		Phase _PHASE_1 = new Phase(1);
-
-	    // add writer component
-		DataRecordMetadata dataRecordMetadata = (DataRecordMetadata) node.getOutMetadata().toArray()[port];
-		Edge edge0 = new Edge("EDGE0", dataRecordMetadata);
-		Edge edge1 = null;
-		if (filterExpression != null) {
-			edge1 = new Edge("EDGE1", dataRecordMetadata);
-		}
-		Node writer = getWriter(viewMode, dataRecordMetadata, fileUrl, delimiter, recordFrom, recordCount, fields);
-		
-		// add Edges & Nodes & Phases to graph
-		try {
-			viewGraph.addPhase(_PHASE_1);
-			viewGraph.addEdge(edge0);
-			_PHASE_1.addNode(node);
-			_PHASE_1.addNode(writer);
-			
-			if (filterExpression != null) {
-				viewGraph.addEdge(edge1);
-				extFilter = new ExtFilter("ExtFilter0");
-				extFilter.setFilterExpression(filterExpression);
-				_PHASE_1.addNode(extFilter);
-			}
-		} catch (GraphConfigurationException e) {
-			e.printStackTrace();
-		}
-
-		// assign ports (input & output)
-		node.addOutputPort(0,edge0);
-		if (filterExpression != null) {
-			extFilter.addInputPort(0,edge0);
-			extFilter.addOutputPort(0,edge1);
-			writer.addInputPort(0,edge1); 
-		} else {
-			writer.addInputPort(0,edge0);
-		}
-
-		if(!viewGraph.init()){
-			System.err.println("Graph initialization failed !");
-			return;
-		}
-	    
-        // set tracking interval
-        if (trackingInterval != -1) {
-        	viewGraph.setTrackingInterval(trackingInterval * 1000);
-        }
-
-        //	start all Nodes (each node is one thread)
-		Result result=Result.N_A;
-		try {
-            result = viewGraph.run();
-        } catch (RuntimeException ex) {
-            System.err.println("Fatal error during graph run !");
-            System.err.println(ex.getCause().getMessage());
-            if (verbose) {
-                ex.printStackTrace();
-            }
-            System.exit(-1);
-        }
-        switch (result) {
-
-        case FINISHED_OK:
-            // everything O.K.
-            System.out.println("Execution of graph successful !");
-            System.exit(0);
-            break;
-        case ABORTED:
-            // execution was ABORTED !!
-            System.err.println("Execution of graph aborted !");
-            System.exit(result.code());
-            break;
-        default:
-            System.err.println("Execution of graph failed !");
-            System.exit(result.code());
-        }
-
-	}
-    
-	private static Node getWriter(Mode mode, DataRecordMetadata dataRecordMetadata, String fileUrl, String delimiter, long recordFrom, long recordCount, String fields) {
-		if (mode == null) return null;
-		Node writer = null;
-		String[] aFiealds = fields == null ? null : fields.split(";");
-		
-		if (mode.equals(Mode.HTML)) {
-			StringBuilder maskBuilder = new StringBuilder();
-			if (aFiealds == null) {
-				maskBuilder.append("<tr>");
-				for (int i=0;i<dataRecordMetadata.getNumFields();i++){
-					maskBuilder.append("<td>$");
-					maskBuilder.append(dataRecordMetadata.getField(i).getName());
-					maskBuilder.append("</td>");
-				}
-				maskBuilder.append("</tr>\n");
-			} else if (aFiealds.length > 0) {
-				maskBuilder.append("<tr>");
-				for (String sfield: aFiealds){
-					if (dataRecordMetadata.getField(sfield) == null) {
-						System.err.println("Field name '"+ sfield + "' not found.");
-						System.exit(-1);
-					}
-					maskBuilder.append("<td>$");
-					maskBuilder.append(sfield);
-					maskBuilder.append("</td>");
-				}
-				maskBuilder.append("</tr>\n");
-			} else {
-				System.err.println("No field found.");
-				System.exit(-1);
-			}
-			
-			StructureWriter structureWriter = new StructureWriter("STRUCTURE_WRITER0", fileUrl, null, false, maskBuilder.toString());
-			structureWriter.setRecordFrom(recordFrom);
-			structureWriter.setRecordCount(recordCount);
-			StringBuilder sb = new StringBuilder();
-			
-			sb.append("<table name=\"" + dataRecordMetadata.getName() + "\" border=1>\n");
-			sb.append("<tr>");
-			if (aFiealds == null ) {
-				for (int i=0;i<dataRecordMetadata.getNumFields();i++){
-					sb.append("<th>");
-					sb.append(dataRecordMetadata.getField(i).getName());
-					sb.append("</th>");
-				}
-			} else {
-				for (String sfield: aFiealds){
-					sb.append("<th>");
-					sb.append(dataRecordMetadata.getField(sfield).getName());
-					sb.append("</th>");
-				}
-			}
-			sb.append("</tr>\n");
-			structureWriter.setHeader(sb.toString());
-			
-			sb = new StringBuilder();
-			sb.append("</table>\n");
-			structureWriter.setFooter(sb.toString());
-			writer = structureWriter;
-			
-		} else if (mode.equals(Mode.TEXT)) {
-			DataWriter dataWriter = new DataWriter("DATA_WRITER0", fileUrl, dataRecordMetadata.getLocaleStr(), false);
-			//TODO agata dodelat selekci na fieldy
-			dataWriter.setRecordFrom(recordFrom);
-			dataWriter.setRecordCount(recordCount);
-			if (delimiter != null) dataWriter.setDataDelimiter(delimiter);
-			writer = dataWriter;
-			
-		} else if (mode.equals(Mode.DELIMITER_TEXT)) {
-			TextWriter dataWriter = new TextWriter("TEXT_TABLE_WRITER0", fileUrl, null, false, aFiealds);
-			dataWriter.setRecordFrom(recordFrom);
-			dataWriter.setRecordCount(recordCount);
-			dataWriter.setHeader(true);
-			writer = dataWriter;
-		}
-		return writer;
-	}
-	
-	private static void printHelp() {
-		System.out.println("Usage: runGraph [-(v|P)] [--(cfg|tracking|info|plugins|pass|loghost|mode|delimiter|file|expFilter|recFrom|recCount|fields|logLevel)] <graph definition file> <component id>");
-		System.out.println("Options:");
-		System.out.println("-v\t\t\tbe verbose - print even graph layout");
-		System.out.println("-P:<key>=<value>\tadd definition of property to global graph's property list");
-		System.out.println("--cfg <filename>\t\tload definitions of properties from specified file");
-		System.out.println("--tracking <seconds>\thow frequently output the graph processing status");
-		System.out.println("--info\t\t\tprint info about Clover library version");
-        System.out.println("--plugins\t\tdirectory where to look for plugins/components");
-        System.out.println("--pass\t\tpassword for decrypting of hidden connections passwords");
-        System.out.println("--stdin\t\tload graph definition from STDIN");
-        System.out.println("--loghost\t\tdefine host and port number for socket appender of log4j (log4j library is required); i.e. localhost:4445");
-        System.out.println("--mode\t\thow show data over component {TEXT,HTML,DELIMITER_TEXT}");
-        System.out.println("--delimiter\t\tdelimiter between two fields");
-        System.out.println("--file\t\tfile url for output. If no file defined, output is set to System.out");
-        System.out.println("--expFilter\t\tfilter expression for record filtering");
-        System.out.println("--recFrom\t\tfrom where show records");
-        System.out.println("--recCount\t\thow many records should be showed");
-        System.out.println("--fields\t\tShow only defined fields. If no fields defined, show all fields");
-        System.out.println("--logLevel\t\tLog level for logger {all, info, debug, ..}, default is error log level");
-        System.out.println();
-        System.out.println("Note: <graph definition file> can be either local filename or URL of local/remote file");
-        System.out.println("Note: <component id> over this component will be showed data");
-	}
-
-	private static void printInfo(){
-	    System.out.println("CloverETL library version "+JetelVersion.MAJOR_VERSION+"."+JetelVersion.MINOR_VERSION+" build#"+JetelVersion.BUILD_NUMBER+" compiled "+JetelVersion.LIBRARY_BUILD_DATETIME);
-	}
-
-	public enum Mode {
-	    
-	    TEXT,
-	    HTML,
-	    DELIMITER_TEXT;
-
-	    public static Mode valueModeOf(String value){
-	    	if (value.equalsIgnoreCase(TEXT.name())) {
-	    		return TEXT;
-	    	}
-	    	if (value.equalsIgnoreCase(HTML.name())) {
-	    		return HTML;
-	    	}
-	    	if (value.equalsIgnoreCase(DELIMITER_TEXT.name())) {
-	    		return DELIMITER_TEXT;
-	    	}
-	    	return null;
-	    }
-	    
-	}
-	
-}
-

Copied: trunk/cloveretl.engine/src/org/jetel/main/showData.java (from rev 2430, trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java)
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/main/showComponentData.java	2007-02-01 14:47:34 UTC (rev 2430)
+++ trunk/cloveretl.engine/src/org/jetel/main/showData.java	2007-02-06 14:57:04 UTC (rev 2438)
@@ -0,0 +1,639 @@
+/*
+ *  jETeL/Clover - Java based ETL application framework.
+ *  Copyright (C) 2002-03  David Pavlis
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License as published by the Free Software Foundation; either
+ *    version 2.1 of the License, or (at your option) any later version.
+ *    
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
+ *    Lesser General Public License for more details.
+ *    
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+package org.jetel.main;
+
+import java.io.BufferedInputStream;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Method;
+import java.net.URL;
+import java.util.Map;
+import java.util.Properties;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.commons.cli.ParseException;
+import org.apache.commons.cli.PosixParser;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.log4j.Level;
+import org.apache.log4j.Logger;
+import org.apache.log4j.net.SocketAppender;
+import org.jetel.component.ComponentFactory;
+import org.jetel.data.Defaults;
+import org.jetel.exception.ConfigurationStatus;
+import org.jetel.exception.GraphConfigurationException;
+import org.jetel.exception.XMLConfigurationException;
+import org.jetel.graph.Edge;
+import org.jetel.graph.Node;
+import org.jetel.graph.Phase;
+import org.jetel.graph.Result;
+import org.jetel.graph.TransformationGraph;
+import org.jetel.graph.TransformationGraphXMLReaderWriter;
+import org.jetel.metadata.DataRecordMetadata;
+import org.jetel.plugin.Plugins;
+import org.jetel.util.FileUtils;
+import org.jetel.util.JetelVersion;
+import org.jetel.util.crypto.Enigma;
+
+/**
+ *  class for reading and showing data over input components<br><br>
+ *  The graph layout is read from specified XML file and over component id is written data to output.<br>
+ *  <tt><pre>
+ *  Program parameters:
+ *  <table>
+ *  <tr><td nowrap>-P<i>properyName</i>=<i>propertyValue</i></td><td>add definition of property to global graph's property list</td></tr>
+ *  <tr><td nowrap>--cfg <i>filename</i></td><td>load definitions of properties from specified file</td></tr>
+ *  <tr><td nowrap>--tracking <i>seconds</i></td><td>how frequently output the processing status</td></tr>
+ *  <tr><td nowrap>--info</td><td>print info about Clover library version</td></tr>
+ *  <tr><td nowrap>--plugins <i>filename</i></td><td>directory where to look for plugins/components</td></tr>
+ *  <tr><td nowrap>--pass <i>password</i></td><td>password for decrypting of hidden connections passwords</td></tr>
+ *  <tr><td nowrap>--stdin</td><td>load graph layout from STDIN</td></tr>
+ *  <tr><td nowrap>--mode</td><td>how show data over component {TEXT,HTML,TABLE}</td></tr>
+ *  <tr><td nowrap>--delimiter</td><td>delimiter between two fields</td></tr>
+ *  <tr><td nowrap>--file</td><td>file url for output. If no file defined, output is set to System.out</td></tr>
+ *  <tr><td nowrap>--expFilter</td><td>filter expression for record filtering</td></tr>
+ *  <tr><td nowrap>--recFrom</td><td>from where show records</td></tr>
+ *  <tr><td nowrap>--recCount</td><td>how many records should be showed</td></tr>
+ *  <tr><td nowrap>--fields</td><td>Show only defined fields. If no fields defined, show all fields</td></tr>
+ *  <tr><td nowrap>--logLevel</td><td>Log level for logger {all, info, debug, ..}, default is error log level</td></tr>
+ *  <tr><td nowrap><b>filename</b></td><td>filename or URL of the file (even remote) containing graph's layout in XML (this must be the last parameter passed)</td></tr>
+ *  <tr><td nowrap><b>component id</b></td><td>over this component will be showed data</td></tr>
+ *  </table>
+ *
+ *  <h4>Example:</h4>
+ *  <pre>showData ExampleGraph.grf DELIMITED_DATA_READER0:0</pre>
+ *  
+ *  <pre>showData --plugins ../cloveretl.engine/plugins --mode TEXT --delimiter "+" --expFilter "1==1" --recFrom 2 --recCount 2 --fields "Field1;Field0" ExampleGraph.grf DELIMITED_DATA_READER0:0</pre>
+ *  
+ *  </pre></tt>
+ * @author      jausperger
+ * @since       2007/02/02
+ * @revision    $Revision:  $
+ */
+public class showData {
+    private static Log logger = LogFactory.getLog(showData.class);
+
+    /**
+     * Clover.ETL engine initialization. Should be called only once.
+     * @param pluginsRootDirectory directory path, where plugins specification is located 
+     *        (can be null, then is used constant from Defaults.DEFAULT_PLUGINS_DIRECTORY)
+     * @param password password for encrypting some hidden part of graphs
+     *        <br>i.e. connections passwordss can be encrypted
+     */        int trackingInterval = -1;
+
+    public static void initEngine(String pluginsRootDirectory, String password) {
+        
+        //init password decryptor
+        if(password != null) {
+            Enigma.getInstance().init(password);
+        }
+        
+        //init framework constants
+        Defaults.init();
+
+        //init clover plugins system
+        Plugins.init(pluginsRootDirectory);
+    }
+    
+    
+    /**
+     * Instantiates transformation graph from a given input stream and presets a given properties.
+     * @param inStream
+     * @param properties
+     * @return
+     * @throws XMLConfigurationException
+     * @throws GraphConfigurationException
+     */
+    public static TransformationGraph loadGraph(InputStream inStream, Properties properties) throws XMLConfigurationException, GraphConfigurationException {
+        TransformationGraph graph = new TransformationGraph();
+        TransformationGraphXMLReaderWriter graphReader = new TransformationGraphXMLReaderWriter(graph);
+        if(properties != null) {
+            graph.loadGraphProperties(properties);
+        }
+
+        graphReader.read(inStream);
+        
+        return graph;
+    }
+    
+	/**
+	 *  Description of the Method
+	 *
+	 * @param  args  Description of the Parameter
+	 */
+	public static void main(String args[]) {
+        boolean loadFromSTDIN = false;
+		Properties properties = new Properties();
+        int trackingInterval = -1;
+		String pluginsRootDirectory = null;
+        String password = null;
+        Mode viewMode = Mode.TEXT;
+        String delimiter = null;
+        String fileUrl = null;
+        String filterExpression = null;
+        long recordFrom = -1;
+        long recordCount = -1;
+        String fields = null;
+        String logHost = null;
+		
+		Node extFilter = null;
+        
+		/*System.out.println("***  CloverETL graph component tester ver "+RUN_GRAPH_VERSION+", (c) 2002-06 D.Pavlis, released under GNU Lesser General Public License  ***");
+		System.out.println(" Running with framework version: "+JetelVersion.MAJOR_VERSION+"."+JetelVersion.MINOR_VERSION+" build#"+JetelVersion.BUILD_NUMBER+" compiled "+JetelVersion.LIBRARY_BUILD_DATETIME);
+		System.out.println();
+        */
+		if (args.length < 1) {
+			printHelp();
+			System.exit(-1);
+		}
+        
+		Options options = new Options();
+    	options.addOption(new Option("g", "cfg", true, "Path to property file"));
+    	options.addOption(new Option("P", "propertyDefinition", true, "Property defined by user"));
+    	options.addOption(new Option("t", "tracking", false, "Tracking intrnal switch"));
+    	options.addOption(new Option("i", "info", false, "Information about program"));
+    	options.addOption(new Option("n", "stdin", false, "Load from stdin switch"));
+    	options.addOption(new Option("h", "loghost", false, "Log host switch"));
+    	options.addOption(new Option("p", "plugins", true, "Path to plugins file."));
+    	options.addOption(new Option("s", "pass", true, "Password"));
+    	options.addOption(new Option("m", "mode", true, "View mode"));
+    	options.addOption(new Option("d", "delimiter", true, "Delimiter between two fields"));
+    	options.addOption(new Option("o", "file", true, "File url for output. If no file defined, output is set to System.out"));
+    	options.addOption(new Option("e", "expFilter", true, "Filter expression for record filtering"));
+    	options.addOption(new Option("f", "recFrom", true, "From where show records"));
+    	options.addOption(new Option("c", "recCount", true, "Count of records"));
+    	options.addOption(new Option("l", "fields", true, "Show only defined fields. If no fields defined, show all fields"));
+    	options.addOption(new Option("x", "logLevel", true, "Log level for logger {all, info, debug, ..}, default is error log level"));
+
+    	PosixParser optParser = new PosixParser();
+    	CommandLine cmdLine;
+		try {
+			cmdLine = optParser.parse(options, args);
+		} catch (ParseException e) {
+			logger.error(e.getMessage(), e);
+			return;
+		}
+		
+		loadFromSTDIN = cmdLine.hasOption("n");
+		if (cmdLine.hasOption("h")) {
+            String[] hostAndPort = logHost.split(":");
+            if (hostAndPort[0].length() == 0 || hostAndPort.length > 2) {
+                System.err
+                        .println("Invalid log destination, i.e. -loghost localhost:4445");
+                System.exit(-1);
+            }
+            int port = 4445;
+            try {
+                if (hostAndPort.length == 2) {
+                    port = Integer.parseInt(hostAndPort[1]);
+                }
+            } catch (NumberFormatException e) {
+                System.err
+                        .println("Invalid log destination, i.e. -loghost localhost:4445");
+                System.exit(-1);
+            }
+            Logger.getRootLogger().addAppender(
+                    new SocketAppender(hostAndPort[0], port));
+		}
+		if (cmdLine.hasOption("g")) {
+			InputStream inStream;
+			try {
+				inStream = new BufferedInputStream(new FileInputStream(cmdLine.getOptionValue("g")));
+				properties.load(inStream);
+			} catch (NullPointerException e) {
+				logger.error("cfg file not found: " + e.getMessage(), e);
+				System.exit(-1);
+			} catch (IOException e) {
+				logger.error(e.getMessage(), e);
+				System.exit(-1);
+			}
+		}
+		if (cmdLine.hasOption("P")) {
+	    	String a[] = cmdLine.getOptionValue("P").split(";");
+	    	for (String tmp : a) {
+	    	    properties.setProperty(tmp.substring(0,tmp.indexOf("=")),tmp.substring(tmp.indexOf("=") +1)); 
+	    	}
+		}
+		if (cmdLine.hasOption("i")) {
+		    printInfo();
+		    System.exit(0);
+		}
+		if (cmdLine.hasOption("t")) {
+            try {
+                trackingInterval = Integer.parseInt(cmdLine.getOptionValue("t"));
+            } catch (NumberFormatException ex) {
+                System.err.println("Invalid tracking parameter: \""
+                        + cmdLine.getOptionValue("t") + "\"");
+                System.exit(-1);
+            }
+		}
+		if (cmdLine.hasOption("p")) {
+			pluginsRootDirectory = cmdLine.getOptionValue("p");
+		}
+		if (cmdLine.hasOption("s")) {
+			password = cmdLine.getOptionValue("s");
+		}
+		if (cmdLine.hasOption("m")) {
+			viewMode = Mode.valueModeOf(cmdLine.getOptionValue("m"));
+	        if (viewMode == null) {
+				System.err.println("Unknown mode option: "+cmdLine.getOptionValue("m"));
+				System.exit(-1);
+	        }
+		}
+		if (cmdLine.hasOption("d")) {
+			delimiter = cmdLine.getOptionValue("d");
+		}
+		if (cmdLine.hasOption("o")) {
+			fileUrl = cmdLine.getOptionValue("o");
+		}
+		if (cmdLine.hasOption("e")) {
+			filterExpression = cmdLine.getOptionValue("e");
+		}
+		if (cmdLine.hasOption("f")) {
+	    	recordFrom = Long.parseLong(cmdLine.getOptionValue("f"));
+		}
+		if (cmdLine.hasOption("c")) {
+	    	recordCount = Long.parseLong(cmdLine.getOptionValue("c"));
+		}
+		if (cmdLine.hasOption("l")) {
+        	fields = cmdLine.getOptionValue("l");
+		}
+		Logger.getRootLogger().setLevel(cmdLine.hasOption("x")?Level.toLevel(cmdLine.getOptionValue("x")):Level.ERROR);
+		
+        // setup log4j appenders
+        if (logHost != null) {
+            String[] hostAndPort = logHost.split(":");
+            if (hostAndPort[0].length() == 0 || hostAndPort.length > 2) {
+                System.err
+                        .println("Invalid log destination, i.e. -loghost localhost:4445");
+                System.exit(-1);
+            }
+            int port = 4445;
+            try {
+                if (hostAndPort.length == 2) {
+                    port = Integer.parseInt(hostAndPort[1]);
+                }
+            } catch (NumberFormatException e) {
+                System.err
+                        .println("Invalid log destination, i.e. -loghost localhost:4445");
+                System.exit(-1);
+            }
+            Logger.getRootLogger().addAppender(
+                    new SocketAppender(hostAndPort[0], port));
+        }
+        
+        // engine initialization - should be called only once
+        runGraph.initEngine(pluginsRootDirectory, password);
+
+        // prapere input stream with XML graph definition
+        InputStream in = null;
+        if (loadFromSTDIN) {
+            System.out.println("Graph definition loaded from STDIN");
+            in = System.in;
+        } else {
+            System.out.println("Graph definition file: "
+                    + args[args.length - 2]);
+            try {
+                URL fileURL = FileUtils.getFileURL(null, args[args.length - 2]);
+                in = fileURL.openStream();
+            } catch (IOException e) {
+                System.err
+                        .println("Error - graph definition file can't be read: "
+                                + e.getMessage());
+                System.exit(-1);
+            }
+        }
+        
+        System.out.println("Component id: " + args[args.length - 1]);
+        String componentID = args[args.length - 1];
+        int pos;
+        int port = 0;
+        if ((pos = componentID.indexOf(':')) != -1) {
+        	port = Integer.parseInt(componentID.substring(pos+1));
+        	componentID = componentID.substring(0, pos);
+        }
+
+        // loading graph from the input stream
+        TransformationGraph graph = null;
+        try {
+            graph = runGraph.loadGraph(in, properties);
+
+            // check graph elements configuration
+            logger.info("Checking graph configuration...");
+            try {
+                ConfigurationStatus status = graph.checkConfig(null);
+                status.log();
+            } catch(Exception e) {
+                logger.error("Checking graph failed! (" + e.getMessage() + ")");
+            }
+
+            if (!graph.init()) {
+                throw new GraphConfigurationException(
+                        "Graph initialization failed.");
+            }
+
+            // this can be called only after graph.init()
+            graph.dumpGraphConfiguration();
+        } catch (XMLConfigurationException ex) {
+            logger.error("Error in reading graph from XML !", ex);
+            ex.printStackTrace(System.err);
+            System.exit(-1);
+        } catch (GraphConfigurationException ex) {
+            logger.error("Error - graph's configuration invalid !", ex);
+            ex.printStackTrace(System.err);
+            System.exit(-1);
+        } catch (RuntimeException ex) {
+            logger.error("Error during graph initialization !", ex);
+            ex.printStackTrace(System.err);
+            System.exit(-1);
+        }
+        
+        //check graph elements configuration
+        ConfigurationStatus status = graph.checkConfig(null);
+        status.log();
+        
+		Map map = graph.getNodes();
+		Node node = (Node) map.get(componentID);
+		if (node == null) {
+			//map = graph.getEdges();
+			//Edge edge = (Edge) map.get(componentID);
+			//if (edge == null) {
+				// error
+				logger.error("Component Id '"+ componentID +"' not found!");
+				return;
+			//}
+		}
+		if (!node.isRoot()) {
+			// not implemented
+			System.err.println("Execution is implemented for root node (root node has only output ports connected)!");
+			return;
+		}
+
+		// create new graph
+	    TransformationGraph viewGraph = new TransformationGraph();
+		Phase _PHASE_1 = new Phase(1);
+
+	    // add writer component
+		DataRecordMetadata dataRecordMetadata = (DataRecordMetadata) node.getOutMetadata().toArray()[port];
+		Edge edge0 = new Edge("EDGE0", dataRecordMetadata);
+		Edge edge1 = null;
+		if (filterExpression != null) {
+			edge1 = new Edge("EDGE1", dataRecordMetadata);
+		}
+		Node writer = null;
+		try {
+			writer = getWriter(viewGraph, viewMode, dataRecordMetadata, fileUrl, delimiter, recordFrom, recordCount, fields);
+		} catch (Exception e1) {
+			e1.printStackTrace();
+		}
+		
+		// add Edges & Nodes & Phases to graph
+		try {
+			viewGraph.addPhase(_PHASE_1);
+			viewGraph.addEdge(edge0);
+			_PHASE_1.addNode(node);
+			_PHASE_1.addNode(writer);
+			
+			if (filterExpression != null) {
+				viewGraph.addEdge(edge1);
+				extFilter = ComponentFactory.createComponent(viewGraph, "EXT_FILTER", new Object[] {"ExtFilter0"}, new Class[] {String.class});//new ExtFilter("ExtFilter0");
+				Method method = ComponentFactory.getComponentClass("EXT_FILTER").getMethod("setFilterExpression", new Class[] {String.class});
+				method.invoke(extFilter, filterExpression);
+				_PHASE_1.addNode(extFilter);
+			}
+		} catch (GraphConfigurationException e) {
+			e.printStackTrace();
+			return;
+		} catch (Exception e) {
+			e.printStackTrace();
+			return;
+		}
+
+		// assign ports (input & output)
+		node.addOutputPort(0,edge0);
+		if (filterExpression != null) {
+			extFilter.addInputPort(0,edge0);
+			extFilter.addOutputPort(0,edge1);
+			writer.addInputPort(0,edge1); 
+		} else {
+			writer.addInputPort(0,edge0);
+		}
+
+		if(!viewGraph.init()){
+			System.err.println("Graph initialization failed !");
+			return;
+		}
+	    
+        // set tracking interval
+        if (trackingInterval != -1) {
+        	viewGraph.setTrackingInterval(trackingInterval * 1000);
+        }
+
+        //	start all Nodes (each node is one thread)
+		Result result=Result.N_A;
+		try {
+            result = viewGraph.run();
+        } catch (RuntimeException ex) {
+            System.err.println("Fatal error during graph run !");
+            System.err.println(ex.getCause().getMessage());
+            ex.printStackTrace();
+            System.exit(-1);
+        }
+        switch (result) {
+
+        case FINISHED_OK:
+            // everything O.K.
+            System.out.println("Execution of graph successful !");
+            System.exit(0);
+            break;
+        case ABORTED:
+            // execution was ABORTED !!
+            System.err.println("Execution of graph aborted !");
+            System.exit(result.code());
+            break;
+        default:
+            System.err.println("Execution of graph failed !");
+            System.exit(result.code());
+        }
+
+	}
+    
+	/**
+	 * @param mode
+	 * @param dataRecordMetadata
+	 * @param fileUrl
+	 * @param delimiter
+	 * @param recordFrom
+	 * @param recordCount
+	 * @param fields
+	 * @return
+	 * @throws Exception 
+	 */
+	private static Node getWriter(TransformationGraph graph, Mode mode, DataRecordMetadata dataRecordMetadata, String fileUrl, String delimiter, long recordFrom, long recordCount, String fields) throws Exception {
+		if (mode == null) return null;
+		Node writer = null;
+		String[] aFiealds = fields == null ? null : fields.split(";");
+		
+		// html formating
+		if (mode.equals(Mode.HTML)) {
+			StringBuilder maskBuilder = new StringBuilder();
+			if (aFiealds == null) {
+				maskBuilder.append("<tr>");
+				for (int i=0;i<dataRecordMetadata.getNumFields();i++){
+					maskBuilder.append("<td>$");
+					maskBuilder.append(dataRecordMetadata.getField(i).getName());
+					maskBuilder.append("</td>");
+				}
+				maskBuilder.append("</tr>\n");
+			} else if (aFiealds.length > 0) {
+				maskBuilder.append("<tr>");
+				for (String sfield: aFiealds){
+					if (dataRecordMetadata.getField(sfield) == null) {
+						System.err.println("Field name '"+ sfield + "' not found.");
+						System.exit(-1);
+					}
+					maskBuilder.append("<td>$");
+					maskBuilder.append(sfield);
+					maskBuilder.append("</td>");
+				}
+				maskBuilder.append("</tr>\n");
+			} else {
+				System.err.println("No field found.");
+				System.exit(-1);
+			}
+			
+			Node structureWriter = ComponentFactory.createComponent(graph, "STRUCTURE_WRITER", new Object[] {"STRUCTURE_WRITER0", fileUrl, null, false, maskBuilder.toString()}, new Class[] {String.class, String.class, String.class, boolean.class, String.class});
+			Class cStructureWriter = ComponentFactory.getComponentClass("STRUCTURE_WRITER");
+			Method method = cStructureWriter.getMethod("setRecordFrom", new Class[] {long.class});
+			method.invoke(structureWriter, recordFrom);
+			method = cStructureWriter.getMethod("setRecordCount", new Class[] {long.class});
+			method.invoke(structureWriter, recordCount);
+			StringBuilder sb = new StringBuilder();
+			
+			sb.append("<table name=\"" + dataRecordMetadata.getName() + "\" border=1>\n");
+			sb.append("<thead>\n<tr>");
+			if (aFiealds == null ) {
+				for (int i=0;i<dataRecordMetadata.getNumFields();i++){
+					sb.append("<th>");
+					sb.append(dataRecordMetadata.getField(i).getName());
+					sb.append("</th>");
+				}
+			} else {
+				for (String sfield: aFiealds){
+					sb.append("<th>");
+					sb.append(dataRecordMetadata.getField(sfield).getName());
+					sb.append("</th>");
+				}
+			}
+			sb.append("</tr>\n</thead>\n<tbody>\n");
+			method = cStructureWriter.getMethod("setHeader", new Class[] {String.class});
+			method.invoke(structureWriter, sb.toString());
+			
+			sb = new StringBuilder();
+			sb.append("</tbody>\n</table>\n");
+			method = cStructureWriter.getMethod("setFooter", new Class[] {String.class});
+			method.invoke(structureWriter, sb.toString());
+			writer = structureWriter;
+			
+		// text formating - delimited or fix lenght
+		} else if (mode.equals(Mode.TEXT)) {
+			Node dataWriter = ComponentFactory.createComponent(graph, "DATA_WRITER", new Object[] {"DATA_WRITER0", fileUrl, dataRecordMetadata.getLocaleStr(), false}, new Class[] {String.class, String.class, String.class, boolean.class});
+			//TODO agata dodelat selekci na fieldy
+			Class cDataWriter = ComponentFactory.getComponentClass("DATA_WRITER");
+			Method method = cDataWriter.getMethod("setRecordFrom", new Class[] {long.class});
+			method.invoke(dataWriter, recordFrom);
+			method = cDataWriter.getMethod("setRecordCount", new Class[] {long.class});
+			method.invoke(dataWriter, recordCount);
+			if (delimiter != null) {
+				method = cDataWriter.getMethod("setDataDelimiter", new Class[] {String.class});
+				method.invoke(dataWriter, delimiter);
+			}
+			writer = dataWriter;
+			
+		// table formating
+		} else if (mode.equals(Mode.TABLE)) {
+			//TextWriter dataWriter = new TextWriter("TEXT_TABLE_WRITER0", fileUrl, null, false, aFiealds);
+			Node textWriter = ComponentFactory.createComponent(graph, "TEXT_TABLE_WRITER", new Object[] {"TEXT_TABLE_WRITER0", fileUrl, null, false, aFiealds}, new Class[] {String.class, String.class, String.class, boolean.class, String[].class});
+			Class cDataWriter = ComponentFactory.getComponentClass("TEXT_TABLE_WRITER");
+			Method method = cDataWriter.getMethod("setRecordFrom", new Class[] {long.class});
+			method.invoke(textWriter, recordFrom);
+			method = cDataWriter.getMethod("setRecordCount", new Class[] {long.class});
+			method.invoke(textWriter, recordCount);
+			method = cDataWriter.getMethod("setHeader", new Class[] {boolean.class});
+			method.invoke(textWriter, true);
+			writer = textWriter;
+		}
+		return writer;
+	}
+	
+	private static void printHelp() {
+		System.out.println("Usage: showData [-P] [--(cfg|tracking|info|plugins|pass|loghost|mode|delimiter|file|expFilter|recFrom|recCount|fields|logLevel)] <graph definition file> <component id>");
+		System.out.println("Options:");
+		System.out.println("-P:<key>=<value>\tadd definition of property to global graph's property list");
+		System.out.println("--cfg <filename>\t\tload definitions of properties from specified file");
+		System.out.println("--tracking <seconds>\thow frequently output the graph processing status");
+		System.out.println("--info\t\t\tprint info about Clover library version");
+        System.out.println("--plugins\t\tdirectory where to look for plugins/components");
+        System.out.println("--pass\t\tpassword for decrypting of hidden connections passwords");
+        System.out.println("--stdin\t\tload graph definition from STDIN");
+        System.out.println("--loghost\t\tdefine host and port number for socket appender of log4j (log4j library is required); i.e. localhost:4445");
+        System.out.println("--mode\t\thow show data over component {TEXT,HTML,TABLE}");
+        System.out.println("--delimiter\t\tdelimiter between two fields");
+        System.out.println("--file\t\tfile url for output. If no file defined, output is set to System.out");
+        System.out.println("--expFilter\t\tfilter expression for record filtering");
+        System.out.println("--recFrom\t\tfrom where show records");
+        System.out.println("--recCount\t\thow many records should be showed");
+        System.out.println("--fields\t\tShow only defined fields. If no fields defined, show all fields");
+        System.out.println("--logLevel\t\tLog level for logger {all, info, debug, ..}, default is error log level");
+        System.out.println();
+        System.out.println("Note: <graph definition file> can be either local filename or URL of local/remote file");
+        System.out.println("Note: <component id> over this component will be showed data");
+	}
+
+	private static void printInfo(){
+	    System.out.println("CloverETL library version "+JetelVersion.MAJOR_VERSION+"."+JetelVersion.MINOR_VERSION+" build#"+JetelVersion.BUILD_NUMBER+" compiled "+JetelVersion.LIBRARY_BUILD_DATETIME);
+	}
+
+	public enum Mode {
+	    
+	    TEXT,
+	    HTML,
+	    TABLE;
+
+	    public static Mode valueModeOf(String value){
+	    	if (value.equalsIgnoreCase(TEXT.name())) {
+	    		return TEXT;
+	    	}
+	    	if (value.equalsIgnoreCase(HTML.name())) {
+	    		return HTML;
+	    	}
+	    	if (value.equalsIgnoreCase(TABLE.name())) {
+	    		return TABLE;
+	    	}
+	    	return null;
+	    }
+	    
+	}
+	
+}
+



From cloveretl-svn-commits at lists.berlios.de  Tue Feb  6 16:00:03 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 6 Feb 2007 16:00:03 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2439 - in trunk:
	cloveretl.component cloveretl.engine/plugins/org.jetel.component
Message-ID: <200702061500.l16F03Sv017798@sheep.berlios.de>

Author: ausperger
Date: 2007-02-06 16:00:02 +0100 (Tue, 06 Feb 2007)
New Revision: 2439

Modified:
   trunk/cloveretl.component/plugin.xml
   trunk/cloveretl.engine/plugins/org.jetel.component/plugin.xml
Log:
FIX: add text_table_component record

Modified: trunk/cloveretl.component/plugin.xml
===================================================================
--- trunk/cloveretl.component/plugin.xml	2007-02-06 14:57:04 UTC (rev 2438)
+++ trunk/cloveretl.component/plugin.xml	2007-02-06 15:00:02 UTC (rev 2439)
@@ -247,4 +247,9 @@
 		<parameter id="className" value="org.jetel.component.SequenceChecker"/>
 	</extension>
 
+	<extension point-id="component">
+		<parameter id="type" value="TEXT_TABLE_WRITER"/>
+		<parameter id="className" value="org.jetel.component.TextTableWriter"/>
+	</extension>
+
 </plugin>
\ No newline at end of file

Modified: trunk/cloveretl.engine/plugins/org.jetel.component/plugin.xml
===================================================================
--- trunk/cloveretl.engine/plugins/org.jetel.component/plugin.xml	2007-02-06 14:57:04 UTC (rev 2438)
+++ trunk/cloveretl.engine/plugins/org.jetel.component/plugin.xml	2007-02-06 15:00:02 UTC (rev 2439)
@@ -246,4 +246,9 @@
 		<parameter id="className" value="org.jetel.component.SequenceChecker"/>
 	</extension>
 
+	<extension point-id="component">
+		<parameter id="type" value="TEXT_TABLE_WRITER"/>
+		<parameter id="className" value="org.jetel.component.TextTableWriter"/>
+	</extension>
+
 </plugin>
\ No newline at end of file



From cloveretl-svn-commits at lists.berlios.de  Tue Feb  6 16:40:11 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 6 Feb 2007 16:40:11 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2440 -
	trunk/cloveretl.engine/src/org/jetel/main
Message-ID: <200702061540.l16FeBLb021602@sheep.berlios.de>

Author: otasanek
Date: 2007-02-06 16:40:10 +0100 (Tue, 06 Feb 2007)
New Revision: 2440

Modified:
   trunk/cloveretl.engine/src/org/jetel/main/runGraph.java
Log:
INIT: into runGraph class was added new command line option -checkconfig.

Modified: trunk/cloveretl.engine/src/org/jetel/main/runGraph.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/main/runGraph.java	2007-02-06 15:00:02 UTC (rev 2439)
+++ trunk/cloveretl.engine/src/org/jetel/main/runGraph.java	2007-02-06 15:40:10 UTC (rev 2440)
@@ -82,6 +82,7 @@
  *  <tr><td nowrap>-pass <i>password</i></td><td>password for decrypting of hidden connections passwords</td></tr>
  *  <tr><td nowrap>-stdin</td><td>load graph layout from STDIN</td></tr>
  *  <tr><td nowrap>-loghost</td><td>define host and port number for socket appender of log4j (log4j library is required); i.e. localhost:4445</td></tr>
+ *  <tr><td nowrap>-checkconfig</td><td>only check graph configuration</td></tr>
  *  <tr><td nowrap><b>filename</b></td><td>filename or URL of the file (even remote) containing graph's layout in XML (this must be the last parameter passed)</td></tr>
  *  </table>
  *  </pre></tt>
@@ -103,6 +104,7 @@
     public final static String PASSWORD_SWITCH = "-pass";
     public final static String LOAD_FROM_STDIN_SWITCH = "-stdin";
     public final static String LOG_HOST_SWITCH = "-loghost";
+    public final static String CHECK_CONFIG_SWITCH = "-checkconfig";
 	
     
     /**
@@ -162,7 +164,8 @@
         String pluginsRootDirectory = null;
         String password = null;
         String logHost = null;
-
+        boolean onlyCheckConfig = false;
+        
         System.out
                 .println("***  CloverETL framework/transformation graph runner ver "
                         + RUN_GRAPH_VERSION
@@ -223,6 +226,8 @@
             } else if (args[i].startsWith(LOG_HOST_SWITCH)) {
                 i++;
                 logHost = args[i];
+            } else if (args[i].startsWith(CHECK_CONFIG_SWITCH)) {
+                onlyCheckConfig = true;
             } else if (args[i].startsWith("-")) {
                 System.err.println("Unknown option: " + args[i]);
                 System.exit(-1);
@@ -254,7 +259,7 @@
         // engine initialization - should be called only once
         runGraph.initEngine(pluginsRootDirectory, password);
 
-        // prapere input stream with XML graph definition
+        // prepare input stream with XML graph definition
         InputStream in = null;
         if (loadFromSTDIN) {
             System.out.println("Graph definition loaded from STDIN");
@@ -285,6 +290,8 @@
                 status.log();
             } catch(Exception e) {
                 logger.error("Checking graph failed! (" + e.getMessage() + ")");
+            } finally {
+                if(onlyCheckConfig) System.exit(0);
             }
 
             if (!graph.init()) {
@@ -365,6 +372,7 @@
         System.out.println("-pass\t\tpassword for decrypting of hidden connections passwords");
         System.out.println("-stdin\t\tload graph definition from STDIN");
         System.out.println("-loghost\t\tdefine host and port number for socket appender of log4j (log4j library is required); i.e. localhost:4445");
+        System.out.println("-checkconfig\t\tonly check graph configuration");
         System.out.println();
         System.out.println("Note: <graph definition file> can be either local filename or URL of local/remote file");
         



From cloveretl-svn-commits at lists.berlios.de  Wed Feb  7 09:17:16 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 7 Feb 2007 09:17:16 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2441 -
	trunk/cloveretl.engine/src/org/jetel/component
Message-ID: <200702070817.l178HGJZ018550@sheep.berlios.de>

Author: agad
Date: 2007-02-07 09:17:14 +0100 (Wed, 07 Feb 2007)
New Revision: 2441

Modified:
   trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java
Log:
UPDATE:CustomizedRecordTransform:initialization of rules is in the end of init method

Modified: trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java	2007-02-06 15:40:10 UTC (rev 2440)
+++ trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java	2007-02-07 08:17:14 UTC (rev 2441)
@@ -921,8 +921,8 @@
 					rule1.setProperties(parameters);
 					rule1.setLogger(logger);
 					//prepare rule for concrete data field
-					rule1.init(sourceMetadata, targetMetadata,getRecNo(field),
-							getFieldNo(field),fieldPolicy);
+//					rule1.init(sourceMetadata, targetMetadata,getRecNo(field),
+//							getFieldNo(field),fieldPolicy);
 					transformMap.put(field, rule1);
 				}
 			}
@@ -936,6 +936,8 @@
 			order[index][REC_NO] = getRecNo(field);
 			order[index][FIELD_NO] = getFieldNo(field);
 			transformMapArray[order[index][REC_NO] ][order[index][FIELD_NO]] = i.getValue();
+			transformMapArray[order[index][REC_NO]][order[index][FIELD_NO]].init
+				(sourceMetadata, targetMetadata, getRecNo(field), getFieldNo(field), fieldPolicy);
 			index++;
 		}
 		return true;
@@ -1102,7 +1104,7 @@
 			rule = new FieldRule(ruleString);
 			rule.setLogger(logger);
 			((FieldRule)rule).setFieldParams(String.valueOf(inRecNo) + DOT	+ inFieldNo);
-			rule.init(sourceMetadata, targetMetadata, outRecNo, outFieldNo, fieldPolicy);
+//			rule.init(sourceMetadata, targetMetadata, outRecNo, outFieldNo, fieldPolicy);
 			transformMap.put(String.valueOf(outRecNo) + DOT + outFieldNo, rule);
 			return true;
 		}
@@ -1763,7 +1765,9 @@
 				break;
 			default:
 				errorMessage = "Can't set sequence to data field of type: "
-						+ targetMetadata[recNo].getField(fieldNo).getTypeAsString();
+						+ targetMetadata[recNo].getField(fieldNo).getTypeAsString() +
+						" (" + targetMetadata[recNo].getName() + CustomizedRecordTransform.DOT +
+						targetMetadata[recNo].getField(fieldNo).getName() + ")";
 				logger.error(errorMessage);
 				throw new ComponentNotReadyException(errorMessage);
 			}



From cloveretl-svn-commits at lists.berlios.de  Wed Feb  7 09:17:51 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 7 Feb 2007 09:17:51 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2442 -
	trunk/cloveretl.engine/test/org/jetel/component
Message-ID: <200702070817.l178Hp3h018598@sheep.berlios.de>

Author: agad
Date: 2007-02-07 09:17:51 +0100 (Wed, 07 Feb 2007)
New Revision: 2442

Modified:
   trunk/cloveretl.engine/test/org/jetel/component/CustomizedRecordTransformTest.java
Log:
UPDATE:CustomizedRecordTransform:initialization of rules is in the end of init method

Modified: trunk/cloveretl.engine/test/org/jetel/component/CustomizedRecordTransformTest.java
===================================================================
--- trunk/cloveretl.engine/test/org/jetel/component/CustomizedRecordTransformTest.java	2007-02-07 08:17:14 UTC (rev 2441)
+++ trunk/cloveretl.engine/test/org/jetel/component/CustomizedRecordTransformTest.java	2007-02-07 08:17:51 UTC (rev 2442)
@@ -281,7 +281,7 @@
 		transform.addSequenceToFieldRule(1, 2, "${seq.ID.nextValueString()}");
 		transform.addSequenceToFieldRule(0, "Name", "id");
 		transform.addRule("out.City", "${seq.ID.nextString}");
-//		transform.addSequenceToFieldRule("out.Born", graph.getSequence("ID"));
+		transform.addSequenceToFieldRule("out.Born", graph.getSequence("ID"));
 		transform.deleteRule("${o*.Value}");
 		try {
 			transform.init(null, new DataRecordMetadata[]{metadata, metadata1}, 
@@ -289,6 +289,13 @@
 		} catch (ComponentNotReadyException e) {
 			e.printStackTrace();
 		}
+		transform.deleteRule(3);
+		try {
+			transform.init(null, new DataRecordMetadata[]{metadata, metadata1}, 
+				new DataRecordMetadata[]{metaOut,metaOut1});
+		} catch (ComponentNotReadyException e) {
+			e.printStackTrace();
+		}
 		List<String> rules = transform.getRules();
 		System.out.println("Rules:");
 		for (Iterator<String> i = rules.iterator();i.hasNext();){



From cloveretl-svn-commits at lists.berlios.de  Wed Feb  7 09:18:37 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 7 Feb 2007 09:18:37 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2443 -
	trunk/cloveretl.engine/test/org/jetel/data/tape
Message-ID: <200702070818.l178IbAG018632@sheep.berlios.de>

Author: agad
Date: 2007-02-07 09:18:37 +0100 (Wed, 07 Feb 2007)
New Revision: 2443

Modified:
   trunk/cloveretl.engine/test/org/jetel/data/tape/DataRecordTapeTest.java
Log:
UPDATE:updated due to changes in engine

Modified: trunk/cloveretl.engine/test/org/jetel/data/tape/DataRecordTapeTest.java
===================================================================
--- trunk/cloveretl.engine/test/org/jetel/data/tape/DataRecordTapeTest.java	2007-02-07 08:17:51 UTC (rev 2442)
+++ trunk/cloveretl.engine/test/org/jetel/data/tape/DataRecordTapeTest.java	2007-02-07 08:18:37 UTC (rev 2443)
@@ -25,6 +25,7 @@
 
 import org.jetel.data.DataRecord;
 import org.jetel.data.tape.DataRecordTape;
+import org.jetel.main.runGraph;
 import org.jetel.metadata.DataFieldMetadata;
 import org.jetel.metadata.DataRecordMetadata;
 
@@ -54,6 +55,8 @@
     testRecordA.getField(1).setValue("Second field");
     testRecordA.getField(2).setValue(new Integer(-1234567));
     testRecordB.copyFieldsByPosition(testRecordA);
+    
+    runGraph.initEngine(null, null);
 }
 
 
@@ -70,7 +73,7 @@
 public void test_1_DataTape() {
 	ByteBuffer buffer= ByteBuffer.allocateDirect(2048);
     
-    DataRecordTape tape=new DataRecordTape();
+    DataRecordTape tape=new DataRecordTape("tapeTest.tmp", true, false);
     // first chunk of data
     try{
         tape.open();
@@ -83,7 +86,7 @@
         testRecordA.serialize(buffer);
         buffer.flip();
         try{
-        tape.put(buffer);
+        	tape.put(buffer);
         }catch(IOException ex){
             ex.printStackTrace();
         }



From cloveretl-svn-commits at lists.berlios.de  Wed Feb  7 09:18:51 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 7 Feb 2007 09:18:51 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2444 -
	trunk/cloveretl.engine/test/org/jetel/graph
Message-ID: <200702070818.l178IpR1018661@sheep.berlios.de>

Author: agad
Date: 2007-02-07 09:18:51 +0100 (Wed, 07 Feb 2007)
New Revision: 2444

Modified:
   trunk/cloveretl.engine/test/org/jetel/graph/EdgeTest.java
Log:
UPDATE:updated due to changes in engine

Modified: trunk/cloveretl.engine/test/org/jetel/graph/EdgeTest.java
===================================================================
--- trunk/cloveretl.engine/test/org/jetel/graph/EdgeTest.java	2007-02-07 08:18:37 UTC (rev 2443)
+++ trunk/cloveretl.engine/test/org/jetel/graph/EdgeTest.java	2007-02-07 08:18:51 UTC (rev 2444)
@@ -171,7 +171,11 @@
 	            }catch(Exception ex){
 	            }
 	        }
-	        edge.close();
+	        try {
+				edge.close();
+			} catch (InterruptedException e) {
+				e.printStackTrace();
+			}
 	    }
 	} 
 	



From cloveretl-svn-commits at lists.berlios.de  Wed Feb  7 09:30:07 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 7 Feb 2007 09:30:07 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2445 -
	trunk/cloveretl.engine/src/org/jetel/component
Message-ID: <200702070830.l178U76N019348@sheep.berlios.de>

Author: agad
Date: 2007-02-07 09:30:07 +0100 (Wed, 07 Feb 2007)
New Revision: 2445

Modified:
   trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java
Log:
MINOR:comments updated

Modified: trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java	2007-02-07 08:18:51 UTC (rev 2444)
+++ trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java	2007-02-07 08:30:07 UTC (rev 2445)
@@ -1364,6 +1364,17 @@
 		return fieldPolicy;
 	}
 
+	/**
+	 * Sets the field policy:
+	 * <ul>
+	 * <li>PolicyType.STRICT - mapped output and input fields have to be of the same types
+	 * <li>PolicyType.CONTROLLED - mapped input fields have to be subtypes of output fields<br>
+	 * <li>PolicyType.LENIENT - field's types are not checked during initialization</ul>
+	 * For PolicyType CONTROLLED and LENIENT method transform can work slower as 
+	 * for not identical types for is called method fromString, when method setValue has failed.
+	 * 
+	 * @param fieldPolicy
+	 */
 	public void setFieldPolicy(PolicyType fieldPolicy) {
 		this.fieldPolicy = fieldPolicy;
 	}



From cloveretl-svn-commits at lists.berlios.de  Wed Feb  7 10:47:02 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 7 Feb 2007 10:47:02 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2446 -
	trunk/cloveretl.engine/src/org/jetel/data
Message-ID: <200702070947.l179l2Ks026667@sheep.berlios.de>

Author: otasanek
Date: 2007-02-07 10:47:01 +0100 (Wed, 07 Feb 2007)
New Revision: 2446

Modified:
   trunk/cloveretl.engine/src/org/jetel/data/ByteDataField.java
Log:
UPDATE: return to the previous revision.

Modified: trunk/cloveretl.engine/src/org/jetel/data/ByteDataField.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/ByteDataField.java	2007-02-07 08:30:07 UTC (rev 2445)
+++ trunk/cloveretl.engine/src/org/jetel/data/ByteDataField.java	2007-02-07 09:47:01 UTC (rev 2446)
@@ -151,8 +151,6 @@
                 result[i++] = b.byteValue();
             }
             setValue(result);
-        }else if (value instanceof DataField){
-        	setValue((DataField)value);
 		}else {
 		    throw new BadDataFormatException("Not a byte/byte_array " + value.getClass().getName());
 		}



From cloveretl-svn-commits at lists.berlios.de  Wed Feb  7 11:06:36 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 7 Feb 2007 11:06:36 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2447 - in trunk:
	cloveretl.component/src/org/jetel/component
	cloveretl.connection/src/org/jetel/connection
Message-ID: <200702071006.l17A6ah0028691@sheep.berlios.de>

Author: otasanek
Date: 2007-02-07 11:06:26 +0100 (Wed, 07 Feb 2007)
New Revision: 2447

Modified:
   trunk/cloveretl.component/src/org/jetel/component/DataReader.java
   trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/DelimitedDataReader.java
   trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/FixLenDataReader.java
   trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/MultiLevelReader.java
   trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java
   trunk/cloveretl.component/src/org/jetel/component/Trash.java
   trunk/cloveretl.connection/src/org/jetel/connection/DBConnection.java
Log:
FIX: condition getGraph() calling.

Modified: trunk/cloveretl.component/src/org/jetel/component/DataReader.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DataReader.java	2007-02-07 09:47:01 UTC (rev 2446)
+++ trunk/cloveretl.component/src/org/jetel/component/DataReader.java	2007-02-07 10:06:26 UTC (rev 2447)
@@ -242,7 +242,7 @@
         super.init();
         
 		// initialize multifile reader based on prepared parser
-        reader = new MultiFileReader(parser, getGraph().getProjectURL(), fileURL);
+        reader = new MultiFileReader(parser, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
         reader.setLogger(logger);
         reader.setFileSkip(skipFirstLine ? 1 : 0);
         reader.setSkip(skipRows);

Modified: trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-07 09:47:01 UTC (rev 2446)
+++ trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-07 10:06:26 UTC (rev 2447)
@@ -167,7 +167,7 @@
 
 		if (fileURL != null) {
 	        // initialize multifile writer based on prepared formatter
-	        writer = new MultiFileWriter(formatter, getGraph().getProjectURL(), fileURL);
+	        writer = new MultiFileWriter(formatter, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
 	        writer.setLogger(logger);
 	        writer.setBytesPerFile(bytesPerFile);
 	        writer.setRecordsPerFile(recordsPerFile);

Modified: trunk/cloveretl.component/src/org/jetel/component/DelimitedDataReader.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DelimitedDataReader.java	2007-02-07 09:47:01 UTC (rev 2446)
+++ trunk/cloveretl.component/src/org/jetel/component/DelimitedDataReader.java	2007-02-07 10:06:26 UTC (rev 2447)
@@ -177,7 +177,7 @@
 		super.init();
 
         // initialize multifile reader based on prepared parser
-        reader = new MultiFileReader(parser, getGraph().getProjectURL(), fileURL);
+        reader = new MultiFileReader(parser, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
         reader.setLogger(logger);
         reader.setFileSkip(skipFirstLine ? 1 : 0);
         reader.setSkip(skipRows);

Modified: trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-07 09:47:01 UTC (rev 2446)
+++ trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-07 10:06:26 UTC (rev 2447)
@@ -163,7 +163,7 @@
 		}
         
         // initialize multifile writer based on prepared formatter
-        writer = new MultiFileWriter(formatter, getGraph().getProjectURL(), fileURL);
+        writer = new MultiFileWriter(formatter, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
         writer.setLogger(logger);
         writer.setBytesPerFile(bytesPerFile);
         writer.setRecordsPerFile(recordsPerFile);

Modified: trunk/cloveretl.component/src/org/jetel/component/FixLenDataReader.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/FixLenDataReader.java	2007-02-07 09:47:01 UTC (rev 2446)
+++ trunk/cloveretl.component/src/org/jetel/component/FixLenDataReader.java	2007-02-07 10:06:26 UTC (rev 2447)
@@ -212,7 +212,7 @@
 		super.init();
         
         // initialize multifile reader based on prepared parser
-        reader = new MultiFileReader(parser, getGraph().getProjectURL(), fileURL);
+        reader = new MultiFileReader(parser, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
         reader.setLogger(logger);
         reader.setFileSkip(skipFirstLine ? 1 : 0);
         reader.setSkip(skipRows);

Modified: trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-07 09:47:01 UTC (rev 2446)
+++ trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-07 10:06:26 UTC (rev 2447)
@@ -157,7 +157,7 @@
 	public void init() throws ComponentNotReadyException {
 		super.init();
         // initialize multifile writer based on prepared formatter
-        writer = new MultiFileWriter(formatter, getGraph().getProjectURL(), fileURL);
+        writer = new MultiFileWriter(formatter, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
         writer.setLogger(logger);
         writer.setBytesPerFile(bytesPerFile);
         writer.setRecordsPerFile(recordsPerFile);

Modified: trunk/cloveretl.component/src/org/jetel/component/MultiLevelReader.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/MultiLevelReader.java	2007-02-07 09:47:01 UTC (rev 2446)
+++ trunk/cloveretl.component/src/org/jetel/component/MultiLevelReader.java	2007-02-07 10:06:26 UTC (rev 2447)
@@ -256,7 +256,7 @@
         parser.setExceptionHandler(ParserExceptionHandlerFactory.getHandler(policyType));
 
         // initialize multifile reader based on prepared parser
-        reader = new MultiFileReader(parser, getGraph().getProjectURL(), fileURL);
+        reader = new MultiFileReader(parser, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
         reader.setLogger(logger);
         reader.setFileSkip(skipFirstLine ? 1 : 0);
         reader.setSkip(skipRows);

Modified: trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-07 09:47:01 UTC (rev 2446)
+++ trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-07 10:06:26 UTC (rev 2447)
@@ -234,7 +234,7 @@
 		super.init();
 		// based on file mask, create/open output file
 		try {
-			writer = fileURL == null ? Channels.newChannel(System.out) : FileUtils.getWritableChannel(getGraph().getProjectURL(), fileURL, appendData);
+			writer = fileURL == null ? Channels.newChannel(System.out) : FileUtils.getWritableChannel(getGraph() != null ? getGraph().getProjectURL() : null, fileURL, appendData);
 			buffer = ByteBuffer.allocateDirect(StringUtils.getMaxLength(header,footer));
 			formatter.init(getInputPort(READ_FROM_PORT).getMetadata());
             formatter.setDataTarget(writer);

Modified: trunk/cloveretl.component/src/org/jetel/component/Trash.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/Trash.java	2007-02-07 09:47:01 UTC (rev 2446)
+++ trunk/cloveretl.component/src/org/jetel/component/Trash.java	2007-02-07 10:06:26 UTC (rev 2447)
@@ -192,7 +192,7 @@
 		if (debugPrint) {
             if(debugFilename != null) {
           		try {
-    				outStream = new PrintWriter(Channels.newWriter(FileUtils.getWritableChannel(getGraph().getProjectURL(), debugFilename, false), Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER));
+    				outStream = new PrintWriter(Channels.newWriter(FileUtils.getWritableChannel(getGraph() != null ? getGraph().getProjectURL() : null, debugFilename, false), Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER));
     			} catch (IOException ex) {
     				throw new ComponentNotReadyException(ex.getMessage());
     			}

Modified: trunk/cloveretl.connection/src/org/jetel/connection/DBConnection.java
===================================================================
--- trunk/cloveretl.connection/src/org/jetel/connection/DBConnection.java	2007-02-07 09:47:01 UTC (rev 2446)
+++ trunk/cloveretl.connection/src/org/jetel/connection/DBConnection.java	2007-02-07 10:06:26 UTC (rev 2447)
@@ -203,7 +203,7 @@
         if(!StringUtils.isEmpty(configFileName)) {
             try {
                 InputStream stream = null;
-                URL url = FileUtils.getFileURL(getGraph().getProjectURL(), configFileName);
+                URL url = FileUtils.getFileURL(getGraph() != null ? getGraph().getProjectURL() : null, configFileName);
                 stream = url.openStream();
 
 //old code - last usage in 2.0                 
@@ -264,7 +264,7 @@
 	                    for(int i=0;i<libraryPaths.length;i++){
 	                    	try {
                                 // valid url
-                                myURLs[i] = FileUtils.getFileURL(getGraph() == null ? null : getGraph().getProjectURL(), libraryPaths[i]);
+                                myURLs[i] = FileUtils.getFileURL(getGraph() != null ? getGraph().getProjectURL() : null, libraryPaths[i]);
 	                    	} catch (MalformedURLException ex1) {
 	                    	    throw new RuntimeException("Malformed URL: " + ex1.getMessage());
 	                    	}



From cloveretl-svn-commits at lists.berlios.de  Wed Feb  7 11:40:16 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 7 Feb 2007 11:40:16 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2448 -
	trunk/cloveretl.engine/src/org/jetel/main
Message-ID: <200702071040.l17AeGaK031513@sheep.berlios.de>

Author: ausperger
Date: 2007-02-07 11:40:16 +0100 (Wed, 07 Feb 2007)
New Revision: 2448

Modified:
   trunk/cloveretl.engine/src/org/jetel/main/showData.java
Log:
FIX: remove unused code

Modified: trunk/cloveretl.engine/src/org/jetel/main/showData.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/main/showData.java	2007-02-07 10:06:26 UTC (rev 2447)
+++ trunk/cloveretl.engine/src/org/jetel/main/showData.java	2007-02-07 10:40:16 UTC (rev 2448)
@@ -39,7 +39,6 @@
 import org.apache.log4j.Logger;
 import org.apache.log4j.net.SocketAppender;
 import org.jetel.component.ComponentFactory;
-import org.jetel.data.Defaults;
 import org.jetel.exception.ConfigurationStatus;
 import org.jetel.exception.GraphConfigurationException;
 import org.jetel.exception.XMLConfigurationException;
@@ -48,12 +47,9 @@
 import org.jetel.graph.Phase;
 import org.jetel.graph.Result;
 import org.jetel.graph.TransformationGraph;
-import org.jetel.graph.TransformationGraphXMLReaderWriter;
 import org.jetel.metadata.DataRecordMetadata;
-import org.jetel.plugin.Plugins;
 import org.jetel.util.FileUtils;
 import org.jetel.util.JetelVersion;
-import org.jetel.util.crypto.Enigma;
 
 /**
  *  class for reading and showing data over input components<br><br>
@@ -93,49 +89,6 @@
 public class showData {
     private static Log logger = LogFactory.getLog(showData.class);
 
-    /**
-     * Clover.ETL engine initialization. Should be called only once.
-     * @param pluginsRootDirectory directory path, where plugins specification is located 
-     *        (can be null, then is used constant from Defaults.DEFAULT_PLUGINS_DIRECTORY)
-     * @param password password for encrypting some hidden part of graphs
-     *        <br>i.e. connections passwordss can be encrypted
-     */        int trackingInterval = -1;
-
-    public static void initEngine(String pluginsRootDirectory, String password) {
-        
-        //init password decryptor
-        if(password != null) {
-            Enigma.getInstance().init(password);
-        }
-        
-        //init framework constants
-        Defaults.init();
-
-        //init clover plugins system
-        Plugins.init(pluginsRootDirectory);
-    }
-    
-    
-    /**
-     * Instantiates transformation graph from a given input stream and presets a given properties.
-     * @param inStream
-     * @param properties
-     * @return
-     * @throws XMLConfigurationException
-     * @throws GraphConfigurationException
-     */
-    public static TransformationGraph loadGraph(InputStream inStream, Properties properties) throws XMLConfigurationException, GraphConfigurationException {
-        TransformationGraph graph = new TransformationGraph();
-        TransformationGraphXMLReaderWriter graphReader = new TransformationGraphXMLReaderWriter(graph);
-        if(properties != null) {
-            graph.loadGraphProperties(properties);
-        }
-
-        graphReader.read(inStream);
-        
-        return graph;
-    }
-    
 	/**
 	 *  Description of the Method
 	 *



From cloveretl-svn-commits at lists.berlios.de  Wed Feb  7 12:08:52 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 7 Feb 2007 12:08:52 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2449 -
	trunk/cloveretl.component/src/org/jetel/component
Message-ID: <200702071108.l17B8qs3000943@sheep.berlios.de>

Author: agad
Date: 2007-02-07 12:08:51 +0100 (Wed, 07 Feb 2007)
New Revision: 2449

Modified:
   trunk/cloveretl.component/src/org/jetel/component/DBInputTable.java
Log:
UPDATE:DBInputTable - BadDataFormatException handling changed to be consistent with DelimiterDataReader and FixlengthDataReade

Modified: trunk/cloveretl.component/src/org/jetel/component/DBInputTable.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DBInputTable.java	2007-02-07 10:40:16 UTC (rev 2448)
+++ trunk/cloveretl.component/src/org/jetel/component/DBInputTable.java	2007-02-07 11:08:51 UTC (rev 2449)
@@ -19,14 +19,18 @@
 */
 package org.jetel.component;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.jetel.connection.SQLDataParser;
 import org.jetel.data.DataRecord;
 import org.jetel.database.IConnection;
+import org.jetel.exception.BadDataFormatException;
 import org.jetel.exception.ComponentNotReadyException;
 import org.jetel.exception.ConfigurationProblem;
 import org.jetel.exception.ConfigurationStatus;
 import org.jetel.exception.IParserExceptionHandler;
 import org.jetel.exception.ParserExceptionHandlerFactory;
+import org.jetel.exception.PolicyType;
 import org.jetel.exception.XMLConfigurationException;
 import org.jetel.graph.Node;
 import org.jetel.graph.Result;
@@ -101,6 +105,9 @@
  * @see         org.jetel.database.AnalyzeDB
  */
 public class DBInputTable extends Node {
+
+    static Log logger = LogFactory.getLog(DBInputTable.class);
+	
 	private static final String XML_DATAPOLICY_ATTRIBUTE = "dataPolicy";
 	private static final String XML_DBCONNECTION_ATTRIBUTE = "dbConnection";
 	private static final String XML_SQLQUERY_ATTRIBUTE = "sqlQuery";
@@ -109,6 +116,7 @@
 	private static final String XML_SQLCODE_ELEMENT = "SQLCode";
 	
 	private SQLDataParser parser;
+	private PolicyType policyType;
 
 	private String dbConnectionName;
 	private String sqlQuery;
@@ -168,9 +176,17 @@
 			parser.initSQLDataMap(record);
 
 			// till it reaches end of data or it is stopped from outside
-			while (((record = parser.getNext(record)) != null) && runIt) {
-				//broadcast the record to all connected Edges
-				writeRecordBroadcast(record);
+			try {
+				while (((record = parser.getNext(record)) != null) && runIt) {
+					//broadcast the record to all connected Edges
+					writeRecordBroadcast(record);
+				}
+			} catch (BadDataFormatException bdfe) {
+		        if(policyType == PolicyType.STRICT) {
+		            throw bdfe;
+		        } else {
+		            logger.info(bdfe.getMessage());
+		        }
 			}
 		} catch (Exception e) {
 			throw e;
@@ -251,13 +267,8 @@
                         xattribs.getString(XML_DBCONNECTION_ATTRIBUTE),
                         query);
                 
-                if (xattribs.exists(XML_DATAPOLICY_ATTRIBUTE)) 
-                {
-                    aDBInputTable.setExceptionHandler(ParserExceptionHandlerFactory.getHandler(
-                                                xattribs.getString(XML_DATAPOLICY_ATTRIBUTE)));
-                }
-                
-                if (xattribs.exists(XML_FETCHSIZE_ATTRIBUTE)){
+                 aDBInputTable.setPolicyType(xattribs.getString(XML_DATAPOLICY_ATTRIBUTE,null));
+                 if (xattribs.exists(XML_FETCHSIZE_ATTRIBUTE)){
                         aDBInputTable.setFetchSize(xattribs.getInteger(XML_FETCHSIZE_ATTRIBUTE));
                 }
                 
@@ -281,14 +292,7 @@
 	}
 
 
-	/**
-	 * @param  handler
-	 */
-	private void setExceptionHandler(IParserExceptionHandler handler) {
-		parser.setExceptionHandler(handler);
-	}
 
-
 	/**  Description of the Method */
     @Override
     public ConfigurationStatus checkConfig(ConfigurationStatus status) {
@@ -318,5 +322,19 @@
 	public void setFetchSize(int fetchSize){
 	    this.fetchSize=fetchSize;
 	}
+
+    public void setPolicyType(String strPolicyType) {
+        setPolicyType(PolicyType.valueOfIgnoreCase(strPolicyType));
+    }
+    
+	/**
+	 * Adds BadDataFormatExceptionHandler to behave according to DataPolicy.
+	 *
+	 * @param  handler
+	 */
+	public void setPolicyType(PolicyType policyType) {
+        this.policyType = policyType;
+        parser.setExceptionHandler(ParserExceptionHandlerFactory.getHandler(policyType));
+	}
 	
  }



From cloveretl-svn-commits at lists.berlios.de  Wed Feb  7 12:09:13 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 7 Feb 2007 12:09:13 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2450 -
	trunk/cloveretl.connection/src/org/jetel/connection
Message-ID: <200702071109.l17B9Dwh000985@sheep.berlios.de>

Author: agad
Date: 2007-02-07 12:09:13 +0100 (Wed, 07 Feb 2007)
New Revision: 2450

Modified:
   trunk/cloveretl.connection/src/org/jetel/connection/SQLDataParser.java
Log:
UPDATE:DBInputTable - BadDataFormatException handling changed to be consistent with DelimiterDataReader and FixlengthDataReade

Modified: trunk/cloveretl.connection/src/org/jetel/connection/SQLDataParser.java
===================================================================
--- trunk/cloveretl.connection/src/org/jetel/connection/SQLDataParser.java	2007-02-07 11:08:51 UTC (rev 2449)
+++ trunk/cloveretl.connection/src/org/jetel/connection/SQLDataParser.java	2007-02-07 11:09:13 UTC (rev 2450)
@@ -185,7 +185,7 @@
 			if(exceptionHandler != null ) {  //use handler only if configured
                 exceptionHandler.populateHandler(getErrorMessage(bdfe.getMessage(), recordCounter, fieldNum), record, -1, fieldNum-1, bdfe.getOffendingValue(), bdfe);
 			} else {
-				throw new RuntimeException(getErrorMessage(bdfe.getMessage(), recordCounter, fieldNum));
+				throw bdfe;
 			}
 		} catch (Exception ex) {
             logger.debug(ex.getMessage(),ex);



From cloveretl-svn-commits at lists.berlios.de  Wed Feb  7 12:10:18 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 7 Feb 2007 12:10:18 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2451 -
	trunk/cloveretl.engine/src/org/jetel/component
Message-ID: <200702071110.l17BAIIw001083@sheep.berlios.de>

Author: agad
Date: 2007-02-07 12:10:17 +0100 (Wed, 07 Feb 2007)
New Revision: 2451

Modified:
   trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java
Log:
CHANGE:CustomizedRecordTransform - default field policy is now STRICT

Modified: trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java	2007-02-07 11:09:13 UTC (rev 2450)
+++ trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java	2007-02-07 11:10:17 UTC (rev 2451)
@@ -64,7 +64,7 @@
  * <h4>Order of execution/methods call</h4>
  * <ol>
  * <li>setGraph()</li>
- * <li>setFieldPolicy(PolicyType)</li>
+ * <li>setFieldPolicy(PolicyType) - default value is STRICT</li>
  * <li>add...Rule(...)<br>
  * .<br></li>
  * <li>deleteRule(...)<br>
@@ -230,7 +230,7 @@
 
 	protected TransformationGraph graph;
 	
-	protected PolicyType fieldPolicy = PolicyType.LENIENT;
+	protected PolicyType fieldPolicy = PolicyType.STRICT;
 	protected Log logger;
 	protected String errorMessage;
 	



From cloveretl-svn-commits at lists.berlios.de  Wed Feb  7 12:11:37 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 7 Feb 2007 12:11:37 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2452 -
	trunk/cloveretl.engine/test/org/jetel/component
Message-ID: <200702071111.l17BBbqj001312@sheep.berlios.de>

Author: agad
Date: 2007-02-07 12:11:37 +0100 (Wed, 07 Feb 2007)
New Revision: 2452

Modified:
   trunk/cloveretl.engine/test/org/jetel/component/CustomizedRecordTransformTest.java
Log:
CHANGE:CustomizedRecordTransform - default field policy is now STRICT

Modified: trunk/cloveretl.engine/test/org/jetel/component/CustomizedRecordTransformTest.java
===================================================================
--- trunk/cloveretl.engine/test/org/jetel/component/CustomizedRecordTransformTest.java	2007-02-07 11:10:17 UTC (rev 2451)
+++ trunk/cloveretl.engine/test/org/jetel/component/CustomizedRecordTransformTest.java	2007-02-07 11:11:37 UTC (rev 2452)
@@ -43,6 +43,7 @@
         graph=new TransformationGraph();
         
         transform.setGraph(graph);
+		transform.setFieldPolicy(PolicyType.LENIENT);
         
 		metadata=new DataRecordMetadata("in",DataRecordMetadata.DELIMITED_RECORD);
 		
@@ -130,7 +131,6 @@
 		System.out.println(out.getMetadata().getName() + ":\n" + out.toString());
 		System.out.println(out1.getMetadata().getName() + ":\n" + out1.toString());
 //		transform.setFieldPolicy(PolicyType.CONTROLLED);
-//		transform.setFieldPolicy(PolicyType.STRICT);
 		transform.addFieldToFieldRule("0.1", "0.1");
 		transform.addFieldToFieldRule("${1.?a*}", "${1.*e}");
 		transform.addFieldToFieldRule("${out.0.Name}", "${in.1.3}");



From cloveretl-svn-commits at lists.berlios.de  Wed Feb  7 15:27:09 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 7 Feb 2007 15:27:09 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2453 -
	trunk/cloveretl.engine/src/org/jetel/data/parser
Message-ID: <200702071427.l17ER99E025979@sheep.berlios.de>

Author: agad
Date: 2007-02-07 15:27:08 +0100 (Wed, 07 Feb 2007)
New Revision: 2453

Modified:
   trunk/cloveretl.engine/src/org/jetel/data/parser/FixLenCharDataParser.java
Log:
FIX:FixLenCharDataParser - skipping blank space is after inquoting
unquoting is not aplicated only an byte data fields

Modified: trunk/cloveretl.engine/src/org/jetel/data/parser/FixLenCharDataParser.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/parser/FixLenCharDataParser.java	2007-02-07 11:11:37 UTC (rev 2452)
+++ trunk/cloveretl.engine/src/org/jetel/data/parser/FixLenCharDataParser.java	2007-02-07 14:27:08 UTC (rev 2453)
@@ -27,6 +27,7 @@
 import org.jetel.exception.BadDataFormatException;
 import org.jetel.exception.ComponentNotReadyException;
 import org.jetel.exception.JetelException;
+import org.jetel.metadata.DataFieldMetadata;
 import org.jetel.metadata.DataRecordMetadata;
 import org.jetel.util.StringUtils;
 
@@ -155,21 +156,22 @@
 				rawRec.limit(Math.min(recStart + fieldEnd[fieldIdx], recEnd));
 				rawRec.position(recStart + fieldStart[fieldIdx]);
 				
-                // shall we remove quotes ??
-                switch(record.getField(fieldIdx).getType()){
-                case org.jetel.metadata.DataFieldMetadata.STRING_FIELD:
-                case org.jetel.metadata.DataFieldMetadata.NUMERIC_FIELD:
-                case org.jetel.metadata.DataFieldMetadata.DECIMAL_FIELD:
-					StringUtils.unquote(rawRec);
-                    break;
-				}
-                
 				if (skipLBlanks) {
 					StringUtils.trimLeading(rawRec);
 				}
 				if (skipTBlanks) {
 					StringUtils.trimTrailing(rawRec);
 				}
+                // shall we remove quotes ??
+                switch(record.getField(fieldIdx).getType()){
+                case DataFieldMetadata.BYTE_FIELD:
+                case DataFieldMetadata.BYTE_FIELD_COMPRESSED:
+                     break;
+                default:
+   					StringUtils.unquote(rawRec);
+                	break;
+				}
+                
 				record.getField(fieldIdx).fromString(rawRec);
 			} catch (BadDataFormatException e) {
 					fillXHandler(record, rawRec != null ? rawRec : null, e);



From cloveretl-svn-commits at lists.berlios.de  Wed Feb  7 15:28:17 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 7 Feb 2007 15:28:17 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2454 -
	trunk/cloveretl.engine/src/org/jetel/util
Message-ID: <200702071428.l17ESHUh026036@sheep.berlios.de>

Author: agad
Date: 2007-02-07 15:28:16 +0100 (Wed, 07 Feb 2007)
New Revision: 2454

Modified:
   trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java
Log:
CHANGE:StringUtils - methods trim don't use tmp char array

Modified: trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java	2007-02-07 14:27:08 UTC (rev 2453)
+++ trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java	2007-02-07 14:28:16 UTC (rev 2454)
@@ -292,10 +292,9 @@
 	}
 	
 	public static StringBuilder trimLeading(StringBuilder str){
-		char[] chars = new char[str.length()];
-		str.getChars(0, chars.length, chars, 0);
 		int pos = 0;
-		while (pos < chars.length && Character.isWhitespace(chars[pos])) {
+		int length = str.length();
+		while (pos < length && Character.isWhitespace(str.charAt(pos))) {
 			pos++;
 		}
 		str.delete(0, pos);
@@ -318,10 +317,8 @@
 	}
 	
 	public static StringBuilder trimTrailing(StringBuilder str){
-		char[] chars = new char[str.length()];
-		str.getChars(0, chars.length, chars, 0);
-		int pos = chars.length - 1;
-		while (pos > 0 && Character.isWhitespace(chars[pos])) {
+		int pos = str.length() - 1;
+		while (pos > 0 && Character.isWhitespace(str.charAt(pos))) {
 			pos--;
 		}
 		str.setLength(pos+1);



From cloveretl-svn-commits at lists.berlios.de  Thu Feb  8 09:26:32 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 8 Feb 2007 09:26:32 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2455 -
	trunk/cloveretl.component/src/org/jetel/component
Message-ID: <200702080826.l188QWec022890@sheep.berlios.de>

Author: agad
Date: 2007-02-08 09:26:31 +0100 (Thu, 08 Feb 2007)
New Revision: 2455

Modified:
   trunk/cloveretl.component/src/org/jetel/component/DBInputTable.java
Log:
UPDATE:DBInputTable : method toXML updated (attribute "dataPolicy")

Modified: trunk/cloveretl.component/src/org/jetel/component/DBInputTable.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DBInputTable.java	2007-02-07 14:28:16 UTC (rev 2454)
+++ trunk/cloveretl.component/src/org/jetel/component/DBInputTable.java	2007-02-08 08:26:31 UTC (rev 2455)
@@ -28,7 +28,6 @@
 import org.jetel.exception.ComponentNotReadyException;
 import org.jetel.exception.ConfigurationProblem;
 import org.jetel.exception.ConfigurationStatus;
-import org.jetel.exception.IParserExceptionHandler;
 import org.jetel.exception.ParserExceptionHandlerFactory;
 import org.jetel.exception.PolicyType;
 import org.jetel.exception.XMLConfigurationException;
@@ -225,7 +224,9 @@
 		}
 		
 		xmlElement.setAttribute(XML_DBCONNECTION_ATTRIBUTE, this.dbConnectionName);
-		
+		if (policyType != null){
+			xmlElement.setAttribute(XML_DATAPOLICY_ATTRIBUTE, policyType.toString());
+		}
 	}
 
 	/**



From cloveretl-svn-commits at lists.berlios.de  Thu Feb  8 09:27:50 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 8 Feb 2007 09:27:50 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2456 -
	trunk/cloveretl.component/src/org/jetel/component
Message-ID: <200702080827.l188RoEJ022979@sheep.berlios.de>

Author: agad
Date: 2007-02-08 09:27:48 +0100 (Thu, 08 Feb 2007)
New Revision: 2456

Modified:
   trunk/cloveretl.component/src/org/jetel/component/FixLenDataReader.java
Log:
UPDATE:FixLenDataReader - trim attribute introduced

Modified: trunk/cloveretl.component/src/org/jetel/component/FixLenDataReader.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/FixLenDataReader.java	2007-02-08 08:26:31 UTC (rev 2455)
+++ trunk/cloveretl.component/src/org/jetel/component/FixLenDataReader.java	2007-02-08 08:27:48 UTC (rev 2456)
@@ -118,6 +118,7 @@
     private static final String XML_SKIPFIRSTLINE_ATTRIBUTE = "skipFirstLine";
 	private static final String XML_SKIP_ROWS_ATTRIBUTE = "skipRows";
     private static final String XML_NUMRECORDS_ATTRIBUTE = "numRecords";
+	private static final String XML_TRIM_ATTRIBUTE = "trim";
 	
 	static Log logger = LogFactory.getLog(FixLenDataReader.class);
 	
@@ -256,7 +257,12 @@
 		if (this.skipRows>0){
 		    xmlElement.setAttribute(XML_SKIP_ROWS_ATTRIBUTE, String.valueOf(skipRows));
 		}
-		xmlElement.setAttribute(XML_DATAPOLICY_ATTRIBUTE, policyType.toString());		
+		xmlElement.setAttribute(XML_DATAPOLICY_ATTRIBUTE, policyType.toString());
+		if (parser instanceof FixLenCharDataParser
+				&& ((FixLenCharDataParser) parser).getTrim() != null) {
+			xmlElement.setAttribute(XML_TRIM_ATTRIBUTE, String
+					.valueOf(((FixLenCharDataParser) parser).getTrim()));
+		}
 	}
 
 
@@ -305,6 +311,9 @@
                 aFixLenDataReaderNIO.setNumRecords(xattribs.getInteger(XML_NUMRECORDS_ATTRIBUTE));
             }
 			aFixLenDataReaderNIO.setPolicyType(xattribs.getString(XML_DATAPOLICY_ATTRIBUTE, null));			
+			if (xattribs.exists(XML_TRIM_ATTRIBUTE)){
+				aFixLenDataReaderNIO.setTrim(xattribs.getBoolean(XML_TRIM_ATTRIBUTE));
+			}
 		} catch (Exception ex) {
 	           throw new XMLConfigurationException(COMPONENT_TYPE + ":" + xattribs.getString(XML_ID_ATTRIBUTE," unknown ID ") + ":" + ex.getMessage(),ex);
 		}
@@ -386,5 +395,10 @@
         this.skipFirstLine = skip;
     }
 
+    public void setTrim(Boolean trim){
+    	if (parser instanceof FixLenCharDataParser){
+    		((FixLenCharDataParser)parser).setTrim(trim);
+    	}
+    }
 }
 



From cloveretl-svn-commits at lists.berlios.de  Thu Feb  8 09:28:25 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 8 Feb 2007 09:28:25 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2457 -
	trunk/cloveretl.connection/test
Message-ID: <200702080828.l188SPLk023064@sheep.berlios.de>

Author: agad
Date: 2007-02-08 09:28:24 +0100 (Thu, 08 Feb 2007)
New Revision: 2457

Modified:
   trunk/cloveretl.connection/test/BadDataFormatExceptionHandler_SQLDataParser_Test.java
   trunk/cloveretl.connection/test/SQLDataParserTest.java
Log:
UPDATE:updated due to changes in engine

Modified: trunk/cloveretl.connection/test/BadDataFormatExceptionHandler_SQLDataParser_Test.java
===================================================================
--- trunk/cloveretl.connection/test/BadDataFormatExceptionHandler_SQLDataParser_Test.java	2007-02-08 08:27:48 UTC (rev 2456)
+++ trunk/cloveretl.connection/test/BadDataFormatExceptionHandler_SQLDataParser_Test.java	2007-02-08 08:28:24 UTC (rev 2457)
@@ -221,15 +221,15 @@
 			 fail("Should throw Exception");
 		 }
 	 } catch (BadDataFormatException e){	
-		 fail("Should not raise an BadDataFormatException");
-		 e.printStackTrace();
-	 } catch (RuntimeException re) {
 		 failed = true;
+		System.out.println(e.getMessage());
+	 } catch (RuntimeException re) {
+		 fail("Should throw RuntimeException");
 	 } catch (Exception ee){
 		 ee.printStackTrace();
 	 }
 	 if(!failed)
-		 fail("Should raise an RuntimeException");
+		 fail("Should raise an BadDataFormatException");
  }
 	
 
@@ -276,8 +276,7 @@
 			 recCount++;
 		 }
 	 } catch (BadDataFormatException e){	
-		 fail("Should not raise an BadDataFormatException");
-		 e.printStackTrace();
+		 System.out.println(e.getMessage());
 	 } catch (Exception ee){
 		 fail("Should not throw Exception");
 		 ee.printStackTrace();

Modified: trunk/cloveretl.connection/test/SQLDataParserTest.java
===================================================================
--- trunk/cloveretl.connection/test/SQLDataParserTest.java	2007-02-08 08:27:48 UTC (rev 2456)
+++ trunk/cloveretl.connection/test/SQLDataParserTest.java	2007-02-08 08:28:24 UTC (rev 2457)
@@ -1,5 +1,4 @@
 
-
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 
@@ -8,6 +7,7 @@
 import org.jetel.data.DataRecord;
 import org.jetel.exception.BadDataFormatException;
 import org.jetel.exception.ComponentNotReadyException;
+import org.jetel.main.runGraph;
 import org.jetel.metadata.DataRecordMetadata;
 import org.jetel.metadata.DataRecordMetadataXMLReaderWriter;
 
@@ -15,80 +15,91 @@
 
 /**
  * @author maciorowski
- *
+ * 
  */
-public class SQLDataParserTest  extends TestCase {
-private SQLDataParser aParser2 = null;
-private DataRecord record;
-	
-protected void setUp() { 
-	DataRecordMetadata metadata = null;
-	DataRecordMetadataXMLReaderWriter xmlReader = new DataRecordMetadataXMLReaderWriter();
-	DBConnection aDBConnection = null;
-				
-	try {
-//		metadata = xmlReader.read(new FileInputStream("config\\test\\rec_def\\db_null_def_rec.xml"));
-//		aDBConnection = new DBConnection("", "config\\test\\msaccess.clover_test.txt");
-		metadata = xmlReader.read(new FileInputStream("../cloveretl.engine/config/test/rec_def/db_def_rec.xml"));
-		aDBConnection = new DBConnection("conn", "../cloveretl.engine/examples/koule_postgre.cfg");
-	} catch(FileNotFoundException e){
-		e.printStackTrace();
+public class SQLDataParserTest extends TestCase {
+	private SQLDataParser aParser2 = null;
+
+	private DataRecord record;
+
+	protected void setUp() {
+		DataRecordMetadata metadata = null;
+		DataRecordMetadataXMLReaderWriter xmlReader = new DataRecordMetadataXMLReaderWriter();
+		DBConnection aDBConnection = null;
+
+		runGraph.initEngine("../cloveretl.engine/plugins", null);
+		try {
+			// metadata = xmlReader.read(new
+			// FileInputStream("config\\test\\rec_def\\db_null_def_rec.xml"));
+			// aDBConnection = new DBConnection("",
+			// "config\\test\\msaccess.clover_test.txt");
+			metadata = xmlReader.read(new FileInputStream(
+					"../cloveretl.engine/config/test/rec_def/db_def_rec.xml"));
+			aDBConnection = new DBConnection("conn",
+					"../cloveretl.engine/examples/koule_postgre.cfg");
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+		}
+
+		try {
+			aDBConnection.init();
+		} catch (ComponentNotReadyException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+
+		record = new DataRecord(metadata);
+		record.init();
+
+		aParser2 = new SQLDataParser("connection", "SELECT * FROM good");
+		try {
+			aParser2.init(metadata);
+			aParser2.setDataSource(aDBConnection);
+			aParser2.initSQLDataMap(record);
+		} catch (ComponentNotReadyException e1) {
+			e1.printStackTrace();
+		}
 	}
-	
-	record = new DataRecord(metadata);
-	record.init();
 
-	aParser2 = new SQLDataParser("connection","SELECT * FROM bad");
-	try {
-		aParser2.init(metadata);
-		aParser2.setDataSource(aDBConnection);
-		aParser2.initSQLDataMap(record);
-	} catch (ComponentNotReadyException e1) {
-		e1.printStackTrace();
+	protected void tearDown() {
+		aParser2.close();
+		aParser2 = null;
+		record = null;
 	}
-}
-	
-   protected void tearDown() {
-	   aParser2.close();
-	   aParser2 = null;
-	   record  = null;
-   }
 
-public void test_parsing() {
-// the content of the test file
-//	  N/AStone          01/11/93
-//	-15.5          112  11/03/02
-//	 -0.7Bone Broo    99        
-	int recCount = 0;
-	try{
-		while((record=aParser2.getNext(record))!=null){
-			if(recCount==0) {
-				assertEquals(record.getField(0).toString(),"1.0");
-				assertTrue(record.getField(1).isNull());
-				assertEquals(record.getField(2).toString(),"101");
-				assertEquals(record.getField(3).toString(),"1993-01-11 00:00:00");
-			} else if(recCount==1) {
-				assertEquals(record.getField(0).toString(),"-15.5");
-				assertTrue(record.getField(3).isNull());
-				assertEquals(record.getField(2).toString(),"112");
-				assertEquals(record.getField(1).toString(),"Brook");
-			} else if(recCount==2) {
-				assertTrue(record.getField(0).isNull());
-				assertEquals(record.getField(1).toString(),"Bone Broo");
-				assertTrue(record.getField(2).isNull());
-				assertEquals(record.getField(3).toString(),"2003-01-01 00:00:00");
+	public void test_parsing() {
+		int recCount = 0;
+		try {
+			while ((record = aParser2.getNext(record)) != null) {
+				if (recCount == 0) {
+					assertEquals(record.getField(0).toString(), "1.0");
+					assertEquals(record.getField(1).toString(), "Stone");
+					assertEquals(record.getField(2).toString(), "101");
+					assertEquals(record.getField(3).toString(),
+							"1993-01-11 00:00:00");
+				} else if (recCount == 2) {
+					assertEquals(record.getField(0).toString(), "-15.5");
+					assertEquals(record.getField(2).toString(), "112");
+					assertEquals(record.getField(1).toString(), "Brook");
+					assertEquals(record.getField(3).toString(),
+							"2002-11-03 00:00:00");
+				} else if (recCount == 3) {
+					assertEquals(record.getField(0).toString(), "-0.7");
+					assertEquals(record.getField(1).toString(), "Bone Broo");
+					assertEquals(record.getField(2).toString(), "99");
+					assertEquals(record.getField(3).toString(),
+							"1993-01-01 00:00:00");
+				}
+				recCount++;
 			}
-			recCount++;
+		} catch (BadDataFormatException e) {
+			fail("Should not raise an BadDataFormatException");
+			e.printStackTrace();
+		} catch (Exception ee) {
+			fail("Should not throw Exception");
+			ee.printStackTrace();
 		}
-	} catch (BadDataFormatException e){	
-		fail("Should not raise an BadDataFormatException");
-		e.printStackTrace();
-	} catch (Exception ee){
-		fail("Should not throw Exception");
-		ee.printStackTrace();
+		assertEquals(4, recCount);
 	}
-   assertEquals(3,recCount);
-}
-	
 
 }



From cloveretl-svn-commits at lists.berlios.de  Thu Feb  8 10:00:25 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 8 Feb 2007 10:00:25 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2458 - in trunk:
	cloveretl.component/src/org/jetel/component
	cloveretl.engine/src/org/jetel/main
	cloveretl.engine/src/org/jetel/util
Message-ID: <200702080900.l1890P0s026769@sheep.berlios.de>

Author: ausperger
Date: 2007-02-08 10:00:23 +0100 (Thu, 08 Feb 2007)
New Revision: 2458

Modified:
   trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java
   trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java
   trunk/cloveretl.engine/src/org/jetel/main/showData.java
   trunk/cloveretl.engine/src/org/jetel/util/MultiFileWriter.java
Log:
FIX: MultiFileWriter has new constructor with channelwriter and restriction on skip and count of records;
     optimize next classes

Modified: trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-08 08:28:24 UTC (rev 2457)
+++ trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-08 09:00:23 UTC (rev 2458)
@@ -21,6 +21,7 @@
 package org.jetel.component;
 import java.nio.channels.Channels;
 import java.nio.channels.WritableByteChannel;
+import java.util.Iterator;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -35,7 +36,6 @@
 import org.jetel.graph.Node;
 import org.jetel.graph.Result;
 import org.jetel.graph.TransformationGraph;
-import org.jetel.metadata.DataRecordMetadata;
 import org.jetel.util.ComponentXMLAttributes;
 import org.jetel.util.MultiFileWriter;
 import org.jetel.util.StringUtils;
@@ -76,6 +76,8 @@
  *  <tr><td><b>outputFieldNames</b><br><i>optional</i></td><td>print names of individual fields into output file - as a first row (values: true/false, default:false)</td> 
  *  <tr><td><b>recordsPerFile</b></td><td>max number of records in one output file</td>
  *  <tr><td><b>bytesPerFile</b></td><td>Max size of output files. To avoid splitting a record to two files, max size could be slightly overreached.</td>
+ *  <tr><td><b>recordSkip</b></td><td>number of skipped records</td>
+ *  <tr><td><b>recordCount</b></td><td>number of written records</td>
  *  </tr>
  *  </table>  
  *
@@ -92,6 +94,8 @@
     private static final String XML_OUTPUT_FIELD_NAMES = "outputFieldNames";
 	private static final String XML_RECORDS_PER_FILE = "recordsPerFile";
 	private static final String XML_BYTES_PER_FILE = "bytesPerFile";
+	public static final String XML_RECORD_SKIP_ATTRIBUTE = "recordSkip";
+	public static final String XML_RECORD_COUNT_ATTRIBUTE = "recordCount";
 	private String fileURL;
 	private boolean appendData;
 	private DataFormatter formatter;
@@ -99,17 +103,15 @@
     private boolean outputFieldNames;
 	private int bytesPerFile;
 	private int recordsPerFile;
-	private WritableByteChannel channelWriter;
-	private String delimiter;
-	private long recordFrom = -1;
-	private long recordCount = -1;
+	private WritableByteChannel writableByteChannel;
+    private int skip;
+	private int numRecords;
 
 	static Log logger = LogFactory.getLog(DataWriter.class);
 
 	public final static String COMPONENT_TYPE = "DATA_WRITER";
 	private final static int READ_FROM_PORT = 0;
 
-
 	/**
 	 *Constructor for the DataWriter object
 	 *
@@ -124,33 +126,31 @@
 		this.appendData = appendData;
 		formatter = new DataFormatter(charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
 	}
+	
+	public DataWriter(String id, WritableByteChannel writableByteChannel, String charset, boolean appendData) {
+		super(id);
+		this.writableByteChannel = writableByteChannel;
+		this.appendData = appendData;
+		formatter = new DataFormatter(charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
+	}
 
 	@Override
 	public Result execute() throws Exception {
 		InputPort inPort = getInputPort(READ_FROM_PORT);
 		DataRecord record = new DataRecord(inPort.getMetadata());
-		long iRec = 0;
-		long recordTo = recordCount < 0 ? Long.MAX_VALUE : (recordFrom < 0 ? recordCount+1 : recordFrom + recordCount);
 		record.init();
 		try {
 			while (record != null && runIt) {
-				iRec++;
 				record = inPort.readRecord(record);
-				if (recordFrom > iRec || recordTo <= iRec) continue;
 				if (record != null) {
-					if (channelWriter != null) {
-						formatter.write(record);
-					} else {
-						writer.write(record);
-					}
+					writer.write(record);
 				}
 				SynchronizeUtils.cloverYield();
 			}
-			if (channelWriter != null) formatter.flush();
 		} catch (Exception e) {
 			throw e;
 		}finally{		
-			if (writer != null) writer.close();
+			writer.close();
 		}
         return runIt ? Result.FINISHED_OK : Result.ABORTED;
 	}
@@ -165,29 +165,25 @@
 	public void init() throws ComponentNotReadyException {
 		super.init();
 
+		// initialize multifile writer based on prepared formatter
 		if (fileURL != null) {
-	        // initialize multifile writer based on prepared formatter
 	        writer = new MultiFileWriter(formatter, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
-	        writer.setLogger(logger);
-	        writer.setBytesPerFile(bytesPerFile);
-	        writer.setRecordsPerFile(recordsPerFile);
-	        writer.setAppendData(appendData);
-	        if(outputFieldNames) {
-	            writer.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
-	        }
-	        writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 		} else {
-			channelWriter = Channels.newChannel(System.out);
-			formatter.setDataTarget(channelWriter);
-			DataRecordMetadata metadata = getInputPort(READ_FROM_PORT).getMetadata();
-			if (delimiter != null) {
-				for(int i=0; i<metadata.getNumFields()-1; i++) {
-					metadata.getField(i).setDelimiter(delimiter);
-				}
-				//metadata.getField(metadata.getNumFields()-1).setDelimiter("\n");
+			if (writableByteChannel == null) {
+		        writableByteChannel = Channels.newChannel(System.out);
 			}
-			formatter.init(metadata);
+	        writer = new MultiFileWriter(formatter, new WritableByteChannelIterator(writableByteChannel));
 		}
+        writer.setLogger(logger);
+        writer.setBytesPerFile(bytesPerFile);
+        writer.setRecordsPerFile(recordsPerFile);
+        writer.setAppendData(appendData);
+        writer.setSkip(skip);
+        writer.setNumRecords(numRecords);
+        if(outputFieldNames) {
+            writer.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
+        }
+        writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}
 	
 	/**
@@ -212,6 +208,12 @@
         if (bytesPerFile > 0) {
             xmlElement.setAttribute(XML_BYTES_PER_FILE, Integer.toString(bytesPerFile));
         }
+		if (skip != 0){
+			xmlElement.setAttribute(XML_RECORD_SKIP_ATTRIBUTE, String.valueOf(skip));
+		}
+		if (numRecords != 0){
+			xmlElement.setAttribute(XML_RECORD_COUNT_ATTRIBUTE,String.valueOf(numRecords));
+		}
 		xmlElement.setAttribute(XML_APPEND_ATTRIBUTE, String.valueOf(this.appendData));
 	}
 
@@ -242,6 +244,12 @@
             if(xattribs.exists(XML_BYTES_PER_FILE)) {
                 aDataWriter.setBytesPerFile(xattribs.getInteger(XML_BYTES_PER_FILE));
             }
+			if (xattribs.exists(XML_RECORD_SKIP_ATTRIBUTE)){
+				aDataWriter.setSkip(Integer.parseInt(xattribs.getString(XML_RECORD_SKIP_ATTRIBUTE)));
+			}
+			if (xattribs.exists(XML_RECORD_COUNT_ATTRIBUTE)){
+				aDataWriter.setNumRecords(Integer.parseInt(xattribs.getString(XML_RECORD_COUNT_ATTRIBUTE)));
+			}
         } catch (Exception ex) {
             throw new XMLConfigurationException(COMPONENT_TYPE + ":" + xattribs.getString(XML_ID_ATTRIBUTE," unknown ID ") + ":" + ex.getMessage(),ex);
         }
@@ -285,12 +293,10 @@
         this.bytesPerFile = bytesPerFile;
     }
 
-
     public int getRecordsPerFile() {
         return recordsPerFile;
     }
 
-
     public void setRecordsPerFile(int recordsPerFile) {
         this.recordsPerFile = recordsPerFile;
     }
@@ -299,16 +305,38 @@
         this.outputFieldNames = outputFieldNames;
     }
     
-    public void setDataDelimiter(String delimiter) {
-    	this.delimiter = delimiter;
+    /**
+     * Sets number of skipped records in next call of getNext() method.
+     * @param skip
+     */
+    public void setSkip(int skip) {
+        this.skip = skip;
     }
-    
-	public void setRecordFrom(long recordFrom) {
-		this.recordFrom = recordFrom;
-	}
 
-	public void setRecordCount(long recordCount) {
-		this.recordCount = recordCount;
-	}
+    /**
+     * Sets number of written records.
+     * @param numRecords
+     */
+    public void setNumRecords(int numRecords) {
+        this.numRecords = numRecords;
+    }
+	
+    private class WritableByteChannelIterator implements Iterator<WritableByteChannel> {
+    	WritableByteChannel writableByteChannel;
+    	
+    	public WritableByteChannelIterator(WritableByteChannel writableByteChannel) {
+    		this.writableByteChannel = writableByteChannel;
+    	}
+    	
+		public boolean hasNext() {
+			return true;
+		}
 
+		public WritableByteChannel next() {
+			return writableByteChannel;
+		}
+
+		public void remove() {}
+    }
+    
 }

Modified: trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-08 08:28:24 UTC (rev 2457)
+++ trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-08 09:00:23 UTC (rev 2458)
@@ -81,6 +81,8 @@
  *  where field1 ,.., fieldn are record's fields from metadata</td>
  *  <tr><td><b>header</b></td><td>text to write before records</td>
  *  <tr><td><b>footer</b></td><td>text to write after records</td>
+ *  <tr><td><b>recordSkip</b></td><td>number of skipped records</td>
+ *  <tr><td><b>recordCount</b></td><td>number of written records</td>
  *  </tr>
  *  </table>  
  *
@@ -113,7 +115,7 @@
 	public static final String XML_MASK_ATTRIBUTE = "mask";
 	public static final String XML_HEADER_ATTRIBUTE = "header";
 	public static final String XML_FOOTER_ATTRIBUTE = "footer";
-	public static final String XML_RECORD_FROM_ATTRIBUTE = "recordFrom";
+	public static final String XML_RECORD_SKIP_ATTRIBUTE = "recordSkip";
 	public static final String XML_RECORD_COUNT_ATTRIBUTE = "recordCount";
 
 	private String fileURL;
@@ -124,8 +126,8 @@
 	private WritableByteChannel writer;
 	private ByteBuffer buffer;
 	private String charset;
-	private long recordFrom = -1;
-	private long recordCount = -1;
+    private int skip;
+	private int numRecords;
 
 	public final static String COMPONENT_TYPE = "STRUCTURE_WRITER";
 	private final static int READ_FROM_PORT = 0;
@@ -167,15 +169,15 @@
 		}
 		InputPort inPort = getInputPort(READ_FROM_PORT);
 		DataRecord record = new DataRecord(inPort.getMetadata());
-		long iRec = 0;
-		long recordTo = recordCount < 0 ? Long.MAX_VALUE : (recordFrom < 0 ? recordCount+1 : recordFrom + recordCount);
+		int iRec = 0;
+		int recordTo = numRecords < 0 ? Integer.MAX_VALUE : (skip <= 0 ? numRecords+1 : skip+1 + numRecords);
 		record.init();
 		//write records
 		try {
 			while (record != null && runIt) {
 				iRec++;
 				record = inPort.readRecord(record);
-				if (recordFrom > iRec || recordTo <= iRec) continue;
+				if (skip >= iRec || recordTo <= iRec) continue;
 				if (record != null) {
 					formatter.write(record);
 				}
@@ -262,11 +264,11 @@
 			if (xattribs.exists(XML_FOOTER_ATTRIBUTE)){
 				aDataWriter.setFooter(xattribs.getString(XML_FOOTER_ATTRIBUTE));
 			}
-			if (xattribs.exists(XML_RECORD_FROM_ATTRIBUTE)){
-				aDataWriter.setRecordFrom(Long.parseLong(xattribs.getString(XML_RECORD_FROM_ATTRIBUTE)));
+			if (xattribs.exists(XML_RECORD_SKIP_ATTRIBUTE)){
+				aDataWriter.setSkip(Integer.parseInt(xattribs.getString(XML_RECORD_SKIP_ATTRIBUTE)));
 			}
 			if (xattribs.exists(XML_RECORD_COUNT_ATTRIBUTE)){
-				aDataWriter.setRecordCount(Long.parseLong(xattribs.getString(XML_RECORD_COUNT_ATTRIBUTE)));
+				aDataWriter.setNumRecords(Integer.parseInt(xattribs.getString(XML_RECORD_COUNT_ATTRIBUTE)));
 			}
 		}catch(Exception ex){
 			System.err.println(COMPONENT_TYPE + ":" + xattribs.getString(Node.XML_ID_ATTRIBUTE,"unknown ID") + ":" + ex.getMessage());
@@ -293,11 +295,11 @@
 		if (footer != null){
 			xmlElement.setAttribute(XML_FOOTER_ATTRIBUTE,footer);
 		}
-		if (recordFrom != -1){
-			xmlElement.setAttribute(XML_RECORD_FROM_ATTRIBUTE, String.valueOf(recordFrom));
+		if (skip != 0){
+			xmlElement.setAttribute(XML_RECORD_SKIP_ATTRIBUTE, String.valueOf(skip));
 		}
-		if (recordCount != -1){
-			xmlElement.setAttribute(XML_RECORD_COUNT_ATTRIBUTE,String.valueOf(recordCount));
+		if (numRecords != 0){
+			xmlElement.setAttribute(XML_RECORD_COUNT_ATTRIBUTE,String.valueOf(numRecords));
 		}
 	}
 	
@@ -309,12 +311,20 @@
 		this.header = header;
 	}
 
-	public void setRecordFrom(long recordFrom) {
-		this.recordFrom = recordFrom;
-	}
+    /**
+     * Sets number of skipped records in next call of getNext() method.
+     * @param skip
+     */
+    public void setSkip(int skip) {
+        this.skip = skip;
+    }
 
-	public void setRecordCount(long recordCount) {
-		this.recordCount = recordCount;
-	}
+    /**
+     * Sets number of written records.
+     * @param numRecords
+     */
+    public void setNumRecords(int numRecords) {
+        this.numRecords = numRecords;
+    }
 
 }

Modified: trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java	2007-02-08 08:28:24 UTC (rev 2457)
+++ trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java	2007-02-08 09:00:23 UTC (rev 2458)
@@ -71,6 +71,8 @@
  *  minimal length of the number. Name without wildcard specifies only one file.</td>
  *  <tr><td><b>charset</b></td><td>character encoding of the output file (if not specified, then ISO-8859-1 is used)</td>
  *  <tr><td><b>append</b></td><td>whether to append data at the end if output file exists or replace it (values: true/false)</td>
+ *  <tr><td><b>recordSkip</b></td><td>number of skipped records</td>
+ *  <tr><td><b>recordCount</b></td><td>number of written records</td>
  *  </tr>
  *  </table>  
  *
@@ -94,7 +96,7 @@
 	public static final String XML_CHARSET_ATTRIBUTE = "charset";
 	public static final String XML_MASK_ATTRIBUTE = "mask";
 	public static final String XML_HEADER_ATTRIBUTE = "header";
-	public static final String XML_RECORD_FROM_ATTRIBUTE = "recordFrom";
+	public static final String XML_RECORD_SKIP_ATTRIBUTE = "recordSkip";
 	public static final String XML_RECORD_COUNT_ATTRIBUTE = "recordCount";
 
 	private String fileURL;
@@ -102,9 +104,8 @@
 	private TextTableFormatter formatter;
 	private boolean header = true;
 	private WritableByteChannel writer;
-	private String charset;
-	private long recordFrom = -1;
-	private long recordCount = -1;
+    private int skip;
+	private int numRecords;
 	
 	public final static String COMPONENT_TYPE = "TEXT_TABLE_WRITER";
 	private final static int READ_FROM_PORT = 0;
@@ -123,9 +124,7 @@
 		super(id);
 		this.fileURL = fileURL;
 		this.appendData = appendData;
-		this.charset = charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER;
-		formatter = charset == null ? new TextTableFormatter() : 
-			new TextTableFormatter(charset);
+		formatter = charset == null ? new TextTableFormatter(Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER) : new TextTableFormatter(charset);
 		formatter.setMask(fields);
 	}
 
@@ -143,14 +142,14 @@
 		InputPort inPort = getInputPort(READ_FROM_PORT);
 		DataRecord record = new DataRecord(inPort.getMetadata());
 		long iRec = 0;
-		long recordTo = recordCount < 0 ? Long.MAX_VALUE : (recordFrom < 0 ? recordCount+1 : recordFrom + recordCount);
+		int recordTo = numRecords < 0 ? Integer.MAX_VALUE : (skip <= 0 ? numRecords+1 : skip+1 + numRecords);
 		record.init();
 		//write records
 		try {
 			while (record != null && runIt) {
 				iRec++;
 				record = inPort.readRecord(record);
-				if (recordFrom > iRec || recordTo <= iRec) continue;
+				if (skip >= iRec || recordTo <= iRec) continue;
 				if (record != null) {
 					formatter.write(record);
 				}
@@ -230,11 +229,11 @@
 			if (xattribs.exists(XML_HEADER_ATTRIBUTE)){
 				aDataWriter.setHeader(Boolean.parseBoolean(xattribs.getString(XML_HEADER_ATTRIBUTE)));
 			}
-			if (xattribs.exists(XML_RECORD_FROM_ATTRIBUTE)){
-				aDataWriter.setRecordFrom(Long.parseLong(xattribs.getString(XML_RECORD_FROM_ATTRIBUTE)));
+			if (xattribs.exists(XML_RECORD_SKIP_ATTRIBUTE)){
+				aDataWriter.setSkip(Integer.parseInt(xattribs.getString(XML_RECORD_SKIP_ATTRIBUTE)));
 			}
 			if (xattribs.exists(XML_RECORD_COUNT_ATTRIBUTE)){
-				aDataWriter.setRecordCount(Long.parseLong(xattribs.getString(XML_RECORD_COUNT_ATTRIBUTE)));
+				aDataWriter.setNumRecords(Integer.parseInt(xattribs.getString(XML_RECORD_COUNT_ATTRIBUTE)));
 			}
 		}catch(Exception ex){
 			System.err.println(COMPONENT_TYPE + ":" + xattribs.getString(Node.XML_ID_ATTRIBUTE,"unknown ID") + ":" + ex.getMessage());
@@ -256,11 +255,11 @@
 		}
 		xmlElement.setAttribute(XML_APPEND_ATTRIBUTE, String.valueOf(this.appendData));
 		xmlElement.setAttribute(XML_HEADER_ATTRIBUTE,String.valueOf(header));
-		if (recordFrom != -1){
-			xmlElement.setAttribute(XML_RECORD_FROM_ATTRIBUTE, String.valueOf(recordFrom));
+		if (skip != 0){
+			xmlElement.setAttribute(XML_RECORD_SKIP_ATTRIBUTE, String.valueOf(skip));
 		}
-		if (recordCount != -1){
-			xmlElement.setAttribute(XML_RECORD_COUNT_ATTRIBUTE,String.valueOf(recordCount));
+		if (numRecords != 0){
+			xmlElement.setAttribute(XML_RECORD_COUNT_ATTRIBUTE,String.valueOf(numRecords));
 		}
 	}
 	
@@ -268,12 +267,20 @@
 		this.header = header;
 	}
 
-	public void setRecordFrom(long recordFrom) {
-		this.recordFrom = recordFrom;
-	}
+    /**
+     * Sets number of skipped records in next call of getNext() method.
+     * @param skip
+     */
+    public void setSkip(int skip) {
+        this.skip = skip;
+    }
 
-	public void setRecordCount(long recordCount) {
-		this.recordCount = recordCount;
-	}
+    /**
+     * Sets number of written records.
+     * @param numRecords
+     */
+    public void setNumRecords(int numRecords) {
+        this.numRecords = numRecords;
+    }
 
 }

Modified: trunk/cloveretl.engine/src/org/jetel/main/showData.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/main/showData.java	2007-02-08 08:28:24 UTC (rev 2457)
+++ trunk/cloveretl.engine/src/org/jetel/main/showData.java	2007-02-08 09:00:23 UTC (rev 2458)
@@ -25,6 +25,8 @@
 import java.io.InputStream;
 import java.lang.reflect.Method;
 import java.net.URL;
+import java.nio.channels.Channels;
+import java.nio.channels.WritableByteChannel;
 import java.util.Map;
 import java.util.Properties;
 
@@ -73,7 +75,7 @@
  *  <tr><td nowrap>--fields</td><td>Show only defined fields. If no fields defined, show all fields</td></tr>
  *  <tr><td nowrap>--logLevel</td><td>Log level for logger {all, info, debug, ..}, default is error log level</td></tr>
  *  <tr><td nowrap><b>filename</b></td><td>filename or URL of the file (even remote) containing graph's layout in XML (this must be the last parameter passed)</td></tr>
- *  <tr><td nowrap><b>component id</b></td><td>over this component will be showed data</td></tr>
+ *  <tr><td nowrap><b>component id</b></td><td>data will be shown over this component</td></tr>
  *  </table>
  *
  *  <h4>Example:</h4>
@@ -104,8 +106,8 @@
         String delimiter = null;
         String fileUrl = null;
         String filterExpression = null;
-        long recordFrom = -1;
-        long recordCount = -1;
+        int recordFrom = -1;
+        int recordCount = -1;
         String fields = null;
         String logHost = null;
 		
@@ -223,10 +225,10 @@
 			filterExpression = cmdLine.getOptionValue("e");
 		}
 		if (cmdLine.hasOption("f")) {
-	    	recordFrom = Long.parseLong(cmdLine.getOptionValue("f"));
+	    	recordFrom = Integer.parseInt(cmdLine.getOptionValue("f"));
 		}
 		if (cmdLine.hasOption("c")) {
-	    	recordCount = Long.parseLong(cmdLine.getOptionValue("c"));
+	    	recordCount = Integer.parseInt(cmdLine.getOptionValue("c"));
 		}
 		if (cmdLine.hasOption("l")) {
         	fields = cmdLine.getOptionValue("l");
@@ -355,7 +357,7 @@
 		}
 		Node writer = null;
 		try {
-			writer = getWriter(viewGraph, viewMode, dataRecordMetadata, fileUrl, delimiter, recordFrom, recordCount, fields);
+			writer = getWriter(viewGraph, viewMode, dataRecordMetadata, fileUrl, recordFrom, recordCount, fields);
 		} catch (Exception e1) {
 			e1.printStackTrace();
 		}
@@ -382,6 +384,13 @@
 			return;
 		}
 
+		if (viewMode.equals(Mode.TEXT) && delimiter != null) {
+			for(int i=0; i<edge0.getMetadata().getNumFields()-1; i++) {
+				edge0.getMetadata().getField(i).setDelimiter(delimiter);
+			}
+			//metadata.getField(metadata.getNumFields()-1).setDelimiter("\n");
+		}
+
 		// assign ports (input & output)
 		node.addOutputPort(0,edge0);
 		if (filterExpression != null) {
@@ -442,7 +451,7 @@
 	 * @return
 	 * @throws Exception 
 	 */
-	private static Node getWriter(TransformationGraph graph, Mode mode, DataRecordMetadata dataRecordMetadata, String fileUrl, String delimiter, long recordFrom, long recordCount, String fields) throws Exception {
+	private static Node getWriter(TransformationGraph graph, Mode mode, DataRecordMetadata dataRecordMetadata, String fileUrl, int recordFrom, int recordCount, String fields) throws Exception {
 		if (mode == null) return null;
 		Node writer = null;
 		String[] aFiealds = fields == null ? null : fields.split(";");
@@ -477,9 +486,9 @@
 			
 			Node structureWriter = ComponentFactory.createComponent(graph, "STRUCTURE_WRITER", new Object[] {"STRUCTURE_WRITER0", fileUrl, null, false, maskBuilder.toString()}, new Class[] {String.class, String.class, String.class, boolean.class, String.class});
 			Class cStructureWriter = ComponentFactory.getComponentClass("STRUCTURE_WRITER");
-			Method method = cStructureWriter.getMethod("setRecordFrom", new Class[] {long.class});
-			method.invoke(structureWriter, recordFrom);
-			method = cStructureWriter.getMethod("setRecordCount", new Class[] {long.class});
+			Method method = cStructureWriter.getMethod("setSkip", new Class[] {int.class});
+			method.invoke(structureWriter, recordFrom-1);
+			method = cStructureWriter.getMethod("setNumRecords", new Class[] {int.class});
 			method.invoke(structureWriter, recordCount);
 			StringBuilder sb = new StringBuilder();
 			
@@ -510,17 +519,18 @@
 			
 		// text formating - delimited or fix lenght
 		} else if (mode.equals(Mode.TEXT)) {
-			Node dataWriter = ComponentFactory.createComponent(graph, "DATA_WRITER", new Object[] {"DATA_WRITER0", fileUrl, dataRecordMetadata.getLocaleStr(), false}, new Class[] {String.class, String.class, String.class, boolean.class});
+			Node dataWriter;
+			if (fileUrl == null) {
+				dataWriter = ComponentFactory.createComponent(graph, "DATA_WRITER", new Object[] {"DATA_WRITER0", Channels.newChannel(System.out), dataRecordMetadata.getLocaleStr(), false}, new Class[] {String.class, WritableByteChannel.class, String.class, boolean.class});
+			} else {
+				dataWriter = ComponentFactory.createComponent(graph, "DATA_WRITER", new Object[] {"DATA_WRITER0", fileUrl, dataRecordMetadata.getLocaleStr(), false}, new Class[] {String.class, String.class, String.class, boolean.class});
+			}
 			//TODO agata dodelat selekci na fieldy
 			Class cDataWriter = ComponentFactory.getComponentClass("DATA_WRITER");
-			Method method = cDataWriter.getMethod("setRecordFrom", new Class[] {long.class});
-			method.invoke(dataWriter, recordFrom);
-			method = cDataWriter.getMethod("setRecordCount", new Class[] {long.class});
+			Method method = cDataWriter.getMethod("setSkip", new Class[] {int.class});
+			method.invoke(dataWriter, (int)(recordFrom-1));
+			method = cDataWriter.getMethod("setNumRecords", new Class[] {int.class});
 			method.invoke(dataWriter, recordCount);
-			if (delimiter != null) {
-				method = cDataWriter.getMethod("setDataDelimiter", new Class[] {String.class});
-				method.invoke(dataWriter, delimiter);
-			}
 			writer = dataWriter;
 			
 		// table formating
@@ -528,9 +538,9 @@
 			//TextWriter dataWriter = new TextWriter("TEXT_TABLE_WRITER0", fileUrl, null, false, aFiealds);
 			Node textWriter = ComponentFactory.createComponent(graph, "TEXT_TABLE_WRITER", new Object[] {"TEXT_TABLE_WRITER0", fileUrl, null, false, aFiealds}, new Class[] {String.class, String.class, String.class, boolean.class, String[].class});
 			Class cDataWriter = ComponentFactory.getComponentClass("TEXT_TABLE_WRITER");
-			Method method = cDataWriter.getMethod("setRecordFrom", new Class[] {long.class});
-			method.invoke(textWriter, recordFrom);
-			method = cDataWriter.getMethod("setRecordCount", new Class[] {long.class});
+			Method method = cDataWriter.getMethod("setSkip", new Class[] {int.class});
+			method.invoke(textWriter, recordFrom-1);
+			method = cDataWriter.getMethod("setNumRecords", new Class[] {int.class});
 			method.invoke(textWriter, recordCount);
 			method = cDataWriter.getMethod("setHeader", new Class[] {boolean.class});
 			method.invoke(textWriter, true);
@@ -560,7 +570,7 @@
         System.out.println("--logLevel\t\tLog level for logger {all, info, debug, ..}, default is error log level");
         System.out.println();
         System.out.println("Note: <graph definition file> can be either local filename or URL of local/remote file");
-        System.out.println("Note: <component id> over this component will be showed data");
+        System.out.println("Note: <component id> data will be shown over this component");
 	}
 
 	private static void printInfo(){

Modified: trunk/cloveretl.engine/src/org/jetel/util/MultiFileWriter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/MultiFileWriter.java	2007-02-08 08:28:24 UTC (rev 2457)
+++ trunk/cloveretl.engine/src/org/jetel/util/MultiFileWriter.java	2007-02-08 09:00:23 UTC (rev 2458)
@@ -35,9 +35,9 @@
 import org.jetel.metadata.DataRecordMetadata;
 
 /**
- * Class for transparent writing into multifile. Underlying formatter is used for formatting
- * incoming data records and destination is a list of files defined in fileURL attribute 
- * by org.jetel.util.MultiOutFile.
+ * Class for transparent writing into multifile or multistream. Underlying formatter is used for formatting
+ * incoming data records and destination is a list of files defined in fileURL attribute
+ * by org.jetel.util.MultiOutFile or iterator of writable channels.
  * Usage: 
  * - first instantiate some suitable formatter, set all its parameters (don't call init method)
  * - optionally set appropriate logger
@@ -67,7 +67,11 @@
     private ByteBuffer header;
     private ByteBuffer footer;
     private Iterator<String> fileNames;
+    private Iterator<WritableByteChannel> channels;
     private WritableByteChannel byteChannel;
+    private int skip;
+	private int numRecords;
+	private int counter;
     
     /**
      * Constructor.
@@ -79,14 +83,19 @@
         this.contextURL = contextURL;
         this.fileURL = fileURL;
     }
-    
+
+    public MultiFileWriter(Formatter formatter, Iterator<WritableByteChannel> channels) {
+        this.formatter = formatter;
+        this.channels = channels;
+    }
+
     /**
      * Initializes underlying formatter with a given metadata.
      * @param metadata
      * @throws ComponentNotReadyException 
      */
     public void init(DataRecordMetadata metadata) throws ComponentNotReadyException {
-        fileNames = new MultiOutFile(fileURL);
+    	if (fileURL != null) fileNames = new MultiOutFile(fileURL);
         formatter.init(metadata);
         try {
             setNextOutput();
@@ -101,16 +110,23 @@
      * @throws FileNotFoundException
      */
     private void setNextOutput() throws IOException {
-        if (!fileNames.hasNext()) {
-            logger.warn("Unable to open new output file. This may be caused by missing wildcard in filename specification. "
-                    + "Size of output file will exceed specified limit");
+    	if (fileNames != null) {
+            if (!fileNames.hasNext()) {
+                logger.warn("Unable to open new output file. This may be caused by missing wildcard in filename specification. "
+                        + "Size of output file will exceed specified limit");
+                return;
+            }    		
+    	}
+    	else if (!channels.hasNext()) {
+            logger.warn("Unable to open new output file. Size of output file will exceed specified limit");
             return;
-        }
+        }      	
+
         //write footer to the previous destination if it is not first call of this method
         if(byteChannel != null) {
             writeFooter();
         }
-        byteChannel = FileUtils.getWritableChannel(contextURL, fileNames.next(), appendData);
+        byteChannel = fileNames != null ? FileUtils.getWritableChannel(contextURL, fileNames.next(), appendData) : channels.next();
         //write header
         writeHeader();
         formatter.setDataTarget(byteChannel);
@@ -136,7 +152,18 @@
      * @throws IOException
      */
     public void write(DataRecord record) throws IOException {
-        if ((recordsPerFile > 0 && records >= recordsPerFile)
+        //check for index of last returned record
+        if(numRecords > 0 && numRecords == counter) {
+            return;
+        }
+        
+        //shall i skip some records?
+        if(skip > 0) {
+            skip--;
+            return;
+        }
+    	
+    	if ((recordsPerFile > 0 && records >= recordsPerFile)
                 || (bytesPerFile > 0 && bytes >= bytesPerFile)) {
             setNextOutput();
             records = 0;
@@ -144,6 +171,7 @@
         }
         bytes += formatter.write(record);
         records++;
+        counter++;
     }
 
     /**
@@ -207,4 +235,20 @@
         this.charset = charset;
     }
 
+    /**
+     * Sets number of skipped records in next call of getNext() method.
+     * @param skip
+     */
+    public void setSkip(int skip) {
+        this.skip = skip;
+    }
+
+    /**
+     * Sets number of read reacords
+     * @param numRecords
+     */
+    public void setNumRecords(int numRecords) {
+        this.numRecords = numRecords;
+    }
+
 }



From cloveretl-svn-commits at lists.berlios.de  Thu Feb  8 12:46:15 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 8 Feb 2007 12:46:15 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2459 -
	trunk/cloveretl.engine/src/org/jetel/data/tape
Message-ID: <200702081146.l18BkFHO003815@sheep.berlios.de>

Author: agad
Date: 2007-02-08 12:46:04 +0100 (Thu, 08 Feb 2007)
New Revision: 2459

Modified:
   trunk/cloveretl.engine/src/org/jetel/data/tape/DataRecordTape.java
Log:
FIX:DataRecordTape - sometimes data were lost

Modified: trunk/cloveretl.engine/src/org/jetel/data/tape/DataRecordTape.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/tape/DataRecordTape.java	2007-02-08 09:00:23 UTC (rev 2458)
+++ trunk/cloveretl.engine/src/org/jetel/data/tape/DataRecordTape.java	2007-02-08 11:46:04 UTC (rev 2459)
@@ -208,7 +208,8 @@
 	        return;
 	    }
 	    try{
-	    tmpFileChannel.position(0);
+	    	flush(true);
+	    	tmpFileChannel.position(0);
 	    }catch(IOException ex){
 	        ex.printStackTrace();
 	    }
@@ -248,6 +249,7 @@
 	    }else{
 	        try{
 	            // set file position to the end of file
+	        	flush(true);
 	            tmpFileChannel.position(tmpFileChannel.size());
 	            // add new data chunk
 	            DataChunk chunk=new DataChunk(tmpFileChannel,dataBuffer);



From cloveretl-svn-commits at lists.berlios.de  Thu Feb  8 12:47:26 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 8 Feb 2007 12:47:26 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2460 -
	trunk/cloveretl.engine/src/org/jetel/util
Message-ID: <200702081147.l18BlQXl005727@sheep.berlios.de>

Author: agad
Date: 2007-02-08 12:47:24 +0100 (Thu, 08 Feb 2007)
New Revision: 2460

Modified:
   trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java
Log:
FIX:StringUtils - method isQuuoted throwed exception when got empty string

Modified: trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java	2007-02-08 11:46:04 UTC (rev 2459)
+++ trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java	2007-02-08 11:47:24 UTC (rev 2460)
@@ -240,7 +240,8 @@
 	 * @return true if the string is quoted
 	 */
 	public static final boolean isQuoted(CharSequence str){
-	    return isQuoteChar(str.charAt(0)) && str.charAt(0)==str.charAt(str.length()-1);
+	    return isEmpty(str) ? false :
+	    	isQuoteChar(str.charAt(0)) && str.charAt(0)==str.charAt(str.length()-1);
 	}
 	
     



From cloveretl-svn-commits at lists.berlios.de  Thu Feb  8 14:55:41 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 8 Feb 2007 14:55:41 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2461 -
	trunk/cloveretl.engine/src/org/jetel/util
Message-ID: <200702081355.l18Dtflt025462@sheep.berlios.de>

Author: agad
Date: 2007-02-08 14:55:40 +0100 (Thu, 08 Feb 2007)
New Revision: 2461

Modified:
   trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java
Log:
UPDATE:StringUtils - method specCharToString handles '\\' to be compatible with method stringToSpecChar

Modified: trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java	2007-02-08 11:47:24 UTC (rev 2460)
+++ trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java	2007-02-08 13:55:40 UTC (rev 2461)
@@ -39,7 +39,7 @@
     
 	/**
 	 *  Converts control characters into textual representation<br>
-	 *  Note: This code handles only \n, \r ,\t ,\f, \b special chars
+	 *  Note: This code handles only \n, \r ,\t ,\f, \b, \\ special chars
 	 *
 	 * @param  controlString  string containing control characters
 	 * @return                string where control characters are replaced by their
@@ -67,6 +67,8 @@
                 case '\f':
                     copy.append("\\f");
                     break;
+                case '\\':
+                	copy.append("\\\\");
 				default:
 					copy.append(character);
 			}



From cloveretl-svn-commits at lists.berlios.de  Thu Feb  8 14:57:27 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 8 Feb 2007 14:57:27 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2462 -
	trunk/cloveretl.engine/test/org/jetel/util
Message-ID: <200702081357.l18DvRC3025555@sheep.berlios.de>

Author: agad
Date: 2007-02-08 14:57:27 +0100 (Thu, 08 Feb 2007)
New Revision: 2462

Modified:
   trunk/cloveretl.engine/test/org/jetel/util/StringUtilsTest.java
Log:
UPDATE:test updated due to changes in engine

Modified: trunk/cloveretl.engine/test/org/jetel/util/StringUtilsTest.java
===================================================================
--- trunk/cloveretl.engine/test/org/jetel/util/StringUtilsTest.java	2007-02-08 13:55:40 UTC (rev 2461)
+++ trunk/cloveretl.engine/test/org/jetel/util/StringUtilsTest.java	2007-02-08 13:57:27 UTC (rev 2462)
@@ -67,7 +67,7 @@
 
 		controlString2 = "\\\nn\\nn\\nn\\\\r";
 
-		resultString2 = "\\\\nn\\nn\\nn\\\\r";
+		resultString2 = "\\\\\\nn\\\\nn\\\\nn\\\\\\\\r";
 
 		// for test_formatString test1
 



From cloveretl-svn-commits at lists.berlios.de  Fri Feb  9 10:44:52 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Fri, 9 Feb 2007 10:44:52 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2463 -
	trunk/cloveretl.engine/src/org/jetel/util
Message-ID: <200702090944.l199iqfw031672@sheep.berlios.de>

Author: agad
Date: 2007-02-09 10:44:51 +0100 (Fri, 09 Feb 2007)
New Revision: 2463

Modified:
   trunk/cloveretl.engine/src/org/jetel/util/PropertyRefResolver.java
Log:
UPDADE:PropertyRefResolver - if parameter is not found in graph properties it try to find it among enviroment variables

Modified: trunk/cloveretl.engine/src/org/jetel/util/PropertyRefResolver.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/PropertyRefResolver.java	2007-02-08 13:57:27 UTC (rev 2462)
+++ trunk/cloveretl.engine/src/org/jetel/util/PropertyRefResolver.java	2007-02-09 09:44:51 UTC (rev 2463)
@@ -183,6 +183,9 @@
 //					logger.debug("Reference: "+reference);
 //				}
 				resolvedReference = properties.getProperty(reference);
+				if (resolvedReference == null){
+					resolvedReference = System.getenv(reference);
+				}
 				if (resolvedReference == null) {
 				    logger.warn("Can't resolve reference to graph property: " + reference);
                    // if (strict)



From cloveretl-svn-commits at lists.berlios.de  Fri Feb  9 13:59:58 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Fri, 9 Feb 2007 13:59:58 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2464 -
	trunk/cloveretl.engine/src/org/jetel/util
Message-ID: <200702091259.l19CxwnU021583@sheep.berlios.de>

Author: agad
Date: 2007-02-09 13:59:57 +0100 (Fri, 09 Feb 2007)
New Revision: 2464

Modified:
   trunk/cloveretl.engine/src/org/jetel/util/PropertyRefResolver.java
Log:
UPDADE:PropertyRefResolver - if parameter is not found in graph properties it try to find it among enviroment variables and then in system properties

Modified: trunk/cloveretl.engine/src/org/jetel/util/PropertyRefResolver.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/PropertyRefResolver.java	2007-02-09 09:44:51 UTC (rev 2463)
+++ trunk/cloveretl.engine/src/org/jetel/util/PropertyRefResolver.java	2007-02-09 12:59:57 UTC (rev 2464)
@@ -186,6 +186,10 @@
 				if (resolvedReference == null){
 					resolvedReference = System.getenv(reference);
 				}
+				if (resolvedReference == null){
+					reference = reference.replace('_','.');
+					resolvedReference = System.getProperty(reference);
+				}
 				if (resolvedReference == null) {
 				    logger.warn("Can't resolve reference to graph property: " + reference);
                    // if (strict)



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 13 11:11:46 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 13 Feb 2007 11:11:46 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2465 -
	trunk/cloveretl.engine
Message-ID: <200702131011.l1DABkm9021282@sheep.berlios.de>

Author: ausperger
Date: 2007-02-13 11:11:44 +0100 (Tue, 13 Feb 2007)
New Revision: 2465

Added:
   trunk/cloveretl.engine/runShowData.bat
   trunk/cloveretl.engine/runShowData.sh
Log:
INIT: sh and bat wrapper for showData

Added: trunk/cloveretl.engine/runShowData.bat
===================================================================
--- trunk/cloveretl.engine/runShowData.bat	2007-02-09 12:59:57 UTC (rev 2464)
+++ trunk/cloveretl.engine/runShowData.bat	2007-02-13 10:11:44 UTC (rev 2465)
@@ -0,0 +1,23 @@
+ at echo off
+
+rem ***********************************************
+rem usage - run.bat <graph_name.grf> <component_id>
+rem ***********************************************
+
+rem ***** set this before using script *****
+set JAVA_HOME=c:\Program Files (x86)\Java\jdk1.5.0_04
+set ENGINE_PATH=.
+set LIB_PATH=.\lib
+set TRANSFORM_PATH=.
+rem ****************************************
+
+set ENGINE_JAR=%ENGINE_PATH%\cloveretl.engine.jar
+set COMMONS_LOGGING_JAR=%LIB_PATH%\commons-logging.jar
+set JAVOLUTION_JAR=%LIB_PATH%\javolution.jar
+set JMS_JAR=%LIB_PATH%\jms.jar
+set JXL_JAR=%LIB_PATH%\jxl.jar
+set LOG4J_JAR=%LIB_PATH%\log4j-1.2.12.zip
+set POI_JAR=%LIB_PATH%\poi-2.5.1.jar
+set COMMONS_CLI_JAR=%LIB_PATH%\commons-cli-1.0.jar
+
+java -cp "%TRANSFORM_PATH%;%ENGINE_JAR%;%COMMONS_LOGGING_JAR%;%JAVOLUTION_JAR%;%JMS_JAR%;%JXL_JAR%;%LOG4J_JAR%;%POI_JAR%;%COMMONS_CLI_JAR%;%JAVA_HOME%\lib\tools.jar" org.jetel.main.showData %1 %2

Added: trunk/cloveretl.engine/runShowData.sh
===================================================================
--- trunk/cloveretl.engine/runShowData.sh	2007-02-09 12:59:57 UTC (rev 2464)
+++ trunk/cloveretl.engine/runShowData.sh	2007-02-13 10:11:44 UTC (rev 2465)
@@ -0,0 +1,21 @@
+#!/bin/sh
+
+# ************************************
+# usage - runShowData.bat <graph_name.grf> <component_id>
+
+# ***** set this before using script *****
+JAVA_HOME="/usr/lib64/jvm/java-1.5.0-sun-1.5.0_update8"
+ENGINE_PATH="."
+LIBS_PATH="./lib"
+TRANSFORM_PATH="."
+# ****************************************
+
+ENGINE_JAR="$ENGINE_PATH/cloveretl.engine.jar"
+
+# for i in $LIBS_PATH/*.jar $LIBS_PATH/*.zip; do
+for i in $(ls lib); do
+JARS="$JARS:./lib/$i";
+#JARS="$JARS:$i";
+done;
+
+java -classpath "$TRANSFORM_PATH:$ENGINE_JAR:$JARS:$JAVA_HOME/lib/tools.jar" org.jetel.main.showData $1 $2


Property changes on: trunk/cloveretl.engine/runShowData.sh
___________________________________________________________________
Name: svn:executable
   + *



From cloveretl-svn-commits at lists.berlios.de  Wed Feb 14 10:05:21 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 14 Feb 2007 10:05:21 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2466 -
	trunk/cloveretl.engine/examples
Message-ID: <200702140905.l1E95LRT030331@sheep.berlios.de>

Author: agad
Date: 2007-02-14 10:05:21 +0100 (Wed, 14 Feb 2007)
New Revision: 2466

Modified:
   trunk/cloveretl.engine/examples/graphJoinHashInline.grf
Log:


Modified: trunk/cloveretl.engine/examples/graphJoinHashInline.grf
===================================================================
--- trunk/cloveretl.engine/examples/graphJoinHashInline.grf	2007-02-13 10:11:44 UTC (rev 2465)
+++ trunk/cloveretl.engine/examples/graphJoinHashInline.grf	2007-02-14 09:05:21 UTC (rev 2466)
@@ -9,13 +9,13 @@
 </Global>
 <Phase number="0">
 <Node enabled="enabled" id="INPUT1" type="DELIMITED_DATA_READER"
-fileURL="${WORKSPACE}/data/orders.dat"
+fileURL="${HOME}/${WORKSPACE}/data/orders.dat"
 />
 <Node enabled="enabled" id="INPUT2" type="DELIMITED_DATA_READER"
-fileURL="${WORKSPACE}/data/employees.dat"
+fileURL="${HOME}/${WORKSPACE}/data/employees.dat"
 />
 <Node enabled="enabled" id="INPUT3" type="DELIMITED_DATA_READER"
-fileURL="${WORKSPACE}/data/customers_delimited.txt"
+fileURL="${HOME}/${WORKSPACE}/data/customers_delimited.txt"
 />
 
 <Node enabled="enabled" id="JOIN" type="HASH_JOIN"
@@ -55,7 +55,7 @@
 </attr>
 </Node>
 
-<Node append="false" enabled="enabled" fileURL="${WORKSPACE}/output/joined_data_hash.out" guiHeight="25" guiName="WRITER" guiWidth="50" guiX="370" guiY="20" id="WRITER" type="DELIMITED_DATA_WRITER"/>
+<Node append="false" enabled="enabled" fileURL="${HOME}/${WORKSPACE}/output/joined_data_hash.out" guiHeight="25" guiName="WRITER" guiWidth="50" guiX="370" guiY="20" id="WRITER" type="DELIMITED_DATA_WRITER"/>
 
 <Edge fromNode="INPUT1:0" guiBendpoints="" id="INEDGE1" inPort="0 (JOIN)" metadata="InMetadata1" outPort="0 (INPUT1)" toNode="JOIN:0"/>
 <Edge fromNode="INPUT2:0" guiBendpoints="" id="INEDGE2" inPort="1 (JOIN)" metadata="InMetadata2" outPort="0 (INPUT2)" toNode="JOIN:1"/>



From cloveretl-svn-commits at lists.berlios.de  Wed Feb 14 10:46:59 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 14 Feb 2007 10:46:59 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2467 -
	trunk/cloveretl.engine/src/org/jetel/interpreter
Message-ID: <200702140946.l1E9kxTB032722@sheep.berlios.de>

Author: dpavlis
Date: 2007-02-14 10:46:57 +0100 (Wed, 14 Feb 2007)
New Revision: 2467

Modified:
   trunk/cloveretl.engine/src/org/jetel/interpreter/TransformLangExecutor.java
Log:
BUG:#fix of NULL assignment/initialization, fix of isnull, nvl on empty strings

Modified: trunk/cloveretl.engine/src/org/jetel/interpreter/TransformLangExecutor.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/interpreter/TransformLangExecutor.java	2007-02-14 09:05:21 UTC (rev 2466)
+++ trunk/cloveretl.engine/src/org/jetel/interpreter/TransformLangExecutor.java	2007-02-14 09:46:57 UTC (rev 2467)
@@ -719,7 +719,11 @@
         if (value == null) {
             stack.push(Stack.TRUE_VAL);
         } else {
-            stack.push(Stack.FALSE_VAL);
+            if (value instanceof CharSequence) {
+                stack.push( ((CharSequence)value).length()==0 ? Stack.TRUE_VAL : Stack.FALSE_VAL);
+            }else {
+                stack.push(Stack.FALSE_VAL);
+            }
         }
 
         return data;
@@ -733,7 +737,11 @@
             node.jjtGetChild(1).jjtAccept(this, data);
             // not necessary: stack.push(stack.pop());
         } else {
-            stack.push(value);
+            if ((value instanceof CharSequence) && (((CharSequence)value).length()==0)) {
+                node.jjtGetChild(1).jjtAccept(this, data);
+            }else {
+                stack.push(value);
+            }
         }
 
         return data;
@@ -1458,41 +1466,43 @@
      */
     public Object visit(CLVFVarDeclaration node, Object data) {
         // test for duplicite declaration - should have been done before
-        /*if (stack.symtab.containsKey(node.name)) {
-            throw new TransformLangExecutorRuntimeException(node,
-                    "variable already declared - \"" + node.name + "\"");
-        }*/
+        /*
+         * if (stack.symtab.containsKey(node.name)) { throw new
+         * TransformLangExecutorRuntimeException(node, "variable already
+         * declared - \"" + node.name + "\""); }
+         */
         Object value;
         // create global/local variable
         switch (node.type) {
         case INT_VAR:
-            value= new CloverInteger(0);
+            value = new CloverInteger(0);
             break;
         case LONG_VAR:
-            value= new CloverLong(0);
+            value = new CloverLong(0);
             break;
         case DOUBLE_VAR:
-            value= new CloverDouble(0);
+            value = new CloverDouble(0);
             break;
         case DECIMAL_VAR:
-            if (node.length>0){
-                if (node.precision>0){
-                    value = DecimalFactory.getDecimal(node.length,node.precision);
-                }else{
-                    value = DecimalFactory.getDecimal(node.length,0);
+            if (node.length > 0) {
+                if (node.precision > 0) {
+                    value = DecimalFactory.getDecimal(node.length,
+                            node.precision);
+                } else {
+                    value = DecimalFactory.getDecimal(node.length, 0);
                 }
-            }else{
-                value= DecimalFactory.getDecimal();
+            } else {
+                value = DecimalFactory.getDecimal();
             }
             break;
         case STRING_VAR:
-            value= new StringBuilder();
+            value = new StringBuilder();
             break;
         case DATE_VAR:
-            value=new Date();
+            value = new Date();
             break;
         case BOOLEAN_VAR:
-            value=  Stack.FALSE_VAL;
+            value = Stack.FALSE_VAL;
             break;
         default:
             throw new TransformLangExecutorRuntimeException(node,
@@ -1502,44 +1512,55 @@
 
         }
         stack.storeVar(node.localVar, node.varSlot, value);
-        
-        if (node.jjtGetNumChildren()>0){
+
+        if (node.jjtHasChildren()) {
             node.jjtGetChild(0).jjtAccept(this, data);
-            Object initValue=stack.pop();
-            
+            Object initValue = stack.pop();
             try {
-                if (value instanceof Numeric) {
-                        ((Numeric) value).setValue((Numeric) initValue);
-                } else if (value instanceof StringBuilder) {
-                    StringBuilder var = (StringBuilder) value;
-                    var.setLength(0);
-                    StringUtils.strBuffAppend(var,(CharSequence) initValue);
-                } else if (value instanceof Boolean) {
-                    stack.storeVar(node.localVar,node.varSlot, (Boolean)initValue); // boolean is not updatable - we replace the reference
-                    // stack.put(varName,((Boolean)value).booleanValue() ?
-                    // Stack.TRUE_VAL : Stack.FALSE_VAL);
-                } else if (value instanceof Date) {
+                switch (node.type) {
+                case INT_VAR:
+                case LONG_VAR:
+                case DOUBLE_VAR:
+                case DECIMAL_VAR:
+                    ((Numeric) value).setValue((Numeric) initValue);
+                    break;
+                case STRING_VAR:
+                    if (initValue != null)
+                        StringUtils.strBuffAppend((StringBuilder) value,
+                                (CharSequence) initValue);
+                    break;
+                case DATE_VAR:
                     ((Date) value).setTime(((Date) initValue).getTime());
-                } else {
-                    throw new TransformLangExecutorRuntimeException(node,
-                            "unknown variable \"" + node.name + "\"");
+                    break;
+                case BOOLEAN_VAR:
+                    stack.storeVar(node.localVar, node.varSlot,
+                            (Boolean) initValue);
+                    // boolean is not updatable - we replace the reference
+                    break;
+
                 }
+
             } catch (ClassCastException ex) {
                 throw new TransformLangExecutorRuntimeException(node,
-                        "invalid assignment of \"" + initValue + "\" to variable \""
-                                + node.name + "\" - incompatible data types");
-            } catch (NumberFormatException ex){
+                        "invalid assignment of \"" + initValue
+                                + "\" to variable \"" + node.name
+                                + "\" - incompatible data types");
+            } catch (NumberFormatException ex) {
                 throw new TransformLangExecutorRuntimeException(node,
-                        "invalid assignment of number \"" + initValue + "\" to variable \"" + node.name + "\" : "+ex.getMessage());    
-            } catch (TransformLangExecutorRuntimeException ex){
+                        "invalid assignment of number \"" + initValue
+                                + "\" to variable \"" + node.name + "\" : "
+                                + ex.getMessage());
+            } catch (TransformLangExecutorRuntimeException ex) {
                 throw ex;
-            } catch (Exception ex){
+            } catch (Exception ex) {
                 throw new TransformLangExecutorRuntimeException(node,
-                        "invalid assignment of \"" + value + "\" to variable \"" + node.name + "\" : "+ex.getMessage());  
+                        "invalid assignment of \"" + value
+                                + "\" to variable \"" + node.name + "\" : "
+                                + ex.getMessage());
             }
-            
+
         }
-        
+
         return data;
     }
 
@@ -1559,6 +1580,8 @@
     }
 
     public Object visit(CLVFAssignment node, Object data) {
+        //TODO: proper handling of NULL value assignment
+        
         CLVFVariableLiteral childNode=(CLVFVariableLiteral) node.jjtGetChild(0);
 
         Object variable = stack.getVar(childNode.localVar,childNode.varSlot);
@@ -1570,7 +1593,7 @@
             } else if (variable instanceof StringBuilder) {
                 StringBuilder var = (StringBuilder) variable;
                 var.setLength(0);
-                StringUtils.strBuffAppend(var,(CharSequence) value);
+                if (value !=null) StringUtils.strBuffAppend(var,(CharSequence) value);
             } else if (variable instanceof Boolean) {
                 stack.storeVar(childNode.localVar,childNode.varSlot, (Boolean)value); // boolean is not updatable - we replace the reference
                 // stack.put(varName,((Boolean)value).booleanValue() ?



From cloveretl-svn-commits at lists.berlios.de  Wed Feb 14 15:29:47 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 14 Feb 2007 15:29:47 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2468 -
	trunk/cloveretl.component/src/org/jetel/component
Message-ID: <200702141429.l1EETltA028647@sheep.berlios.de>

Author: agad
Date: 2007-02-14 15:29:44 +0100 (Wed, 14 Feb 2007)
New Revision: 2468

Modified:
   trunk/cloveretl.component/src/org/jetel/component/CloverDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/DBJoin.java
   trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/JmsWriter.java
   trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java
   trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java
   trunk/cloveretl.component/src/org/jetel/component/Trash.java
Log:
BUGFIX:new implementation of checkConfig method - files are not deleted during checkconfig method

Modified: trunk/cloveretl.component/src/org/jetel/component/CloverDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/CloverDataWriter.java	2007-02-14 09:46:57 UTC (rev 2467)
+++ trunk/cloveretl.component/src/org/jetel/component/CloverDataWriter.java	2007-02-14 14:29:44 UTC (rev 2468)
@@ -45,6 +45,7 @@
 import org.jetel.metadata.DataRecordMetadataXMLReaderWriter;
 import org.jetel.util.ByteBufferUtils;
 import org.jetel.util.ComponentXMLAttributes;
+import org.jetel.util.FileUtils;
 import org.jetel.util.StringUtils;
 import org.jetel.util.SynchronizeUtils;
 import org.w3c.dom.Element;
@@ -212,8 +213,14 @@
         checkOutputPorts(status, 0, 0);
 
         try {
-            init();
-            free();
+        	if (!FileUtils.canWrite(
+        			getGraph() != null ? getGraph().getProjectURL() : null, fileURL)){
+        		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + fileURL);
+        		ex.setAttributeName(XML_FILEURL_ATTRIBUTE);
+        		throw ex;
+        	}
+//            init();
+//            free();
         } catch (ComponentNotReadyException e) {
             ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
             if(!StringUtils.isEmpty(e.getAttributeName())) {

Modified: trunk/cloveretl.component/src/org/jetel/component/DBJoin.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DBJoin.java	2007-02-14 09:46:57 UTC (rev 2467)
+++ trunk/cloveretl.component/src/org/jetel/component/DBJoin.java	2007-02-14 14:29:44 UTC (rev 2468)
@@ -252,6 +252,7 @@
     		DataRecordMetadata inMetadata[]={ getInputPort(READ_FROM_PORT).getMetadata(),dbMetadata};
     		DataRecordMetadata outMetadata[]={getOutputPort(WRITE_TO_PORT).getMetadata()};
             lookupTable = new DBLookupTable("LOOKUP_TABLE_FROM_"+this.getId(),(DBConnection) conn,dbMetadata,query,maxCached);
+            lookupTable.checkConfig(status);
     		lookupTable.init();
     		try {
     			recordKey = new RecordKey(joinKey, inMetadata[0]);
@@ -295,6 +296,7 @@
 		DataRecordMetadata inMetadata[]={ getInputPort(READ_FROM_PORT).getMetadata(),dbMetadata};
 		DataRecordMetadata outMetadata[]={getOutputPort(WRITE_TO_PORT).getMetadata()};
         lookupTable = new DBLookupTable("LOOKUP_TABLE_FROM_"+this.getId(),(DBConnection) conn,dbMetadata,query,maxCached);
+        lookupTable.checkConfig(null);
 		lookupTable.init();
 		try {
 			recordKey = new RecordKey(joinKey, inMetadata[0]);

Modified: trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-14 09:46:57 UTC (rev 2467)
+++ trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-14 14:29:44 UTC (rev 2468)
@@ -37,6 +37,7 @@
 import org.jetel.graph.Result;
 import org.jetel.graph.TransformationGraph;
 import org.jetel.util.ComponentXMLAttributes;
+import org.jetel.util.FileUtils;
 import org.jetel.util.MultiFileWriter;
 import org.jetel.util.StringUtils;
 import org.jetel.util.SynchronizeUtils;
@@ -266,8 +267,16 @@
         checkOutputPorts(status, 0, 0);
 
         try {
-            init();
-            free();
+        	if (fileURL != null) {
+        		if (!FileUtils.canWrite(getGraph() != null ? getGraph().getProjectURL() 
+        				: null, fileURL)){
+	        		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + fileURL);
+	        		ex.setAttributeName(XML_FILEURL_ATTRIBUTE);
+	        		throw ex;
+        		}
+        	}
+//            init();
+//            free();
         } catch (ComponentNotReadyException e) {
             ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
             if(!StringUtils.isEmpty(e.getAttributeName())) {

Modified: trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-14 09:46:57 UTC (rev 2467)
+++ trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-14 14:29:44 UTC (rev 2468)
@@ -33,6 +33,7 @@
 import org.jetel.graph.Result;
 import org.jetel.graph.TransformationGraph;
 import org.jetel.util.ComponentXMLAttributes;
+import org.jetel.util.FileUtils;
 import org.jetel.util.MultiFileWriter;
 import org.jetel.util.StringUtils;
 import org.jetel.util.SynchronizeUtils;
@@ -183,8 +184,14 @@
         checkOutputPorts(status, 0, 0);
 
         try {
-            init();
-            free();
+        	if (!FileUtils.canWrite(
+        			getGraph() != null ? getGraph().getProjectURL() : null, fileURL)){
+        		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + fileURL);
+        		ex.setAttributeName(XML_FILEURL_ATTRIBUTE);
+        		throw ex;
+        	}
+//            init();
+//            free();
         } catch (ComponentNotReadyException e) {
             ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
             if(!StringUtils.isEmpty(e.getAttributeName())) {

Modified: trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-14 09:46:57 UTC (rev 2467)
+++ trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-14 14:29:44 UTC (rev 2468)
@@ -32,6 +32,7 @@
 import org.jetel.graph.Result;
 import org.jetel.graph.TransformationGraph;
 import org.jetel.util.ComponentXMLAttributes;
+import org.jetel.util.FileUtils;
 import org.jetel.util.MultiFileWriter;
 import org.jetel.util.StringUtils;
 import org.w3c.dom.Element;
@@ -264,8 +265,14 @@
         checkOutputPorts(status, 0, 0);
 
         try {
-            init();
-            free();
+        	if (!FileUtils.canWrite(
+        			getGraph() != null ? getGraph().getProjectURL() : null, fileURL)){
+        		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + fileURL);
+        		ex.setAttributeName(XML_FILEURL_ATTRIBUTE);
+        		throw ex;
+        	}
+//            init();
+//            free();
         } catch (ComponentNotReadyException e) {
             ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
             if(!StringUtils.isEmpty(e.getAttributeName())) {

Modified: trunk/cloveretl.component/src/org/jetel/component/JmsWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/JmsWriter.java	2007-02-14 09:46:57 UTC (rev 2467)
+++ trunk/cloveretl.component/src/org/jetel/component/JmsWriter.java	2007-02-14 14:29:44 UTC (rev 2468)
@@ -33,7 +33,6 @@
 import org.jetel.data.DataRecord;
 import org.jetel.database.IConnection;
 import org.jetel.exception.ComponentNotReadyException;
-import org.jetel.exception.ConfigurationProblem;
 import org.jetel.exception.ConfigurationStatus;
 import org.jetel.exception.JetelException;
 import org.jetel.exception.XMLConfigurationException;
@@ -43,7 +42,6 @@
 import org.jetel.graph.TransformationGraph;
 import org.jetel.util.ComponentXMLAttributes;
 import org.jetel.util.DynamicJavaCode;
-import org.jetel.util.StringUtils;
 import org.w3c.dom.Element;
 
 

Modified: trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-14 09:46:57 UTC (rev 2467)
+++ trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-14 14:29:44 UTC (rev 2468)
@@ -215,8 +215,14 @@
         checkOutputPorts(status, 0, 0);
 
         try {
-            init();
-            free();
+        	if (!FileUtils.canWrite(
+        			getGraph() != null ? getGraph().getProjectURL() : null, fileURL)){
+        		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + fileURL);
+        		ex.setAttributeName(XML_FILEURL_ATTRIBUTE);
+        		throw ex;
+        	}
+//            init();
+//            free();
         } catch (ComponentNotReadyException e) {
             ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
             if(!StringUtils.isEmpty(e.getAttributeName())) {

Modified: trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java	2007-02-14 09:46:57 UTC (rev 2467)
+++ trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java	2007-02-14 14:29:44 UTC (rev 2468)
@@ -181,8 +181,14 @@
         checkOutputPorts(status, 0, 0);
 
         try {
-            init();
-            free();
+        	if (fileURL != null && !FileUtils.canWrite(
+        			getGraph() != null ? getGraph().getProjectURL() : null, fileURL)){
+        		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + fileURL);
+        		ex.setAttributeName(XML_FILEURL_ATTRIBUTE);
+        		throw ex;
+        	}
+//            init();
+//            free();
         } catch (ComponentNotReadyException e) {
             ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
             if(!StringUtils.isEmpty(e.getAttributeName())) {

Modified: trunk/cloveretl.component/src/org/jetel/component/Trash.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/Trash.java	2007-02-14 09:46:57 UTC (rev 2467)
+++ trunk/cloveretl.component/src/org/jetel/component/Trash.java	2007-02-14 14:29:44 UTC (rev 2468)
@@ -19,9 +19,6 @@
 */
 package org.jetel.component;
 
-import java.io.BufferedOutputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.nio.ByteBuffer;
@@ -257,8 +254,23 @@
             checkOutputPorts(status, 0, 0);
 
             try {
-                init();
-                free();
+        		recordBuffer = ByteBuffer.allocateDirect(Defaults.Record.MAX_RECORD_SIZE);
+        		if (recordBuffer == null) {
+        			throw new ComponentNotReadyException("Can NOT allocate internal record buffer ! Required size:" +
+        					Defaults.Record.MAX_RECORD_SIZE);
+        		}
+        		recordBuffer = null;
+        		if (debugPrint) {
+                    if(debugFilename != null && !FileUtils.canWrite(
+                    		getGraph() != null ? getGraph().getProjectURL() : null, 
+                    				debugFilename)) {
+                		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + debugFilename);
+                		ex.setAttributeName(XML_DEBUGFILENAME_ATTRIBUTE);
+                		throw ex;
+                    }
+                 }
+//                init();
+//                free();
             } catch (ComponentNotReadyException e) {
                 ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
                 if(!StringUtils.isEmpty(e.getAttributeName())) {



From cloveretl-svn-commits at lists.berlios.de  Wed Feb 14 15:30:27 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 14 Feb 2007 15:30:27 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2469 -
	trunk/cloveretl.engine/src/org/jetel/util
Message-ID: <200702141430.l1EEUR8Z028757@sheep.berlios.de>

Author: agad
Date: 2007-02-14 15:30:26 +0100 (Wed, 14 Feb 2007)
New Revision: 2469

Modified:
   trunk/cloveretl.engine/src/org/jetel/util/FileUtils.java
   trunk/cloveretl.engine/src/org/jetel/util/MultiOutFile.java
Log:
BUGFIX:new implementation of checkConfig method - files are not deleted during checkconfig method

Modified: trunk/cloveretl.engine/src/org/jetel/util/FileUtils.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/FileUtils.java	2007-02-14 14:29:44 UTC (rev 2468)
+++ trunk/cloveretl.engine/src/org/jetel/util/FileUtils.java	2007-02-14 14:30:26 UTC (rev 2469)
@@ -20,12 +20,14 @@
 package org.jetel.util;
 
 import java.io.BufferedReader;
+import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.net.MalformedURLException;
+import java.net.URI;
 import java.net.URL;
 import java.nio.channels.Channels;
 import java.nio.channels.ReadableByteChannel;
@@ -39,6 +41,7 @@
 import java.util.zip.ZipOutputStream;
 
 import org.jetel.data.Defaults;
+import org.jetel.exception.ComponentNotReadyException;
 /**
  *  Helper class with some useful methods regarding file manipulation
  *
@@ -249,6 +252,54 @@
         }
 	}
     
+	/**
+	 * This method checks wheather is is possible to write to given file
+	 * 
+	 * @param contextURL
+	 * @param fileURL
+	 * @return true if can write, false otherwise
+	 * @throws ComponentNotReadyException
+	 */
+	public static boolean canWrite(URL contextURL, String fileURL)
+			throws ComponentNotReadyException {
+		String fileName;
+		if (fileURL.startsWith("zip:")){
+			fileName = fileURL.substring(fileURL.indexOf(':') + 1, 
+					fileURL.indexOf('#'));
+		}else if (fileURL.startsWith("gzip:")){
+			fileName = fileURL.substring(fileURL.indexOf(':') + 1);
+		}else{
+			fileName = fileURL;
+		}
+		MultiOutFile multiOut = new MultiOutFile(fileName);
+		URI uri;
+		File file;
+		boolean tmp;
+		//create file on given URL
+		try {
+			uri = getFileURL(contextURL, multiOut.next()).toURI();
+			file = new File(uri);
+		} catch (Exception e) {
+			throw new ComponentNotReadyException(e + ": " + fileURL);
+		}
+		//check if can write to this file
+		if (file.exists()) {
+			tmp = file.canWrite();
+		} else {
+			try {
+				tmp = file.createNewFile();
+			} catch (IOException e) {
+				throw new ComponentNotReadyException(e + ": " + uri);
+			}
+			if (tmp) {
+				file.delete();
+			}
+		}
+		if (!tmp) {
+			return false;
+		}
+		return true;
+	}
 }
 
 /*

Modified: trunk/cloveretl.engine/src/org/jetel/util/MultiOutFile.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/MultiOutFile.java	2007-02-14 14:29:44 UTC (rev 2468)
+++ trunk/cloveretl.engine/src/org/jetel/util/MultiOutFile.java	2007-02-14 14:30:26 UTC (rev 2469)
@@ -28,13 +28,13 @@
 /**
  * @author Jan Hadrava, Javlin Consulting (www.javlinconsulting.cz)
  * This implements list of filenames based on a specially formed mask. The mask
- * may contain a sequence of wildcard characters '#'. They will be replaced by sequential
+ * may contain a sequence of wildcard characters '$'. They will be replaced by sequential
  * number of the file. Count of wildcards specifies minimal length of the sequential number.
  * For a mask containing wildcards the list is infinite, for mask without wildcards it has only
  * one element - the mask itself. The mask must not be followed by any directory separators.
  */
 public class MultiOutFile implements Iterator<String> {
-	private static final char NUM_CHAR='#';
+	private static final char NUM_CHAR='$';
 	
 	private int digitCnt;
 	private int counter;



From cloveretl-svn-commits at lists.berlios.de  Wed Feb 14 17:05:35 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 14 Feb 2007 17:05:35 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2470 - in
	branches/cloveretl.engine.rel-2-1-0:
	cloveretl.component/src/org/jetel/component
	cloveretl.engine/src/org/jetel/util
Message-ID: <200702141605.l1EG5Zru005427@sheep.berlios.de>

Author: otasanek
Date: 2007-02-14 17:05:34 +0100 (Wed, 14 Feb 2007)
New Revision: 2470

Modified:
   branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/CloverDataWriter.java
   branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/DBJoin.java
   branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/DataWriter.java
   branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
   branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
   branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/JmsWriter.java
   branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/StructureWriter.java
   branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/Trash.java
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/util/FileUtils.java
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/util/MultiOutFile.java
Log:
SVN: merge for 2.1.0 (1).

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/CloverDataWriter.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/CloverDataWriter.java	2007-02-14 14:30:26 UTC (rev 2469)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/CloverDataWriter.java	2007-02-14 16:05:34 UTC (rev 2470)
@@ -45,6 +45,7 @@
 import org.jetel.metadata.DataRecordMetadataXMLReaderWriter;
 import org.jetel.util.ByteBufferUtils;
 import org.jetel.util.ComponentXMLAttributes;
+import org.jetel.util.FileUtils;
 import org.jetel.util.StringUtils;
 import org.jetel.util.SynchronizeUtils;
 import org.w3c.dom.Element;
@@ -212,8 +213,14 @@
         checkOutputPorts(status, 0, 0);
 
         try {
-            init();
-            free();
+        	if (!FileUtils.canWrite(
+        			getGraph() != null ? getGraph().getProjectURL() : null, fileURL)){
+        		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + fileURL);
+        		ex.setAttributeName(XML_FILEURL_ATTRIBUTE);
+        		throw ex;
+        	}
+//            init();
+//            free();
         } catch (ComponentNotReadyException e) {
             ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
             if(!StringUtils.isEmpty(e.getAttributeName())) {

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/DBJoin.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/DBJoin.java	2007-02-14 14:30:26 UTC (rev 2469)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/DBJoin.java	2007-02-14 16:05:34 UTC (rev 2470)
@@ -252,6 +252,7 @@
     		DataRecordMetadata inMetadata[]={ getInputPort(READ_FROM_PORT).getMetadata(),dbMetadata};
     		DataRecordMetadata outMetadata[]={getOutputPort(WRITE_TO_PORT).getMetadata()};
             lookupTable = new DBLookupTable("LOOKUP_TABLE_FROM_"+this.getId(),(DBConnection) conn,dbMetadata,query,maxCached);
+            lookupTable.checkConfig(status);
     		lookupTable.init();
     		try {
     			recordKey = new RecordKey(joinKey, inMetadata[0]);
@@ -295,6 +296,7 @@
 		DataRecordMetadata inMetadata[]={ getInputPort(READ_FROM_PORT).getMetadata(),dbMetadata};
 		DataRecordMetadata outMetadata[]={getOutputPort(WRITE_TO_PORT).getMetadata()};
         lookupTable = new DBLookupTable("LOOKUP_TABLE_FROM_"+this.getId(),(DBConnection) conn,dbMetadata,query,maxCached);
+        lookupTable.checkConfig(null);
 		lookupTable.init();
 		try {
 			recordKey = new RecordKey(joinKey, inMetadata[0]);

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/DataWriter.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-14 14:30:26 UTC (rev 2469)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-14 16:05:34 UTC (rev 2470)
@@ -33,6 +33,7 @@
 import org.jetel.graph.Result;
 import org.jetel.graph.TransformationGraph;
 import org.jetel.util.ComponentXMLAttributes;
+import org.jetel.util.FileUtils;
 import org.jetel.util.MultiFileWriter;
 import org.jetel.util.StringUtils;
 import org.jetel.util.SynchronizeUtils;
@@ -228,8 +229,16 @@
         checkOutputPorts(status, 0, 0);
 
         try {
-            init();
-            free();
+        	if (fileURL != null) {
+        		if (!FileUtils.canWrite(getGraph() != null ? getGraph().getProjectURL() 
+        				: null, fileURL)){
+	        		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + fileURL);
+	        		ex.setAttributeName(XML_FILEURL_ATTRIBUTE);
+	        		throw ex;
+        		}
+        	}
+//            init();
+//            free();
         } catch (ComponentNotReadyException e) {
             ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
             if(!StringUtils.isEmpty(e.getAttributeName())) {

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-14 14:30:26 UTC (rev 2469)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-14 16:05:34 UTC (rev 2470)
@@ -33,6 +33,7 @@
 import org.jetel.graph.Result;
 import org.jetel.graph.TransformationGraph;
 import org.jetel.util.ComponentXMLAttributes;
+import org.jetel.util.FileUtils;
 import org.jetel.util.MultiFileWriter;
 import org.jetel.util.StringUtils;
 import org.jetel.util.SynchronizeUtils;
@@ -183,8 +184,14 @@
         checkOutputPorts(status, 0, 0);
 
         try {
-            init();
-            free();
+        	if (!FileUtils.canWrite(
+        			getGraph() != null ? getGraph().getProjectURL() : null, fileURL)){
+        		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + fileURL);
+        		ex.setAttributeName(XML_FILEURL_ATTRIBUTE);
+        		throw ex;
+        	}
+//            init();
+//            free();
         } catch (ComponentNotReadyException e) {
             ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
             if(!StringUtils.isEmpty(e.getAttributeName())) {

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-14 14:30:26 UTC (rev 2469)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-14 16:05:34 UTC (rev 2470)
@@ -32,6 +32,7 @@
 import org.jetel.graph.Result;
 import org.jetel.graph.TransformationGraph;
 import org.jetel.util.ComponentXMLAttributes;
+import org.jetel.util.FileUtils;
 import org.jetel.util.MultiFileWriter;
 import org.jetel.util.StringUtils;
 import org.w3c.dom.Element;
@@ -264,8 +265,14 @@
         checkOutputPorts(status, 0, 0);
 
         try {
-            init();
-            free();
+        	if (!FileUtils.canWrite(
+        			getGraph() != null ? getGraph().getProjectURL() : null, fileURL)){
+        		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + fileURL);
+        		ex.setAttributeName(XML_FILEURL_ATTRIBUTE);
+        		throw ex;
+        	}
+//            init();
+//            free();
         } catch (ComponentNotReadyException e) {
             ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
             if(!StringUtils.isEmpty(e.getAttributeName())) {

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/JmsWriter.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/JmsWriter.java	2007-02-14 14:30:26 UTC (rev 2469)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/JmsWriter.java	2007-02-14 16:05:34 UTC (rev 2470)
@@ -33,7 +33,6 @@
 import org.jetel.data.DataRecord;
 import org.jetel.database.IConnection;
 import org.jetel.exception.ComponentNotReadyException;
-import org.jetel.exception.ConfigurationProblem;
 import org.jetel.exception.ConfigurationStatus;
 import org.jetel.exception.JetelException;
 import org.jetel.exception.XMLConfigurationException;
@@ -43,7 +42,6 @@
 import org.jetel.graph.TransformationGraph;
 import org.jetel.util.ComponentXMLAttributes;
 import org.jetel.util.DynamicJavaCode;
-import org.jetel.util.StringUtils;
 import org.w3c.dom.Element;
 
 

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/StructureWriter.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-14 14:30:26 UTC (rev 2469)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-14 16:05:34 UTC (rev 2470)
@@ -204,8 +204,14 @@
         checkOutputPorts(status, 0, 0);
 
         try {
-            init();
-            free();
+        	if (!FileUtils.canWrite(
+        			getGraph() != null ? getGraph().getProjectURL() : null, fileURL)){
+        		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + fileURL);
+        		ex.setAttributeName(XML_FILEURL_ATTRIBUTE);
+        		throw ex;
+        	}
+//            init();
+//            free();
         } catch (ComponentNotReadyException e) {
             ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
             if(!StringUtils.isEmpty(e.getAttributeName())) {

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/Trash.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/Trash.java	2007-02-14 14:30:26 UTC (rev 2469)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/Trash.java	2007-02-14 16:05:34 UTC (rev 2470)
@@ -19,9 +19,6 @@
 */
 package org.jetel.component;
 
-import java.io.BufferedOutputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.nio.ByteBuffer;
@@ -257,8 +254,23 @@
             checkOutputPorts(status, 0, 0);
 
             try {
-                init();
-                free();
+        		recordBuffer = ByteBuffer.allocateDirect(Defaults.Record.MAX_RECORD_SIZE);
+        		if (recordBuffer == null) {
+        			throw new ComponentNotReadyException("Can NOT allocate internal record buffer ! Required size:" +
+        					Defaults.Record.MAX_RECORD_SIZE);
+        		}
+        		recordBuffer = null;
+        		if (debugPrint) {
+                    if(debugFilename != null && !FileUtils.canWrite(
+                    		getGraph() != null ? getGraph().getProjectURL() : null, 
+                    				debugFilename)) {
+                		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + debugFilename);
+                		ex.setAttributeName(XML_DEBUGFILENAME_ATTRIBUTE);
+                		throw ex;
+                    }
+                 }
+//                init();
+//                free();
             } catch (ComponentNotReadyException e) {
                 ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
                 if(!StringUtils.isEmpty(e.getAttributeName())) {

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/util/FileUtils.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/util/FileUtils.java	2007-02-14 14:30:26 UTC (rev 2469)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/util/FileUtils.java	2007-02-14 16:05:34 UTC (rev 2470)
@@ -20,12 +20,14 @@
 package org.jetel.util;
 
 import java.io.BufferedReader;
+import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.net.MalformedURLException;
+import java.net.URI;
 import java.net.URL;
 import java.nio.channels.Channels;
 import java.nio.channels.ReadableByteChannel;
@@ -39,6 +41,7 @@
 import java.util.zip.ZipOutputStream;
 
 import org.jetel.data.Defaults;
+import org.jetel.exception.ComponentNotReadyException;
 /**
  *  Helper class with some useful methods regarding file manipulation
  *
@@ -249,6 +252,54 @@
         }
 	}
     
+	/**
+	 * This method checks wheather is is possible to write to given file
+	 * 
+	 * @param contextURL
+	 * @param fileURL
+	 * @return true if can write, false otherwise
+	 * @throws ComponentNotReadyException
+	 */
+	public static boolean canWrite(URL contextURL, String fileURL)
+			throws ComponentNotReadyException {
+		String fileName;
+		if (fileURL.startsWith("zip:")){
+			fileName = fileURL.substring(fileURL.indexOf(':') + 1, 
+					fileURL.indexOf('#'));
+		}else if (fileURL.startsWith("gzip:")){
+			fileName = fileURL.substring(fileURL.indexOf(':') + 1);
+		}else{
+			fileName = fileURL;
+		}
+		MultiOutFile multiOut = new MultiOutFile(fileName);
+		URI uri;
+		File file;
+		boolean tmp;
+		//create file on given URL
+		try {
+			uri = getFileURL(contextURL, multiOut.next()).toURI();
+			file = new File(uri);
+		} catch (Exception e) {
+			throw new ComponentNotReadyException(e + ": " + fileURL);
+		}
+		//check if can write to this file
+		if (file.exists()) {
+			tmp = file.canWrite();
+		} else {
+			try {
+				tmp = file.createNewFile();
+			} catch (IOException e) {
+				throw new ComponentNotReadyException(e + ": " + uri);
+			}
+			if (tmp) {
+				file.delete();
+			}
+		}
+		if (!tmp) {
+			return false;
+		}
+		return true;
+	}
 }
 
 /*

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/util/MultiOutFile.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/util/MultiOutFile.java	2007-02-14 14:30:26 UTC (rev 2469)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/util/MultiOutFile.java	2007-02-14 16:05:34 UTC (rev 2470)
@@ -28,13 +28,13 @@
 /**
  * @author Jan Hadrava, Javlin Consulting (www.javlinconsulting.cz)
  * This implements list of filenames based on a specially formed mask. The mask
- * may contain a sequence of wildcard characters '#'. They will be replaced by sequential
+ * may contain a sequence of wildcard characters '$'. They will be replaced by sequential
  * number of the file. Count of wildcards specifies minimal length of the sequential number.
  * For a mask containing wildcards the list is infinite, for mask without wildcards it has only
  * one element - the mask itself. The mask must not be followed by any directory separators.
  */
 public class MultiOutFile implements Iterator<String> {
-	private static final char NUM_CHAR='#';
+	private static final char NUM_CHAR='$';
 	
 	private int digitCnt;
 	private int counter;



From cloveretl-svn-commits at lists.berlios.de  Fri Feb 16 13:50:39 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Fri, 16 Feb 2007 13:50:39 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2471 -
	trunk/cloveretl.engine/src/org/jetel/data
Message-ID: <200702161250.l1GCodAb029602@sheep.berlios.de>

Author: agad
Date: 2007-02-16 13:50:38 +0100 (Fri, 16 Feb 2007)
New Revision: 2471

Modified:
   trunk/cloveretl.engine/src/org/jetel/data/IntegerDataField.java
   trunk/cloveretl.engine/src/org/jetel/data/LongDataField.java
   trunk/cloveretl.engine/src/org/jetel/data/NumericDataField.java
Log:
BUGFIX:fix method compareTo(Object) to call method compareTo(Numeric) if argument is Numeric

Modified: trunk/cloveretl.engine/src/org/jetel/data/IntegerDataField.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/IntegerDataField.java	2007-02-14 16:05:34 UTC (rev 2470)
+++ trunk/cloveretl.engine/src/org/jetel/data/IntegerDataField.java	2007-02-16 12:50:38 UTC (rev 2471)
@@ -464,12 +464,8 @@
 		if (obj==null) return 1;
 		if (isNull) return -1;
 	    
-		if (obj instanceof IntegerDataField){
-			if (!((IntegerDataField) obj).isNull()) {
-				return compareTo(((IntegerDataField) obj).value);
-			}else{
-				return 1;
-			}
+		if (obj instanceof Numeric){
+			return compareTo((Numeric) obj);
 		}else if (obj instanceof Integer){
 			return compareTo(((Integer)obj).intValue());
 		}else if (obj instanceof Long){

Modified: trunk/cloveretl.engine/src/org/jetel/data/LongDataField.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/LongDataField.java	2007-02-14 16:05:34 UTC (rev 2470)
+++ trunk/cloveretl.engine/src/org/jetel/data/LongDataField.java	2007-02-16 12:50:38 UTC (rev 2471)
@@ -472,8 +472,8 @@
 		if (obj==null) return 1;
 		if (isNull) return -1;
 		
-		if (obj instanceof LongDataField){
-			return compareTo(((LongDataField) obj).getLong());
+		if (obj instanceof Numeric){
+			return compareTo((Numeric) obj);
 		}else if (obj instanceof Integer){
 			return compareTo(((Integer)obj).longValue());
 		}else if (obj instanceof Long){

Modified: trunk/cloveretl.engine/src/org/jetel/data/NumericDataField.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/NumericDataField.java	2007-02-14 16:05:34 UTC (rev 2470)
+++ trunk/cloveretl.engine/src/org/jetel/data/NumericDataField.java	2007-02-16 12:50:38 UTC (rev 2471)
@@ -552,12 +552,8 @@
 		if (obj==null) return 1;
 		if (isNull) return -1;
 	    
-		if (obj instanceof NumericDataField){
-			if (!((NumericDataField) obj).isNull()) {
-				return compareTo(((NumericDataField) obj).value);
-			}else {
-				return 1;
-			}
+		if (obj instanceof Numeric){
+			return compareTo((Numeric) obj);
 		}else if (obj instanceof Double){
 			return compareTo(((Double)obj).doubleValue());
 		}else if (obj instanceof Integer){



From cloveretl-svn-commits at lists.berlios.de  Fri Feb 16 14:16:08 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Fri, 16 Feb 2007 14:16:08 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2472 - in
	branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples:
	data metadata
Message-ID: <200702161316.l1GDG84T031224@sheep.berlios.de>

Author: agad
Date: 2007-02-16 14:16:07 +0100 (Fri, 16 Feb 2007)
New Revision: 2472

Modified:
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/data/employees2.dat
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/data/employees3.dat
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/metadata/employees.fmt
Log:
UPDATE:graph updated to work with actual engine version

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/data/employees2.dat
===================================================================
(Binary files differ)

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/data/employees3.dat
===================================================================
(Binary files differ)

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/metadata/employees.fmt
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/metadata/employees.fmt	2007-02-16 12:50:38 UTC (rev 2471)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/metadata/employees.fmt	2007-02-16 13:16:07 UTC (rev 2472)
@@ -16,5 +16,5 @@
 <Field delimiter=";" name="Extension" nullable="true" shift="0" type="string"/>
 <Field delimiter=";" name="Photo" nullable="true" shift="0" type="string"/>
 <Field delimiter=";" name="Memo" nullable="true" shift="0" type="string"/>
-<Field delimiter="\r\n" name="ReportsTo" nullable="true" shift="0" type="integer"/>
+<Field delimiter="\n" name="ReportsTo" nullable="true" shift="0" type="integer"/>
 </Record>



From cloveretl-svn-commits at lists.berlios.de  Fri Feb 16 14:17:30 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Fri, 16 Feb 2007 14:17:30 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2473 -
	branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples
Message-ID: <200702161317.l1GDHUtK031311@sheep.berlios.de>

Author: agad
Date: 2007-02-16 14:17:29 +0100 (Fri, 16 Feb 2007)
New Revision: 2473

Modified:
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphDBExecute.grf
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphDBRead.grf
Log:


Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphDBExecute.grf
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphDBExecute.grf	2007-02-16 13:16:07 UTC (rev 2472)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphDBExecute.grf	2007-02-16 13:17:29 UTC (rev 2473)
@@ -5,7 +5,7 @@
 </Global>
 <Phase number="0">
 <Node dbConnection="DBConnection0" enabled="enabled" guiHeight="0" guiName="DB Execute" guiWidth="0" guiX="26" guiY="25" id="DB_EXECUTE0" type="DB_EXECUTE">
-<attr name="dbSQL">drop table employee1;
+<attr name="sqlQuery">drop table employee1;
 drop table employee_TMP;
 
 create table employee1 (EMP_NO NUMERIC not null,FIRST_NAME  VARCHAR(15) not null,LAST_NAME VARCHAR(20) not null,PHONE_EXT VARCHAR(4),HIRE_DATE DATE not null,DEPT_NO CHAR(3) not null,JOB_CODE VARCHAR(5) not null,JOB_GRADE NUMERIC(4,2) not null,JOB_COUNTRY VARCHAR(15) not null,SALARY NUMERIC(15,2) not null,FULL_NAME VARCHAR(35));

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphDBRead.grf
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphDBRead.grf	2007-02-16 13:16:07 UTC (rev 2472)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphDBRead.grf	2007-02-16 13:17:29 UTC (rev 2473)
@@ -89,7 +89,7 @@
 </Phase>
 <Phase number="1">
 <Node dbConnection="DBConnection0" enabled="enabled" guiHeight="75" guiName="drop customer_tmp" guiWidth="124" guiX="57" guiY="495" id="DB_EXECUTE0" type="DB_EXECUTE">
-<attr name="dbSQL">drop table customer_tmp;</attr>
+<attr name="sqlQuery">drop table customer_tmp;</attr>
 </Node>
 </Phase>
 </Graph>



From cloveretl-svn-commits at lists.berlios.de  Fri Feb 16 14:18:17 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Fri, 16 Feb 2007 14:18:17 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2474 -
	branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples
Message-ID: <200702161318.l1GDIHow031354@sheep.berlios.de>

Author: agad
Date: 2007-02-16 14:18:16 +0100 (Fri, 16 Feb 2007)
New Revision: 2474

Modified:
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphGenerateData.grf
Log:
UPDATE:graph updated to work with actual engine version

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphGenerateData.grf
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphGenerateData.grf	2007-02-16 13:17:29 UTC (rev 2473)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphGenerateData.grf	2007-02-16 13:18:16 UTC (rev 2474)
@@ -1,19 +1,15 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<Graph created="Thu Jan 11 09:49:56 CET 2007" guiVersion="1.5" licenseType="Evaluation license" modified="Fri Jan 12 15:34:56 CET 2007" name="graphGenerateData" revision="1.13">
+<Graph created="Thu Jan 11 09:49:56 CET 2007" guiVersion="1.6" licenseType="Unlicensed clover.GUI" modified="Fri Feb 16 11:19:56 CET 2007" name="graphGenerateData" revision="1.14">
 <Global>
 <Metadata fileURL="metadata/orders.fmt" id="Metadata0"/>
 <Metadata fileURL="metadata/ordersFix.fmt" id="Metadata1"/>
 <Property fileURL="workspace.prm" id="GraphParameter0"/>
+<Property id="GraphParameter1" name="ORDER_DATE" value="01.01.2007"/>
+<Property id="GraphParameter2" name="REQUIRED_DATE" value="31.01.2007"/>
 <Sequence cached="20" fileURL="seq.seq" id="Sequence0" name="ordersID" start="1" step="1" type="SIMPLE_SEQUENCE"/>
 </Global>
 <Phase number="0">
-<Node enabled="enabled" guiHeight="0" guiName="Data Generator" guiWidth="0" guiX="68" guiY="278" id="DATA_GENERATOR1" type="DATA_GENERATOR">
-<attr name="randomFields">EmployeeID=random(1,1000);ShippedDate=random(${ORDER_DATE},${REQUIRED_DATE})</attr>
-<attr name="recordsNumber">10000</attr>
-<attr name="sequenceFields">OrderID</attr>
-<attr name="pattern">                 aga${ORDER_DATE}${REQUIRED_DATE}  1      10                name          adressPragu   EU   12000CZ
-</attr>
-</Node>
+<Node enabled="enabled" guiHeight="0" guiName="Data Generator" guiWidth="0" guiX="68" guiY="278" id="DATA_GENERATOR1" pattern="                 aga${ORDER_DATE}${REQUIRED_DATE}  1      10                name          adressPragu   EU   12000CZ&#10;" randomFields="EmployeeID=random(1,1000);ShippedDate=random(${ORDER_DATE},${REQUIRED_DATE})" recordsNumber="10000" sequenceFields="OrderID" type="DATA_GENERATOR"/>
 <Node enabled="enabled" guiHeight="0" guiName="Simple Copy" guiWidth="0" guiX="245" guiY="278" id="SIMPLE_COPY0" type="SIMPLE_COPY"/>
 <Node enabled="enabled" fileURL="${WORKSPACE}/output/orders.xls" guiHeight="0" guiName="XLS Data Writer" guiWidth="0" guiX="398" guiY="278" id="XLS_WRITER0" namesRow="1" type="XLS_WRITER"/>
 <Edge fromNode="DATA_GENERATOR1:0" guiBendpoints="" id="Edge3" inPort="0 (Simple Copy)" metadata="Metadata1" outPort="0 (Data Generator)" toNode="SIMPLE_COPY0:0"/>



From cloveretl-svn-commits at lists.berlios.de  Fri Feb 16 14:18:35 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Fri, 16 Feb 2007 14:18:35 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2475 -
	branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples
Message-ID: <200702161318.l1GDIZog031448@sheep.berlios.de>

Author: agad
Date: 2007-02-16 14:18:35 +0100 (Fri, 16 Feb 2007)
New Revision: 2475

Modified:
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphJoinHashInline.grf
Log:
UPDATE:graph updated to work with actual engine version

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphJoinHashInline.grf
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphJoinHashInline.grf	2007-02-16 13:18:16 UTC (rev 2474)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphJoinHashInline.grf	2007-02-16 13:18:35 UTC (rev 2475)
@@ -1,28 +1,18 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<Graph description="This graph demonstrates how to use HASH_JOIN component for 3way join. HASH_JOIN component&#10;performs joining of master data with slave data based on specified key. First all slave&#10;data are read and hash-table is constructed from them. Then for every master record, attempt&#10;is made to find corresponding slave-record.&#10;HASH_JOIN performs better than SORT/MERGE_JOIN when you have relatively small slave data set&#10;and big master data set. It doesn't require master and slave data to be sorted" name="Testing Hash Joiner">
+<Graph created="Fri Feb 16 10:01:53 CET 2007" description="This graph demonstrates how to use HASH_JOIN component for 3way join. HASH_JOIN component&#10;performs joining of master data with slave data based on specified key. First all slave&#10;data are read and hash-table is constructed from them. Then for every master record, attempt&#10;is made to find corresponding slave-record.&#10;HASH_JOIN performs better than SORT/MERGE_JOIN when you have relatively small slave data set&#10;and big master data set. It doesn't require master and slave data to be sorted" guiVersion="1.6" licenseType="Unlicensed clover.GUI" modified="Fri Feb 16 11:47:07 CET 2007" name="Testing Hash Joiner" revision="1.1">
 <Global>
-<Metadata fileURL="metadata/orders.fmt" id="InMetadata1"/>
-<Metadata fileURL="metadata/employees.fmt" id="InMetadata2"/>
 <Metadata fileURL="metadata/customers.fmt" id="InMetadata3"/>
+<Metadata fileURL="metadata/employees.fmt" id="InMetadata2"/>
 <Metadata fileURL="metadata/joinedOrders3way.fmt" id="OutMetadata"/>
+<Metadata fileURL="metadata/orders.fmt" id="InMetadata1"/>
 <Property fileURL="workspace.prm" id="GraphParameter0"/>
 </Global>
 <Phase number="0">
-<Node enabled="enabled" id="INPUT1" type="DELIMITED_DATA_READER"
-fileURL="${WORKSPACE}/data/orders.dat"
-/>
-<Node enabled="enabled" id="INPUT2" type="DELIMITED_DATA_READER"
-fileURL="${WORKSPACE}/data/employees.dat"
-/>
-<Node enabled="enabled" id="INPUT3" type="DELIMITED_DATA_READER"
-fileURL="${WORKSPACE}/data/customers_delimited.txt"
-/>
-
-<Node enabled="enabled" id="JOIN" type="HASH_JOIN"
-joinKey="EmployeeID=EmployeeID#CustomerID=CUSTOMERID"
-joinType="leftOuter"
-slaveDuplicates="true"
-><attr name="transform">
+<Node enabled="enabled" fileURL="${WORKSPACE}/data/orders.dat" guiHeight="25" guiName="INPUT1" guiWidth="50" guiX="59" guiY="48" id="INPUT1" type="DELIMITED_DATA_READER"/>
+<Node enabled="enabled" fileURL="${WORKSPACE}/data/employees.dat" guiHeight="25" guiName="INPUT2" guiWidth="50" guiX="59" guiY="136" id="INPUT2" type="DELIMITED_DATA_READER"/>
+<Node enabled="enabled" fileURL="${WORKSPACE}/data/customers_delimited.txt" guiHeight="25" guiName="INPUT3" guiWidth="50" guiX="59" guiY="223" id="INPUT3" type="DELIMITED_DATA_READER"/>
+<Node enabled="enabled" guiHeight="25" guiName="JOIN" guiWidth="50" guiX="256" guiY="48" id="JOIN" joinKey="EmployeeID=EmployeeID#CustomerID=CUSTOMERID" joinType="leftOuter" slaveDuplicates="true" type="EXT_HASH_JOIN">
+<attr name="transform">
 import org.jetel.component.DataRecordTransform;
 import org.jetel.data.*;
 
@@ -54,14 +44,10 @@
 
 </attr>
 </Node>
-
-<Node append="false" enabled="enabled" fileURL="${WORKSPACE}/output/joined_data_hash.out" guiHeight="25" guiName="WRITER" guiWidth="50" guiX="370" guiY="20" id="WRITER" type="DELIMITED_DATA_WRITER"/>
-
+<Node append="false" enabled="enabled" fileURL="${WORKSPACE}/output/joined_data_hash.out" guiHeight="25" guiName="WRITER" guiWidth="50" guiX="448" guiY="48" id="WRITER" type="DELIMITED_DATA_WRITER"/>
 <Edge fromNode="INPUT1:0" guiBendpoints="" id="INEDGE1" inPort="0 (JOIN)" metadata="InMetadata1" outPort="0 (INPUT1)" toNode="JOIN:0"/>
 <Edge fromNode="INPUT2:0" guiBendpoints="" id="INEDGE2" inPort="1 (JOIN)" metadata="InMetadata2" outPort="0 (INPUT2)" toNode="JOIN:1"/>
 <Edge fromNode="INPUT3:0" guiBendpoints="" id="INEDGE3" inPort="2 (JOIN)" metadata="InMetadata3" outPort="0 (INPUT3)" toNode="JOIN:2"/>
-
 <Edge fromNode="JOIN:0" guiBendpoints="" id="OUTEDGE" inPort="0 (WRITER)" metadata="OutMetadata" outPort="0 (JOIN)" toNode="WRITER:0"/>
-
 </Phase>
 </Graph>



From cloveretl-svn-commits at lists.berlios.de  Fri Feb 16 14:19:02 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Fri, 16 Feb 2007 14:19:02 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2476 -
	branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples
Message-ID: <200702161319.l1GDJ2PA031577@sheep.berlios.de>

Author: agad
Date: 2007-02-16 14:19:01 +0100 (Fri, 16 Feb 2007)
New Revision: 2476

Modified:
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphJoinHashUsingTransform.grf
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphJoinHashUsingTransformLanguage.grf
Log:
UPDATE:graph updated to work with actual engine version

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphJoinHashUsingTransform.grf
===================================================================
(Binary files differ)

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphJoinHashUsingTransformLanguage.grf
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphJoinHashUsingTransformLanguage.grf	2007-02-16 13:18:35 UTC (rev 2475)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphJoinHashUsingTransformLanguage.grf	2007-02-16 13:19:01 UTC (rev 2476)
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<Graph description="This graph demonstrates functionality of HASH_JOIN components. HASH_JOIN component&#10;performs joining of master data with slave data based on specified key. First all slave&#10;data are read and hash-table is constructed from them. Then for every master record, attempt&#10;is made to find corresponding slave-record.&#10;HASH_JOIN performs better than SORT/MERGE_JOIN when you have relatively small slave data set&#10;and big master data set. It doesn't require master and slave data to be sorted" name="Testing Hash Joiner">
+<Graph created="Fri Feb 16 10:01:53 CET 2007" description="This graph demonstrates functionality of HASH_JOIN components. HASH_JOIN component&#10;performs joining of master data with slave data based on specified key. First all slave&#10;data are read and hash-table is constructed from them. Then for every master record, attempt&#10;is made to find corresponding slave-record.&#10;HASH_JOIN performs better than SORT/MERGE_JOIN when you have relatively small slave data set&#10;and big master data set. It doesn't require master and slave data to be sorted" guiVersion="1.6" licenseType="Unlicensed clover.GUI" modified="Fri Feb 16 11:50:49 CET 2007" name="Testing Hash Joiner" revision="1.0">
 <Global>
 <Metadata fileURL="metadata/employees.fmt" id="InMetadata2"/>
 <Metadata fileURL="metadata/joinedOrders.fmt" id="OutMetadata"/>
@@ -15,7 +15,7 @@
 $OrderID := $OrderID;
 $CustomerID := $CustomerID;
 $EmployeeID := $EmployeeID;
-$EmployeeID2 := $1.EmployeeID;
+$EmployeeID2 := num2str($1.EmployeeID);
 $LastName := concat($1.LastName,":",$1.FirstName);
 }
 </attr>



From cloveretl-svn-commits at lists.berlios.de  Fri Feb 16 14:19:23 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Fri, 16 Feb 2007 14:19:23 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2477 -
	branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples
Message-ID: <200702161319.l1GDJNC7031609@sheep.berlios.de>

Author: agad
Date: 2007-02-16 14:19:23 +0100 (Fri, 16 Feb 2007)
New Revision: 2477

Modified:
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphJoinMergeInline.grf
Log:
UPDATE:graph updated to work with actual engine version

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphJoinMergeInline.grf
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphJoinMergeInline.grf	2007-02-16 13:19:01 UTC (rev 2476)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphJoinMergeInline.grf	2007-02-16 13:19:23 UTC (rev 2477)
@@ -13,7 +13,7 @@
 <Node enabled="enabled" guiHeight="0" guiName="Ext Sort" guiWidth="0" guiX="275" guiY="83" id="EXT_SORT0" sortKey="EmployeeID" type="EXT_SORT"/>
 <Node enabled="enabled" guiHeight="0" guiName="Ext Sort" guiWidth="0" guiX="275" guiY="190" id="EXT_SORT1" sortKey="EmployeeID" type="EXT_SORT"/>
 <Node enabled="enabled" guiHeight="0" guiName="Ext Sort" guiWidth="0" guiX="275" guiY="276" id="EXT_SORT2" sortKey="ReportsTo" type="EXT_SORT"/>
-<Node enabled="enabled" guiHeight="0" guiName="Ext Merge Join" guiWidth="0" guiX="480" guiY="190" id="MERGE_JOIN1" joinKey="EmployeeID=EmployeeID#EmployeeID=ReportsTo" type="MERGE_JOIN">
+<Node enabled="enabled" guiHeight="0" guiName="Ext Merge Join" guiWidth="0" guiX="480" guiY="190" id="MERGE_JOIN1" joinKey="EmployeeID=EmployeeID#EmployeeID=ReportsTo" type="EXT_MERGE_JOIN">
 <attr name="transform">
 import org.jetel.component.DataRecordTransform;
 import org.jetel.data.*;



From cloveretl-svn-commits at lists.berlios.de  Fri Feb 16 14:20:18 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Fri, 16 Feb 2007 14:20:18 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2478 -
	branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples
Message-ID: <200702161320.l1GDKIEO031670@sheep.berlios.de>

Author: agad
Date: 2007-02-16 14:20:18 +0100 (Fri, 16 Feb 2007)
New Revision: 2478

Modified:
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphParametrizedLookup.grf
Log:
UPDATE:graph updated to work with actual engine version

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphParametrizedLookup.grf
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphParametrizedLookup.grf	2007-02-16 13:19:23 UTC (rev 2477)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/graphParametrizedLookup.grf	2007-02-16 13:20:18 UTC (rev 2478)
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<Graph created="Fri Jan 12 15:46:21 CET 2007" description="This graph demonstrates usage of Node-level parameters" guiVersion="1.5" licenseType="Evaluation license" modified="Fri Jan 12 16:33:07 CET 2007" name="Testing Simple Lookup with parameters" revision="1.0">
+<Graph created="Fri Jan 12 15:46:21 CET 2007" description="This graph demonstrates usage of Node-level parameters" guiVersion="1.6" licenseType="Unlicensed clover.GUI" modified="Fri Feb 16 14:05:16 CET 2007" name="Testing Simple Lookup with parameters" revision="1.2">
 <Global>
 <Metadata fileURL="metadata/employees.fmt" id="InMetadata2"/>
 <Metadata fileURL="metadata/joinedOrders.fmt" id="OutMetadata"/>
@@ -58,7 +58,7 @@
 		target[0].getField(0).setValue(source[0].getField(0).getValue());&#13;
   		target[0].getField(1).setValue(source[0].getField(1).getValue());&#13;
 		target[0].getField(2).setValue(source[0].getField(2).getValue());&#13;
-		target[0].getField(3).setValue(employee.getField(0).getValue());&#13;
+		target[0].getField(3).setValue(employee.getField(0).getValue().toString());&#13;
 		target[0].getField(4).setValue(employee.getField(1).getValue());&#13;
 &#13;
 		return true;&#13;



From cloveretl-svn-commits at lists.berlios.de  Fri Feb 16 14:20:39 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Fri, 16 Feb 2007 14:20:39 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2479 -
	branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples
Message-ID: <200702161320.l1GDKd1a031704@sheep.berlios.de>

Author: agad
Date: 2007-02-16 14:20:38 +0100 (Fri, 16 Feb 2007)
New Revision: 2479

Modified:
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/reformatJoinTest.java
Log:
UPDATE:graph updated to work with actual engine version

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/reformatJoinTest.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/reformatJoinTest.java	2007-02-16 13:20:18 UTC (rev 2478)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/examples/reformatJoinTest.java	2007-02-16 13:20:38 UTC (rev 2479)
@@ -33,11 +33,11 @@
 		target[0].getField(1).setValue(source[0].getField(1).getValue());
 		System.out.print("|");
 		System.out.print(source[0].getField(2).toString());
-		target[0].getField(2).setValue(source[0].getField(2).getValue());
+		target[0].getField(2).setValue(source[0].getField(2).getValue().toString());
 		if (source[1]!=null){
 			System.out.print("|");
 			System.out.print(source[1].getField(0).toString());
-			target[0].getField(3).setValue(source[1].getField(0).getValue());
+			target[0].getField(3).setValue(source[1].getField(0).getValue().toString());
 			System.out.print("|");
 			System.out.print(source[1].getField(1).toString());
 			target[0].getField(4).setValue(source[1].getField(1).getValue());



From cloveretl-svn-commits at lists.berlios.de  Fri Feb 16 16:22:41 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Fri, 16 Feb 2007 16:22:41 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2480 - in
	trunk/cloveretl.engine/examples: . data metadata
Message-ID: <200702161522.l1GFMftV008406@sheep.berlios.de>

Author: otasanek
Date: 2007-02-16 16:22:40 +0100 (Fri, 16 Feb 2007)
New Revision: 2480

Modified:
   trunk/cloveretl.engine/examples/data/employees2.dat
   trunk/cloveretl.engine/examples/data/employees3.dat
   trunk/cloveretl.engine/examples/graphDBExecute.grf
   trunk/cloveretl.engine/examples/graphDBRead.grf
   trunk/cloveretl.engine/examples/graphGenerateData.grf
   trunk/cloveretl.engine/examples/graphJoinHashInline.grf
   trunk/cloveretl.engine/examples/graphJoinHashUsingTransform.grf
   trunk/cloveretl.engine/examples/graphJoinHashUsingTransformLanguage.grf
   trunk/cloveretl.engine/examples/graphJoinMergeInline.grf
   trunk/cloveretl.engine/examples/graphParametrizedLookup.grf
   trunk/cloveretl.engine/examples/metadata/employees.fmt
   trunk/cloveretl.engine/examples/reformatJoinTest.java
Log:
SVN: merge for trunk from 2.1.0 - examples.

Modified: trunk/cloveretl.engine/examples/data/employees2.dat
===================================================================
(Binary files differ)

Modified: trunk/cloveretl.engine/examples/data/employees3.dat
===================================================================
(Binary files differ)

Modified: trunk/cloveretl.engine/examples/graphDBExecute.grf
===================================================================
--- trunk/cloveretl.engine/examples/graphDBExecute.grf	2007-02-16 13:20:38 UTC (rev 2479)
+++ trunk/cloveretl.engine/examples/graphDBExecute.grf	2007-02-16 15:22:40 UTC (rev 2480)
@@ -5,7 +5,7 @@
 </Global>
 <Phase number="0">
 <Node dbConnection="DBConnection0" enabled="enabled" guiHeight="0" guiName="DB Execute" guiWidth="0" guiX="26" guiY="25" id="DB_EXECUTE0" type="DB_EXECUTE">
-<attr name="dbSQL">drop table employee1;
+<attr name="sqlQuery">drop table employee1;
 drop table employee_TMP;
 
 create table employee1 (EMP_NO NUMERIC not null,FIRST_NAME  VARCHAR(15) not null,LAST_NAME VARCHAR(20) not null,PHONE_EXT VARCHAR(4),HIRE_DATE DATE not null,DEPT_NO CHAR(3) not null,JOB_CODE VARCHAR(5) not null,JOB_GRADE NUMERIC(4,2) not null,JOB_COUNTRY VARCHAR(15) not null,SALARY NUMERIC(15,2) not null,FULL_NAME VARCHAR(35));

Modified: trunk/cloveretl.engine/examples/graphDBRead.grf
===================================================================
--- trunk/cloveretl.engine/examples/graphDBRead.grf	2007-02-16 13:20:38 UTC (rev 2479)
+++ trunk/cloveretl.engine/examples/graphDBRead.grf	2007-02-16 15:22:40 UTC (rev 2480)
@@ -89,7 +89,7 @@
 </Phase>
 <Phase number="1">
 <Node dbConnection="DBConnection0" enabled="enabled" guiHeight="75" guiName="drop customer_tmp" guiWidth="124" guiX="57" guiY="495" id="DB_EXECUTE0" type="DB_EXECUTE">
-<attr name="dbSQL">drop table customer_tmp;</attr>
+<attr name="sqlQuery">drop table customer_tmp;</attr>
 </Node>
 </Phase>
 </Graph>

Modified: trunk/cloveretl.engine/examples/graphGenerateData.grf
===================================================================
--- trunk/cloveretl.engine/examples/graphGenerateData.grf	2007-02-16 13:20:38 UTC (rev 2479)
+++ trunk/cloveretl.engine/examples/graphGenerateData.grf	2007-02-16 15:22:40 UTC (rev 2480)
@@ -1,19 +1,15 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<Graph created="Thu Jan 11 09:49:56 CET 2007" guiVersion="1.5" licenseType="Evaluation license" modified="Fri Jan 12 15:34:56 CET 2007" name="graphGenerateData" revision="1.13">
+<Graph created="Thu Jan 11 09:49:56 CET 2007" guiVersion="1.6" licenseType="Unlicensed clover.GUI" modified="Fri Feb 16 11:19:56 CET 2007" name="graphGenerateData" revision="1.14">
 <Global>
 <Metadata fileURL="metadata/orders.fmt" id="Metadata0"/>
 <Metadata fileURL="metadata/ordersFix.fmt" id="Metadata1"/>
 <Property fileURL="workspace.prm" id="GraphParameter0"/>
+<Property id="GraphParameter1" name="ORDER_DATE" value="01.01.2007"/>
+<Property id="GraphParameter2" name="REQUIRED_DATE" value="31.01.2007"/>
 <Sequence cached="20" fileURL="seq.seq" id="Sequence0" name="ordersID" start="1" step="1" type="SIMPLE_SEQUENCE"/>
 </Global>
 <Phase number="0">
-<Node enabled="enabled" guiHeight="0" guiName="Data Generator" guiWidth="0" guiX="68" guiY="278" id="DATA_GENERATOR1" type="DATA_GENERATOR">
-<attr name="randomFields">EmployeeID=random(1,1000);ShippedDate=random(${ORDER_DATE},${REQUIRED_DATE})</attr>
-<attr name="recordsNumber">10000</attr>
-<attr name="sequenceFields">OrderID</attr>
-<attr name="pattern">                 aga${ORDER_DATE}${REQUIRED_DATE}  1      10                name          adressPragu   EU   12000CZ
-</attr>
-</Node>
+<Node enabled="enabled" guiHeight="0" guiName="Data Generator" guiWidth="0" guiX="68" guiY="278" id="DATA_GENERATOR1" pattern="                 aga${ORDER_DATE}${REQUIRED_DATE}  1      10                name          adressPragu   EU   12000CZ&#10;" randomFields="EmployeeID=random(1,1000);ShippedDate=random(${ORDER_DATE},${REQUIRED_DATE})" recordsNumber="10000" sequenceFields="OrderID" type="DATA_GENERATOR"/>
 <Node enabled="enabled" guiHeight="0" guiName="Simple Copy" guiWidth="0" guiX="245" guiY="278" id="SIMPLE_COPY0" type="SIMPLE_COPY"/>
 <Node enabled="enabled" fileURL="${WORKSPACE}/output/orders.xls" guiHeight="0" guiName="XLS Data Writer" guiWidth="0" guiX="398" guiY="278" id="XLS_WRITER0" namesRow="1" type="XLS_WRITER"/>
 <Edge fromNode="DATA_GENERATOR1:0" guiBendpoints="" id="Edge3" inPort="0 (Simple Copy)" metadata="Metadata1" outPort="0 (Data Generator)" toNode="SIMPLE_COPY0:0"/>

Modified: trunk/cloveretl.engine/examples/graphJoinHashInline.grf
===================================================================
--- trunk/cloveretl.engine/examples/graphJoinHashInline.grf	2007-02-16 13:20:38 UTC (rev 2479)
+++ trunk/cloveretl.engine/examples/graphJoinHashInline.grf	2007-02-16 15:22:40 UTC (rev 2480)
@@ -1,28 +1,18 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<Graph description="This graph demonstrates how to use HASH_JOIN component for 3way join. HASH_JOIN component&#10;performs joining of master data with slave data based on specified key. First all slave&#10;data are read and hash-table is constructed from them. Then for every master record, attempt&#10;is made to find corresponding slave-record.&#10;HASH_JOIN performs better than SORT/MERGE_JOIN when you have relatively small slave data set&#10;and big master data set. It doesn't require master and slave data to be sorted" name="Testing Hash Joiner">
+<Graph created="Fri Feb 16 10:01:53 CET 2007" description="This graph demonstrates how to use HASH_JOIN component for 3way join. HASH_JOIN component&#10;performs joining of master data with slave data based on specified key. First all slave&#10;data are read and hash-table is constructed from them. Then for every master record, attempt&#10;is made to find corresponding slave-record.&#10;HASH_JOIN performs better than SORT/MERGE_JOIN when you have relatively small slave data set&#10;and big master data set. It doesn't require master and slave data to be sorted" guiVersion="1.6" licenseType="Unlicensed clover.GUI" modified="Fri Feb 16 11:47:07 CET 2007" name="Testing Hash Joiner" revision="1.1">
 <Global>
-<Metadata fileURL="metadata/orders.fmt" id="InMetadata1"/>
-<Metadata fileURL="metadata/employees.fmt" id="InMetadata2"/>
 <Metadata fileURL="metadata/customers.fmt" id="InMetadata3"/>
+<Metadata fileURL="metadata/employees.fmt" id="InMetadata2"/>
 <Metadata fileURL="metadata/joinedOrders3way.fmt" id="OutMetadata"/>
+<Metadata fileURL="metadata/orders.fmt" id="InMetadata1"/>
 <Property fileURL="workspace.prm" id="GraphParameter0"/>
 </Global>
 <Phase number="0">
-<Node enabled="enabled" id="INPUT1" type="DELIMITED_DATA_READER"
-fileURL="${HOME}/${WORKSPACE}/data/orders.dat"
-/>
-<Node enabled="enabled" id="INPUT2" type="DELIMITED_DATA_READER"
-fileURL="${HOME}/${WORKSPACE}/data/employees.dat"
-/>
-<Node enabled="enabled" id="INPUT3" type="DELIMITED_DATA_READER"
-fileURL="${HOME}/${WORKSPACE}/data/customers_delimited.txt"
-/>
-
-<Node enabled="enabled" id="JOIN" type="HASH_JOIN"
-joinKey="EmployeeID=EmployeeID#CustomerID=CUSTOMERID"
-joinType="leftOuter"
-slaveDuplicates="true"
-><attr name="transform">
+<Node enabled="enabled" fileURL="${WORKSPACE}/data/orders.dat" guiHeight="25" guiName="INPUT1" guiWidth="50" guiX="59" guiY="48" id="INPUT1" type="DELIMITED_DATA_READER"/>
+<Node enabled="enabled" fileURL="${WORKSPACE}/data/employees.dat" guiHeight="25" guiName="INPUT2" guiWidth="50" guiX="59" guiY="136" id="INPUT2" type="DELIMITED_DATA_READER"/>
+<Node enabled="enabled" fileURL="${WORKSPACE}/data/customers_delimited.txt" guiHeight="25" guiName="INPUT3" guiWidth="50" guiX="59" guiY="223" id="INPUT3" type="DELIMITED_DATA_READER"/>
+<Node enabled="enabled" guiHeight="25" guiName="JOIN" guiWidth="50" guiX="256" guiY="48" id="JOIN" joinKey="EmployeeID=EmployeeID#CustomerID=CUSTOMERID" joinType="leftOuter" slaveDuplicates="true" type="EXT_HASH_JOIN">
+<attr name="transform">
 import org.jetel.component.DataRecordTransform;
 import org.jetel.data.*;
 
@@ -54,14 +44,10 @@
 
 </attr>
 </Node>
-
-<Node append="false" enabled="enabled" fileURL="${HOME}/${WORKSPACE}/output/joined_data_hash.out" guiHeight="25" guiName="WRITER" guiWidth="50" guiX="370" guiY="20" id="WRITER" type="DELIMITED_DATA_WRITER"/>
-
+<Node append="false" enabled="enabled" fileURL="${WORKSPACE}/output/joined_data_hash.out" guiHeight="25" guiName="WRITER" guiWidth="50" guiX="448" guiY="48" id="WRITER" type="DELIMITED_DATA_WRITER"/>
 <Edge fromNode="INPUT1:0" guiBendpoints="" id="INEDGE1" inPort="0 (JOIN)" metadata="InMetadata1" outPort="0 (INPUT1)" toNode="JOIN:0"/>
 <Edge fromNode="INPUT2:0" guiBendpoints="" id="INEDGE2" inPort="1 (JOIN)" metadata="InMetadata2" outPort="0 (INPUT2)" toNode="JOIN:1"/>
 <Edge fromNode="INPUT3:0" guiBendpoints="" id="INEDGE3" inPort="2 (JOIN)" metadata="InMetadata3" outPort="0 (INPUT3)" toNode="JOIN:2"/>
-
 <Edge fromNode="JOIN:0" guiBendpoints="" id="OUTEDGE" inPort="0 (WRITER)" metadata="OutMetadata" outPort="0 (JOIN)" toNode="WRITER:0"/>
-
 </Phase>
 </Graph>

Modified: trunk/cloveretl.engine/examples/graphJoinHashUsingTransform.grf
===================================================================
(Binary files differ)

Modified: trunk/cloveretl.engine/examples/graphJoinHashUsingTransformLanguage.grf
===================================================================
--- trunk/cloveretl.engine/examples/graphJoinHashUsingTransformLanguage.grf	2007-02-16 13:20:38 UTC (rev 2479)
+++ trunk/cloveretl.engine/examples/graphJoinHashUsingTransformLanguage.grf	2007-02-16 15:22:40 UTC (rev 2480)
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<Graph description="This graph demonstrates functionality of HASH_JOIN components. HASH_JOIN component&#10;performs joining of master data with slave data based on specified key. First all slave&#10;data are read and hash-table is constructed from them. Then for every master record, attempt&#10;is made to find corresponding slave-record.&#10;HASH_JOIN performs better than SORT/MERGE_JOIN when you have relatively small slave data set&#10;and big master data set. It doesn't require master and slave data to be sorted" name="Testing Hash Joiner">
+<Graph created="Fri Feb 16 10:01:53 CET 2007" description="This graph demonstrates functionality of HASH_JOIN components. HASH_JOIN component&#10;performs joining of master data with slave data based on specified key. First all slave&#10;data are read and hash-table is constructed from them. Then for every master record, attempt&#10;is made to find corresponding slave-record.&#10;HASH_JOIN performs better than SORT/MERGE_JOIN when you have relatively small slave data set&#10;and big master data set. It doesn't require master and slave data to be sorted" guiVersion="1.6" licenseType="Unlicensed clover.GUI" modified="Fri Feb 16 11:50:49 CET 2007" name="Testing Hash Joiner" revision="1.0">
 <Global>
 <Metadata fileURL="metadata/employees.fmt" id="InMetadata2"/>
 <Metadata fileURL="metadata/joinedOrders.fmt" id="OutMetadata"/>
@@ -15,7 +15,7 @@
 $OrderID := $OrderID;
 $CustomerID := $CustomerID;
 $EmployeeID := $EmployeeID;
-$EmployeeID2 := $1.EmployeeID;
+$EmployeeID2 := num2str($1.EmployeeID);
 $LastName := concat($1.LastName,":",$1.FirstName);
 }
 </attr>

Modified: trunk/cloveretl.engine/examples/graphJoinMergeInline.grf
===================================================================
--- trunk/cloveretl.engine/examples/graphJoinMergeInline.grf	2007-02-16 13:20:38 UTC (rev 2479)
+++ trunk/cloveretl.engine/examples/graphJoinMergeInline.grf	2007-02-16 15:22:40 UTC (rev 2480)
@@ -13,7 +13,7 @@
 <Node enabled="enabled" guiHeight="0" guiName="Ext Sort" guiWidth="0" guiX="275" guiY="83" id="EXT_SORT0" sortKey="EmployeeID" type="EXT_SORT"/>
 <Node enabled="enabled" guiHeight="0" guiName="Ext Sort" guiWidth="0" guiX="275" guiY="190" id="EXT_SORT1" sortKey="EmployeeID" type="EXT_SORT"/>
 <Node enabled="enabled" guiHeight="0" guiName="Ext Sort" guiWidth="0" guiX="275" guiY="276" id="EXT_SORT2" sortKey="ReportsTo" type="EXT_SORT"/>
-<Node enabled="enabled" guiHeight="0" guiName="Ext Merge Join" guiWidth="0" guiX="480" guiY="190" id="MERGE_JOIN1" joinKey="EmployeeID=EmployeeID#EmployeeID=ReportsTo" type="MERGE_JOIN">
+<Node enabled="enabled" guiHeight="0" guiName="Ext Merge Join" guiWidth="0" guiX="480" guiY="190" id="MERGE_JOIN1" joinKey="EmployeeID=EmployeeID#EmployeeID=ReportsTo" type="EXT_MERGE_JOIN">
 <attr name="transform">
 import org.jetel.component.DataRecordTransform;
 import org.jetel.data.*;

Modified: trunk/cloveretl.engine/examples/graphParametrizedLookup.grf
===================================================================
--- trunk/cloveretl.engine/examples/graphParametrizedLookup.grf	2007-02-16 13:20:38 UTC (rev 2479)
+++ trunk/cloveretl.engine/examples/graphParametrizedLookup.grf	2007-02-16 15:22:40 UTC (rev 2480)
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<Graph created="Fri Jan 12 15:46:21 CET 2007" description="This graph demonstrates usage of Node-level parameters" guiVersion="1.5" licenseType="Evaluation license" modified="Fri Jan 12 16:33:07 CET 2007" name="Testing Simple Lookup with parameters" revision="1.0">
+<Graph created="Fri Jan 12 15:46:21 CET 2007" description="This graph demonstrates usage of Node-level parameters" guiVersion="1.6" licenseType="Unlicensed clover.GUI" modified="Fri Feb 16 14:05:16 CET 2007" name="Testing Simple Lookup with parameters" revision="1.2">
 <Global>
 <Metadata fileURL="metadata/employees.fmt" id="InMetadata2"/>
 <Metadata fileURL="metadata/joinedOrders.fmt" id="OutMetadata"/>
@@ -58,7 +58,7 @@
 		target[0].getField(0).setValue(source[0].getField(0).getValue());&#13;
   		target[0].getField(1).setValue(source[0].getField(1).getValue());&#13;
 		target[0].getField(2).setValue(source[0].getField(2).getValue());&#13;
-		target[0].getField(3).setValue(employee.getField(0).getValue());&#13;
+		target[0].getField(3).setValue(employee.getField(0).getValue().toString());&#13;
 		target[0].getField(4).setValue(employee.getField(1).getValue());&#13;
 &#13;
 		return true;&#13;

Modified: trunk/cloveretl.engine/examples/metadata/employees.fmt
===================================================================
--- trunk/cloveretl.engine/examples/metadata/employees.fmt	2007-02-16 13:20:38 UTC (rev 2479)
+++ trunk/cloveretl.engine/examples/metadata/employees.fmt	2007-02-16 15:22:40 UTC (rev 2480)
@@ -16,5 +16,5 @@
 <Field delimiter=";" name="Extension" nullable="true" shift="0" type="string"/>
 <Field delimiter=";" name="Photo" nullable="true" shift="0" type="string"/>
 <Field delimiter=";" name="Memo" nullable="true" shift="0" type="string"/>
-<Field delimiter="\r\n" name="ReportsTo" nullable="true" shift="0" type="integer"/>
+<Field delimiter="\n" name="ReportsTo" nullable="true" shift="0" type="integer"/>
 </Record>

Modified: trunk/cloveretl.engine/examples/reformatJoinTest.java
===================================================================
--- trunk/cloveretl.engine/examples/reformatJoinTest.java	2007-02-16 13:20:38 UTC (rev 2479)
+++ trunk/cloveretl.engine/examples/reformatJoinTest.java	2007-02-16 15:22:40 UTC (rev 2480)
@@ -33,11 +33,11 @@
 		target[0].getField(1).setValue(source[0].getField(1).getValue());
 		System.out.print("|");
 		System.out.print(source[0].getField(2).toString());
-		target[0].getField(2).setValue(source[0].getField(2).getValue());
+		target[0].getField(2).setValue(source[0].getField(2).getValue().toString());
 		if (source[1]!=null){
 			System.out.print("|");
 			System.out.print(source[1].getField(0).toString());
-			target[0].getField(3).setValue(source[1].getField(0).getValue());
+			target[0].getField(3).setValue(source[1].getField(0).getValue().toString());
 			System.out.print("|");
 			System.out.print(source[1].getField(1).toString());
 			target[0].getField(4).setValue(source[1].getField(1).getValue());



From cloveretl-svn-commits at lists.berlios.de  Fri Feb 16 17:02:00 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Fri, 16 Feb 2007 17:02:00 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2481 -
	trunk/cloveretl.engine/src/org/jetel/metadata
Message-ID: <200702161602.l1GG20Mv011777@sheep.berlios.de>

Author: jausperger
Date: 2007-02-16 17:01:59 +0100 (Fri, 16 Feb 2007)
New Revision: 2481

Modified:
   trunk/cloveretl.engine/src/org/jetel/metadata/DataRecordMetadataXMLReaderWriter.java
   trunk/cloveretl.engine/src/org/jetel/metadata/XsdMetadata.java
Log:
UPDATE: metadata can read directly from graph, (and fix xs to xsd)

Modified: trunk/cloveretl.engine/src/org/jetel/metadata/DataRecordMetadataXMLReaderWriter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/metadata/DataRecordMetadataXMLReaderWriter.java	2007-02-16 15:22:40 UTC (rev 2480)
+++ trunk/cloveretl.engine/src/org/jetel/metadata/DataRecordMetadataXMLReaderWriter.java	2007-02-16 16:01:59 UTC (rev 2481)
@@ -140,6 +140,8 @@
 
 	//private static boolean setSchemaSupport = true;
 	//private static boolean setSchemaFullSupport = false;
+	private static final String METADATA_ELEMENT = "Metadata";
+	private static final String ID = "id";
 	private static final String RECORD_ELEMENT = "Record";
 	private static final String FIELD_ELEMENT = "Field";
 	private static final String CODE_ELEMENT = "Code";
@@ -203,6 +205,10 @@
 	 * @since May 6, 2002
 	 */
 	public DataRecordMetadata read(InputStream in) {
+		return read(in, null);
+	}
+	
+	public DataRecordMetadata read(InputStream in, String metadataId) {
 		Document document;
 
 		try {
@@ -238,7 +244,7 @@
 		}
 
 		try {
-			return parseRecordMetadata(document);
+			return parseRecordMetadata(document, metadataId);
 		} catch (DOMException ex) {
 			logger.fatal(ex.getMessage());
 			return null;
@@ -380,16 +386,32 @@
 
 	public DataRecordMetadata parseRecordMetadata(Document document)
 			throws DOMException {
+		return parseRecordMetadata(document, null);
+	}
+
+	public DataRecordMetadata parseRecordMetadata(Document document, String metadataId) throws DOMException {
 		org.w3c.dom.NodeList nodes;
-		nodes = document.getElementsByTagName(RECORD_ELEMENT);
-		if (nodes.getLength() == 0) {
-			throw new DOMException(DOMException.NOT_FOUND_ERR,
-					"No Record element has been found ! ");
+		if (metadataId != null) {
+			nodes = document.getElementsByTagName(METADATA_ELEMENT);
+			int lenght = nodes.getLength();
+			org.w3c.dom.Node node = null;
+			for (int i=0; i<lenght; i++) {
+				node = nodes.item(i);
+				if (node.getAttributes().getNamedItem(ID).getNodeValue().equals(metadataId)) {
+					return parseRecordMetadata(node.getChildNodes().item(1));
+				}
+			}
+			return null;
+		} else {
+			nodes = document.getElementsByTagName(RECORD_ELEMENT);
+			if (nodes.getLength() == 0) {
+				throw new DOMException(DOMException.NOT_FOUND_ERR,
+						"No Record element has been found ! ");
+			}
+			return parseRecordMetadata(nodes.item(0));
 		}
-
-		return parseRecordMetadata(nodes.item(0));
 	}
-
+	
 	public DataRecordMetadata parseRecordMetadata(org.w3c.dom.Node topNode)
 			throws DOMException {
 

Modified: trunk/cloveretl.engine/src/org/jetel/metadata/XsdMetadata.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/metadata/XsdMetadata.java	2007-02-16 15:22:40 UTC (rev 2480)
+++ trunk/cloveretl.engine/src/org/jetel/metadata/XsdMetadata.java	2007-02-16 16:01:59 UTC (rev 2481)
@@ -33,6 +33,12 @@
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
 
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.commons.cli.ParseException;
+import org.apache.commons.cli.PosixParser;
+import org.jetel.data.Defaults;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.NodeList;
@@ -143,7 +149,7 @@
 	private static Document createXsdDocument() throws ParserConfigurationException {
 		Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
 		Element preamble = doc.createElement("xsd:schema");
-		preamble.setAttribute("xmlns:xs", XMLSCHEMA);
+		preamble.setAttribute("xmlns:xsd", XMLSCHEMA);
 		if (NAMESPACE != null) {
 			preamble.setAttribute("targetNamespace", NAMESPACE);
 			preamble.setAttribute("xmlns", NAMESPACE);
@@ -257,27 +263,55 @@
 
 	/**
 	 * Converts clover metadata read from XML file to XSD written to file.
+	 * XML file can be metadata file or graph file. If XML file is graph, 
+	 * then you define metadata_id.
 	 * 
-	 * usage: XsdMetadata [infile] [outfile]
+	 * usage: XsdMetadata [--metadata_id id] [infile] [outfile]
 	 * @param argv {input_file, output_file}. "-" for std input/output
 	 */
 	public static void main(String argv[]) {
+		String metadataId = null;
+		
         try {
         	InputStream input;
-        	if (argv.length < 1 || argv[0].equals("-")) {
-        		input = System.in;
-        	} else {
-        		input = new FileInputStream(argv[0]);
-        	}
         	OutputStream output;
-        	if (argv.length < 2 || argv[1].equals("-")) {
-        		output = System.out;
-        	} else {
-        		output = new FileOutputStream(argv[1]);
-        	}
+       	
+    		Options options = new Options();
+        	options.addOption(new Option("m", "metadata_id", true, "Methadata id in graph file"));
+        	options.addOption(new Option("i", "in_file", true, "Input file"));
+        	options.addOption(new Option("o", "out_file", true, "Output file"));
         	
+        	PosixParser optParser = new PosixParser();
+        	CommandLine cmdLine;
+    		try {
+    			cmdLine = optParser.parse(options, argv);
+    		} catch (ParseException e) {
+    			e.printStackTrace();
+    			return;
+    		}
+    		
+    		if (cmdLine.hasOption("m")) {
+    			metadataId = cmdLine.getOptionValue("m");
+    		}
+    		if (cmdLine.hasOption("i")) {
+        		input = new FileInputStream(cmdLine.getOptionValue("i"));
+    		} else {
+    			input = System.in;
+    		}
+    		if (cmdLine.hasOption("o")) {
+        		output = new FileOutputStream(cmdLine.getOptionValue("o"));
+    		} else {
+    			output = System.out;
+    		}
+
+			Defaults.init();
+    		
             DataRecordMetadataXMLReaderWriter xmlReader = new DataRecordMetadataXMLReaderWriter();
-			DataRecordMetadata metadata = xmlReader.read(new BufferedInputStream(input));
+            DataRecordMetadata metadata;
+            if (metadataId == null)
+            	metadata = xmlReader.read(new BufferedInputStream(input));
+            else 
+            	metadata = xmlReader.read(new BufferedInputStream(input), metadataId);
 			(new XsdMetadata(metadata)).write(output);
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();



From cloveretl-svn-commits at lists.berlios.de  Mon Feb 19 09:29:26 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Mon, 19 Feb 2007 09:29:26 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2482 -
	trunk/cloveretl.component/src/org/jetel/component
Message-ID: <200702190829.l1J8TQP2006143@sheep.berlios.de>

Author: agad
Date: 2007-02-19 09:29:26 +0100 (Mon, 19 Feb 2007)
New Revision: 2482

Modified:
   trunk/cloveretl.component/src/org/jetel/component/DataGenerator.java
Log:
UPDATE:DataGenerator - string set as constant

Modified: trunk/cloveretl.component/src/org/jetel/component/DataGenerator.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DataGenerator.java	2007-02-16 16:01:59 UTC (rev 2481)
+++ trunk/cloveretl.component/src/org/jetel/component/DataGenerator.java	2007-02-19 08:29:26 UTC (rev 2482)
@@ -138,11 +138,13 @@
 
 	/** XML attribute names */
 	private static final String XML_PATTERN_ATTRIBUTE = "pattern";
-	private static final String XML_RANDOM_FIELDS_ATTRIBUTE = "randomFields";
+	public static final String XML_RANDOM_FIELDS_ATTRIBUTE = "randomFields";
 	private static final String XML_RANDOM_SEED_ATTRIBUTE = "randomSeed";
-	private static final String XML_SEQUENCE_FIELDS_ATTRIBUTE = "sequenceFields";
+	public static final String XML_SEQUENCE_FIELDS_ATTRIBUTE = "sequenceFields";
 	private static final String XML_RECORDS_NUMBER_ATTRIBUTE = "recordsNumber"; 
 	
+	public final static String EQUAL_CHAR = "=";
+	
 	private final int MIN = 0;
 	private final int MAX = 1;
 	private final int MULTIPLIER = 2; 
@@ -532,8 +534,9 @@
 		if (randomFields != null){
 			StringBuilder fields = new StringBuilder();
 			for (int i=0;i<randomFields.length;i++){
+				fields.append(EQUAL_CHAR);
 				fields.append(randomFields[i]);
-				fields.append("=random(");
+				fields.append("random(");
 				fields.append(randomRanges[i][MIN]);
 				fields.append(',');
 				fields.append(randomRanges[i][MAX]);
@@ -547,7 +550,7 @@
 			StringBuilder fields = new StringBuilder();
 			for (int i=0;i<sequenceFields.length;i++){
 				fields.append(sequenceFields[i]);
-				fields.append("=");
+				fields.append(EQUAL_CHAR);
 				if (sequenceIDs[i] != null) {
 					fields.append(sequenceIDs[i]);
 				}				
@@ -580,7 +583,7 @@
 		int commaIndex;
 		int rightParantesisIndex;
 		for (int i = 0; i < fields.length; i++) {
-			param = fields[i].split("=");
+			param = fields[i].split(EQUAL_CHAR);
 			this.randomFields[i] = param[0].trim();
 			if (param.length > 1){
 				leftParenthesisIndex = param[1].indexOf('('); 



From cloveretl-svn-commits at lists.berlios.de  Mon Feb 19 09:30:45 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Mon, 19 Feb 2007 09:30:45 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2483 -
	trunk/cloveretl.component/src/org/jetel/component
Message-ID: <200702190830.l1J8UjCq006298@sheep.berlios.de>

Author: agad
Date: 2007-02-19 09:30:44 +0100 (Mon, 19 Feb 2007)
New Revision: 2483

Modified:
   trunk/cloveretl.component/src/org/jetel/component/CloverDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java
   trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java
   trunk/cloveretl.component/src/org/jetel/component/Trash.java
Log:
UPDATE:writers - method chackConfig better handles exceptions

Modified: trunk/cloveretl.component/src/org/jetel/component/CloverDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/CloverDataWriter.java	2007-02-19 08:29:26 UTC (rev 2482)
+++ trunk/cloveretl.component/src/org/jetel/component/CloverDataWriter.java	2007-02-19 08:30:44 UTC (rev 2483)
@@ -46,7 +46,6 @@
 import org.jetel.util.ByteBufferUtils;
 import org.jetel.util.ComponentXMLAttributes;
 import org.jetel.util.FileUtils;
-import org.jetel.util.StringUtils;
 import org.jetel.util.SynchronizeUtils;
 import org.w3c.dom.Element;
 
@@ -213,20 +212,11 @@
         checkOutputPorts(status, 0, 0);
 
         try {
-        	if (!FileUtils.canWrite(
-        			getGraph() != null ? getGraph().getProjectURL() : null, fileURL)){
-        		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + fileURL);
-        		ex.setAttributeName(XML_FILEURL_ATTRIBUTE);
-        		throw ex;
-        	}
-//            init();
-//            free();
+        	FileUtils.canWrite(getGraph() != null ? getGraph().getProjectURL() 
+        			: null, fileURL);
         } catch (ComponentNotReadyException e) {
-            ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
-            if(!StringUtils.isEmpty(e.getAttributeName())) {
-                problem.setAttributeName(e.getAttributeName());
-            }
-            status.add(problem);
+            status.add(e,ConfigurationStatus.Severity.ERROR,this,
+            		ConfigurationStatus.Priority.NORMAL,XML_FILEURL_ATTRIBUTE);
         }
         
         return status;

Modified: trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-19 08:29:26 UTC (rev 2482)
+++ trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-19 08:30:44 UTC (rev 2483)
@@ -39,7 +39,6 @@
 import org.jetel.util.ComponentXMLAttributes;
 import org.jetel.util.FileUtils;
 import org.jetel.util.MultiFileWriter;
-import org.jetel.util.StringUtils;
 import org.jetel.util.SynchronizeUtils;
 import org.w3c.dom.Element;
 
@@ -267,25 +266,15 @@
         checkOutputPorts(status, 0, 0);
 
         try {
-        	if (fileURL != null) {
-        		if (!FileUtils.canWrite(getGraph() != null ? getGraph().getProjectURL() 
-        				: null, fileURL)){
-	        		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + fileURL);
-	        		ex.setAttributeName(XML_FILEURL_ATTRIBUTE);
-	        		throw ex;
-        		}
-        	}
-//            init();
-//            free();
+        	FileUtils.canWrite(getGraph() != null ? getGraph().getProjectURL() 
+        			: null, fileURL);
         } catch (ComponentNotReadyException e) {
-            ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
-            if(!StringUtils.isEmpty(e.getAttributeName())) {
-                problem.setAttributeName(e.getAttributeName());
-            }
-            status.add(problem);
+            status.add(e,ConfigurationStatus.Severity.ERROR,this,
+            		ConfigurationStatus.Priority.NORMAL,XML_FILEURL_ATTRIBUTE);
         }
         
         return status;
+        
     }
 	
 	public String getType(){

Modified: trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-19 08:29:26 UTC (rev 2482)
+++ trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-19 08:30:44 UTC (rev 2483)
@@ -184,20 +184,11 @@
         checkOutputPorts(status, 0, 0);
 
         try {
-        	if (!FileUtils.canWrite(
-        			getGraph() != null ? getGraph().getProjectURL() : null, fileURL)){
-        		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + fileURL);
-        		ex.setAttributeName(XML_FILEURL_ATTRIBUTE);
-        		throw ex;
-        	}
-//            init();
-//            free();
+        	FileUtils.canWrite(getGraph() != null ? getGraph().getProjectURL() 
+        			: null, fileURL);
         } catch (ComponentNotReadyException e) {
-            ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
-            if(!StringUtils.isEmpty(e.getAttributeName())) {
-                problem.setAttributeName(e.getAttributeName());
-            }
-            status.add(problem);
+            status.add(e,ConfigurationStatus.Severity.ERROR,this,
+            		ConfigurationStatus.Priority.NORMAL,XML_FILEURL_ATTRIBUTE);
         }
         
         return status;

Modified: trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-19 08:29:26 UTC (rev 2482)
+++ trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-19 08:30:44 UTC (rev 2483)
@@ -34,7 +34,6 @@
 import org.jetel.util.ComponentXMLAttributes;
 import org.jetel.util.FileUtils;
 import org.jetel.util.MultiFileWriter;
-import org.jetel.util.StringUtils;
 import org.w3c.dom.Element;
 
 /**
@@ -265,20 +264,11 @@
         checkOutputPorts(status, 0, 0);
 
         try {
-        	if (!FileUtils.canWrite(
-        			getGraph() != null ? getGraph().getProjectURL() : null, fileURL)){
-        		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + fileURL);
-        		ex.setAttributeName(XML_FILEURL_ATTRIBUTE);
-        		throw ex;
-        	}
-//            init();
-//            free();
+        	FileUtils.canWrite(getGraph() != null ? getGraph().getProjectURL() 
+        			: null, fileURL);
         } catch (ComponentNotReadyException e) {
-            ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
-            if(!StringUtils.isEmpty(e.getAttributeName())) {
-                problem.setAttributeName(e.getAttributeName());
-            }
-            status.add(problem);
+            status.add(e,ConfigurationStatus.Severity.ERROR,this,
+            		ConfigurationStatus.Priority.NORMAL,XML_FILEURL_ATTRIBUTE);
         }
         
         return status;

Modified: trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-19 08:29:26 UTC (rev 2482)
+++ trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-19 08:30:44 UTC (rev 2483)
@@ -215,20 +215,11 @@
         checkOutputPorts(status, 0, 0);
 
         try {
-        	if (!FileUtils.canWrite(
-        			getGraph() != null ? getGraph().getProjectURL() : null, fileURL)){
-        		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + fileURL);
-        		ex.setAttributeName(XML_FILEURL_ATTRIBUTE);
-        		throw ex;
-        	}
-//            init();
-//            free();
+        	FileUtils.canWrite(getGraph() != null ? getGraph().getProjectURL() 
+        			: null, fileURL);
         } catch (ComponentNotReadyException e) {
-            ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
-            if(!StringUtils.isEmpty(e.getAttributeName())) {
-                problem.setAttributeName(e.getAttributeName());
-            }
-            status.add(problem);
+            status.add(e,ConfigurationStatus.Severity.ERROR,this,
+            		ConfigurationStatus.Priority.NORMAL,XML_FILEURL_ATTRIBUTE);
         }
         
         return status;

Modified: trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java	2007-02-19 08:29:26 UTC (rev 2482)
+++ trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java	2007-02-19 08:30:44 UTC (rev 2483)
@@ -181,20 +181,11 @@
         checkOutputPorts(status, 0, 0);
 
         try {
-        	if (fileURL != null && !FileUtils.canWrite(
-        			getGraph() != null ? getGraph().getProjectURL() : null, fileURL)){
-        		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + fileURL);
-        		ex.setAttributeName(XML_FILEURL_ATTRIBUTE);
-        		throw ex;
-        	}
-//            init();
-//            free();
+        	FileUtils.canWrite(getGraph() != null ? getGraph().getProjectURL() 
+        			: null, fileURL);
         } catch (ComponentNotReadyException e) {
-            ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
-            if(!StringUtils.isEmpty(e.getAttributeName())) {
-                problem.setAttributeName(e.getAttributeName());
-            }
-            status.add(problem);
+            status.add(e,ConfigurationStatus.Severity.ERROR,this,
+            		ConfigurationStatus.Priority.NORMAL,XML_FILEURL_ATTRIBUTE);
         }
         
         return status;

Modified: trunk/cloveretl.component/src/org/jetel/component/Trash.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/Trash.java	2007-02-19 08:29:26 UTC (rev 2482)
+++ trunk/cloveretl.component/src/org/jetel/component/Trash.java	2007-02-19 08:30:44 UTC (rev 2483)
@@ -27,7 +27,6 @@
 import org.jetel.data.DataRecord;
 import org.jetel.data.Defaults;
 import org.jetel.exception.ComponentNotReadyException;
-import org.jetel.exception.ConfigurationProblem;
 import org.jetel.exception.ConfigurationStatus;
 import org.jetel.exception.JetelException;
 import org.jetel.exception.XMLConfigurationException;
@@ -37,7 +36,6 @@
 import org.jetel.graph.TransformationGraph;
 import org.jetel.util.ComponentXMLAttributes;
 import org.jetel.util.FileUtils;
-import org.jetel.util.StringUtils;
 import org.jetel.util.SynchronizeUtils;
 import org.w3c.dom.Element;
 
@@ -253,33 +251,25 @@
     		checkInputPorts(status, 1, 1);
             checkOutputPorts(status, 0, 0);
 
-            try {
-        		recordBuffer = ByteBuffer.allocateDirect(Defaults.Record.MAX_RECORD_SIZE);
-        		if (recordBuffer == null) {
-        			throw new ComponentNotReadyException("Can NOT allocate internal record buffer ! Required size:" +
-        					Defaults.Record.MAX_RECORD_SIZE);
-        		}
-        		recordBuffer = null;
-        		if (debugPrint) {
-                    if(debugFilename != null && !FileUtils.canWrite(
-                    		getGraph() != null ? getGraph().getProjectURL() : null, 
-                    				debugFilename)) {
-                		ComponentNotReadyException ex = new ComponentNotReadyException(this,"Can't write to file: " + debugFilename);
-                		ex.setAttributeName(XML_DEBUGFILENAME_ATTRIBUTE);
-                		throw ex;
-                    }
-                 }
-//                init();
-//                free();
-            } catch (ComponentNotReadyException e) {
-                ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
-                if(!StringUtils.isEmpty(e.getAttributeName())) {
-                    problem.setAttributeName(e.getAttributeName());
-                }
-                status.add(problem);
-            }
+    		recordBuffer = ByteBuffer.allocateDirect(Defaults.Record.MAX_RECORD_SIZE);
+    		if (recordBuffer == null) {
+                status.add("Can NOT allocate internal record buffer ! Required size:" + Defaults.Record.MAX_RECORD_SIZE, 
+                		ConfigurationStatus.Severity.ERROR, this, 
+                		ConfigurationStatus.Priority.NORMAL);
+    		}
+    		recordBuffer = null;
+
+    		if (debugPrint && debugFilename != null) {
+                try {
+                	FileUtils.canWrite(getGraph() != null ? 
+                			getGraph().getProjectURL() : null, debugFilename);
+                } catch (ComponentNotReadyException e) {
+	                status.add(e, ConfigurationStatus.Severity.ERROR, this, 
+	                		ConfigurationStatus.Priority.NORMAL, XML_DEBUGFILENAME_ATTRIBUTE);
+				}
+    		}
             
-            return status;
+    		return status;
         }
 	
 	public String getType(){



From cloveretl-svn-commits at lists.berlios.de  Mon Feb 19 09:31:32 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Mon, 19 Feb 2007 09:31:32 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2484 -
	trunk/cloveretl.engine/src/org/jetel/exception
Message-ID: <200702190831.l1J8VWSQ006376@sheep.berlios.de>

Author: agad
Date: 2007-02-19 09:31:31 +0100 (Mon, 19 Feb 2007)
New Revision: 2484

Modified:
   trunk/cloveretl.engine/src/org/jetel/exception/ConfigurationProblem.java
   trunk/cloveretl.engine/src/org/jetel/exception/ConfigurationStatus.java
Log:
UPDATE:writers - method chackConfig better handles exceptions

Modified: trunk/cloveretl.engine/src/org/jetel/exception/ConfigurationProblem.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/exception/ConfigurationProblem.java	2007-02-19 08:30:44 UTC (rev 2483)
+++ trunk/cloveretl.engine/src/org/jetel/exception/ConfigurationProblem.java	2007-02-19 08:31:31 UTC (rev 2484)
@@ -23,6 +23,7 @@
 import org.jetel.exception.ConfigurationStatus.Priority;
 import org.jetel.exception.ConfigurationStatus.Severity;
 import org.jetel.graph.GraphElement;
+import org.jetel.util.StringUtils;
 
 /**
  * Instances of this class are collected in ConfigurationStatus, which is return value of
@@ -45,13 +46,26 @@
     
     private String attributeName;
     
-    public ConfigurationProblem(String message, Severity severity, GraphElement graphElement, Priority priority) {
+    public ConfigurationProblem(String message, Severity severity, GraphElement graphElement, Priority priority, String attributeName) {
         this.message = message;
         this.severity = severity;
         this.graphElement = graphElement;
         this.priority = priority;
+        this.attributeName = attributeName;
     }
+    
+    public ConfigurationProblem(String message, Severity severity, GraphElement graphElement, Priority priority) {
+    	this(message, severity, graphElement, priority, null);
+    }
 
+    public ConfigurationProblem(ComponentNotReadyException e, Severity severity, GraphElement graphElement, Priority priority, String attributeName) {
+        this(e.getMessage(), severity, graphElement, priority, attributeName);
+        
+        if(!StringUtils.isEmpty(e.getAttributeName()) && StringUtils.isEmpty(attributeName)) {
+            setAttributeName(e.getAttributeName());
+        }
+    }
+
     public void log(Log logger) {
         switch(severity) {
         case INFO:

Modified: trunk/cloveretl.engine/src/org/jetel/exception/ConfigurationStatus.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/exception/ConfigurationStatus.java	2007-02-19 08:30:44 UTC (rev 2483)
+++ trunk/cloveretl.engine/src/org/jetel/exception/ConfigurationStatus.java	2007-02-19 08:31:31 UTC (rev 2484)
@@ -23,6 +23,7 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.jetel.graph.GraphElement;
 
 /**
  * This class is return value of all checkConfig() methods in the engine.
@@ -49,4 +50,18 @@
             problem.log(logger);
         }
     }
+    
+    public void add(String message, Severity severity, GraphElement graphElement, Priority priority, String attributeName) {
+    	add(new ConfigurationProblem(message, severity, graphElement, priority, attributeName));
+    }
+
+    public void add(ComponentNotReadyException e, Severity severity, GraphElement graphElement, Priority priority, String attributeName) {
+    	add(new ConfigurationProblem(e, severity, graphElement, priority, attributeName));
+    }
+
+    public void add(String message, Severity severity, GraphElement graphElement, Priority priority) {
+    	this.add(message, severity, graphElement, priority, null);
+    }
+
+    
 }



From cloveretl-svn-commits at lists.berlios.de  Mon Feb 19 09:33:19 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Mon, 19 Feb 2007 09:33:19 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2485 -
	trunk/cloveretl.engine/src/org/jetel/util
Message-ID: <200702190833.l1J8XJLM006776@sheep.berlios.de>

Author: agad
Date: 2007-02-19 09:33:19 +0100 (Mon, 19 Feb 2007)
New Revision: 2485

Modified:
   trunk/cloveretl.engine/src/org/jetel/util/FileUtils.java
Log:
UPDATE:writers - method chackConfig better handles exceptions

Modified: trunk/cloveretl.engine/src/org/jetel/util/FileUtils.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/FileUtils.java	2007-02-19 08:31:31 UTC (rev 2484)
+++ trunk/cloveretl.engine/src/org/jetel/util/FileUtils.java	2007-02-19 08:33:19 UTC (rev 2485)
@@ -296,7 +296,7 @@
 			}
 		}
 		if (!tmp) {
-			return false;
+			throw new ComponentNotReadyException("Can't write to: " + uri);
 		}
 		return true;
 	}



From cloveretl-svn-commits at lists.berlios.de  Mon Feb 19 14:10:52 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Mon, 19 Feb 2007 14:10:52 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2486 -
	trunk/cloveretl.component/src/org/jetel/component
Message-ID: <200702191310.l1JDAq3a005024@sheep.berlios.de>

Author: agad
Date: 2007-02-19 14:10:51 +0100 (Mon, 19 Feb 2007)
New Revision: 2486

Modified:
   trunk/cloveretl.component/src/org/jetel/component/DBInputTable.java
Log:
BUGFIX:DBInputTable - fixed error handling: when BadDataFormatException catched and dataPolicy is strict reading data continues

Modified: trunk/cloveretl.component/src/org/jetel/component/DBInputTable.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DBInputTable.java	2007-02-19 08:33:19 UTC (rev 2485)
+++ trunk/cloveretl.component/src/org/jetel/component/DBInputTable.java	2007-02-19 13:10:51 UTC (rev 2486)
@@ -175,17 +175,19 @@
 			parser.initSQLDataMap(record);
 
 			// till it reaches end of data or it is stopped from outside
-			try {
-				while (((record = parser.getNext(record)) != null) && runIt) {
-					//broadcast the record to all connected Edges
-					writeRecordBroadcast(record);
+			while (record != null && runIt){
+				try{
+					record = parser.getNext();
+					if (record != null) {
+						writeRecordBroadcast(record);
+					}
+				}catch(BadDataFormatException bdfe){
+			        if(policyType == PolicyType.STRICT) {
+			            throw bdfe;
+			        } else {
+			            logger.info(bdfe.getMessage());
+			        }
 				}
-			} catch (BadDataFormatException bdfe) {
-		        if(policyType == PolicyType.STRICT) {
-		            throw bdfe;
-		        } else {
-		            logger.info(bdfe.getMessage());
-		        }
 			}
 		} catch (Exception e) {
 			throw e;



From cloveretl-svn-commits at lists.berlios.de  Mon Feb 19 15:47:02 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Mon, 19 Feb 2007 15:47:02 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2487 -
	trunk/cloveretl.engine/src/org/jetel/metadata
Message-ID: <200702191447.l1JEl2NU013562@sheep.berlios.de>

Author: otasanek
Date: 2007-02-19 15:47:01 +0100 (Mon, 19 Feb 2007)
New Revision: 2487

Modified:
   trunk/cloveretl.engine/src/org/jetel/metadata/XsdMetadata.java
Log:
FIX: better error handling.

Modified: trunk/cloveretl.engine/src/org/jetel/metadata/XsdMetadata.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/metadata/XsdMetadata.java	2007-02-19 13:10:51 UTC (rev 2486)
+++ trunk/cloveretl.engine/src/org/jetel/metadata/XsdMetadata.java	2007-02-19 14:47:01 UTC (rev 2487)
@@ -312,6 +312,11 @@
             	metadata = xmlReader.read(new BufferedInputStream(input));
             else 
             	metadata = xmlReader.read(new BufferedInputStream(input), metadataId);
+            
+            if(metadata == null) {
+                System.err.println("Metadata doesn't exist." + (metadataId != null ? " (" + metadataId + ")" : ""));
+                return;
+            }
 			(new XsdMetadata(metadata)).write(output);
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();



From cloveretl-svn-commits at lists.berlios.de  Mon Feb 19 16:42:26 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Mon, 19 Feb 2007 16:42:26 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2488 - in
	branches/cloveretl.engine.rel-2-1-0: cloveretl.component
	cloveretl.component/src/org/jetel/component cloveretl.engine
	cloveretl.engine/lib cloveretl.engine/plugins/org.jetel.component
	cloveretl.engine/src/org/jetel/interpreter
	cloveretl.engine/src/org/jetel/metadata
	cloveretl.engine/src/org/jetel/util
	cloveretl.sequence/src/org/jetel/sequence
Message-ID: <200702191542.l1JFgQBr018169@sheep.berlios.de>

Author: otasanek
Date: 2007-02-19 16:42:18 +0100 (Mon, 19 Feb 2007)
New Revision: 2488

Added:
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/lib/commons-cli-1.0.jar
Modified:
   branches/cloveretl.engine.rel-2-1-0/cloveretl.component/plugin.xml
   branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/JmsWriter.java
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/build.xml
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/plugins/org.jetel.component/plugin.xml
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/interpreter/TransformLangExecutor.java
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/metadata/DataRecordMetadataXMLReaderWriter.java
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/metadata/XsdMetadata.java
   branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/util/FileUtils.java
   branches/cloveretl.engine.rel-2-1-0/cloveretl.sequence/src/org/jetel/sequence/SimpleSequence.java
Log:
UPDATE: changes dedicated to be merged with trunk!

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.component/plugin.xml
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.component/plugin.xml	2007-02-19 14:47:01 UTC (rev 2487)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.component/plugin.xml	2007-02-19 15:42:18 UTC (rev 2488)
@@ -94,6 +94,11 @@
 
 	<extension point-id="component">
 	    <parameter id="className" value="org.jetel.component.MergeJoin"/>
+	    <parameter id="type" value="EXT_MERGE_JOIN"/>
+	</extension>
+
+	<extension point-id="component">
+	    <parameter id="className" value="org.jetel.component.MergeJoin"/>
 	    <parameter id="type" value="SORTED_JOIN"/>
 	</extension>
 
@@ -113,6 +118,11 @@
 	</extension>
 
 	<extension point-id="component">
+	    <parameter id="className" value="org.jetel.component.HashJoin"/>
+	    <parameter id="type" value="EXT_HASH_JOIN"/>
+	</extension>
+
+	<extension point-id="component">
 	    <parameter id="className" value="org.jetel.component.CheckForeignKey"/>
 	    <parameter id="type" value="CHECK_FOREIGN_KEY"/>
 	</extension>

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/JmsWriter.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/JmsWriter.java	2007-02-19 14:47:01 UTC (rev 2487)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.component/src/org/jetel/component/JmsWriter.java	2007-02-19 15:42:18 UTC (rev 2488)
@@ -33,6 +33,7 @@
 import org.jetel.data.DataRecord;
 import org.jetel.database.IConnection;
 import org.jetel.exception.ComponentNotReadyException;
+import org.jetel.exception.ConfigurationProblem;
 import org.jetel.exception.ConfigurationStatus;
 import org.jetel.exception.JetelException;
 import org.jetel.exception.XMLConfigurationException;
@@ -42,6 +43,7 @@
 import org.jetel.graph.TransformationGraph;
 import org.jetel.util.ComponentXMLAttributes;
 import org.jetel.util.DynamicJavaCode;
+import org.jetel.util.StringUtils;
 import org.w3c.dom.Element;
 
 

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/build.xml
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/build.xml	2007-02-19 14:47:01 UTC (rev 2487)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/build.xml	2007-02-19 15:42:18 UTC (rev 2488)
@@ -117,6 +117,9 @@
 	<target name="clean" depends="checkproperties" description="Delete old compiled files">
 		<delete dir="${dir.bin}"/>
 		<delete dir="${dir.dist}"/>
+		<delete dir="${distribution.dir}"/>
+		<delete dir="${src.distribution.dir}"/>
+		<delete dir="${dir.doc}"/>
 	</target>
 
 	<!-- Target sets directory-properties unless they have been defined (in parent ant build) -->

Added: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/lib/commons-cli-1.0.jar
===================================================================
(Binary files differ)


Property changes on: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/lib/commons-cli-1.0.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/plugins/org.jetel.component/plugin.xml
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/plugins/org.jetel.component/plugin.xml	2007-02-19 14:47:01 UTC (rev 2487)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/plugins/org.jetel.component/plugin.xml	2007-02-19 15:42:18 UTC (rev 2488)
@@ -94,6 +94,11 @@
 
 	<extension point-id="component">
 	    <parameter id="className" value="org.jetel.component.MergeJoin"/>
+	    <parameter id="type" value="EXT_MERGE_JOIN"/>
+	</extension>
+
+	<extension point-id="component">
+	    <parameter id="className" value="org.jetel.component.MergeJoin"/>
 	    <parameter id="type" value="SORTED_JOIN"/>
 	</extension>
 
@@ -113,6 +118,11 @@
 	</extension>
 
 	<extension point-id="component">
+	    <parameter id="className" value="org.jetel.component.HashJoin"/>
+	    <parameter id="type" value="EXT_HASH_JOIN"/>
+	</extension>
+
+	<extension point-id="component">
 	    <parameter id="className" value="org.jetel.component.CheckForeignKey"/>
 	    <parameter id="type" value="CHECK_FOREIGN_KEY"/>
 	</extension>

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/interpreter/TransformLangExecutor.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/interpreter/TransformLangExecutor.java	2007-02-19 14:47:01 UTC (rev 2487)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/interpreter/TransformLangExecutor.java	2007-02-19 15:42:18 UTC (rev 2488)
@@ -719,7 +719,11 @@
         if (value == null) {
             stack.push(Stack.TRUE_VAL);
         } else {
-            stack.push(Stack.FALSE_VAL);
+            if (value instanceof CharSequence) {
+                stack.push( ((CharSequence)value).length()==0 ? Stack.TRUE_VAL : Stack.FALSE_VAL);
+            }else {
+                stack.push(Stack.FALSE_VAL);
+            }
         }
 
         return data;
@@ -733,7 +737,11 @@
             node.jjtGetChild(1).jjtAccept(this, data);
             // not necessary: stack.push(stack.pop());
         } else {
-            stack.push(value);
+            if ((value instanceof CharSequence) && (((CharSequence)value).length()==0)) {
+                node.jjtGetChild(1).jjtAccept(this, data);
+            }else {
+                stack.push(value);
+            }
         }
 
         return data;
@@ -1458,41 +1466,43 @@
      */
     public Object visit(CLVFVarDeclaration node, Object data) {
         // test for duplicite declaration - should have been done before
-        /*if (stack.symtab.containsKey(node.name)) {
-            throw new TransformLangExecutorRuntimeException(node,
-                    "variable already declared - \"" + node.name + "\"");
-        }*/
+        /*
+         * if (stack.symtab.containsKey(node.name)) { throw new
+         * TransformLangExecutorRuntimeException(node, "variable already
+         * declared - \"" + node.name + "\""); }
+         */
         Object value;
         // create global/local variable
         switch (node.type) {
         case INT_VAR:
-            value= new CloverInteger(0);
+            value = new CloverInteger(0);
             break;
         case LONG_VAR:
-            value= new CloverLong(0);
+            value = new CloverLong(0);
             break;
         case DOUBLE_VAR:
-            value= new CloverDouble(0);
+            value = new CloverDouble(0);
             break;
         case DECIMAL_VAR:
-            if (node.length>0){
-                if (node.precision>0){
-                    value = DecimalFactory.getDecimal(node.length,node.precision);
-                }else{
-                    value = DecimalFactory.getDecimal(node.length,0);
+            if (node.length > 0) {
+                if (node.precision > 0) {
+                    value = DecimalFactory.getDecimal(node.length,
+                            node.precision);
+                } else {
+                    value = DecimalFactory.getDecimal(node.length, 0);
                 }
-            }else{
-                value= DecimalFactory.getDecimal();
+            } else {
+                value = DecimalFactory.getDecimal();
             }
             break;
         case STRING_VAR:
-            value= new StringBuilder();
+            value = new StringBuilder();
             break;
         case DATE_VAR:
-            value=new Date();
+            value = new Date();
             break;
         case BOOLEAN_VAR:
-            value=  Stack.FALSE_VAL;
+            value = Stack.FALSE_VAL;
             break;
         default:
             throw new TransformLangExecutorRuntimeException(node,
@@ -1502,44 +1512,55 @@
 
         }
         stack.storeVar(node.localVar, node.varSlot, value);
-        
-        if (node.jjtGetNumChildren()>0){
+
+        if (node.jjtHasChildren()) {
             node.jjtGetChild(0).jjtAccept(this, data);
-            Object initValue=stack.pop();
-            
+            Object initValue = stack.pop();
             try {
-                if (value instanceof Numeric) {
-                        ((Numeric) value).setValue((Numeric) initValue);
-                } else if (value instanceof StringBuilder) {
-                    StringBuilder var = (StringBuilder) value;
-                    var.setLength(0);
-                    StringUtils.strBuffAppend(var,(CharSequence) initValue);
-                } else if (value instanceof Boolean) {
-                    stack.storeVar(node.localVar,node.varSlot, (Boolean)initValue); // boolean is not updatable - we replace the reference
-                    // stack.put(varName,((Boolean)value).booleanValue() ?
-                    // Stack.TRUE_VAL : Stack.FALSE_VAL);
-                } else if (value instanceof Date) {
+                switch (node.type) {
+                case INT_VAR:
+                case LONG_VAR:
+                case DOUBLE_VAR:
+                case DECIMAL_VAR:
+                    ((Numeric) value).setValue((Numeric) initValue);
+                    break;
+                case STRING_VAR:
+                    if (initValue != null)
+                        StringUtils.strBuffAppend((StringBuilder) value,
+                                (CharSequence) initValue);
+                    break;
+                case DATE_VAR:
                     ((Date) value).setTime(((Date) initValue).getTime());
-                } else {
-                    throw new TransformLangExecutorRuntimeException(node,
-                            "unknown variable \"" + node.name + "\"");
+                    break;
+                case BOOLEAN_VAR:
+                    stack.storeVar(node.localVar, node.varSlot,
+                            (Boolean) initValue);
+                    // boolean is not updatable - we replace the reference
+                    break;
+
                 }
+
             } catch (ClassCastException ex) {
                 throw new TransformLangExecutorRuntimeException(node,
-                        "invalid assignment of \"" + initValue + "\" to variable \""
-                                + node.name + "\" - incompatible data types");
-            } catch (NumberFormatException ex){
+                        "invalid assignment of \"" + initValue
+                                + "\" to variable \"" + node.name
+                                + "\" - incompatible data types");
+            } catch (NumberFormatException ex) {
                 throw new TransformLangExecutorRuntimeException(node,
-                        "invalid assignment of number \"" + initValue + "\" to variable \"" + node.name + "\" : "+ex.getMessage());    
-            } catch (TransformLangExecutorRuntimeException ex){
+                        "invalid assignment of number \"" + initValue
+                                + "\" to variable \"" + node.name + "\" : "
+                                + ex.getMessage());
+            } catch (TransformLangExecutorRuntimeException ex) {
                 throw ex;
-            } catch (Exception ex){
+            } catch (Exception ex) {
                 throw new TransformLangExecutorRuntimeException(node,
-                        "invalid assignment of \"" + value + "\" to variable \"" + node.name + "\" : "+ex.getMessage());  
+                        "invalid assignment of \"" + value
+                                + "\" to variable \"" + node.name + "\" : "
+                                + ex.getMessage());
             }
-            
+
         }
-        
+
         return data;
     }
 
@@ -1559,6 +1580,8 @@
     }
 
     public Object visit(CLVFAssignment node, Object data) {
+        //TODO: proper handling of NULL value assignment
+        
         CLVFVariableLiteral childNode=(CLVFVariableLiteral) node.jjtGetChild(0);
 
         Object variable = stack.getVar(childNode.localVar,childNode.varSlot);
@@ -1570,7 +1593,7 @@
             } else if (variable instanceof StringBuilder) {
                 StringBuilder var = (StringBuilder) variable;
                 var.setLength(0);
-                StringUtils.strBuffAppend(var,(CharSequence) value);
+                if (value !=null) StringUtils.strBuffAppend(var,(CharSequence) value);
             } else if (variable instanceof Boolean) {
                 stack.storeVar(childNode.localVar,childNode.varSlot, (Boolean)value); // boolean is not updatable - we replace the reference
                 // stack.put(varName,((Boolean)value).booleanValue() ?

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/metadata/DataRecordMetadataXMLReaderWriter.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/metadata/DataRecordMetadataXMLReaderWriter.java	2007-02-19 14:47:01 UTC (rev 2487)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/metadata/DataRecordMetadataXMLReaderWriter.java	2007-02-19 15:42:18 UTC (rev 2488)
@@ -140,6 +140,8 @@
 
 	//private static boolean setSchemaSupport = true;
 	//private static boolean setSchemaFullSupport = false;
+	private static final String METADATA_ELEMENT = "Metadata";
+	private static final String ID = "id";
 	private static final String RECORD_ELEMENT = "Record";
 	private static final String FIELD_ELEMENT = "Field";
 	private static final String CODE_ELEMENT = "Code";
@@ -203,6 +205,10 @@
 	 * @since May 6, 2002
 	 */
 	public DataRecordMetadata read(InputStream in) {
+		return read(in, null);
+	}
+	
+	public DataRecordMetadata read(InputStream in, String metadataId) {
 		Document document;
 
 		try {
@@ -238,7 +244,7 @@
 		}
 
 		try {
-			return parseRecordMetadata(document);
+			return parseRecordMetadata(document, metadataId);
 		} catch (DOMException ex) {
 			logger.fatal(ex.getMessage());
 			return null;
@@ -380,16 +386,32 @@
 
 	public DataRecordMetadata parseRecordMetadata(Document document)
 			throws DOMException {
+		return parseRecordMetadata(document, null);
+	}
+
+	public DataRecordMetadata parseRecordMetadata(Document document, String metadataId) throws DOMException {
 		org.w3c.dom.NodeList nodes;
-		nodes = document.getElementsByTagName(RECORD_ELEMENT);
-		if (nodes.getLength() == 0) {
-			throw new DOMException(DOMException.NOT_FOUND_ERR,
-					"No Record element has been found ! ");
+		if (metadataId != null) {
+			nodes = document.getElementsByTagName(METADATA_ELEMENT);
+			int lenght = nodes.getLength();
+			org.w3c.dom.Node node = null;
+			for (int i=0; i<lenght; i++) {
+				node = nodes.item(i);
+				if (node.getAttributes().getNamedItem(ID).getNodeValue().equals(metadataId)) {
+					return parseRecordMetadata(node.getChildNodes().item(1));
+				}
+			}
+			return null;
+		} else {
+			nodes = document.getElementsByTagName(RECORD_ELEMENT);
+			if (nodes.getLength() == 0) {
+				throw new DOMException(DOMException.NOT_FOUND_ERR,
+						"No Record element has been found ! ");
+			}
+			return parseRecordMetadata(nodes.item(0));
 		}
-
-		return parseRecordMetadata(nodes.item(0));
 	}
-
+	
 	public DataRecordMetadata parseRecordMetadata(org.w3c.dom.Node topNode)
 			throws DOMException {
 

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/metadata/XsdMetadata.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/metadata/XsdMetadata.java	2007-02-19 14:47:01 UTC (rev 2487)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/metadata/XsdMetadata.java	2007-02-19 15:42:18 UTC (rev 2488)
@@ -33,6 +33,12 @@
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
 
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.commons.cli.ParseException;
+import org.apache.commons.cli.PosixParser;
+import org.jetel.data.Defaults;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.NodeList;
@@ -143,7 +149,7 @@
 	private static Document createXsdDocument() throws ParserConfigurationException {
 		Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
 		Element preamble = doc.createElement("xsd:schema");
-		preamble.setAttribute("xmlns:xs", XMLSCHEMA);
+		preamble.setAttribute("xmlns:xsd", XMLSCHEMA);
 		if (NAMESPACE != null) {
 			preamble.setAttribute("targetNamespace", NAMESPACE);
 			preamble.setAttribute("xmlns", NAMESPACE);
@@ -257,27 +263,60 @@
 
 	/**
 	 * Converts clover metadata read from XML file to XSD written to file.
+	 * XML file can be metadata file or graph file. If XML file is graph, 
+	 * then you define metadata_id.
 	 * 
-	 * usage: XsdMetadata [infile] [outfile]
+	 * usage: XsdMetadata [--metadata_id id] [infile] [outfile]
 	 * @param argv {input_file, output_file}. "-" for std input/output
 	 */
 	public static void main(String argv[]) {
+		String metadataId = null;
+		
         try {
         	InputStream input;
-        	if (argv.length < 1 || argv[0].equals("-")) {
-        		input = System.in;
-        	} else {
-        		input = new FileInputStream(argv[0]);
-        	}
         	OutputStream output;
-        	if (argv.length < 2 || argv[1].equals("-")) {
-        		output = System.out;
-        	} else {
-        		output = new FileOutputStream(argv[1]);
-        	}
+       	
+    		Options options = new Options();
+        	options.addOption(new Option("m", "metadata_id", true, "Methadata id in graph file"));
+        	options.addOption(new Option("i", "in_file", true, "Input file"));
+        	options.addOption(new Option("o", "out_file", true, "Output file"));
         	
+        	PosixParser optParser = new PosixParser();
+        	CommandLine cmdLine;
+    		try {
+    			cmdLine = optParser.parse(options, argv);
+    		} catch (ParseException e) {
+    			e.printStackTrace();
+    			return;
+    		}
+    		
+    		if (cmdLine.hasOption("m")) {
+    			metadataId = cmdLine.getOptionValue("m");
+    		}
+    		if (cmdLine.hasOption("i")) {
+        		input = new FileInputStream(cmdLine.getOptionValue("i"));
+    		} else {
+    			input = System.in;
+    		}
+    		if (cmdLine.hasOption("o")) {
+        		output = new FileOutputStream(cmdLine.getOptionValue("o"));
+    		} else {
+    			output = System.out;
+    		}
+
+			Defaults.init();
+    		
             DataRecordMetadataXMLReaderWriter xmlReader = new DataRecordMetadataXMLReaderWriter();
-			DataRecordMetadata metadata = xmlReader.read(new BufferedInputStream(input));
+            DataRecordMetadata metadata;
+            if (metadataId == null)
+            	metadata = xmlReader.read(new BufferedInputStream(input));
+            else 
+            	metadata = xmlReader.read(new BufferedInputStream(input), metadataId);
+            
+            if(metadata == null) {
+                System.err.println("Metadata doesn't exist." + (metadataId != null ? " (" + metadataId + ")" : ""));
+                return;
+            }
 			(new XsdMetadata(metadata)).write(output);
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/util/FileUtils.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/util/FileUtils.java	2007-02-19 14:47:01 UTC (rev 2487)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.engine/src/org/jetel/util/FileUtils.java	2007-02-19 15:42:18 UTC (rev 2488)
@@ -27,7 +27,6 @@
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.net.MalformedURLException;
-import java.net.URI;
 import java.net.URL;
 import java.nio.channels.Channels;
 import java.nio.channels.ReadableByteChannel;
@@ -272,13 +271,14 @@
 			fileName = fileURL;
 		}
 		MultiOutFile multiOut = new MultiOutFile(fileName);
-		URI uri;
 		File file;
+        URL url;
 		boolean tmp;
 		//create file on given URL
 		try {
-			uri = getFileURL(contextURL, multiOut.next()).toURI();
-			file = new File(uri);
+			url = getFileURL(contextURL, multiOut.next());
+            if(!url.getProtocol().equalsIgnoreCase("file")) return true;
+			file = new File(url.getPath());
 		} catch (Exception e) {
 			throw new ComponentNotReadyException(e + ": " + fileURL);
 		}
@@ -289,7 +289,7 @@
 			try {
 				tmp = file.createNewFile();
 			} catch (IOException e) {
-				throw new ComponentNotReadyException(e + ": " + uri);
+				throw new ComponentNotReadyException(e + ": " + fileURL);
 			}
 			if (tmp) {
 				file.delete();

Modified: branches/cloveretl.engine.rel-2-1-0/cloveretl.sequence/src/org/jetel/sequence/SimpleSequence.java
===================================================================
--- branches/cloveretl.engine.rel-2-1-0/cloveretl.sequence/src/org/jetel/sequence/SimpleSequence.java	2007-02-19 14:47:01 UTC (rev 2487)
+++ branches/cloveretl.engine.rel-2-1-0/cloveretl.sequence/src/org/jetel/sequence/SimpleSequence.java	2007-02-19 15:42:18 UTC (rev 2488)
@@ -226,7 +226,7 @@
             }
         } catch (IOException ex) {
             logger.error("I/O error when accessing sequence " + getName() + " - " + ex.getMessage());
-            throw new RuntimeException("I/O error when accessing sequence " + getName() + " - " + ex.getMessage());
+            //throw new RuntimeException("I/O error when accessing sequence " + getName() + " - " + ex.getMessage());
         }
     }
     



From cloveretl-svn-commits at lists.berlios.de  Mon Feb 19 16:47:56 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Mon, 19 Feb 2007 16:47:56 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2489 -
	trunk/cloveretl.engine/src/org/jetel/util
Message-ID: <200702191547.l1JFlutg019075@sheep.berlios.de>

Author: otasanek
Date: 2007-02-19 16:47:55 +0100 (Mon, 19 Feb 2007)
New Revision: 2489

Modified:
   trunk/cloveretl.engine/src/org/jetel/util/MultiFileWriter.java
Log:
MINOR: better arranged piece of code.

Modified: trunk/cloveretl.engine/src/org/jetel/util/MultiFileWriter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/MultiFileWriter.java	2007-02-19 15:42:18 UTC (rev 2488)
+++ trunk/cloveretl.engine/src/org/jetel/util/MultiFileWriter.java	2007-02-19 15:47:55 UTC (rev 2489)
@@ -110,15 +110,13 @@
      * @throws FileNotFoundException
      */
     private void setNextOutput() throws IOException {
-    	if (fileNames != null) {
-            if (!fileNames.hasNext()) {
-                logger.warn("Unable to open new output file. This may be caused by missing wildcard in filename specification. "
-                        + "Size of output file will exceed specified limit");
-                return;
-            }    		
+    	if (fileNames != null && !fileNames.hasNext()) {
+            logger.warn("Unable to open new output file. This may be caused by missing wildcard in filename specification. "
+                    + "Size of output file will exceed specified limit.");
+            return;
     	}
-    	else if (!channels.hasNext()) {
-            logger.warn("Unable to open new output file. Size of output file will exceed specified limit");
+    	if (channels != null && !channels.hasNext()) {
+            logger.warn("Unable to open new output stream. Size of last output stream will exceed specified limit.");
             return;
         }      	
 



From cloveretl-svn-commits at lists.berlios.de  Mon Feb 19 16:49:13 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Mon, 19 Feb 2007 16:49:13 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2490 -
	trunk/cloveretl.engine
Message-ID: <200702191549.l1JFnD1Y019251@sheep.berlios.de>

Author: otasanek
Date: 2007-02-19 16:49:12 +0100 (Mon, 19 Feb 2007)
New Revision: 2490

Modified:
   trunk/cloveretl.engine/build.xml
Log:
UPDATE: build.xml copies all run* script into binary release.

Modified: trunk/cloveretl.engine/build.xml
===================================================================
--- trunk/cloveretl.engine/build.xml	2007-02-19 15:47:55 UTC (rev 2489)
+++ trunk/cloveretl.engine/build.xml	2007-02-19 15:49:12 UTC (rev 2490)
@@ -196,6 +196,11 @@
 		<copy todir="${dir.dist}/docs">
 			<fileset dir="${dir.docs}"/>
 		</copy>
+
+		<!-- copy all run scripts -->
+		<copy todir="${dir.dist}">
+			<fileset file="${basedir}/run*"/>
+		</copy>
 	</target>
 	
 	<!-- ask user for MAJOR and MINOR release number -->



From cloveretl-svn-commits at lists.berlios.de  Mon Feb 19 17:14:32 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Mon, 19 Feb 2007 17:14:32 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2491 - in trunk:
	cloveretl.component
	cloveretl.component/src/org/jetel/component cloveretl.engine
	cloveretl.engine/plugins/org.jetel.component
	cloveretl.engine/src/org/jetel/util
	cloveretl.sequence/src/org/jetel/sequence
Message-ID: <200702191614.l1JGEWtx024053@sheep.berlios.de>

Author: otasanek
Date: 2007-02-19 17:14:18 +0100 (Mon, 19 Feb 2007)
New Revision: 2491

Modified:
   trunk/cloveretl.component/plugin.xml
   trunk/cloveretl.component/src/org/jetel/component/JmsWriter.java
   trunk/cloveretl.engine/build.xml
   trunk/cloveretl.engine/plugins/org.jetel.component/plugin.xml
   trunk/cloveretl.engine/src/org/jetel/util/FileUtils.java
   trunk/cloveretl.sequence/src/org/jetel/sequence/SimpleSequence.java
Log:
SVN: merge with branch 2.1.0.

Modified: trunk/cloveretl.component/plugin.xml
===================================================================
--- trunk/cloveretl.component/plugin.xml	2007-02-19 15:49:12 UTC (rev 2490)
+++ trunk/cloveretl.component/plugin.xml	2007-02-19 16:14:18 UTC (rev 2491)
@@ -94,6 +94,11 @@
 
 	<extension point-id="component">
 	    <parameter id="className" value="org.jetel.component.MergeJoin"/>
+	    <parameter id="type" value="EXT_MERGE_JOIN"/>
+	</extension>
+
+	<extension point-id="component">
+	    <parameter id="className" value="org.jetel.component.MergeJoin"/>
 	    <parameter id="type" value="SORTED_JOIN"/>
 	</extension>
 
@@ -113,6 +118,11 @@
 	</extension>
 
 	<extension point-id="component">
+	    <parameter id="className" value="org.jetel.component.HashJoin"/>
+	    <parameter id="type" value="EXT_HASH_JOIN"/>
+	</extension>
+
+	<extension point-id="component">
 	    <parameter id="className" value="org.jetel.component.CheckForeignKey"/>
 	    <parameter id="type" value="CHECK_FOREIGN_KEY"/>
 	</extension>

Modified: trunk/cloveretl.component/src/org/jetel/component/JmsWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/JmsWriter.java	2007-02-19 15:49:12 UTC (rev 2490)
+++ trunk/cloveretl.component/src/org/jetel/component/JmsWriter.java	2007-02-19 16:14:18 UTC (rev 2491)
@@ -33,6 +33,7 @@
 import org.jetel.data.DataRecord;
 import org.jetel.database.IConnection;
 import org.jetel.exception.ComponentNotReadyException;
+import org.jetel.exception.ConfigurationProblem;
 import org.jetel.exception.ConfigurationStatus;
 import org.jetel.exception.JetelException;
 import org.jetel.exception.XMLConfigurationException;
@@ -42,6 +43,7 @@
 import org.jetel.graph.TransformationGraph;
 import org.jetel.util.ComponentXMLAttributes;
 import org.jetel.util.DynamicJavaCode;
+import org.jetel.util.StringUtils;
 import org.w3c.dom.Element;
 
 

Modified: trunk/cloveretl.engine/build.xml
===================================================================
--- trunk/cloveretl.engine/build.xml	2007-02-19 15:49:12 UTC (rev 2490)
+++ trunk/cloveretl.engine/build.xml	2007-02-19 16:14:18 UTC (rev 2491)
@@ -117,6 +117,9 @@
 	<target name="clean" depends="checkproperties" description="Delete old compiled files">
 		<delete dir="${dir.bin}"/>
 		<delete dir="${dir.dist}"/>
+		<delete dir="${distribution.dir}"/>
+		<delete dir="${src.distribution.dir}"/>
+		<delete dir="${dir.doc}"/>
 	</target>
 
 	<!-- Target sets directory-properties unless they have been defined (in parent ant build) -->

Modified: trunk/cloveretl.engine/plugins/org.jetel.component/plugin.xml
===================================================================
--- trunk/cloveretl.engine/plugins/org.jetel.component/plugin.xml	2007-02-19 15:49:12 UTC (rev 2490)
+++ trunk/cloveretl.engine/plugins/org.jetel.component/plugin.xml	2007-02-19 16:14:18 UTC (rev 2491)
@@ -94,6 +94,11 @@
 
 	<extension point-id="component">
 	    <parameter id="className" value="org.jetel.component.MergeJoin"/>
+	    <parameter id="type" value="EXT_MERGE_JOIN"/>
+	</extension>
+
+	<extension point-id="component">
+	    <parameter id="className" value="org.jetel.component.MergeJoin"/>
 	    <parameter id="type" value="SORTED_JOIN"/>
 	</extension>
 
@@ -113,6 +118,11 @@
 	</extension>
 
 	<extension point-id="component">
+	    <parameter id="className" value="org.jetel.component.HashJoin"/>
+	    <parameter id="type" value="EXT_HASH_JOIN"/>
+	</extension>
+
+	<extension point-id="component">
 	    <parameter id="className" value="org.jetel.component.CheckForeignKey"/>
 	    <parameter id="type" value="CHECK_FOREIGN_KEY"/>
 	</extension>

Modified: trunk/cloveretl.engine/src/org/jetel/util/FileUtils.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/FileUtils.java	2007-02-19 15:49:12 UTC (rev 2490)
+++ trunk/cloveretl.engine/src/org/jetel/util/FileUtils.java	2007-02-19 16:14:18 UTC (rev 2491)
@@ -27,7 +27,6 @@
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.net.MalformedURLException;
-import java.net.URI;
 import java.net.URL;
 import java.nio.channels.Channels;
 import java.nio.channels.ReadableByteChannel;
@@ -272,13 +271,14 @@
 			fileName = fileURL;
 		}
 		MultiOutFile multiOut = new MultiOutFile(fileName);
-		URI uri;
 		File file;
+        URL url;
 		boolean tmp;
 		//create file on given URL
 		try {
-			uri = getFileURL(contextURL, multiOut.next()).toURI();
-			file = new File(uri);
+			url = getFileURL(contextURL, multiOut.next());
+            if(!url.getProtocol().equalsIgnoreCase("file")) return true;
+			file = new File(url.getPath());
 		} catch (Exception e) {
 			throw new ComponentNotReadyException(e + ": " + fileURL);
 		}
@@ -289,14 +289,14 @@
 			try {
 				tmp = file.createNewFile();
 			} catch (IOException e) {
-				throw new ComponentNotReadyException(e + ": " + uri);
+				throw new ComponentNotReadyException(e + ": " + fileURL);
 			}
 			if (tmp) {
 				file.delete();
 			}
 		}
 		if (!tmp) {
-			throw new ComponentNotReadyException("Can't write to: " + uri);
+			throw new ComponentNotReadyException("Can't write to: " + fileURL);
 		}
 		return true;
 	}

Modified: trunk/cloveretl.sequence/src/org/jetel/sequence/SimpleSequence.java
===================================================================
--- trunk/cloveretl.sequence/src/org/jetel/sequence/SimpleSequence.java	2007-02-19 15:49:12 UTC (rev 2490)
+++ trunk/cloveretl.sequence/src/org/jetel/sequence/SimpleSequence.java	2007-02-19 16:14:18 UTC (rev 2491)
@@ -226,7 +226,7 @@
             }
         } catch (IOException ex) {
             logger.error("I/O error when accessing sequence " + getName() + " - " + ex.getMessage());
-            throw new RuntimeException("I/O error when accessing sequence " + getName() + " - " + ex.getMessage());
+            //throw new RuntimeException("I/O error when accessing sequence " + getName() + " - " + ex.getMessage());
         }
     }
     



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 20 14:36:21 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 20 Feb 2007 14:36:21 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2492 - in
	trunk/cloveretl.engine/src/org/jetel/util: . dml2clover
Message-ID: <200702201336.l1KDaLw1024491@sheep.berlios.de>

Author: jausperger
Date: 2007-02-20 14:36:20 +0100 (Tue, 20 Feb 2007)
New Revision: 2492

Added:
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2Clover.jj
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DataType.java
Log:
INIT: create metadata from create statement

Added: trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2Clover.jj
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2Clover.jj	2007-02-19 16:14:18 UTC (rev 2491)
+++ trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2Clover.jj	2007-02-20 13:36:20 UTC (rev 2492)
@@ -0,0 +1,408 @@
+/**
+ * JavaCC file
+ */
+ 
+options
+{ 
+	JDK_VERSION = "1.5";
+	STATIC=false;
+	CACHE_TOKENS=true;
+	IGNORE_CASE=true;
+}
+
+PARSER_BEGIN(DML2Clover)
+package org.jetel.util.dml2clover;
+
+import java.util.*;
+import java.io.*;
+import org.jetel.metadata.*;
+import java.math.*;
+
+public class DML2Clover {
+
+	/**
+		 * The class parses sql script containing only create statements. Output is a DataRecordMetadata List.
+		 */
+	 
+	private List<DataRecordMetadata> list = new LinkedList<DataRecordMetadata>();
+	private String fieldDelimiter;
+	private String recordDelimiter;
+	
+	private static final Long booleanLenght = Long.valueOf(5); // false / true
+	private static final Long byteLenght = Long.valueOf(String.valueOf(Byte.MIN_VALUE).length());
+	private static final Long integerLenght = Long.valueOf(String.valueOf(Integer.MIN_VALUE).length());
+	private static final Long longLenght = Long.valueOf(String.valueOf(Long.MIN_VALUE).length());
+	private static final Long floatLenght = Long.valueOf(String.valueOf(7));
+	private static final Long doubleLenght = Long.valueOf(String.valueOf(15));
+	private static final Long dateLenght = Long.valueOf(10); // "10.10.2007"
+	private static final Long dateTimeLenght = Long.valueOf(24); // "10.10.2007 23:10:10.111"
+	
+	public static void main(String args[]) throws ParseException, FileNotFoundException {
+		DML2Clover parser = new DML2Clover(new FileInputStream(new File("text.txt")));
+		parser.getDataRecordMetadataList(";", "\n");
+		parser.testPrint(parser.list);
+		System.out.println("Ok");
+	}
+
+	public List<DataRecordMetadata> getDataRecordMetadataList() throws ParseException {
+		return getDataRecordMetadataList(null, null);
+	}
+
+	public List<DataRecordMetadata> getDataRecordMetadataList(String fieldDelimiter, String recordDelimiter) throws ParseException {
+		this.fieldDelimiter = fieldDelimiter;
+		this.recordDelimiter = recordDelimiter;
+		while (!isEOF()) {
+			list.add(createTableStatement());
+		}
+		return list;
+	}
+	
+	private void testPrint(List<DataRecordMetadata> list) {
+		DataRecordMetadataXMLReaderWriter writer = new DataRecordMetadataXMLReaderWriter();
+   		for (DataRecordMetadata dataRecordMetadata : list) {
+			writer.write(dataRecordMetadata, System.out);
+			System.out.println();
+   		}		
+	}
+	
+}
+
+PARSER_END(DML2Clover)
+
+// The SQL lexical grammar
+
+SKIP:
+{
+	// blank space
+		" "
+	|	"\t"
+	|	"\n"
+	|	"\r"
+	|	"\n\r"
+}
+
+// HANDLING COMMENTS
+SPECIAL_TOKEN: 
+{
+	<"/*"> : WithinComment 
+}
+
+<WithinComment> SPECIAL_TOKEN:	{ <"*/"> : DEFAULT }
+<WithinComment> MORE: { <~[]> }
+
+SPECIAL_TOKEN: 
+{  
+	<"//"> : WithinLineComment 
+}
+
+<WithinLineComment> SPECIAL_TOKEN: { <"\n"> : DEFAULT }
+<WithinLineComment> MORE: { <~[]> }
+
+
+TOKEN:
+{
+	// keywords
+		< BOOLEAN: "boolean" >
+	|	< BLOB: "blob" >
+	|	< CHAR: "char" >
+	|	< CHARACTER: "character" >
+	|	< CLOB: "clob" >
+	|	< COMMIT: "commit" >
+	|	< CREATE: "create" >
+	|	< DATE:"date" >
+	|	< DATETIME:"datetime" >
+	|	< DEC:"dec" >
+	|	< DECIMAL:"decimal" >
+	|	< DEFAULT_: "default" >
+	|	< DELETE: "delete" >
+	|	< FLOAT:"float" >
+	|	< GLOBAL: "global" >
+	|	< INT: "int" >
+	|	< INTEGER: "integer" >
+	|	< KEY: "key" >
+	|	< LOCAL: "local" >
+	|	< NOT: "not" >
+	|	< NULL: "null" >
+	|	< NUMBER: "number" >
+	|	< NUMERIC: "numeric" >
+	|	< ON: "on" >
+	|	< PRESERVE:"preserve" >
+	|	< PRIMARY:"primary" >
+	|	< REFERENCES:"references" >
+	|	< ROWS: "rows" >
+	|	< SMALLINT: "smallint" >
+	|	< TABLE: "table" >
+	|	< TIMESTAMP: "timestamp" >
+	|	< TEMPORARY: "TEMPORARY" >
+	|	< UNIQUE: "unique" >
+	|	< VARCHAR: "varchar" >
+	|	< VARCHAR2: "varchar2" >
+
+	// literals
+	|	< STRING_LITERAL: "'" (~["'"])* ( "''" (~["'"])* )* "'" >
+	|	< INTEGER_LITERAL: 	(["0"-"9"])+ >
+	|	< FLOAT_LITERAL:	(["0"-"9"])+ "." (["0"-"9"])+ (<EXP>)?
+							|	"." (["0"-"9"])+ (<EXP>)?
+							|	(["0"-"9"])+ (<EXP>)?>
+	|	< #EXP: ["e","E"] (["+","-"])? (["0"-"9"])+ >
+
+	// identifiers
+	|	< IDENTIFIER: ( <LETTER> )+ ( "_" | "$" | "#" | <DIGIT> | <LETTER> )* >
+	|	< LETTER: ["A"-"Z", "a"-"z"] >
+	|	< DIGIT: ["0"-"9"] >
+
+	// separators and operators
+	|	< CLOSEPAREN: ")" >
+	|	< COMA: "," >
+	|	< DOT: "." >
+	|	< OPENPAREN: "(" >
+	|	< SEMICOLON: ";" >
+}
+
+/*******************************************************************
+ * The SQL syntatic grammar starts here
+ *******************************************************************/
+
+DataRecordMetadata createTableStatement() : {
+	DataRecordMetadata dataRecordMetadata;
+	List<DataFieldMetadata> list;
+}
+{
+	<CREATE> [tableScope()] <TABLE> [LOOKAHEAD(2)(<IDENTIFIER><DOT>)] {dataRecordMetadata = new DataRecordMetadata(identifier());}
+		// table element list
+		{
+			list = tableElementList(); 
+			for (DataFieldMetadata field : list) {
+				dataRecordMetadata.addField(field);
+			}
+		}
+		// | OF  <path-resolved user-defined type name> [ <subtable clause> ] [ <table element list> ]
+		// | <as subquery clause>
+	[ <ON> <COMMIT> (<PRESERVE> | <DELETE>)? <ROWS>]
+	<SEMICOLON>
+	{
+		if (fieldDelimiter != null && recordDelimiter != null) {
+			dataRecordMetadata.setRecType(DataRecordMetadata.DELIMITED_RECORD);
+		} else if (fieldDelimiter == null && recordDelimiter == null) {
+			dataRecordMetadata.setRecType(DataRecordMetadata.FIXEDLEN_RECORD);
+		}
+	}
+	{ return dataRecordMetadata; }
+}
+
+List<DataFieldMetadata> tableElementList() :
+{
+	List<DataFieldMetadata> list = new LinkedList<DataFieldMetadata>();
+	DataFieldMetadata ret;
+}
+{
+	<OPENPAREN> 
+	ret = tableElement() 			
+	{ 
+		ret.setDelimiter(fieldDelimiter);
+		list.add(ret); 
+	}
+	(<COMA> ret = tableElement() 	
+	{
+		ret.setDelimiter(fieldDelimiter);
+		list.add(ret); 
+	})*
+	{ret.setDelimiter(recordDelimiter);}
+	<CLOSEPAREN> 
+	{ return list; }
+}
+
+void tableScope() :
+{}
+{
+	[<GLOBAL> | <LOCAL>]  <TEMPORARY>
+}
+
+
+boolean isEOF() :
+{
+	boolean isEof = false;
+}
+{
+	(<EOF> isEof = t())?
+	{return isEof;}
+}
+
+boolean t() :
+{
+}
+{
+	{return true;}
+}
+
+//+
+void columnConstraintDefinition() :
+{}
+{
+	(	<NOT> <NULL>
+	|	<UNIQUE>
+	|	<PRIMARY> <KEY>
+//	|	<CHECK> <OPENPAREN> <CLOSEPAREN>
+	|	<REFERENCES> tableName() <OPENPAREN> identifierList() <CLOSEPAREN>
+	)
+}
+
+//+
+DataFieldMetadata columnDefinition() :
+{
+	DataFieldMetadata dataFieldMetadata;
+	String name;
+	DataType type;
+	Object value = null;
+}
+{
+	name = columnName() 
+	type = dataType()
+	(<DEFAULT_> value = defaultValue())?
+	(columnConstraintDefinition())?
+	{ if (type.length == null) {
+		dataFieldMetadata = new DataFieldMetadata(name, type.type, null);
+	  } else {
+		//dataFieldMetadata = new DataFieldMetadata(name, type.type, type.length.shortValue());
+		dataFieldMetadata = new DataFieldMetadata(name, type.type, type.length.shortValue());
+	  }
+	  dataFieldMetadata.setDefaultValue(value);
+	  return dataFieldMetadata; 
+	}
+}
+
+DataFieldMetadata tableElement() :
+{
+	DataFieldMetadata ret = null;
+}
+{
+	(	ret = columnDefinition()
+	// | tableConstraintDefinition()
+	// | <like clause>
+	// | <self-referencing column specification>
+	// | <column options>
+	)
+	{ return ret; }
+}
+
+//+
+String columnName() :
+{
+	String ret;
+}
+{
+	(LOOKAHEAD(2) identifier() <DOT>)? ret = identifier()
+	{ return ret; }
+}
+
+//+TODO dodelat dalsi typu jako DATE, VARCHAR,...
+DataType dataType() :
+{
+	char type;
+	Long temp;
+	Long lenght = null;
+	Long scale = null;
+}
+{
+	(	<BOOLEAN> { type = DataFieldMetadata.INTEGER_FIELD;		lenght = integerLenght;}
+	|	<BLOB> { type = DataFieldMetadata.BYTE_FIELD; } 		(<OPENPAREN> temp = integerLiteral() <CLOSEPAREN> { lenght = temp; })?
+	|	<CHAR> { type = DataFieldMetadata.STRING_FIELD; } 		(<OPENPAREN> temp = integerLiteral() <CLOSEPAREN> { lenght = temp; })?
+	|	<CHARACTER> { type = DataFieldMetadata.STRING_FIELD; } 	(<OPENPAREN> temp = integerLiteral() <CLOSEPAREN> { lenght = temp; })?
+	|	<CLOB> { type = DataFieldMetadata.BYTE_FIELD; } 		(<OPENPAREN> temp = integerLiteral() <CLOSEPAREN> { lenght = temp; })?
+	|	<DATE> { type = DataFieldMetadata.DATE_FIELD; 			lenght = dateLenght;}
+	|	<DATETIME> { type = DataFieldMetadata.DATE_FIELD;	    lenght = dateTimeLenght;}
+	|	<DEC> { type = DataFieldMetadata.DECIMAL_FIELD; }		(<OPENPAREN> temp = integerLiteral() (<COMA> scale = integerLiteral() )? <CLOSEPAREN> { lenght = temp; })?
+	|	<DECIMAL> { type = DataFieldMetadata.DECIMAL_FIELD; }	(<OPENPAREN> temp = integerLiteral() (<COMA> scale = integerLiteral() )? <CLOSEPAREN> { lenght = temp; })?
+	|	<FLOAT> { type = DataFieldMetadata.NUMERIC_FIELD; 		lenght = floatLenght;}
+	|	<INT> { type = DataFieldMetadata.INTEGER_FIELD; 		lenght = integerLenght;}
+	|	<INTEGER> { type = DataFieldMetadata.INTEGER_FIELD; 	lenght = integerLenght;}
+	|	<SMALLINT> { type = DataFieldMetadata.INTEGER_FIELD; 	lenght = integerLenght;}
+	|	<TIMESTAMP> { type = DataFieldMetadata.DATE_FIELD;		lenght = dateTimeLenght;}
+	|	<NUMERIC> { type = DataFieldMetadata.DECIMAL_FIELD; }	(<OPENPAREN> temp = integerLiteral() (<COMA> scale = integerLiteral() )? <CLOSEPAREN> { lenght = temp; })?
+	|	<VARCHAR> { type = DataFieldMetadata.STRING_FIELD; }	<OPENPAREN> temp = integerLiteral() <CLOSEPAREN> { lenght = temp; }
+	|	<VARCHAR2> { type = DataFieldMetadata.STRING_FIELD; }	<OPENPAREN> temp = integerLiteral() <CLOSEPAREN> { lenght = temp; }
+	)
+	{ return new DataType(type, lenght, scale); }
+}
+
+//+
+Object defaultValue() : 
+{
+	Object ret;
+}
+{
+	(	ret = literal()
+	|	ret = nullLiteral() 
+	)
+	{ return ret; }
+}
+
+//+
+BigDecimal floatLiteral() :
+{}
+{
+	<FLOAT_LITERAL> { return new BigDecimal(token.image); }
+}
+
+//+
+String identifier() :
+{}
+{
+	<IDENTIFIER>
+	{ return token.image; }
+}
+
+//+
+void identifierList() :
+{
+}
+{
+	identifier()
+	(<COMA> identifier())*	
+}
+
+//+
+Object literal() :
+{
+	Object ret;
+}
+{
+	(	ret = integerLiteral()
+	|	ret = floatLiteral()
+	|	ret = stringLiteral()
+	)
+	{ return ret; }
+}
+
+//+
+Long integerLiteral() :
+{}
+{
+	<INTEGER_LITERAL> { return new Long(token.image); }
+}
+
+//+
+Object nullLiteral() : 
+{}
+{
+	<NULL> { return	null; }
+}
+	
+//+
+String stringLiteral() :
+{}
+{
+	<STRING_LITERAL> 
+	{ 
+		String value = token.image.intern();
+		return value.substring(1, value.length() - 1); 
+	}
+}
+
+//+
+void tableName() :
+{}
+{
+	<IDENTIFIER>
+}
+

Added: trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DataType.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DataType.java	2007-02-19 16:14:18 UTC (rev 2491)
+++ trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DataType.java	2007-02-20 13:36:20 UTC (rev 2492)
@@ -0,0 +1,19 @@
+package org.jetel.util.dml2clover;
+public final class DataType {
+
+    /** Data type, based on java.sql.Types */
+    public final char type;
+
+    /** Used when data type has fixed length */
+    public final Number length;
+
+    /** Used when data type has scale */
+    public final Number scale;
+
+    public DataType(char type, Number length, Number scale) {
+        this.type = type;
+        this.length = length;
+        this.scale = scale;
+    }
+
+}
\ No newline at end of file



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 20 14:57:36 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 20 Feb 2007 14:57:36 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2493 -
	trunk/cloveretl.engine/src/org/jetel/util/dml2clover
Message-ID: <200702201357.l1KDvaFD025469@sheep.berlios.de>

Author: jausperger
Date: 2007-02-20 14:57:34 +0100 (Tue, 20 Feb 2007)
New Revision: 2493

Added:
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2Clover.java
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverConstants.java
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverTokenManager.java
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/ParseException.java
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/SimpleCharStream.java
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/Token.java
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/TokenMgrError.java
Log:
INIT: create metadata from create statement

Added: trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2Clover.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2Clover.java	2007-02-20 13:36:20 UTC (rev 2492)
+++ trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2Clover.java	2007-02-20 13:57:34 UTC (rev 2493)
@@ -0,0 +1,881 @@
+/* Generated By:JavaCC: Do not edit this line. DML2Clover.java */
+package org.jetel.util.dml2clover;
+
+import java.util.*;
+import java.io.*;
+import org.jetel.metadata.*;
+import java.math.*;
+
+public class DML2Clover implements DML2CloverConstants {
+
+        /**
+		 * The class parses sql script containing only create statements. Output is a DataRecordMetadata List.
+		 */
+
+        private List<DataRecordMetadata> list = new LinkedList<DataRecordMetadata>();
+        private String fieldDelimiter;
+        private String recordDelimiter;
+
+        private static final Long booleanLenght = Long.valueOf(5); // false / true
+        private static final Long byteLenght = Long.valueOf(String.valueOf(Byte.MIN_VALUE).length());
+        private static final Long integerLenght = Long.valueOf(String.valueOf(Integer.MIN_VALUE).length());
+        private static final Long longLenght = Long.valueOf(String.valueOf(Long.MIN_VALUE).length());
+        private static final Long floatLenght = Long.valueOf(String.valueOf(7));
+        private static final Long doubleLenght = Long.valueOf(String.valueOf(15));
+        private static final Long dateLenght = Long.valueOf(10); // "10.10.2007"
+        private static final Long dateTimeLenght = Long.valueOf(24); // "10.10.2007 23:10:10.111"
+
+        public static void main(String args[]) throws ParseException, FileNotFoundException {
+                DML2Clover parser = new DML2Clover(new FileInputStream(new File("text.txt")));
+                parser.getDataRecordMetadataList(";", "\n");
+                parser.testPrint(parser.list);
+                System.out.println("Ok");
+        }
+
+        public List<DataRecordMetadata> getDataRecordMetadataList() throws ParseException {
+                return getDataRecordMetadataList(null, null);
+        }
+
+        public List<DataRecordMetadata> getDataRecordMetadataList(String fieldDelimiter, String recordDelimiter) throws ParseException {
+                this.fieldDelimiter = fieldDelimiter;
+                this.recordDelimiter = recordDelimiter;
+                while (!isEOF()) {
+                        list.add(createTableStatement());
+                }
+                return list;
+        }
+
+        private void testPrint(List<DataRecordMetadata> list) {
+                DataRecordMetadataXMLReaderWriter writer = new DataRecordMetadataXMLReaderWriter();
+                for (DataRecordMetadata dataRecordMetadata : list) {
+                        writer.write(dataRecordMetadata, System.out);
+                        System.out.println();
+                }
+        }
+
+/*******************************************************************
+ * The SQL syntatic grammar starts here
+ *******************************************************************/
+  final public DataRecordMetadata createTableStatement() throws ParseException {
+        DataRecordMetadata dataRecordMetadata;
+        List<DataFieldMetadata> list;
+    jj_consume_token(CREATE);
+    switch (jj_nt.kind) {
+    case GLOBAL:
+    case LOCAL:
+    case TEMPORARY:
+      tableScope();
+      break;
+    default:
+      jj_la1[0] = jj_gen;
+      ;
+    }
+    jj_consume_token(TABLE);
+    if (jj_2_1(2)) {
+      jj_consume_token(IDENTIFIER);
+      jj_consume_token(DOT);
+    } else {
+      ;
+    }
+                                                                           dataRecordMetadata = new DataRecordMetadata(identifier());
+                        list = tableElementList();
+                        for (DataFieldMetadata field : list) {
+                                dataRecordMetadata.addField(field);
+                        }
+    switch (jj_nt.kind) {
+    case ON:
+      jj_consume_token(ON);
+      jj_consume_token(COMMIT);
+      switch (jj_nt.kind) {
+      case DELETE:
+      case PRESERVE:
+        switch (jj_nt.kind) {
+        case PRESERVE:
+          jj_consume_token(PRESERVE);
+          break;
+        case DELETE:
+          jj_consume_token(DELETE);
+          break;
+        default:
+          jj_la1[1] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+      default:
+        jj_la1[2] = jj_gen;
+        ;
+      }
+      jj_consume_token(ROWS);
+      break;
+    default:
+      jj_la1[3] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+                if (fieldDelimiter != null && recordDelimiter != null) {
+                        dataRecordMetadata.setRecType(DataRecordMetadata.DELIMITED_RECORD);
+                } else if (fieldDelimiter == null && recordDelimiter == null) {
+                        dataRecordMetadata.setRecType(DataRecordMetadata.FIXEDLEN_RECORD);
+                }
+          {if (true) return dataRecordMetadata;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List<DataFieldMetadata> tableElementList() throws ParseException {
+        List<DataFieldMetadata> list = new LinkedList<DataFieldMetadata>();
+        DataFieldMetadata ret;
+    jj_consume_token(OPENPAREN);
+    ret = tableElement();
+                ret.setDelimiter(fieldDelimiter);
+                list.add(ret);
+    label_1:
+    while (true) {
+      switch (jj_nt.kind) {
+      case COMA:
+        ;
+        break;
+      default:
+        jj_la1[4] = jj_gen;
+        break label_1;
+      }
+      jj_consume_token(COMA);
+      ret = tableElement();
+                ret.setDelimiter(fieldDelimiter);
+                list.add(ret);
+    }
+         ret.setDelimiter(recordDelimiter);
+    jj_consume_token(CLOSEPAREN);
+          {if (true) return list;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void tableScope() throws ParseException {
+    switch (jj_nt.kind) {
+    case GLOBAL:
+    case LOCAL:
+      switch (jj_nt.kind) {
+      case GLOBAL:
+        jj_consume_token(GLOBAL);
+        break;
+      case LOCAL:
+        jj_consume_token(LOCAL);
+        break;
+      default:
+        jj_la1[5] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[6] = jj_gen;
+      ;
+    }
+    jj_consume_token(TEMPORARY);
+  }
+
+  final public boolean isEOF() throws ParseException {
+        boolean isEof = false;
+    switch (jj_nt.kind) {
+    case 0:
+      jj_consume_token(0);
+      isEof = t();
+      break;
+    default:
+      jj_la1[7] = jj_gen;
+      ;
+    }
+         {if (true) return isEof;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public boolean t() throws ParseException {
+         {if (true) return true;}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public void columnConstraintDefinition() throws ParseException {
+    switch (jj_nt.kind) {
+    case NOT:
+      jj_consume_token(NOT);
+      jj_consume_token(NULL);
+      break;
+    case UNIQUE:
+      jj_consume_token(UNIQUE);
+      break;
+    case PRIMARY:
+      jj_consume_token(PRIMARY);
+      jj_consume_token(KEY);
+      break;
+    case REFERENCES:
+      jj_consume_token(REFERENCES);
+      tableName();
+      jj_consume_token(OPENPAREN);
+      identifierList();
+      jj_consume_token(CLOSEPAREN);
+      break;
+    default:
+      jj_la1[8] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+//+
+  final public DataFieldMetadata columnDefinition() throws ParseException {
+        DataFieldMetadata dataFieldMetadata;
+        String name;
+        DataType type;
+        Object value = null;
+    name = columnName();
+    type = dataType();
+    switch (jj_nt.kind) {
+    case DEFAULT_:
+      jj_consume_token(DEFAULT_);
+      value = defaultValue();
+      break;
+    default:
+      jj_la1[9] = jj_gen;
+      ;
+    }
+    switch (jj_nt.kind) {
+    case NOT:
+    case PRIMARY:
+    case REFERENCES:
+    case UNIQUE:
+      columnConstraintDefinition();
+      break;
+    default:
+      jj_la1[10] = jj_gen;
+      ;
+    }
+          if (type.length == null) {
+                dataFieldMetadata = new DataFieldMetadata(name, type.type, null);
+          } else {
+                //dataFieldMetadata = new DataFieldMetadata(name, type.type, type.length.shortValue());
+                dataFieldMetadata = new DataFieldMetadata(name, type.type, type.length.shortValue());
+          }
+          dataFieldMetadata.setDefaultValue(value);
+          {if (true) return dataFieldMetadata;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public DataFieldMetadata tableElement() throws ParseException {
+        DataFieldMetadata ret = null;
+    ret = columnDefinition();
+          {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public String columnName() throws ParseException {
+        String ret;
+    if (jj_2_2(2)) {
+      identifier();
+      jj_consume_token(DOT);
+    } else {
+      ;
+    }
+    ret = identifier();
+          {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+//+TODO dodelat dalsi typu jako DATE, VARCHAR,...
+  final public DataType dataType() throws ParseException {
+        char type;
+        Long temp;
+        Long lenght = null;
+        Long scale = null;
+    switch (jj_nt.kind) {
+    case BOOLEAN:
+      jj_consume_token(BOOLEAN);
+                            type = DataFieldMetadata.INTEGER_FIELD;             lenght = integerLenght;
+      break;
+    case BLOB:
+      jj_consume_token(BLOB);
+                         type = DataFieldMetadata.BYTE_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                    lenght = temp;
+        break;
+      default:
+        jj_la1[11] = jj_gen;
+        ;
+      }
+      break;
+    case CHAR:
+      jj_consume_token(CHAR);
+                         type = DataFieldMetadata.STRING_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                    lenght = temp;
+        break;
+      default:
+        jj_la1[12] = jj_gen;
+        ;
+      }
+      break;
+    case CHARACTER:
+      jj_consume_token(CHARACTER);
+                              type = DataFieldMetadata.STRING_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                            lenght = temp;
+        break;
+      default:
+        jj_la1[13] = jj_gen;
+        ;
+      }
+      break;
+    case CLOB:
+      jj_consume_token(CLOB);
+                         type = DataFieldMetadata.BYTE_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                    lenght = temp;
+        break;
+      default:
+        jj_la1[14] = jj_gen;
+        ;
+      }
+      break;
+    case DATE:
+      jj_consume_token(DATE);
+                         type = DataFieldMetadata.DATE_FIELD;                   lenght = dateLenght;
+      break;
+    case DATETIME:
+      jj_consume_token(DATETIME);
+                             type = DataFieldMetadata.DATE_FIELD;           lenght = dateTimeLenght;
+      break;
+    case DEC:
+      jj_consume_token(DEC);
+                        type = DataFieldMetadata.DECIMAL_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        switch (jj_nt.kind) {
+        case COMA:
+          jj_consume_token(COMA);
+          scale = integerLiteral();
+          break;
+        default:
+          jj_la1[15] = jj_gen;
+          ;
+        }
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                                                        lenght = temp;
+        break;
+      default:
+        jj_la1[16] = jj_gen;
+        ;
+      }
+      break;
+    case DECIMAL:
+      jj_consume_token(DECIMAL);
+                            type = DataFieldMetadata.DECIMAL_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        switch (jj_nt.kind) {
+        case COMA:
+          jj_consume_token(COMA);
+          scale = integerLiteral();
+          break;
+        default:
+          jj_la1[17] = jj_gen;
+          ;
+        }
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                                                lenght = temp;
+        break;
+      default:
+        jj_la1[18] = jj_gen;
+        ;
+      }
+      break;
+    case FLOAT:
+      jj_consume_token(FLOAT);
+                          type = DataFieldMetadata.NUMERIC_FIELD;               lenght = floatLenght;
+      break;
+    case INT:
+      jj_consume_token(INT);
+                        type = DataFieldMetadata.INTEGER_FIELD;                 lenght = integerLenght;
+      break;
+    case INTEGER:
+      jj_consume_token(INTEGER);
+                            type = DataFieldMetadata.INTEGER_FIELD;     lenght = integerLenght;
+      break;
+    case SMALLINT:
+      jj_consume_token(SMALLINT);
+                             type = DataFieldMetadata.INTEGER_FIELD;    lenght = integerLenght;
+      break;
+    case TIMESTAMP:
+      jj_consume_token(TIMESTAMP);
+                              type = DataFieldMetadata.DATE_FIELD;              lenght = dateTimeLenght;
+      break;
+    case NUMERIC:
+      jj_consume_token(NUMERIC);
+                            type = DataFieldMetadata.DECIMAL_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        switch (jj_nt.kind) {
+        case COMA:
+          jj_consume_token(COMA);
+          scale = integerLiteral();
+          break;
+        default:
+          jj_la1[19] = jj_gen;
+          ;
+        }
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                                                lenght = temp;
+        break;
+      default:
+        jj_la1[20] = jj_gen;
+        ;
+      }
+      break;
+    case VARCHAR:
+      jj_consume_token(VARCHAR);
+                            type = DataFieldMetadata.STRING_FIELD;
+      jj_consume_token(OPENPAREN);
+      temp = integerLiteral();
+      jj_consume_token(CLOSEPAREN);
+                                                                                                                           lenght = temp;
+      break;
+    case VARCHAR2:
+      jj_consume_token(VARCHAR2);
+                             type = DataFieldMetadata.STRING_FIELD;
+      jj_consume_token(OPENPAREN);
+      temp = integerLiteral();
+      jj_consume_token(CLOSEPAREN);
+                                                                                                                           lenght = temp;
+      break;
+    default:
+      jj_la1[21] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+          {if (true) return new DataType(type, lenght, scale);}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public Object defaultValue() throws ParseException {
+        Object ret;
+    switch (jj_nt.kind) {
+    case STRING_LITERAL:
+    case INTEGER_LITERAL:
+    case FLOAT_LITERAL:
+      ret = literal();
+      break;
+    case NULL:
+      ret = nullLiteral();
+      break;
+    default:
+      jj_la1[22] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+          {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public BigDecimal floatLiteral() throws ParseException {
+    jj_consume_token(FLOAT_LITERAL);
+                          {if (true) return new BigDecimal(token.image);}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public String identifier() throws ParseException {
+    jj_consume_token(IDENTIFIER);
+          {if (true) return token.image;}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public void identifierList() throws ParseException {
+    identifier();
+    label_2:
+    while (true) {
+      switch (jj_nt.kind) {
+      case COMA:
+        ;
+        break;
+      default:
+        jj_la1[23] = jj_gen;
+        break label_2;
+      }
+      jj_consume_token(COMA);
+      identifier();
+    }
+  }
+
+//+
+  final public Object literal() throws ParseException {
+        Object ret;
+    switch (jj_nt.kind) {
+    case INTEGER_LITERAL:
+      ret = integerLiteral();
+      break;
+    case FLOAT_LITERAL:
+      ret = floatLiteral();
+      break;
+    case STRING_LITERAL:
+      ret = stringLiteral();
+      break;
+    default:
+      jj_la1[24] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+          {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public Long integerLiteral() throws ParseException {
+    jj_consume_token(INTEGER_LITERAL);
+                            {if (true) return new Long(token.image);}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public Object nullLiteral() throws ParseException {
+    jj_consume_token(NULL);
+                 {if (true) return null;}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public String stringLiteral() throws ParseException {
+    jj_consume_token(STRING_LITERAL);
+                String value = token.image.intern();
+                {if (true) return value.substring(1, value.length() - 1);}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public void tableName() throws ParseException {
+    jj_consume_token(IDENTIFIER);
+  }
+
+  final private boolean jj_2_1(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_1(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(0, xla); }
+  }
+
+  final private boolean jj_2_2(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_2(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(1, xla); }
+  }
+
+  final private boolean jj_3R_3() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    return false;
+  }
+
+  final private boolean jj_3_2() {
+    if (jj_3R_3()) return true;
+    if (jj_scan_token(DOT)) return true;
+    return false;
+  }
+
+  final private boolean jj_3_1() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    if (jj_scan_token(DOT)) return true;
+    return false;
+  }
+
+  public DML2CloverTokenManager token_source;
+  SimpleCharStream jj_input_stream;
+  public Token token, jj_nt;
+  private Token jj_scanpos, jj_lastpos;
+  private int jj_la;
+  public boolean lookingAhead = false;
+  private boolean jj_semLA;
+  private int jj_gen;
+  final private int[] jj_la1 = new int[25];
+  static private int[] jj_la1_0;
+  static private int[] jj_la1_1;
+  static {
+      jj_la1_0();
+      jj_la1_1();
+   }
+   private static void jj_la1_0() {
+      jj_la1_0 = new int[] {0x44000000,0x1000000,0x1000000,0x0,0x0,0x44000000,0x44000000,0x1,0x80000000,0x800000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1a79f000,0x0,0x0,0x0,};
+   }
+   private static void jj_la1_1() {
+      jj_la1_1 = new int[] {0x800,0x10,0x10,0x8,0x800000,0x0,0x0,0x0,0x1060,0x0,0x1060,0x2000000,0x2000000,0x2000000,0x2000000,0x800000,0x2000000,0x800000,0x2000000,0x800000,0x2000000,0x6504,0x38001,0x800000,0x38000,};
+   }
+  final private JJCalls[] jj_2_rtns = new JJCalls[2];
+  private boolean jj_rescan = false;
+  private int jj_gc = 0;
+
+  public DML2Clover(java.io.InputStream stream) {
+     this(stream, null);
+  }
+  public DML2Clover(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source = new DML2CloverTokenManager(jj_input_stream);
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public void ReInit(java.io.InputStream stream) {
+     ReInit(stream, null);
+  }
+  public void ReInit(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public DML2Clover(java.io.Reader stream) {
+    jj_input_stream = new SimpleCharStream(stream, 1, 1);
+    token_source = new DML2CloverTokenManager(jj_input_stream);
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public void ReInit(java.io.Reader stream) {
+    jj_input_stream.ReInit(stream, 1, 1);
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public DML2Clover(DML2CloverTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public void ReInit(DML2CloverTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  final private Token jj_consume_token(int kind) throws ParseException {
+    Token oldToken = token;
+    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
+    else jj_nt = jj_nt.next = token_source.getNextToken();
+    if (token.kind == kind) {
+      jj_gen++;
+      if (++jj_gc > 100) {
+        jj_gc = 0;
+        for (int i = 0; i < jj_2_rtns.length; i++) {
+          JJCalls c = jj_2_rtns[i];
+          while (c != null) {
+            if (c.gen < jj_gen) c.first = null;
+            c = c.next;
+          }
+        }
+      }
+      return token;
+    }
+    jj_nt = token;
+    token = oldToken;
+    jj_kind = kind;
+    throw generateParseException();
+  }
+
+  static private final class LookaheadSuccess extends java.lang.Error { }
+  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
+  final private boolean jj_scan_token(int kind) {
+    if (jj_scanpos == jj_lastpos) {
+      jj_la--;
+      if (jj_scanpos.next == null) {
+        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
+      } else {
+        jj_lastpos = jj_scanpos = jj_scanpos.next;
+      }
+    } else {
+      jj_scanpos = jj_scanpos.next;
+    }
+    if (jj_rescan) {
+      int i = 0; Token tok = token;
+      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
+      if (tok != null) jj_add_error_token(kind, i);
+    }
+    if (jj_scanpos.kind != kind) return true;
+    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
+    return false;
+  }
+
+  final public Token getNextToken() {
+    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
+    else jj_nt = jj_nt.next = token_source.getNextToken();
+    jj_gen++;
+    return token;
+  }
+
+  final public Token getToken(int index) {
+    Token t = lookingAhead ? jj_scanpos : token;
+    for (int i = 0; i < index; i++) {
+      if (t.next != null) t = t.next;
+      else t = t.next = token_source.getNextToken();
+    }
+    return t;
+  }
+
+  private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();
+  private int[] jj_expentry;
+  private int jj_kind = -1;
+  private int[] jj_lasttokens = new int[100];
+  private int jj_endpos;
+
+  private void jj_add_error_token(int kind, int pos) {
+    if (pos >= 100) return;
+    if (pos == jj_endpos + 1) {
+      jj_lasttokens[jj_endpos++] = kind;
+    } else if (jj_endpos != 0) {
+      jj_expentry = new int[jj_endpos];
+      for (int i = 0; i < jj_endpos; i++) {
+        jj_expentry[i] = jj_lasttokens[i];
+      }
+      boolean exists = false;
+      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
+        int[] oldentry = (int[])(e.nextElement());
+        if (oldentry.length == jj_expentry.length) {
+          exists = true;
+          for (int i = 0; i < jj_expentry.length; i++) {
+            if (oldentry[i] != jj_expentry[i]) {
+              exists = false;
+              break;
+            }
+          }
+          if (exists) break;
+        }
+      }
+      if (!exists) jj_expentries.addElement(jj_expentry);
+      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
+    }
+  }
+
+  public ParseException generateParseException() {
+    jj_expentries.removeAllElements();
+    boolean[] la1tokens = new boolean[59];
+    for (int i = 0; i < 59; i++) {
+      la1tokens[i] = false;
+    }
+    if (jj_kind >= 0) {
+      la1tokens[jj_kind] = true;
+      jj_kind = -1;
+    }
+    for (int i = 0; i < 25; i++) {
+      if (jj_la1[i] == jj_gen) {
+        for (int j = 0; j < 32; j++) {
+          if ((jj_la1_0[i] & (1<<j)) != 0) {
+            la1tokens[j] = true;
+          }
+          if ((jj_la1_1[i] & (1<<j)) != 0) {
+            la1tokens[32+j] = true;
+          }
+        }
+      }
+    }
+    for (int i = 0; i < 59; i++) {
+      if (la1tokens[i]) {
+        jj_expentry = new int[1];
+        jj_expentry[0] = i;
+        jj_expentries.addElement(jj_expentry);
+      }
+    }
+    jj_endpos = 0;
+    jj_rescan_token();
+    jj_add_error_token(0, 0);
+    int[][] exptokseq = new int[jj_expentries.size()][];
+    for (int i = 0; i < jj_expentries.size(); i++) {
+      exptokseq[i] = (int[])jj_expentries.elementAt(i);
+    }
+    return new ParseException(token, exptokseq, tokenImage);
+  }
+
+  final public void enable_tracing() {
+  }
+
+  final public void disable_tracing() {
+  }
+
+  final private void jj_rescan_token() {
+    jj_rescan = true;
+    for (int i = 0; i < 2; i++) {
+    try {
+      JJCalls p = jj_2_rtns[i];
+      do {
+        if (p.gen > jj_gen) {
+          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
+          switch (i) {
+            case 0: jj_3_1(); break;
+            case 1: jj_3_2(); break;
+          }
+        }
+        p = p.next;
+      } while (p != null);
+      } catch(LookaheadSuccess ls) { }
+    }
+    jj_rescan = false;
+  }
+
+  final private void jj_save(int index, int xla) {
+    JJCalls p = jj_2_rtns[index];
+    while (p.gen > jj_gen) {
+      if (p.next == null) { p = p.next = new JJCalls(); break; }
+      p = p.next;
+    }
+    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
+  }
+
+  static final class JJCalls {
+    int gen;
+    Token first;
+    int arg;
+    JJCalls next;
+  }
+
+}

Added: trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverConstants.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverConstants.java	2007-02-20 13:36:20 UTC (rev 2492)
+++ trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverConstants.java	2007-02-20 13:57:34 UTC (rev 2493)
@@ -0,0 +1,121 @@
+/* Generated By:JavaCC: Do not edit this line. DML2CloverConstants.java */
+package org.jetel.util.dml2clover;
+
+public interface DML2CloverConstants {
+
+  int EOF = 0;
+  int BOOLEAN = 12;
+  int BLOB = 13;
+  int CHAR = 14;
+  int CHARACTER = 15;
+  int CLOB = 16;
+  int COMMIT = 17;
+  int CREATE = 18;
+  int DATE = 19;
+  int DATETIME = 20;
+  int DEC = 21;
+  int DECIMAL = 22;
+  int DEFAULT_ = 23;
+  int DELETE = 24;
+  int FLOAT = 25;
+  int GLOBAL = 26;
+  int INT = 27;
+  int INTEGER = 28;
+  int KEY = 29;
+  int LOCAL = 30;
+  int NOT = 31;
+  int NULL = 32;
+  int NUMBER = 33;
+  int NUMERIC = 34;
+  int ON = 35;
+  int PRESERVE = 36;
+  int PRIMARY = 37;
+  int REFERENCES = 38;
+  int ROWS = 39;
+  int SMALLINT = 40;
+  int TABLE = 41;
+  int TIMESTAMP = 42;
+  int TEMPORARY = 43;
+  int UNIQUE = 44;
+  int VARCHAR = 45;
+  int VARCHAR2 = 46;
+  int STRING_LITERAL = 47;
+  int INTEGER_LITERAL = 48;
+  int FLOAT_LITERAL = 49;
+  int EXP = 50;
+  int IDENTIFIER = 51;
+  int LETTER = 52;
+  int DIGIT = 53;
+  int CLOSEPAREN = 54;
+  int COMA = 55;
+  int DOT = 56;
+  int OPENPAREN = 57;
+  int SEMICOLON = 58;
+
+  int DEFAULT = 0;
+  int WithinComment = 1;
+  int WithinLineComment = 2;
+
+  String[] tokenImage = {
+    "<EOF>",
+    "\" \"",
+    "\"\\t\"",
+    "\"\\n\"",
+    "\"\\r\"",
+    "\"\\n\\r\"",
+    "\"/*\"",
+    "\"*/\"",
+    "<token of kind 8>",
+    "\"//\"",
+    "\"\\n\"",
+    "<token of kind 11>",
+    "\"boolean\"",
+    "\"blob\"",
+    "\"char\"",
+    "\"character\"",
+    "\"clob\"",
+    "\"commit\"",
+    "\"create\"",
+    "\"date\"",
+    "\"datetime\"",
+    "\"dec\"",
+    "\"decimal\"",
+    "\"default\"",
+    "\"delete\"",
+    "\"float\"",
+    "\"global\"",
+    "\"int\"",
+    "\"integer\"",
+    "\"key\"",
+    "\"local\"",
+    "\"not\"",
+    "\"null\"",
+    "\"number\"",
+    "\"numeric\"",
+    "\"on\"",
+    "\"preserve\"",
+    "\"primary\"",
+    "\"references\"",
+    "\"rows\"",
+    "\"smallint\"",
+    "\"table\"",
+    "\"timestamp\"",
+    "\"TEMPORARY\"",
+    "\"unique\"",
+    "\"varchar\"",
+    "\"varchar2\"",
+    "<STRING_LITERAL>",
+    "<INTEGER_LITERAL>",
+    "<FLOAT_LITERAL>",
+    "<EXP>",
+    "<IDENTIFIER>",
+    "<LETTER>",
+    "<DIGIT>",
+    "\")\"",
+    "\",\"",
+    "\".\"",
+    "\"(\"",
+    "\";\"",
+  };
+
+}

Added: trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverTokenManager.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverTokenManager.java	2007-02-20 13:36:20 UTC (rev 2492)
+++ trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverTokenManager.java	2007-02-20 13:57:34 UTC (rev 2493)
@@ -0,0 +1,1197 @@
+/* Generated By:JavaCC: Do not edit this line. DML2CloverTokenManager.java */
+package org.jetel.util.dml2clover;
+import java.util.*;
+import java.io.*;
+import org.jetel.metadata.*;
+import java.math.*;
+
+public class DML2CloverTokenManager implements DML2CloverConstants
+{
+  public  java.io.PrintStream debugStream = System.out;
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_0(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x7ffffffff000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            return 25;
+         }
+         if ((active0 & 0x100000000000000L) != 0L)
+            return 7;
+         return -1;
+      case 1:
+         if ((active0 & 0x7ff7fffff000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 1;
+            return 25;
+         }
+         if ((active0 & 0x800000000L) != 0L)
+            return 25;
+         return -1;
+      case 2:
+         if ((active0 & 0x7ff7479ff000L) != 0L)
+         {
+            if (jjmatchedPos != 2)
+            {
+               jjmatchedKind = 51;
+               jjmatchedPos = 2;
+            }
+            return 25;
+         }
+         if ((active0 & 0xb8600000L) != 0L)
+            return 25;
+         return -1;
+      case 3:
+         if ((active0 & 0x7f7657c61000L) != 0L)
+         {
+            if (jjmatchedPos != 3)
+            {
+               jjmatchedKind = 51;
+               jjmatchedPos = 3;
+            }
+            return 25;
+         }
+         if ((active0 & 0x810019e000L) != 0L)
+            return 25;
+         return -1;
+      case 4:
+         if ((active0 & 0x20042000000L) != 0L)
+            return 25;
+         if ((active0 & 0x7d7615d69000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 4;
+            return 25;
+         }
+         return -1;
+      case 5:
+         if ((active0 & 0x6d7410d09000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 5;
+            return 25;
+         }
+         if ((active0 & 0x100205060000L) != 0L)
+            return 25;
+         return -1;
+      case 6:
+         if ((active0 & 0xd5000108000L) != 0L)
+         {
+            if (jjmatchedPos != 6)
+            {
+               jjmatchedKind = 51;
+               jjmatchedPos = 6;
+            }
+            return 25;
+         }
+         if ((active0 & 0x602410c01000L) != 0L)
+            return 25;
+         return -1;
+      case 7:
+         if ((active0 & 0x400000000000L) != 0L)
+            return 24;
+         if ((active0 & 0x11000100000L) != 0L)
+            return 25;
+         if ((active0 & 0xc4000008000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 7;
+            return 25;
+         }
+         return -1;
+      case 8:
+         if ((active0 & 0x4000000000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 8;
+            return 25;
+         }
+         if ((active0 & 0xc0000008000L) != 0L)
+            return 25;
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_0(int pos, long active0)
+{
+   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
+}
+private final int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private final int jjStartNfaWithStates_0(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_0(state, pos + 1);
+}
+private final int jjMoveStringLiteralDfa0_0()
+{
+   switch(curChar)
+   {
+      case 10:
+         jjmatchedKind = 3;
+         return jjMoveStringLiteralDfa1_0(0x20L);
+      case 40:
+         return jjStopAtPos(0, 57);
+      case 41:
+         return jjStopAtPos(0, 54);
+      case 44:
+         return jjStopAtPos(0, 55);
+      case 46:
+         return jjStartNfaWithStates_0(0, 56, 7);
+      case 47:
+         return jjMoveStringLiteralDfa1_0(0x240L);
+      case 59:
+         return jjStopAtPos(0, 58);
+      case 66:
+      case 98:
+         return jjMoveStringLiteralDfa1_0(0x3000L);
+      case 67:
+      case 99:
+         return jjMoveStringLiteralDfa1_0(0x7c000L);
+      case 68:
+      case 100:
+         return jjMoveStringLiteralDfa1_0(0x1f80000L);
+      case 70:
+      case 102:
+         return jjMoveStringLiteralDfa1_0(0x2000000L);
+      case 71:
+      case 103:
+         return jjMoveStringLiteralDfa1_0(0x4000000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa1_0(0x18000000L);
+      case 75:
+      case 107:
+         return jjMoveStringLiteralDfa1_0(0x20000000L);
+      case 76:
+      case 108:
+         return jjMoveStringLiteralDfa1_0(0x40000000L);
+      case 78:
+      case 110:
+         return jjMoveStringLiteralDfa1_0(0x780000000L);
+      case 79:
+      case 111:
+         return jjMoveStringLiteralDfa1_0(0x800000000L);
+      case 80:
+      case 112:
+         return jjMoveStringLiteralDfa1_0(0x3000000000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa1_0(0xc000000000L);
+      case 83:
+      case 115:
+         return jjMoveStringLiteralDfa1_0(0x10000000000L);
+      case 84:
+      case 116:
+         return jjMoveStringLiteralDfa1_0(0xe0000000000L);
+      case 85:
+      case 117:
+         return jjMoveStringLiteralDfa1_0(0x100000000000L);
+      case 86:
+      case 118:
+         return jjMoveStringLiteralDfa1_0(0x600000000000L);
+      default :
+         return jjMoveNfa_0(0, 0);
+   }
+}
+private final int jjMoveStringLiteralDfa1_0(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 13:
+         if ((active0 & 0x20L) != 0L)
+            return jjStopAtPos(1, 5);
+         break;
+      case 42:
+         if ((active0 & 0x40L) != 0L)
+            return jjStopAtPos(1, 6);
+         break;
+      case 47:
+         if ((active0 & 0x200L) != 0L)
+            return jjStopAtPos(1, 9);
+         break;
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa2_0(active0, 0x620000180000L);
+      case 69:
+      case 101:
+         return jjMoveStringLiteralDfa2_0(active0, 0x84021e00000L);
+      case 72:
+      case 104:
+         return jjMoveStringLiteralDfa2_0(active0, 0xc000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa2_0(active0, 0x40000000000L);
+      case 76:
+      case 108:
+         return jjMoveStringLiteralDfa2_0(active0, 0x6012000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa2_0(active0, 0x10000000000L);
+      case 78:
+      case 110:
+         if ((active0 & 0x800000000L) != 0L)
+            return jjStartNfaWithStates_0(1, 35, 25);
+         return jjMoveStringLiteralDfa2_0(active0, 0x100018000000L);
+      case 79:
+      case 111:
+         return jjMoveStringLiteralDfa2_0(active0, 0x80c0021000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa2_0(active0, 0x3000040000L);
+      case 85:
+      case 117:
+         return jjMoveStringLiteralDfa2_0(active0, 0x700000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(0, active0);
+}
+private final int jjMoveStringLiteralDfa2_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(0, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(1, active0);
+      return 2;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa3_0(active0, 0x1000000c000L);
+      case 66:
+      case 98:
+         return jjMoveStringLiteralDfa3_0(active0, 0x20000000000L);
+      case 67:
+      case 99:
+         if ((active0 & 0x200000L) != 0L)
+         {
+            jjmatchedKind = 21;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x40400000L);
+      case 69:
+      case 101:
+         return jjMoveStringLiteralDfa3_0(active0, 0x1000040000L);
+      case 70:
+      case 102:
+         return jjMoveStringLiteralDfa3_0(active0, 0x4000800000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa3_0(active0, 0x102000000000L);
+      case 76:
+      case 108:
+         return jjMoveStringLiteralDfa3_0(active0, 0x101000000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa3_0(active0, 0xc0600020000L);
+      case 79:
+      case 111:
+         return jjMoveStringLiteralDfa3_0(active0, 0x6013000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa3_0(active0, 0x600000000000L);
+      case 84:
+      case 116:
+         if ((active0 & 0x8000000L) != 0L)
+         {
+            jjmatchedKind = 27;
+            jjmatchedPos = 2;
+         }
+         else if ((active0 & 0x80000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 31, 25);
+         return jjMoveStringLiteralDfa3_0(active0, 0x10180000L);
+      case 87:
+      case 119:
+         return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L);
+      case 89:
+      case 121:
+         if ((active0 & 0x20000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 29, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(1, active0);
+}
+private final int jjMoveStringLiteralDfa3_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(1, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(2, active0);
+      return 3;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa4_0(active0, 0x42840000L);
+      case 66:
+      case 98:
+         if ((active0 & 0x2000L) != 0L)
+            return jjStartNfaWithStates_0(3, 13, 25);
+         else if ((active0 & 0x10000L) != 0L)
+            return jjStartNfaWithStates_0(3, 16, 25);
+         return jjMoveStringLiteralDfa4_0(active0, 0x204000000L);
+      case 67:
+      case 99:
+         return jjMoveStringLiteralDfa4_0(active0, 0x600000000000L);
+      case 69:
+      case 101:
+         if ((active0 & 0x80000L) != 0L)
+         {
+            jjmatchedKind = 19;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x44411100000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa4_0(active0, 0x400000L);
+      case 76:
+      case 108:
+         if ((active0 & 0x100000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 32, 25);
+         return jjMoveStringLiteralDfa4_0(active0, 0x30000001000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa4_0(active0, 0x2000020000L);
+      case 80:
+      case 112:
+         return jjMoveStringLiteralDfa4_0(active0, 0x80000000000L);
+      case 81:
+      case 113:
+         return jjMoveStringLiteralDfa4_0(active0, 0x100000000000L);
+      case 82:
+      case 114:
+         if ((active0 & 0x4000L) != 0L)
+         {
+            jjmatchedKind = 14;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x8000L);
+      case 83:
+      case 115:
+         if ((active0 & 0x8000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 39, 25);
+         return jjMoveStringLiteralDfa4_0(active0, 0x1000000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(2, active0);
+}
+private final int jjMoveStringLiteralDfa4_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(2, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(3, active0);
+      return 4;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa5_0(active0, 0x2004008000L);
+      case 69:
+      case 101:
+         if ((active0 & 0x20000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 41, 25);
+         return jjMoveStringLiteralDfa5_0(active0, 0x1200001000L);
+      case 71:
+      case 103:
+         return jjMoveStringLiteralDfa5_0(active0, 0x10000000L);
+      case 72:
+      case 104:
+         return jjMoveStringLiteralDfa5_0(active0, 0x600000000000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa5_0(active0, 0x20000L);
+      case 76:
+      case 108:
+         if ((active0 & 0x40000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 30, 25);
+         return jjMoveStringLiteralDfa5_0(active0, 0x10000000000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa5_0(active0, 0x400000L);
+      case 79:
+      case 111:
+         return jjMoveStringLiteralDfa5_0(active0, 0x80000000000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa5_0(active0, 0x4400000000L);
+      case 83:
+      case 115:
+         return jjMoveStringLiteralDfa5_0(active0, 0x40000000000L);
+      case 84:
+      case 116:
+         if ((active0 & 0x2000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 25, 25);
+         return jjMoveStringLiteralDfa5_0(active0, 0x1140000L);
+      case 85:
+      case 117:
+         return jjMoveStringLiteralDfa5_0(active0, 0x100000800000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(3, active0);
+}
+private final int jjMoveStringLiteralDfa5_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(3, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(4, active0);
+      return 5;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa6_0(active0, 0x600000401000L);
+      case 67:
+      case 99:
+         return jjMoveStringLiteralDfa6_0(active0, 0x8000L);
+      case 69:
+      case 101:
+         if ((active0 & 0x40000L) != 0L)
+            return jjStartNfaWithStates_0(5, 18, 25);
+         else if ((active0 & 0x1000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 24, 25);
+         else if ((active0 & 0x100000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 44, 25);
+         return jjMoveStringLiteralDfa6_0(active0, 0x4010000000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa6_0(active0, 0x10400100000L);
+      case 76:
+      case 108:
+         if ((active0 & 0x4000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 26, 25);
+         return jjMoveStringLiteralDfa6_0(active0, 0x800000L);
+      case 82:
+      case 114:
+         if ((active0 & 0x200000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 33, 25);
+         return jjMoveStringLiteralDfa6_0(active0, 0x83000000000L);
+      case 84:
+      case 116:
+         if ((active0 & 0x20000L) != 0L)
+            return jjStartNfaWithStates_0(5, 17, 25);
+         return jjMoveStringLiteralDfa6_0(active0, 0x40000000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(4, active0);
+}
+private final int jjMoveStringLiteralDfa6_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(4, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(5, active0);
+      return 6;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa7_0(active0, 0xc0000000000L);
+      case 67:
+      case 99:
+         if ((active0 & 0x400000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 34, 25);
+         break;
+      case 76:
+      case 108:
+         if ((active0 & 0x400000L) != 0L)
+            return jjStartNfaWithStates_0(6, 22, 25);
+         break;
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa7_0(active0, 0x100000L);
+      case 78:
+      case 110:
+         if ((active0 & 0x1000L) != 0L)
+            return jjStartNfaWithStates_0(6, 12, 25);
+         return jjMoveStringLiteralDfa7_0(active0, 0x14000000000L);
+      case 82:
+      case 114:
+         if ((active0 & 0x10000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 28, 25);
+         else if ((active0 & 0x200000000000L) != 0L)
+         {
+            jjmatchedKind = 45;
+            jjmatchedPos = 6;
+         }
+         return jjMoveStringLiteralDfa7_0(active0, 0x400000000000L);
+      case 84:
+      case 116:
+         if ((active0 & 0x800000L) != 0L)
+            return jjStartNfaWithStates_0(6, 23, 25);
+         return jjMoveStringLiteralDfa7_0(active0, 0x8000L);
+      case 86:
+      case 118:
+         return jjMoveStringLiteralDfa7_0(active0, 0x1000000000L);
+      case 89:
+      case 121:
+         if ((active0 & 0x2000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 37, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(5, active0);
+}
+private final int jjMoveStringLiteralDfa7_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(5, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(6, active0);
+      return 7;
+   }
+   switch(curChar)
+   {
+      case 50:
+         if ((active0 & 0x400000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 46, 24);
+         break;
+      case 67:
+      case 99:
+         return jjMoveStringLiteralDfa8_0(active0, 0x4000000000L);
+      case 69:
+      case 101:
+         if ((active0 & 0x100000L) != 0L)
+            return jjStartNfaWithStates_0(7, 20, 25);
+         else if ((active0 & 0x1000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 36, 25);
+         return jjMoveStringLiteralDfa8_0(active0, 0x8000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa8_0(active0, 0x40000000000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa8_0(active0, 0x80000000000L);
+      case 84:
+      case 116:
+         if ((active0 & 0x10000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 40, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(6, active0);
+}
+private final int jjMoveStringLiteralDfa8_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(6, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(7, active0);
+      return 8;
+   }
+   switch(curChar)
+   {
+      case 69:
+      case 101:
+         return jjMoveStringLiteralDfa9_0(active0, 0x4000000000L);
+      case 80:
+      case 112:
+         if ((active0 & 0x40000000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 42, 25);
+         break;
+      case 82:
+      case 114:
+         if ((active0 & 0x8000L) != 0L)
+            return jjStartNfaWithStates_0(8, 15, 25);
+         break;
+      case 89:
+      case 121:
+         if ((active0 & 0x80000000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 43, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(7, active0);
+}
+private final int jjMoveStringLiteralDfa9_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(7, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(8, active0);
+      return 9;
+   }
+   switch(curChar)
+   {
+      case 83:
+      case 115:
+         if ((active0 & 0x4000000000L) != 0L)
+            return jjStartNfaWithStates_0(9, 38, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(8, active0);
+}
+private final void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private final void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private final void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+private final void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+private final void jjCheckNAddStates(int start)
+{
+   jjCheckNAdd(jjnextStates[start]);
+   jjCheckNAdd(jjnextStates[start + 1]);
+}
+static final long[] jjbitVec0 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+private final int jjMoveNfa_0(int startState, int curPos)
+{
+   int[] nextStates;
+   int startsAt = 0;
+   jjnewStateCnt = 25;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int j, kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         MatchLoop: do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x3ff000000000000L & l) != 0L)
+                  {
+                     if (kind > 48)
+                        kind = 48;
+                     jjCheckNAddStates(0, 4);
+                  }
+                  else if (curChar == 46)
+                     jjCheckNAdd(7);
+                  else if (curChar == 39)
+                     jjCheckNAddStates(5, 7);
+                  break;
+               case 25:
+               case 24:
+                  if ((0x3ff001800000000L & l) == 0L)
+                     break;
+                  if (kind > 51)
+                     kind = 51;
+                  jjCheckNAdd(24);
+                  break;
+               case 1:
+                  if ((0xffffff7fffffffffL & l) != 0L)
+                     jjCheckNAddStates(5, 7);
+                  break;
+               case 2:
+                  if (curChar == 39)
+                     jjCheckNAddStates(8, 10);
+                  break;
+               case 3:
+                  if (curChar == 39)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  break;
+               case 4:
+                  if ((0xffffff7fffffffffL & l) != 0L)
+                     jjCheckNAddStates(8, 10);
+                  break;
+               case 5:
+                  if (curChar == 39 && kind > 47)
+                     kind = 47;
+                  break;
+               case 6:
+                  if (curChar == 46)
+                     jjCheckNAdd(7);
+                  break;
+               case 7:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 49)
+                     kind = 49;
+                  jjCheckNAddTwoStates(7, 8);
+                  break;
+               case 9:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(10);
+                  break;
+               case 10:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 49)
+                     kind = 49;
+                  jjCheckNAdd(10);
+                  break;
+               case 11:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 48)
+                     kind = 48;
+                  jjCheckNAddStates(0, 4);
+                  break;
+               case 12:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 48)
+                     kind = 48;
+                  jjCheckNAdd(12);
+                  break;
+               case 13:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(13, 14);
+                  break;
+               case 14:
+                  if (curChar == 46)
+                     jjCheckNAdd(15);
+                  break;
+               case 15:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 49)
+                     kind = 49;
+                  jjCheckNAddTwoStates(15, 16);
+                  break;
+               case 17:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(18);
+                  break;
+               case 18:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 49)
+                     kind = 49;
+                  jjCheckNAdd(18);
+                  break;
+               case 19:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 49)
+                     kind = 49;
+                  jjCheckNAddTwoStates(19, 20);
+                  break;
+               case 21:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(22);
+                  break;
+               case 22:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 49)
+                     kind = 49;
+                  jjCheckNAdd(22);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         MatchLoop: do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 23:
+                  if ((0x7fffffe07fffffeL & l) == 0L)
+                     break;
+                  if (kind > 51)
+                     kind = 51;
+                  jjCheckNAddTwoStates(23, 24);
+                  break;
+               case 25:
+                  if ((0x7fffffe87fffffeL & l) != 0L)
+                  {
+                     if (kind > 51)
+                        kind = 51;
+                     jjCheckNAdd(24);
+                  }
+                  if ((0x7fffffe07fffffeL & l) != 0L)
+                  {
+                     if (kind > 51)
+                        kind = 51;
+                     jjCheckNAddTwoStates(23, 24);
+                  }
+                  break;
+               case 1:
+                  jjCheckNAddStates(5, 7);
+                  break;
+               case 4:
+                  jjCheckNAddStates(8, 10);
+                  break;
+               case 8:
+                  if ((0x2000000020L & l) != 0L)
+                     jjAddStates(11, 12);
+                  break;
+               case 16:
+                  if ((0x2000000020L & l) != 0L)
+                     jjAddStates(13, 14);
+                  break;
+               case 20:
+                  if ((0x2000000020L & l) != 0L)
+                     jjAddStates(15, 16);
+                  break;
+               case 24:
+                  if ((0x7fffffe87fffffeL & l) == 0L)
+                     break;
+                  if (kind > 51)
+                     kind = 51;
+                  jjCheckNAdd(24);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         MatchLoop: do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 1:
+                  if ((jjbitVec0[i2] & l2) != 0L)
+                     jjCheckNAddStates(5, 7);
+                  break;
+               case 4:
+                  if ((jjbitVec0[i2] & l2) != 0L)
+                     jjCheckNAddStates(8, 10);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 25 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private final int jjMoveStringLiteralDfa0_2()
+{
+   switch(curChar)
+   {
+      case 10:
+         return jjStopAtPos(0, 10);
+      default :
+         return 1;
+   }
+}
+private final int jjMoveStringLiteralDfa0_1()
+{
+   switch(curChar)
+   {
+      case 42:
+         return jjMoveStringLiteralDfa1_1(0x80L);
+      default :
+         return 1;
+   }
+}
+private final int jjMoveStringLiteralDfa1_1(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 47:
+         if ((active0 & 0x80L) != 0L)
+            return jjStopAtPos(1, 7);
+         break;
+      default :
+         return 2;
+   }
+   return 2;
+}
+static final int[] jjnextStates = {
+   12, 13, 14, 19, 20, 1, 3, 5, 3, 4, 5, 9, 10, 17, 18, 21, 
+   22, 
+};
+public static final String[] jjstrLiteralImages = {
+"", null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, "\51", 
+"\54", "\56", "\50", "\73", };
+public static final String[] lexStateNames = {
+   "DEFAULT", 
+   "WithinComment", 
+   "WithinLineComment", 
+};
+public static final int[] jjnewLexState = {
+   -1, -1, -1, -1, -1, -1, 1, 0, -1, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+};
+static final long[] jjtoToken = {
+   0x7fbfffffffff001L, 
+};
+static final long[] jjtoSkip = {
+   0x6feL, 
+};
+static final long[] jjtoSpecial = {
+   0x6c0L, 
+};
+static final long[] jjtoMore = {
+   0x900L, 
+};
+protected SimpleCharStream input_stream;
+private final int[] jjrounds = new int[25];
+private final int[] jjstateSet = new int[50];
+StringBuffer image;
+int jjimageLen;
+int lengthOfMatch;
+protected char curChar;
+public DML2CloverTokenManager(SimpleCharStream stream){
+   if (SimpleCharStream.staticFlag)
+      throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
+   input_stream = stream;
+}
+public DML2CloverTokenManager(SimpleCharStream stream, int lexState){
+   this(stream);
+   SwitchTo(lexState);
+}
+public void ReInit(SimpleCharStream stream)
+{
+   jjmatchedPos = jjnewStateCnt = 0;
+   curLexState = defaultLexState;
+   input_stream = stream;
+   ReInitRounds();
+}
+private final void ReInitRounds()
+{
+   int i;
+   jjround = 0x80000001;
+   for (i = 25; i-- > 0;)
+      jjrounds[i] = 0x80000000;
+}
+public void ReInit(SimpleCharStream stream, int lexState)
+{
+   ReInit(stream);
+   SwitchTo(lexState);
+}
+public void SwitchTo(int lexState)
+{
+   if (lexState >= 3 || lexState < 0)
+      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
+   else
+      curLexState = lexState;
+}
+
+protected Token jjFillToken()
+{
+   Token t = Token.newToken(jjmatchedKind);
+   t.kind = jjmatchedKind;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   t.image = (im == null) ? input_stream.GetImage() : im;
+   t.beginLine = input_stream.getBeginLine();
+   t.beginColumn = input_stream.getBeginColumn();
+   t.endLine = input_stream.getEndLine();
+   t.endColumn = input_stream.getEndColumn();
+   return t;
+}
+
+int curLexState = 0;
+int defaultLexState = 0;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+public Token getNextToken() 
+{
+  int kind;
+  Token specialToken = null;
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {   
+   try   
+   {     
+      curChar = input_stream.BeginToken();
+   }     
+   catch(java.io.IOException e)
+   {        
+      jjmatchedKind = 0;
+      matchedToken = jjFillToken();
+      matchedToken.specialToken = specialToken;
+      return matchedToken;
+   }
+   image = null;
+   jjimageLen = 0;
+
+   for (;;)
+   {
+     switch(curLexState)
+     {
+       case 0:
+         try { input_stream.backup(0);
+            while (curChar <= 32 && (0x100002200L & (1L << curChar)) != 0L)
+               curChar = input_stream.BeginToken();
+         }
+         catch (java.io.IOException e1) { continue EOFLoop; }
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_0();
+         break;
+       case 1:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_1();
+         if (jjmatchedPos == 0 && jjmatchedKind > 8)
+         {
+            jjmatchedKind = 8;
+         }
+         break;
+       case 2:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_2();
+         if (jjmatchedPos == 0 && jjmatchedKind > 11)
+         {
+            jjmatchedKind = 11;
+         }
+         break;
+     }
+     if (jjmatchedKind != 0x7fffffff)
+     {
+        if (jjmatchedPos + 1 < curPos)
+           input_stream.backup(curPos - jjmatchedPos - 1);
+        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           matchedToken = jjFillToken();
+           matchedToken.specialToken = specialToken;
+       if (jjnewLexState[jjmatchedKind] != -1)
+         curLexState = jjnewLexState[jjmatchedKind];
+           return matchedToken;
+        }
+        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+           {
+              matchedToken = jjFillToken();
+              if (specialToken == null)
+                 specialToken = matchedToken;
+              else
+              {
+                 matchedToken.specialToken = specialToken;
+                 specialToken = (specialToken.next = matchedToken);
+              }
+              SkipLexicalActions(matchedToken);
+           }
+           else 
+              SkipLexicalActions(null);
+         if (jjnewLexState[jjmatchedKind] != -1)
+           curLexState = jjnewLexState[jjmatchedKind];
+           continue EOFLoop;
+        }
+        jjimageLen += jjmatchedPos + 1;
+      if (jjnewLexState[jjmatchedKind] != -1)
+        curLexState = jjnewLexState[jjmatchedKind];
+        curPos = 0;
+        jjmatchedKind = 0x7fffffff;
+        try {
+           curChar = input_stream.readChar();
+           continue;
+        }
+        catch (java.io.IOException e1) { }
+     }
+     int error_line = input_stream.getEndLine();
+     int error_column = input_stream.getEndColumn();
+     String error_after = null;
+     boolean EOFSeen = false;
+     try { input_stream.readChar(); input_stream.backup(1); }
+     catch (java.io.IOException e1) {
+        EOFSeen = true;
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+        if (curChar == '\n' || curChar == '\r') {
+           error_line++;
+           error_column = 0;
+        }
+        else
+           error_column++;
+     }
+     if (!EOFSeen) {
+        input_stream.backup(1);
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+     }
+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+   }
+  }
+}
+
+void SkipLexicalActions(Token matchedToken)
+{
+   switch(jjmatchedKind)
+   {
+      default :
+         break;
+   }
+}
+}

Added: trunk/cloveretl.engine/src/org/jetel/util/dml2clover/ParseException.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/ParseException.java	2007-02-20 13:36:20 UTC (rev 2492)
+++ trunk/cloveretl.engine/src/org/jetel/util/dml2clover/ParseException.java	2007-02-20 13:57:34 UTC (rev 2493)
@@ -0,0 +1,192 @@
+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */
+package org.jetel.util.dml2clover;
+
+/**
+ * This exception is thrown when parse errors are encountered.
+ * You can explicitly create objects of this exception type by
+ * calling the method generateParseException in the generated
+ * parser.
+ *
+ * You can modify this class to customize your error reporting
+ * mechanisms so long as you retain the public fields.
+ */
+public class ParseException extends Exception {
+
+  /**
+   * This constructor is used by the method "generateParseException"
+   * in the generated parser.  Calling this constructor generates
+   * a new object of this type with the fields "currentToken",
+   * "expectedTokenSequences", and "tokenImage" set.  The boolean
+   * flag "specialConstructor" is also set to true to indicate that
+   * this constructor was used to create this object.
+   * This constructor calls its super class with the empty string
+   * to force the "toString" method of parent class "Throwable" to
+   * print the error message in the form:
+   *     ParseException: <result of getMessage>
+   */
+  public ParseException(Token currentTokenVal,
+                        int[][] expectedTokenSequencesVal,
+                        String[] tokenImageVal
+                       )
+  {
+    super("");
+    specialConstructor = true;
+    currentToken = currentTokenVal;
+    expectedTokenSequences = expectedTokenSequencesVal;
+    tokenImage = tokenImageVal;
+  }
+
+  /**
+   * The following constructors are for use by you for whatever
+   * purpose you can think of.  Constructing the exception in this
+   * manner makes the exception behave in the normal way - i.e., as
+   * documented in the class "Throwable".  The fields "errorToken",
+   * "expectedTokenSequences", and "tokenImage" do not contain
+   * relevant information.  The JavaCC generated code does not use
+   * these constructors.
+   */
+
+  public ParseException() {
+    super();
+    specialConstructor = false;
+  }
+
+  public ParseException(String message) {
+    super(message);
+    specialConstructor = false;
+  }
+
+  /**
+   * This variable determines which constructor was used to create
+   * this object and thereby affects the semantics of the
+   * "getMessage" method (see below).
+   */
+  protected boolean specialConstructor;
+
+  /**
+   * This is the last token that has been consumed successfully.  If
+   * this object has been created due to a parse error, the token
+   * followng this token will (therefore) be the first error token.
+   */
+  public Token currentToken;
+
+  /**
+   * Each entry in this array is an array of integers.  Each array
+   * of integers represents a sequence of tokens (by their ordinal
+   * values) that is expected at this point of the parse.
+   */
+  public int[][] expectedTokenSequences;
+
+  /**
+   * This is a reference to the "tokenImage" array of the generated
+   * parser within which the parse error occurred.  This array is
+   * defined in the generated ...Constants interface.
+   */
+  public String[] tokenImage;
+
+  /**
+   * This method has the standard behavior when this object has been
+   * created using the standard constructors.  Otherwise, it uses
+   * "currentToken" and "expectedTokenSequences" to generate a parse
+   * error message and returns it.  If this object has been created
+   * due to a parse error, and you do not catch it (it gets thrown
+   * from the parser), then this method is called during the printing
+   * of the final stack trace, and hence the correct error message
+   * gets displayed.
+   */
+  public String getMessage() {
+    if (!specialConstructor) {
+      return super.getMessage();
+    }
+    StringBuffer expected = new StringBuffer();
+    int maxSize = 0;
+    for (int i = 0; i < expectedTokenSequences.length; i++) {
+      if (maxSize < expectedTokenSequences[i].length) {
+        maxSize = expectedTokenSequences[i].length;
+      }
+      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
+        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(" ");
+      }
+      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
+        expected.append("...");
+      }
+      expected.append(eol).append("    ");
+    }
+    String retval = "Encountered \"";
+    Token tok = currentToken.next;
+    for (int i = 0; i < maxSize; i++) {
+      if (i != 0) retval += " ";
+      if (tok.kind == 0) {
+        retval += tokenImage[0];
+        break;
+      }
+      retval += add_escapes(tok.image);
+      tok = tok.next; 
+    }
+    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
+    retval += "." + eol;
+    if (expectedTokenSequences.length == 1) {
+      retval += "Was expecting:" + eol + "    ";
+    } else {
+      retval += "Was expecting one of:" + eol + "    ";
+    }
+    retval += expected.toString();
+    return retval;
+  }
+
+  /**
+   * The end of line string for this machine.
+   */
+  protected String eol = System.getProperty("line.separator", "\n");
+ 
+  /**
+   * Used to convert raw characters to their escaped version
+   * when these raw version cannot be used as part of an ASCII
+   * string literal.
+   */
+  protected String add_escapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+}

Added: trunk/cloveretl.engine/src/org/jetel/util/dml2clover/SimpleCharStream.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/SimpleCharStream.java	2007-02-20 13:36:20 UTC (rev 2492)
+++ trunk/cloveretl.engine/src/org/jetel/util/dml2clover/SimpleCharStream.java	2007-02-20 13:57:34 UTC (rev 2493)
@@ -0,0 +1,439 @@
+/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.0 */
+package org.jetel.util.dml2clover;
+
+/**
+ * An implementation of interface CharStream, where the stream is assumed to
+ * contain only ASCII characters (without unicode processing).
+ */
+
+public class SimpleCharStream
+{
+  public static final boolean staticFlag = false;
+  int bufsize;
+  int available;
+  int tokenBegin;
+  public int bufpos = -1;
+  protected int bufline[];
+  protected int bufcolumn[];
+
+  protected int column = 0;
+  protected int line = 1;
+
+  protected boolean prevCharIsCR = false;
+  protected boolean prevCharIsLF = false;
+
+  protected java.io.Reader inputStream;
+
+  protected char[] buffer;
+  protected int maxNextCharInd = 0;
+  protected int inBuf = 0;
+  protected int tabSize = 8;
+
+  protected void setTabSize(int i) { tabSize = i; }
+  protected int getTabSize(int i) { return tabSize; }
+
+
+  protected void ExpandBuff(boolean wrapAround)
+  {
+     char[] newbuffer = new char[bufsize + 2048];
+     int newbufline[] = new int[bufsize + 2048];
+     int newbufcolumn[] = new int[bufsize + 2048];
+
+     try
+     {
+        if (wrapAround)
+        {
+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+           System.arraycopy(buffer, 0, newbuffer,
+                                             bufsize - tokenBegin, bufpos);
+           buffer = newbuffer;
+
+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
+           bufline = newbufline;
+
+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
+           bufcolumn = newbufcolumn;
+
+           maxNextCharInd = (bufpos += (bufsize - tokenBegin));
+        }
+        else
+        {
+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+           buffer = newbuffer;
+
+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+           bufline = newbufline;
+
+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+           bufcolumn = newbufcolumn;
+
+           maxNextCharInd = (bufpos -= tokenBegin);
+        }
+     }
+     catch (Throwable t)
+     {
+        throw new Error(t.getMessage());
+     }
+
+
+     bufsize += 2048;
+     available = bufsize;
+     tokenBegin = 0;
+  }
+
+  protected void FillBuff() throws java.io.IOException
+  {
+     if (maxNextCharInd == available)
+     {
+        if (available == bufsize)
+        {
+           if (tokenBegin > 2048)
+           {
+              bufpos = maxNextCharInd = 0;
+              available = tokenBegin;
+           }
+           else if (tokenBegin < 0)
+              bufpos = maxNextCharInd = 0;
+           else
+              ExpandBuff(false);
+        }
+        else if (available > tokenBegin)
+           available = bufsize;
+        else if ((tokenBegin - available) < 2048)
+           ExpandBuff(true);
+        else
+           available = tokenBegin;
+     }
+
+     int i;
+     try {
+        if ((i = inputStream.read(buffer, maxNextCharInd,
+                                    available - maxNextCharInd)) == -1)
+        {
+           inputStream.close();
+           throw new java.io.IOException();
+        }
+        else
+           maxNextCharInd += i;
+        return;
+     }
+     catch(java.io.IOException e) {
+        --bufpos;
+        backup(0);
+        if (tokenBegin == -1)
+           tokenBegin = bufpos;
+        throw e;
+     }
+  }
+
+  public char BeginToken() throws java.io.IOException
+  {
+     tokenBegin = -1;
+     char c = readChar();
+     tokenBegin = bufpos;
+
+     return c;
+  }
+
+  protected void UpdateLineColumn(char c)
+  {
+     column++;
+
+     if (prevCharIsLF)
+     {
+        prevCharIsLF = false;
+        line += (column = 1);
+     }
+     else if (prevCharIsCR)
+     {
+        prevCharIsCR = false;
+        if (c == '\n')
+        {
+           prevCharIsLF = true;
+        }
+        else
+           line += (column = 1);
+     }
+
+     switch (c)
+     {
+        case '\r' :
+           prevCharIsCR = true;
+           break;
+        case '\n' :
+           prevCharIsLF = true;
+           break;
+        case '\t' :
+           column--;
+           column += (tabSize - (column % tabSize));
+           break;
+        default :
+           break;
+     }
+
+     bufline[bufpos] = line;
+     bufcolumn[bufpos] = column;
+  }
+
+  public char readChar() throws java.io.IOException
+  {
+     if (inBuf > 0)
+     {
+        --inBuf;
+
+        if (++bufpos == bufsize)
+           bufpos = 0;
+
+        return buffer[bufpos];
+     }
+
+     if (++bufpos >= maxNextCharInd)
+        FillBuff();
+
+     char c = buffer[bufpos];
+
+     UpdateLineColumn(c);
+     return (c);
+  }
+
+  /**
+   * @deprecated 
+   * @see #getEndColumn
+   */
+
+  public int getColumn() {
+     return bufcolumn[bufpos];
+  }
+
+  /**
+   * @deprecated 
+   * @see #getEndLine
+   */
+
+  public int getLine() {
+     return bufline[bufpos];
+  }
+
+  public int getEndColumn() {
+     return bufcolumn[bufpos];
+  }
+
+  public int getEndLine() {
+     return bufline[bufpos];
+  }
+
+  public int getBeginColumn() {
+     return bufcolumn[tokenBegin];
+  }
+
+  public int getBeginLine() {
+     return bufline[tokenBegin];
+  }
+
+  public void backup(int amount) {
+
+    inBuf += amount;
+    if ((bufpos -= amount) < 0)
+       bufpos += bufsize;
+  }
+
+  public SimpleCharStream(java.io.Reader dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    available = bufsize = buffersize;
+    buffer = new char[buffersize];
+    bufline = new int[buffersize];
+    bufcolumn = new int[buffersize];
+  }
+
+  public SimpleCharStream(java.io.Reader dstream, int startline,
+                          int startcolumn)
+  {
+     this(dstream, startline, startcolumn, 4096);
+  }
+
+  public SimpleCharStream(java.io.Reader dstream)
+  {
+     this(dstream, 1, 1, 4096);
+  }
+  public void ReInit(java.io.Reader dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    if (buffer == null || buffersize != buffer.length)
+    {
+      available = bufsize = buffersize;
+      buffer = new char[buffersize];
+      bufline = new int[buffersize];
+      bufcolumn = new int[buffersize];
+    }
+    prevCharIsLF = prevCharIsCR = false;
+    tokenBegin = inBuf = maxNextCharInd = 0;
+    bufpos = -1;
+  }
+
+  public void ReInit(java.io.Reader dstream, int startline,
+                     int startcolumn)
+  {
+     ReInit(dstream, startline, startcolumn, 4096);
+  }
+
+  public void ReInit(java.io.Reader dstream)
+  {
+     ReInit(dstream, 1, 1, 4096);
+  }
+  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+     this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+  public SimpleCharStream(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+     this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+  }
+
+  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
+                          int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+     this(dstream, encoding, startline, startcolumn, 4096);
+  }
+
+  public SimpleCharStream(java.io.InputStream dstream, int startline,
+                          int startcolumn)
+  {
+     this(dstream, startline, startcolumn, 4096);
+  }
+
+  public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+     this(dstream, encoding, 1, 1, 4096);
+  }
+
+  public SimpleCharStream(java.io.InputStream dstream)
+  {
+     this(dstream, 1, 1, 4096);
+  }
+
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+                          int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+  public void ReInit(java.io.InputStream dstream, int startline,
+                          int startcolumn, int buffersize)
+  {
+     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+  }
+
+  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(dstream, encoding, 1, 1, 4096);
+  }
+
+  public void ReInit(java.io.InputStream dstream)
+  {
+     ReInit(dstream, 1, 1, 4096);
+  }
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+                     int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(dstream, encoding, startline, startcolumn, 4096);
+  }
+  public void ReInit(java.io.InputStream dstream, int startline,
+                     int startcolumn)
+  {
+     ReInit(dstream, startline, startcolumn, 4096);
+  }
+  public String GetImage()
+  {
+     if (bufpos >= tokenBegin)
+        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
+     else
+        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
+                              new String(buffer, 0, bufpos + 1);
+  }
+
+  public char[] GetSuffix(int len)
+  {
+     char[] ret = new char[len];
+
+     if ((bufpos + 1) >= len)
+        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
+     else
+     {
+        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
+                                                          len - bufpos - 1);
+        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
+     }
+
+     return ret;
+  }
+
+  public void Done()
+  {
+     buffer = null;
+     bufline = null;
+     bufcolumn = null;
+  }
+
+  /**
+   * Method to adjust line and column numbers for the start of a token.
+   */
+  public void adjustBeginLineColumn(int newLine, int newCol)
+  {
+     int start = tokenBegin;
+     int len;
+
+     if (bufpos >= tokenBegin)
+     {
+        len = bufpos - tokenBegin + inBuf + 1;
+     }
+     else
+     {
+        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
+     }
+
+     int i = 0, j = 0, k = 0;
+     int nextColDiff = 0, columnDiff = 0;
+
+     while (i < len &&
+            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
+     {
+        bufline[j] = newLine;
+        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
+        bufcolumn[j] = newCol + columnDiff;
+        columnDiff = nextColDiff;
+        i++;
+     } 
+
+     if (i < len)
+     {
+        bufline[j] = newLine++;
+        bufcolumn[j] = newCol + columnDiff;
+
+        while (i++ < len)
+        {
+           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
+              bufline[j] = newLine++;
+           else
+              bufline[j] = newLine;
+        }
+     }
+
+     line = bufline[j];
+     column = bufcolumn[j];
+  }
+
+}

Added: trunk/cloveretl.engine/src/org/jetel/util/dml2clover/Token.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/Token.java	2007-02-20 13:36:20 UTC (rev 2492)
+++ trunk/cloveretl.engine/src/org/jetel/util/dml2clover/Token.java	2007-02-20 13:57:34 UTC (rev 2493)
@@ -0,0 +1,81 @@
+/* Generated By:JavaCC: Do not edit this line. Token.java Version 3.0 */
+package org.jetel.util.dml2clover;
+
+/**
+ * Describes the input token stream.
+ */
+
+public class Token {
+
+  /**
+   * An integer that describes the kind of this token.  This numbering
+   * system is determined by JavaCCParser, and a table of these numbers is
+   * stored in the file ...Constants.java.
+   */
+  public int kind;
+
+  /**
+   * beginLine and beginColumn describe the position of the first character
+   * of this token; endLine and endColumn describe the position of the
+   * last character of this token.
+   */
+  public int beginLine, beginColumn, endLine, endColumn;
+
+  /**
+   * The string image of the token.
+   */
+  public String image;
+
+  /**
+   * A reference to the next regular (non-special) token from the input
+   * stream.  If this is the last token from the input stream, or if the
+   * token manager has not read tokens beyond this one, this field is
+   * set to null.  This is true only if this token is also a regular
+   * token.  Otherwise, see below for a description of the contents of
+   * this field.
+   */
+  public Token next;
+
+  /**
+   * This field is used to access special tokens that occur prior to this
+   * token, but after the immediately preceding regular (non-special) token.
+   * If there are no such special tokens, this field is set to null.
+   * When there are more than one such special token, this field refers
+   * to the last of these special tokens, which in turn refers to the next
+   * previous special token through its specialToken field, and so on
+   * until the first special token (whose specialToken field is null).
+   * The next fields of special tokens refer to other special tokens that
+   * immediately follow it (without an intervening regular token).  If there
+   * is no such token, this field is null.
+   */
+  public Token specialToken;
+
+  /**
+   * Returns the image.
+   */
+  public String toString()
+  {
+     return image;
+  }
+
+  /**
+   * Returns a new Token object, by default. However, if you want, you
+   * can create and return subclass objects based on the value of ofKind.
+   * Simply add the cases to the switch for all those special cases.
+   * For example, if you have a subclass of Token called IDToken that
+   * you want to create if ofKind is ID, simlpy add something like :
+   *
+   *    case MyParserConstants.ID : return new IDToken();
+   *
+   * to the following switch statement. Then you can cast matchedToken
+   * variable to the appropriate type and use it in your lexical actions.
+   */
+  public static final Token newToken(int ofKind)
+  {
+     switch(ofKind)
+     {
+       default : return new Token();
+     }
+  }
+
+}

Added: trunk/cloveretl.engine/src/org/jetel/util/dml2clover/TokenMgrError.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/TokenMgrError.java	2007-02-20 13:36:20 UTC (rev 2492)
+++ trunk/cloveretl.engine/src/org/jetel/util/dml2clover/TokenMgrError.java	2007-02-20 13:57:34 UTC (rev 2493)
@@ -0,0 +1,133 @@
+/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 3.0 */
+package org.jetel.util.dml2clover;
+
+public class TokenMgrError extends Error
+{
+   /*
+    * Ordinals for various reasons why an Error of this type can be thrown.
+    */
+
+   /**
+    * Lexical error occured.
+    */
+   static final int LEXICAL_ERROR = 0;
+
+   /**
+    * An attempt wass made to create a second instance of a static token manager.
+    */
+   static final int STATIC_LEXER_ERROR = 1;
+
+   /**
+    * Tried to change to an invalid lexical state.
+    */
+   static final int INVALID_LEXICAL_STATE = 2;
+
+   /**
+    * Detected (and bailed out of) an infinite loop in the token manager.
+    */
+   static final int LOOP_DETECTED = 3;
+
+   /**
+    * Indicates the reason why the exception is thrown. It will have
+    * one of the above 4 values.
+    */
+   int errorCode;
+
+   /**
+    * Replaces unprintable characters by their espaced (or unicode escaped)
+    * equivalents in the given string
+    */
+   protected static final String addEscapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+   /**
+    * Returns a detailed message for the Error when it is thrown by the
+    * token manager to indicate a lexical error.
+    * Parameters : 
+    *    EOFSeen     : indicates if EOF caused the lexicl error
+    *    curLexState : lexical state in which this error occured
+    *    errorLine   : line number when the error occured
+    *    errorColumn : column number when the error occured
+    *    errorAfter  : prefix that was seen before this error occured
+    *    curchar     : the offending character
+    * Note: You can customize the lexical error message by modifying this method.
+    */
+   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
+      return("Lexical error at line " +
+           errorLine + ", column " +
+           errorColumn + ".  Encountered: " +
+           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
+           "after : \"" + addEscapes(errorAfter) + "\"");
+   }
+
+   /**
+    * You can also modify the body of this method to customize your error messages.
+    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
+    * of end-users concern, so you can return something like : 
+    *
+    *     "Internal Error : Please file a bug report .... "
+    *
+    * from this method for such cases in the release version of your parser.
+    */
+   public String getMessage() {
+      return super.getMessage();
+   }
+
+   /*
+    * Constructors of various flavors follow.
+    */
+
+   public TokenMgrError() {
+   }
+
+   public TokenMgrError(String message, int reason) {
+      super(message);
+      errorCode = reason;
+   }
+
+   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
+      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
+   }
+}



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 20 15:45:19 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 20 Feb 2007 15:45:19 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2495 -
	trunk/cloveretl.engine/src/org/jetel/util/ddl2clover
Message-ID: <200702201445.l1KEjJte029819@sheep.berlios.de>

Author: jausperger
Date: 2007-02-20 15:45:19 +0100 (Tue, 20 Feb 2007)
New Revision: 2495

Added:
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2Clover.jj
Removed:
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2Clover.jj
Log:
INIT: create metadata from create statement - refactoring dml2ddl

Copied: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2Clover.jj (from rev 2494, trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2Clover.jj)

Deleted: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2Clover.jj
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2Clover.jj	2007-02-20 14:44:00 UTC (rev 2494)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2Clover.jj	2007-02-20 14:45:19 UTC (rev 2495)
@@ -1,408 +0,0 @@
-/**
- * JavaCC file
- */
- 
-options
-{ 
-	JDK_VERSION = "1.5";
-	STATIC=false;
-	CACHE_TOKENS=true;
-	IGNORE_CASE=true;
-}
-
-PARSER_BEGIN(DDL2Clover)
-package org.jetel.util.ddl2clover;
-
-import java.util.*;
-import java.io.*;
-import org.jetel.metadata.*;
-import java.math.*;
-
-public class DDL2Clover {
-
-	/**
-		 * The class parses sql script containing only create statements. Output is a DataRecordMetadata List.
-		 */
-	 
-	private List<DataRecordMetadata> list = new LinkedList<DataRecordMetadata>();
-	private String fieldDelimiter;
-	private String recordDelimiter;
-	
-	private static final Long booleanLenght = Long.valueOf(5); // false / true
-	private static final Long byteLenght = Long.valueOf(String.valueOf(Byte.MIN_VALUE).length());
-	private static final Long integerLenght = Long.valueOf(String.valueOf(Integer.MIN_VALUE).length());
-	private static final Long longLenght = Long.valueOf(String.valueOf(Long.MIN_VALUE).length());
-	private static final Long floatLenght = Long.valueOf(String.valueOf(7));
-	private static final Long doubleLenght = Long.valueOf(String.valueOf(15));
-	private static final Long dateLenght = Long.valueOf(10); // "10.10.2007"
-	private static final Long dateTimeLenght = Long.valueOf(24); // "10.10.2007 23:10:10.111"
-	
-	public static void main(String args[]) throws ParseException, FileNotFoundException {
-		DDL2Clover parser = new DDL2Clover(new FileInputStream(new File("text.txt")));
-		parser.getDataRecordMetadataList(";", "\n");
-		parser.testPrint(parser.list);
-		System.out.println("Ok");
-	}
-
-	public List<DataRecordMetadata> getDataRecordMetadataList() throws ParseException {
-		return getDataRecordMetadataList(null, null);
-	}
-
-	public List<DataRecordMetadata> getDataRecordMetadataList(String fieldDelimiter, String recordDelimiter) throws ParseException {
-		this.fieldDelimiter = fieldDelimiter;
-		this.recordDelimiter = recordDelimiter;
-		while (!isEOF()) {
-			list.add(createTableStatement());
-		}
-		return list;
-	}
-	
-	private void testPrint(List<DataRecordMetadata> list) {
-		DataRecordMetadataXMLReaderWriter writer = new DataRecordMetadataXMLReaderWriter();
-   		for (DataRecordMetadata dataRecordMetadata : list) {
-			writer.write(dataRecordMetadata, System.out);
-			System.out.println();
-   		}		
-	}
-	
-}
-
-PARSER_END(DDL2Clover)
-
-// The SQL lexical grammar
-
-SKIP:
-{
-	// blank space
-		" "
-	|	"\t"
-	|	"\n"
-	|	"\r"
-	|	"\n\r"
-}
-
-// HANDLING COMMENTS
-SPECIAL_TOKEN: 
-{
-	<"/*"> : WithinComment 
-}
-
-<WithinComment> SPECIAL_TOKEN:	{ <"*/"> : DEFAULT }
-<WithinComment> MORE: { <~[]> }
-
-SPECIAL_TOKEN: 
-{  
-	<"//"> : WithinLineComment 
-}
-
-<WithinLineComment> SPECIAL_TOKEN: { <"\n"> : DEFAULT }
-<WithinLineComment> MORE: { <~[]> }
-
-
-TOKEN:
-{
-	// keywords
-		< BOOLEAN: "boolean" >
-	|	< BLOB: "blob" >
-	|	< CHAR: "char" >
-	|	< CHARACTER: "character" >
-	|	< CLOB: "clob" >
-	|	< COMMIT: "commit" >
-	|	< CREATE: "create" >
-	|	< DATE:"date" >
-	|	< DATETIME:"datetime" >
-	|	< DEC:"dec" >
-	|	< DECIMAL:"decimal" >
-	|	< DEFAULT_: "default" >
-	|	< DELETE: "delete" >
-	|	< FLOAT:"float" >
-	|	< GLOBAL: "global" >
-	|	< INT: "int" >
-	|	< INTEGER: "integer" >
-	|	< KEY: "key" >
-	|	< LOCAL: "local" >
-	|	< NOT: "not" >
-	|	< NULL: "null" >
-	|	< NUMBER: "number" >
-	|	< NUMERIC: "numeric" >
-	|	< ON: "on" >
-	|	< PRESERVE:"preserve" >
-	|	< PRIMARY:"primary" >
-	|	< REFERENCES:"references" >
-	|	< ROWS: "rows" >
-	|	< SMALLINT: "smallint" >
-	|	< TABLE: "table" >
-	|	< TIMESTAMP: "timestamp" >
-	|	< TEMPORARY: "TEMPORARY" >
-	|	< UNIQUE: "unique" >
-	|	< VARCHAR: "varchar" >
-	|	< VARCHAR2: "varchar2" >
-
-	// literals
-	|	< STRING_LITERAL: "'" (~["'"])* ( "''" (~["'"])* )* "'" >
-	|	< INTEGER_LITERAL: 	(["0"-"9"])+ >
-	|	< FLOAT_LITERAL:	(["0"-"9"])+ "." (["0"-"9"])+ (<EXP>)?
-							|	"." (["0"-"9"])+ (<EXP>)?
-							|	(["0"-"9"])+ (<EXP>)?>
-	|	< #EXP: ["e","E"] (["+","-"])? (["0"-"9"])+ >
-
-	// identifiers
-	|	< IDENTIFIER: ( <LETTER> )+ ( "_" | "$" | "#" | <DIGIT> | <LETTER> )* >
-	|	< LETTER: ["A"-"Z", "a"-"z"] >
-	|	< DIGIT: ["0"-"9"] >
-
-	// separators and operators
-	|	< CLOSEPAREN: ")" >
-	|	< COMA: "," >
-	|	< DOT: "." >
-	|	< OPENPAREN: "(" >
-	|	< SEMICOLON: ";" >
-}
-
-/*******************************************************************
- * The SQL syntatic grammar starts here
- *******************************************************************/
-
-DataRecordMetadata createTableStatement() : {
-	DataRecordMetadata dataRecordMetadata;
-	List<DataFieldMetadata> list;
-}
-{
-	<CREATE> [tableScope()] <TABLE> [LOOKAHEAD(2)(<IDENTIFIER><DOT>)] {dataRecordMetadata = new DataRecordMetadata(identifier());}
-		// table element list
-		{
-			list = tableElementList(); 
-			for (DataFieldMetadata field : list) {
-				dataRecordMetadata.addField(field);
-			}
-		}
-		// | OF  <path-resolved user-defined type name> [ <subtable clause> ] [ <table element list> ]
-		// | <as subquery clause>
-	[ <ON> <COMMIT> (<PRESERVE> | <DELETE>)? <ROWS>]
-	<SEMICOLON>
-	{
-		if (fieldDelimiter != null && recordDelimiter != null) {
-			dataRecordMetadata.setRecType(DataRecordMetadata.DELIMITED_RECORD);
-		} else if (fieldDelimiter == null && recordDelimiter == null) {
-			dataRecordMetadata.setRecType(DataRecordMetadata.FIXEDLEN_RECORD);
-		}
-	}
-	{ return dataRecordMetadata; }
-}
-
-List<DataFieldMetadata> tableElementList() :
-{
-	List<DataFieldMetadata> list = new LinkedList<DataFieldMetadata>();
-	DataFieldMetadata ret;
-}
-{
-	<OPENPAREN> 
-	ret = tableElement() 			
-	{ 
-		ret.setDelimiter(fieldDelimiter);
-		list.add(ret); 
-	}
-	(<COMA> ret = tableElement() 	
-	{
-		ret.setDelimiter(fieldDelimiter);
-		list.add(ret); 
-	})*
-	{ret.setDelimiter(recordDelimiter);}
-	<CLOSEPAREN> 
-	{ return list; }
-}
-
-void tableScope() :
-{}
-{
-	[<GLOBAL> | <LOCAL>]  <TEMPORARY>
-}
-
-
-boolean isEOF() :
-{
-	boolean isEof = false;
-}
-{
-	(<EOF> isEof = t())?
-	{return isEof;}
-}
-
-boolean t() :
-{
-}
-{
-	{return true;}
-}
-
-//+
-void columnConstraintDefinition() :
-{}
-{
-	(	<NOT> <NULL>
-	|	<UNIQUE>
-	|	<PRIMARY> <KEY>
-//	|	<CHECK> <OPENPAREN> <CLOSEPAREN>
-	|	<REFERENCES> tableName() <OPENPAREN> identifierList() <CLOSEPAREN>
-	)
-}
-
-//+
-DataFieldMetadata columnDefinition() :
-{
-	DataFieldMetadata dataFieldMetadata;
-	String name;
-	DataType type;
-	Object value = null;
-}
-{
-	name = columnName() 
-	type = dataType()
-	(<DEFAULT_> value = defaultValue())?
-	(columnConstraintDefinition())?
-	{ if (type.length == null) {
-		dataFieldMetadata = new DataFieldMetadata(name, type.type, null);
-	  } else {
-		//dataFieldMetadata = new DataFieldMetadata(name, type.type, type.length.shortValue());
-		dataFieldMetadata = new DataFieldMetadata(name, type.type, type.length.shortValue());
-	  }
-	  dataFieldMetadata.setDefaultValue(value);
-	  return dataFieldMetadata; 
-	}
-}
-
-DataFieldMetadata tableElement() :
-{
-	DataFieldMetadata ret = null;
-}
-{
-	(	ret = columnDefinition()
-	// | tableConstraintDefinition()
-	// | <like clause>
-	// | <self-referencing column specification>
-	// | <column options>
-	)
-	{ return ret; }
-}
-
-//+
-String columnName() :
-{
-	String ret;
-}
-{
-	(LOOKAHEAD(2) identifier() <DOT>)? ret = identifier()
-	{ return ret; }
-}
-
-//+TODO dodelat dalsi typu jako DATE, VARCHAR,...
-DataType dataType() :
-{
-	char type;
-	Long temp;
-	Long lenght = null;
-	Long scale = null;
-}
-{
-	(	<BOOLEAN> { type = DataFieldMetadata.INTEGER_FIELD;		lenght = integerLenght;}
-	|	<BLOB> { type = DataFieldMetadata.BYTE_FIELD; } 		(<OPENPAREN> temp = integerLiteral() <CLOSEPAREN> { lenght = temp; })?
-	|	<CHAR> { type = DataFieldMetadata.STRING_FIELD; } 		(<OPENPAREN> temp = integerLiteral() <CLOSEPAREN> { lenght = temp; })?
-	|	<CHARACTER> { type = DataFieldMetadata.STRING_FIELD; } 	(<OPENPAREN> temp = integerLiteral() <CLOSEPAREN> { lenght = temp; })?
-	|	<CLOB> { type = DataFieldMetadata.BYTE_FIELD; } 		(<OPENPAREN> temp = integerLiteral() <CLOSEPAREN> { lenght = temp; })?
-	|	<DATE> { type = DataFieldMetadata.DATE_FIELD; 			lenght = dateLenght;}
-	|	<DATETIME> { type = DataFieldMetadata.DATE_FIELD;	    lenght = dateTimeLenght;}
-	|	<DEC> { type = DataFieldMetadata.DECIMAL_FIELD; }		(<OPENPAREN> temp = integerLiteral() (<COMA> scale = integerLiteral() )? <CLOSEPAREN> { lenght = temp; })?
-	|	<DECIMAL> { type = DataFieldMetadata.DECIMAL_FIELD; }	(<OPENPAREN> temp = integerLiteral() (<COMA> scale = integerLiteral() )? <CLOSEPAREN> { lenght = temp; })?
-	|	<FLOAT> { type = DataFieldMetadata.NUMERIC_FIELD; 		lenght = floatLenght;}
-	|	<INT> { type = DataFieldMetadata.INTEGER_FIELD; 		lenght = integerLenght;}
-	|	<INTEGER> { type = DataFieldMetadata.INTEGER_FIELD; 	lenght = integerLenght;}
-	|	<SMALLINT> { type = DataFieldMetadata.INTEGER_FIELD; 	lenght = integerLenght;}
-	|	<TIMESTAMP> { type = DataFieldMetadata.DATE_FIELD;		lenght = dateTimeLenght;}
-	|	<NUMERIC> { type = DataFieldMetadata.DECIMAL_FIELD; }	(<OPENPAREN> temp = integerLiteral() (<COMA> scale = integerLiteral() )? <CLOSEPAREN> { lenght = temp; })?
-	|	<VARCHAR> { type = DataFieldMetadata.STRING_FIELD; }	<OPENPAREN> temp = integerLiteral() <CLOSEPAREN> { lenght = temp; }
-	|	<VARCHAR2> { type = DataFieldMetadata.STRING_FIELD; }	<OPENPAREN> temp = integerLiteral() <CLOSEPAREN> { lenght = temp; }
-	)
-	{ return new DataType(type, lenght, scale); }
-}
-
-//+
-Object defaultValue() : 
-{
-	Object ret;
-}
-{
-	(	ret = literal()
-	|	ret = nullLiteral() 
-	)
-	{ return ret; }
-}
-
-//+
-BigDecimal floatLiteral() :
-{}
-{
-	<FLOAT_LITERAL> { return new BigDecimal(token.image); }
-}
-
-//+
-String identifier() :
-{}
-{
-	<IDENTIFIER>
-	{ return token.image; }
-}
-
-//+
-void identifierList() :
-{
-}
-{
-	identifier()
-	(<COMA> identifier())*	
-}
-
-//+
-Object literal() :
-{
-	Object ret;
-}
-{
-	(	ret = integerLiteral()
-	|	ret = floatLiteral()
-	|	ret = stringLiteral()
-	)
-	{ return ret; }
-}
-
-//+
-Long integerLiteral() :
-{}
-{
-	<INTEGER_LITERAL> { return new Long(token.image); }
-}
-
-//+
-Object nullLiteral() : 
-{}
-{
-	<NULL> { return	null; }
-}
-	
-//+
-String stringLiteral() :
-{}
-{
-	<STRING_LITERAL> 
-	{ 
-		String value = token.image.intern();
-		return value.substring(1, value.length() - 1); 
-	}
-}
-
-//+
-void tableName() :
-{}
-{
-	<IDENTIFIER>
-}
-



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 20 15:44:02 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 20 Feb 2007 15:44:02 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2494 - in
	trunk/cloveretl.engine/src/org/jetel/util: . ddl2clover
Message-ID: <200702201444.l1KEi2xk029716@sheep.berlios.de>

Author: jausperger
Date: 2007-02-20 15:44:00 +0100 (Tue, 20 Feb 2007)
New Revision: 2494

Added:
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2Clover.java
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2CloverConstants.java
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2CloverTokenManager.java
Removed:
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2Clover.java
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2CloverConstants.java
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2CloverTokenManager.java
   trunk/cloveretl.engine/src/org/jetel/util/dml2clover/
Modified:
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2Clover.jj
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DataType.java
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/ParseException.java
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/SimpleCharStream.java
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/Token.java
   trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/TokenMgrError.java
Log:
INIT: create metadata from create statement

Copied: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover (from rev 2493, trunk/cloveretl.engine/src/org/jetel/util/dml2clover)

Added: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2Clover.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DDL2Clover.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2Clover.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -0,0 +1,881 @@
+/* Generated By:JavaCC: Do not edit this line. DDL2Clover.java */
+package org.jetel.util.ddl2clover;
+
+import java.util.*;
+import java.io.*;
+import org.jetel.metadata.*;
+import java.math.*;
+
+public class DDL2Clover implements DDL2CloverConstants {
+
+        /**
+		 * The class parses sql script containing only create statements. Output is a DataRecordMetadata List.
+		 */
+
+        private List<DataRecordMetadata> list = new LinkedList<DataRecordMetadata>();
+        private String fieldDelimiter;
+        private String recordDelimiter;
+
+        private static final Long booleanLenght = Long.valueOf(5); // false / true
+        private static final Long byteLenght = Long.valueOf(String.valueOf(Byte.MIN_VALUE).length());
+        private static final Long integerLenght = Long.valueOf(String.valueOf(Integer.MIN_VALUE).length());
+        private static final Long longLenght = Long.valueOf(String.valueOf(Long.MIN_VALUE).length());
+        private static final Long floatLenght = Long.valueOf(String.valueOf(7));
+        private static final Long doubleLenght = Long.valueOf(String.valueOf(15));
+        private static final Long dateLenght = Long.valueOf(10); // "10.10.2007"
+        private static final Long dateTimeLenght = Long.valueOf(24); // "10.10.2007 23:10:10.111"
+
+        public static void main(String args[]) throws ParseException, FileNotFoundException {
+                DDL2Clover parser = new DDL2Clover(new FileInputStream(new File("text.txt")));
+                parser.getDataRecordMetadataList(";", "\n");
+                parser.testPrint(parser.list);
+                System.out.println("Ok");
+        }
+
+        public List<DataRecordMetadata> getDataRecordMetadataList() throws ParseException {
+                return getDataRecordMetadataList(null, null);
+        }
+
+        public List<DataRecordMetadata> getDataRecordMetadataList(String fieldDelimiter, String recordDelimiter) throws ParseException {
+                this.fieldDelimiter = fieldDelimiter;
+                this.recordDelimiter = recordDelimiter;
+                while (!isEOF()) {
+                        list.add(createTableStatement());
+                }
+                return list;
+        }
+
+        private void testPrint(List<DataRecordMetadata> list) {
+                DataRecordMetadataXMLReaderWriter writer = new DataRecordMetadataXMLReaderWriter();
+                for (DataRecordMetadata dataRecordMetadata : list) {
+                        writer.write(dataRecordMetadata, System.out);
+                        System.out.println();
+                }
+        }
+
+/*******************************************************************
+ * The SQL syntatic grammar starts here
+ *******************************************************************/
+  final public DataRecordMetadata createTableStatement() throws ParseException {
+        DataRecordMetadata dataRecordMetadata;
+        List<DataFieldMetadata> list;
+    jj_consume_token(CREATE);
+    switch (jj_nt.kind) {
+    case GLOBAL:
+    case LOCAL:
+    case TEMPORARY:
+      tableScope();
+      break;
+    default:
+      jj_la1[0] = jj_gen;
+      ;
+    }
+    jj_consume_token(TABLE);
+    if (jj_2_1(2)) {
+      jj_consume_token(IDENTIFIER);
+      jj_consume_token(DOT);
+    } else {
+      ;
+    }
+                                                                           dataRecordMetadata = new DataRecordMetadata(identifier());
+                        list = tableElementList();
+                        for (DataFieldMetadata field : list) {
+                                dataRecordMetadata.addField(field);
+                        }
+    switch (jj_nt.kind) {
+    case ON:
+      jj_consume_token(ON);
+      jj_consume_token(COMMIT);
+      switch (jj_nt.kind) {
+      case DELETE:
+      case PRESERVE:
+        switch (jj_nt.kind) {
+        case PRESERVE:
+          jj_consume_token(PRESERVE);
+          break;
+        case DELETE:
+          jj_consume_token(DELETE);
+          break;
+        default:
+          jj_la1[1] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+      default:
+        jj_la1[2] = jj_gen;
+        ;
+      }
+      jj_consume_token(ROWS);
+      break;
+    default:
+      jj_la1[3] = jj_gen;
+      ;
+    }
+    jj_consume_token(SEMICOLON);
+                if (fieldDelimiter != null && recordDelimiter != null) {
+                        dataRecordMetadata.setRecType(DataRecordMetadata.DELIMITED_RECORD);
+                } else if (fieldDelimiter == null && recordDelimiter == null) {
+                        dataRecordMetadata.setRecType(DataRecordMetadata.FIXEDLEN_RECORD);
+                }
+          {if (true) return dataRecordMetadata;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List<DataFieldMetadata> tableElementList() throws ParseException {
+        List<DataFieldMetadata> list = new LinkedList<DataFieldMetadata>();
+        DataFieldMetadata ret;
+    jj_consume_token(OPENPAREN);
+    ret = tableElement();
+                ret.setDelimiter(fieldDelimiter);
+                list.add(ret);
+    label_1:
+    while (true) {
+      switch (jj_nt.kind) {
+      case COMA:
+        ;
+        break;
+      default:
+        jj_la1[4] = jj_gen;
+        break label_1;
+      }
+      jj_consume_token(COMA);
+      ret = tableElement();
+                ret.setDelimiter(fieldDelimiter);
+                list.add(ret);
+    }
+         ret.setDelimiter(recordDelimiter);
+    jj_consume_token(CLOSEPAREN);
+          {if (true) return list;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void tableScope() throws ParseException {
+    switch (jj_nt.kind) {
+    case GLOBAL:
+    case LOCAL:
+      switch (jj_nt.kind) {
+      case GLOBAL:
+        jj_consume_token(GLOBAL);
+        break;
+      case LOCAL:
+        jj_consume_token(LOCAL);
+        break;
+      default:
+        jj_la1[5] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[6] = jj_gen;
+      ;
+    }
+    jj_consume_token(TEMPORARY);
+  }
+
+  final public boolean isEOF() throws ParseException {
+        boolean isEof = false;
+    switch (jj_nt.kind) {
+    case 0:
+      jj_consume_token(0);
+      isEof = t();
+      break;
+    default:
+      jj_la1[7] = jj_gen;
+      ;
+    }
+         {if (true) return isEof;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public boolean t() throws ParseException {
+         {if (true) return true;}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public void columnConstraintDefinition() throws ParseException {
+    switch (jj_nt.kind) {
+    case NOT:
+      jj_consume_token(NOT);
+      jj_consume_token(NULL);
+      break;
+    case UNIQUE:
+      jj_consume_token(UNIQUE);
+      break;
+    case PRIMARY:
+      jj_consume_token(PRIMARY);
+      jj_consume_token(KEY);
+      break;
+    case REFERENCES:
+      jj_consume_token(REFERENCES);
+      tableName();
+      jj_consume_token(OPENPAREN);
+      identifierList();
+      jj_consume_token(CLOSEPAREN);
+      break;
+    default:
+      jj_la1[8] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+//+
+  final public DataFieldMetadata columnDefinition() throws ParseException {
+        DataFieldMetadata dataFieldMetadata;
+        String name;
+        DataType type;
+        Object value = null;
+    name = columnName();
+    type = dataType();
+    switch (jj_nt.kind) {
+    case DEFAULT_:
+      jj_consume_token(DEFAULT_);
+      value = defaultValue();
+      break;
+    default:
+      jj_la1[9] = jj_gen;
+      ;
+    }
+    switch (jj_nt.kind) {
+    case NOT:
+    case PRIMARY:
+    case REFERENCES:
+    case UNIQUE:
+      columnConstraintDefinition();
+      break;
+    default:
+      jj_la1[10] = jj_gen;
+      ;
+    }
+          if (type.length == null) {
+                dataFieldMetadata = new DataFieldMetadata(name, type.type, null);
+          } else {
+                //dataFieldMetadata = new DataFieldMetadata(name, type.type, type.length.shortValue());
+                dataFieldMetadata = new DataFieldMetadata(name, type.type, type.length.shortValue());
+          }
+          dataFieldMetadata.setDefaultValue(value);
+          {if (true) return dataFieldMetadata;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public DataFieldMetadata tableElement() throws ParseException {
+        DataFieldMetadata ret = null;
+    ret = columnDefinition();
+          {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public String columnName() throws ParseException {
+        String ret;
+    if (jj_2_2(2)) {
+      identifier();
+      jj_consume_token(DOT);
+    } else {
+      ;
+    }
+    ret = identifier();
+          {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+//+TODO dodelat dalsi typu jako DATE, VARCHAR,...
+  final public DataType dataType() throws ParseException {
+        char type;
+        Long temp;
+        Long lenght = null;
+        Long scale = null;
+    switch (jj_nt.kind) {
+    case BOOLEAN:
+      jj_consume_token(BOOLEAN);
+                            type = DataFieldMetadata.INTEGER_FIELD;             lenght = integerLenght;
+      break;
+    case BLOB:
+      jj_consume_token(BLOB);
+                         type = DataFieldMetadata.BYTE_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                    lenght = temp;
+        break;
+      default:
+        jj_la1[11] = jj_gen;
+        ;
+      }
+      break;
+    case CHAR:
+      jj_consume_token(CHAR);
+                         type = DataFieldMetadata.STRING_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                    lenght = temp;
+        break;
+      default:
+        jj_la1[12] = jj_gen;
+        ;
+      }
+      break;
+    case CHARACTER:
+      jj_consume_token(CHARACTER);
+                              type = DataFieldMetadata.STRING_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                            lenght = temp;
+        break;
+      default:
+        jj_la1[13] = jj_gen;
+        ;
+      }
+      break;
+    case CLOB:
+      jj_consume_token(CLOB);
+                         type = DataFieldMetadata.BYTE_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                    lenght = temp;
+        break;
+      default:
+        jj_la1[14] = jj_gen;
+        ;
+      }
+      break;
+    case DATE:
+      jj_consume_token(DATE);
+                         type = DataFieldMetadata.DATE_FIELD;                   lenght = dateLenght;
+      break;
+    case DATETIME:
+      jj_consume_token(DATETIME);
+                             type = DataFieldMetadata.DATE_FIELD;           lenght = dateTimeLenght;
+      break;
+    case DEC:
+      jj_consume_token(DEC);
+                        type = DataFieldMetadata.DECIMAL_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        switch (jj_nt.kind) {
+        case COMA:
+          jj_consume_token(COMA);
+          scale = integerLiteral();
+          break;
+        default:
+          jj_la1[15] = jj_gen;
+          ;
+        }
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                                                        lenght = temp;
+        break;
+      default:
+        jj_la1[16] = jj_gen;
+        ;
+      }
+      break;
+    case DECIMAL:
+      jj_consume_token(DECIMAL);
+                            type = DataFieldMetadata.DECIMAL_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        switch (jj_nt.kind) {
+        case COMA:
+          jj_consume_token(COMA);
+          scale = integerLiteral();
+          break;
+        default:
+          jj_la1[17] = jj_gen;
+          ;
+        }
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                                                lenght = temp;
+        break;
+      default:
+        jj_la1[18] = jj_gen;
+        ;
+      }
+      break;
+    case FLOAT:
+      jj_consume_token(FLOAT);
+                          type = DataFieldMetadata.NUMERIC_FIELD;               lenght = floatLenght;
+      break;
+    case INT:
+      jj_consume_token(INT);
+                        type = DataFieldMetadata.INTEGER_FIELD;                 lenght = integerLenght;
+      break;
+    case INTEGER:
+      jj_consume_token(INTEGER);
+                            type = DataFieldMetadata.INTEGER_FIELD;     lenght = integerLenght;
+      break;
+    case SMALLINT:
+      jj_consume_token(SMALLINT);
+                             type = DataFieldMetadata.INTEGER_FIELD;    lenght = integerLenght;
+      break;
+    case TIMESTAMP:
+      jj_consume_token(TIMESTAMP);
+                              type = DataFieldMetadata.DATE_FIELD;              lenght = dateTimeLenght;
+      break;
+    case NUMERIC:
+      jj_consume_token(NUMERIC);
+                            type = DataFieldMetadata.DECIMAL_FIELD;
+      switch (jj_nt.kind) {
+      case OPENPAREN:
+        jj_consume_token(OPENPAREN);
+        temp = integerLiteral();
+        switch (jj_nt.kind) {
+        case COMA:
+          jj_consume_token(COMA);
+          scale = integerLiteral();
+          break;
+        default:
+          jj_la1[19] = jj_gen;
+          ;
+        }
+        jj_consume_token(CLOSEPAREN);
+                                                                                                                                                                lenght = temp;
+        break;
+      default:
+        jj_la1[20] = jj_gen;
+        ;
+      }
+      break;
+    case VARCHAR:
+      jj_consume_token(VARCHAR);
+                            type = DataFieldMetadata.STRING_FIELD;
+      jj_consume_token(OPENPAREN);
+      temp = integerLiteral();
+      jj_consume_token(CLOSEPAREN);
+                                                                                                                           lenght = temp;
+      break;
+    case VARCHAR2:
+      jj_consume_token(VARCHAR2);
+                             type = DataFieldMetadata.STRING_FIELD;
+      jj_consume_token(OPENPAREN);
+      temp = integerLiteral();
+      jj_consume_token(CLOSEPAREN);
+                                                                                                                           lenght = temp;
+      break;
+    default:
+      jj_la1[21] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+          {if (true) return new DataType(type, lenght, scale);}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public Object defaultValue() throws ParseException {
+        Object ret;
+    switch (jj_nt.kind) {
+    case STRING_LITERAL:
+    case INTEGER_LITERAL:
+    case FLOAT_LITERAL:
+      ret = literal();
+      break;
+    case NULL:
+      ret = nullLiteral();
+      break;
+    default:
+      jj_la1[22] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+          {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public BigDecimal floatLiteral() throws ParseException {
+    jj_consume_token(FLOAT_LITERAL);
+                          {if (true) return new BigDecimal(token.image);}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public String identifier() throws ParseException {
+    jj_consume_token(IDENTIFIER);
+          {if (true) return token.image;}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public void identifierList() throws ParseException {
+    identifier();
+    label_2:
+    while (true) {
+      switch (jj_nt.kind) {
+      case COMA:
+        ;
+        break;
+      default:
+        jj_la1[23] = jj_gen;
+        break label_2;
+      }
+      jj_consume_token(COMA);
+      identifier();
+    }
+  }
+
+//+
+  final public Object literal() throws ParseException {
+        Object ret;
+    switch (jj_nt.kind) {
+    case INTEGER_LITERAL:
+      ret = integerLiteral();
+      break;
+    case FLOAT_LITERAL:
+      ret = floatLiteral();
+      break;
+    case STRING_LITERAL:
+      ret = stringLiteral();
+      break;
+    default:
+      jj_la1[24] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+          {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public Long integerLiteral() throws ParseException {
+    jj_consume_token(INTEGER_LITERAL);
+                            {if (true) return new Long(token.image);}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public Object nullLiteral() throws ParseException {
+    jj_consume_token(NULL);
+                 {if (true) return null;}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public String stringLiteral() throws ParseException {
+    jj_consume_token(STRING_LITERAL);
+                String value = token.image.intern();
+                {if (true) return value.substring(1, value.length() - 1);}
+    throw new Error("Missing return statement in function");
+  }
+
+//+
+  final public void tableName() throws ParseException {
+    jj_consume_token(IDENTIFIER);
+  }
+
+  final private boolean jj_2_1(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_1(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(0, xla); }
+  }
+
+  final private boolean jj_2_2(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_2(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(1, xla); }
+  }
+
+  final private boolean jj_3R_3() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    return false;
+  }
+
+  final private boolean jj_3_2() {
+    if (jj_3R_3()) return true;
+    if (jj_scan_token(DOT)) return true;
+    return false;
+  }
+
+  final private boolean jj_3_1() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    if (jj_scan_token(DOT)) return true;
+    return false;
+  }
+
+  public DDL2CloverTokenManager token_source;
+  SimpleCharStream jj_input_stream;
+  public Token token, jj_nt;
+  private Token jj_scanpos, jj_lastpos;
+  private int jj_la;
+  public boolean lookingAhead = false;
+  private boolean jj_semLA;
+  private int jj_gen;
+  final private int[] jj_la1 = new int[25];
+  static private int[] jj_la1_0;
+  static private int[] jj_la1_1;
+  static {
+      jj_la1_0();
+      jj_la1_1();
+   }
+   private static void jj_la1_0() {
+      jj_la1_0 = new int[] {0x44000000,0x1000000,0x1000000,0x0,0x0,0x44000000,0x44000000,0x1,0x80000000,0x800000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1a79f000,0x0,0x0,0x0,};
+   }
+   private static void jj_la1_1() {
+      jj_la1_1 = new int[] {0x800,0x10,0x10,0x8,0x800000,0x0,0x0,0x0,0x1060,0x0,0x1060,0x2000000,0x2000000,0x2000000,0x2000000,0x800000,0x2000000,0x800000,0x2000000,0x800000,0x2000000,0x6504,0x38001,0x800000,0x38000,};
+   }
+  final private JJCalls[] jj_2_rtns = new JJCalls[2];
+  private boolean jj_rescan = false;
+  private int jj_gc = 0;
+
+  public DDL2Clover(java.io.InputStream stream) {
+     this(stream, null);
+  }
+  public DDL2Clover(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source = new DDL2CloverTokenManager(jj_input_stream);
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public void ReInit(java.io.InputStream stream) {
+     ReInit(stream, null);
+  }
+  public void ReInit(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public DDL2Clover(java.io.Reader stream) {
+    jj_input_stream = new SimpleCharStream(stream, 1, 1);
+    token_source = new DDL2CloverTokenManager(jj_input_stream);
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public void ReInit(java.io.Reader stream) {
+    jj_input_stream.ReInit(stream, 1, 1);
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public DDL2Clover(DDL2CloverTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  public void ReInit(DDL2CloverTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    token.next = jj_nt = token_source.getNextToken();
+    jj_gen = 0;
+    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  final private Token jj_consume_token(int kind) throws ParseException {
+    Token oldToken = token;
+    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
+    else jj_nt = jj_nt.next = token_source.getNextToken();
+    if (token.kind == kind) {
+      jj_gen++;
+      if (++jj_gc > 100) {
+        jj_gc = 0;
+        for (int i = 0; i < jj_2_rtns.length; i++) {
+          JJCalls c = jj_2_rtns[i];
+          while (c != null) {
+            if (c.gen < jj_gen) c.first = null;
+            c = c.next;
+          }
+        }
+      }
+      return token;
+    }
+    jj_nt = token;
+    token = oldToken;
+    jj_kind = kind;
+    throw generateParseException();
+  }
+
+  static private final class LookaheadSuccess extends java.lang.Error { }
+  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
+  final private boolean jj_scan_token(int kind) {
+    if (jj_scanpos == jj_lastpos) {
+      jj_la--;
+      if (jj_scanpos.next == null) {
+        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
+      } else {
+        jj_lastpos = jj_scanpos = jj_scanpos.next;
+      }
+    } else {
+      jj_scanpos = jj_scanpos.next;
+    }
+    if (jj_rescan) {
+      int i = 0; Token tok = token;
+      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
+      if (tok != null) jj_add_error_token(kind, i);
+    }
+    if (jj_scanpos.kind != kind) return true;
+    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
+    return false;
+  }
+
+  final public Token getNextToken() {
+    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
+    else jj_nt = jj_nt.next = token_source.getNextToken();
+    jj_gen++;
+    return token;
+  }
+
+  final public Token getToken(int index) {
+    Token t = lookingAhead ? jj_scanpos : token;
+    for (int i = 0; i < index; i++) {
+      if (t.next != null) t = t.next;
+      else t = t.next = token_source.getNextToken();
+    }
+    return t;
+  }
+
+  private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();
+  private int[] jj_expentry;
+  private int jj_kind = -1;
+  private int[] jj_lasttokens = new int[100];
+  private int jj_endpos;
+
+  private void jj_add_error_token(int kind, int pos) {
+    if (pos >= 100) return;
+    if (pos == jj_endpos + 1) {
+      jj_lasttokens[jj_endpos++] = kind;
+    } else if (jj_endpos != 0) {
+      jj_expentry = new int[jj_endpos];
+      for (int i = 0; i < jj_endpos; i++) {
+        jj_expentry[i] = jj_lasttokens[i];
+      }
+      boolean exists = false;
+      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
+        int[] oldentry = (int[])(e.nextElement());
+        if (oldentry.length == jj_expentry.length) {
+          exists = true;
+          for (int i = 0; i < jj_expentry.length; i++) {
+            if (oldentry[i] != jj_expentry[i]) {
+              exists = false;
+              break;
+            }
+          }
+          if (exists) break;
+        }
+      }
+      if (!exists) jj_expentries.addElement(jj_expentry);
+      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
+    }
+  }
+
+  public ParseException generateParseException() {
+    jj_expentries.removeAllElements();
+    boolean[] la1tokens = new boolean[59];
+    for (int i = 0; i < 59; i++) {
+      la1tokens[i] = false;
+    }
+    if (jj_kind >= 0) {
+      la1tokens[jj_kind] = true;
+      jj_kind = -1;
+    }
+    for (int i = 0; i < 25; i++) {
+      if (jj_la1[i] == jj_gen) {
+        for (int j = 0; j < 32; j++) {
+          if ((jj_la1_0[i] & (1<<j)) != 0) {
+            la1tokens[j] = true;
+          }
+          if ((jj_la1_1[i] & (1<<j)) != 0) {
+            la1tokens[32+j] = true;
+          }
+        }
+      }
+    }
+    for (int i = 0; i < 59; i++) {
+      if (la1tokens[i]) {
+        jj_expentry = new int[1];
+        jj_expentry[0] = i;
+        jj_expentries.addElement(jj_expentry);
+      }
+    }
+    jj_endpos = 0;
+    jj_rescan_token();
+    jj_add_error_token(0, 0);
+    int[][] exptokseq = new int[jj_expentries.size()][];
+    for (int i = 0; i < jj_expentries.size(); i++) {
+      exptokseq[i] = (int[])jj_expentries.elementAt(i);
+    }
+    return new ParseException(token, exptokseq, tokenImage);
+  }
+
+  final public void enable_tracing() {
+  }
+
+  final public void disable_tracing() {
+  }
+
+  final private void jj_rescan_token() {
+    jj_rescan = true;
+    for (int i = 0; i < 2; i++) {
+    try {
+      JJCalls p = jj_2_rtns[i];
+      do {
+        if (p.gen > jj_gen) {
+          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
+          switch (i) {
+            case 0: jj_3_1(); break;
+            case 1: jj_3_2(); break;
+          }
+        }
+        p = p.next;
+      } while (p != null);
+      } catch(LookaheadSuccess ls) { }
+    }
+    jj_rescan = false;
+  }
+
+  final private void jj_save(int index, int xla) {
+    JJCalls p = jj_2_rtns[index];
+    while (p.gen > jj_gen) {
+      if (p.next == null) { p = p.next = new JJCalls(); break; }
+      p = p.next;
+    }
+    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
+  }
+
+  static final class JJCalls {
+    int gen;
+    Token first;
+    int arg;
+    JJCalls next;
+  }
+
+}

Added: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2CloverConstants.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DDL2CloverConstants.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2CloverConstants.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -0,0 +1,121 @@
+/* Generated By:JavaCC: Do not edit this line. DML2CloverConstants.java */
+package org.jetel.util.ddl2clover;
+
+public interface DDL2CloverConstants {
+
+  int EOF = 0;
+  int BOOLEAN = 12;
+  int BLOB = 13;
+  int CHAR = 14;
+  int CHARACTER = 15;
+  int CLOB = 16;
+  int COMMIT = 17;
+  int CREATE = 18;
+  int DATE = 19;
+  int DATETIME = 20;
+  int DEC = 21;
+  int DECIMAL = 22;
+  int DEFAULT_ = 23;
+  int DELETE = 24;
+  int FLOAT = 25;
+  int GLOBAL = 26;
+  int INT = 27;
+  int INTEGER = 28;
+  int KEY = 29;
+  int LOCAL = 30;
+  int NOT = 31;
+  int NULL = 32;
+  int NUMBER = 33;
+  int NUMERIC = 34;
+  int ON = 35;
+  int PRESERVE = 36;
+  int PRIMARY = 37;
+  int REFERENCES = 38;
+  int ROWS = 39;
+  int SMALLINT = 40;
+  int TABLE = 41;
+  int TIMESTAMP = 42;
+  int TEMPORARY = 43;
+  int UNIQUE = 44;
+  int VARCHAR = 45;
+  int VARCHAR2 = 46;
+  int STRING_LITERAL = 47;
+  int INTEGER_LITERAL = 48;
+  int FLOAT_LITERAL = 49;
+  int EXP = 50;
+  int IDENTIFIER = 51;
+  int LETTER = 52;
+  int DIGIT = 53;
+  int CLOSEPAREN = 54;
+  int COMA = 55;
+  int DOT = 56;
+  int OPENPAREN = 57;
+  int SEMICOLON = 58;
+
+  int DEFAULT = 0;
+  int WithinComment = 1;
+  int WithinLineComment = 2;
+
+  String[] tokenImage = {
+    "<EOF>",
+    "\" \"",
+    "\"\\t\"",
+    "\"\\n\"",
+    "\"\\r\"",
+    "\"\\n\\r\"",
+    "\"/*\"",
+    "\"*/\"",
+    "<token of kind 8>",
+    "\"//\"",
+    "\"\\n\"",
+    "<token of kind 11>",
+    "\"boolean\"",
+    "\"blob\"",
+    "\"char\"",
+    "\"character\"",
+    "\"clob\"",
+    "\"commit\"",
+    "\"create\"",
+    "\"date\"",
+    "\"datetime\"",
+    "\"dec\"",
+    "\"decimal\"",
+    "\"default\"",
+    "\"delete\"",
+    "\"float\"",
+    "\"global\"",
+    "\"int\"",
+    "\"integer\"",
+    "\"key\"",
+    "\"local\"",
+    "\"not\"",
+    "\"null\"",
+    "\"number\"",
+    "\"numeric\"",
+    "\"on\"",
+    "\"preserve\"",
+    "\"primary\"",
+    "\"references\"",
+    "\"rows\"",
+    "\"smallint\"",
+    "\"table\"",
+    "\"timestamp\"",
+    "\"TEMPORARY\"",
+    "\"unique\"",
+    "\"varchar\"",
+    "\"varchar2\"",
+    "<STRING_LITERAL>",
+    "<INTEGER_LITERAL>",
+    "<FLOAT_LITERAL>",
+    "<EXP>",
+    "<IDENTIFIER>",
+    "<LETTER>",
+    "<DIGIT>",
+    "\")\"",
+    "\",\"",
+    "\".\"",
+    "\"(\"",
+    "\";\"",
+  };
+
+}

Added: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2CloverTokenManager.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DDL2CloverTokenManager.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DDL2CloverTokenManager.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -0,0 +1,1197 @@
+/* Generated By:JavaCC: Do not edit this line. DML2CloverTokenManager.java */
+package org.jetel.util.ddl2clover;
+import java.util.*;
+import java.io.*;
+import org.jetel.metadata.*;
+import java.math.*;
+
+public class DDL2CloverTokenManager implements DDL2CloverConstants
+{
+  public  java.io.PrintStream debugStream = System.out;
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_0(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x7ffffffff000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            return 25;
+         }
+         if ((active0 & 0x100000000000000L) != 0L)
+            return 7;
+         return -1;
+      case 1:
+         if ((active0 & 0x7ff7fffff000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 1;
+            return 25;
+         }
+         if ((active0 & 0x800000000L) != 0L)
+            return 25;
+         return -1;
+      case 2:
+         if ((active0 & 0x7ff7479ff000L) != 0L)
+         {
+            if (jjmatchedPos != 2)
+            {
+               jjmatchedKind = 51;
+               jjmatchedPos = 2;
+            }
+            return 25;
+         }
+         if ((active0 & 0xb8600000L) != 0L)
+            return 25;
+         return -1;
+      case 3:
+         if ((active0 & 0x7f7657c61000L) != 0L)
+         {
+            if (jjmatchedPos != 3)
+            {
+               jjmatchedKind = 51;
+               jjmatchedPos = 3;
+            }
+            return 25;
+         }
+         if ((active0 & 0x810019e000L) != 0L)
+            return 25;
+         return -1;
+      case 4:
+         if ((active0 & 0x20042000000L) != 0L)
+            return 25;
+         if ((active0 & 0x7d7615d69000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 4;
+            return 25;
+         }
+         return -1;
+      case 5:
+         if ((active0 & 0x6d7410d09000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 5;
+            return 25;
+         }
+         if ((active0 & 0x100205060000L) != 0L)
+            return 25;
+         return -1;
+      case 6:
+         if ((active0 & 0xd5000108000L) != 0L)
+         {
+            if (jjmatchedPos != 6)
+            {
+               jjmatchedKind = 51;
+               jjmatchedPos = 6;
+            }
+            return 25;
+         }
+         if ((active0 & 0x602410c01000L) != 0L)
+            return 25;
+         return -1;
+      case 7:
+         if ((active0 & 0x400000000000L) != 0L)
+            return 24;
+         if ((active0 & 0x11000100000L) != 0L)
+            return 25;
+         if ((active0 & 0xc4000008000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 7;
+            return 25;
+         }
+         return -1;
+      case 8:
+         if ((active0 & 0x4000000000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 8;
+            return 25;
+         }
+         if ((active0 & 0xc0000008000L) != 0L)
+            return 25;
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_0(int pos, long active0)
+{
+   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
+}
+private final int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private final int jjStartNfaWithStates_0(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_0(state, pos + 1);
+}
+private final int jjMoveStringLiteralDfa0_0()
+{
+   switch(curChar)
+   {
+      case 10:
+         jjmatchedKind = 3;
+         return jjMoveStringLiteralDfa1_0(0x20L);
+      case 40:
+         return jjStopAtPos(0, 57);
+      case 41:
+         return jjStopAtPos(0, 54);
+      case 44:
+         return jjStopAtPos(0, 55);
+      case 46:
+         return jjStartNfaWithStates_0(0, 56, 7);
+      case 47:
+         return jjMoveStringLiteralDfa1_0(0x240L);
+      case 59:
+         return jjStopAtPos(0, 58);
+      case 66:
+      case 98:
+         return jjMoveStringLiteralDfa1_0(0x3000L);
+      case 67:
+      case 99:
+         return jjMoveStringLiteralDfa1_0(0x7c000L);
+      case 68:
+      case 100:
+         return jjMoveStringLiteralDfa1_0(0x1f80000L);
+      case 70:
+      case 102:
+         return jjMoveStringLiteralDfa1_0(0x2000000L);
+      case 71:
+      case 103:
+         return jjMoveStringLiteralDfa1_0(0x4000000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa1_0(0x18000000L);
+      case 75:
+      case 107:
+         return jjMoveStringLiteralDfa1_0(0x20000000L);
+      case 76:
+      case 108:
+         return jjMoveStringLiteralDfa1_0(0x40000000L);
+      case 78:
+      case 110:
+         return jjMoveStringLiteralDfa1_0(0x780000000L);
+      case 79:
+      case 111:
+         return jjMoveStringLiteralDfa1_0(0x800000000L);
+      case 80:
+      case 112:
+         return jjMoveStringLiteralDfa1_0(0x3000000000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa1_0(0xc000000000L);
+      case 83:
+      case 115:
+         return jjMoveStringLiteralDfa1_0(0x10000000000L);
+      case 84:
+      case 116:
+         return jjMoveStringLiteralDfa1_0(0xe0000000000L);
+      case 85:
+      case 117:
+         return jjMoveStringLiteralDfa1_0(0x100000000000L);
+      case 86:
+      case 118:
+         return jjMoveStringLiteralDfa1_0(0x600000000000L);
+      default :
+         return jjMoveNfa_0(0, 0);
+   }
+}
+private final int jjMoveStringLiteralDfa1_0(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 13:
+         if ((active0 & 0x20L) != 0L)
+            return jjStopAtPos(1, 5);
+         break;
+      case 42:
+         if ((active0 & 0x40L) != 0L)
+            return jjStopAtPos(1, 6);
+         break;
+      case 47:
+         if ((active0 & 0x200L) != 0L)
+            return jjStopAtPos(1, 9);
+         break;
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa2_0(active0, 0x620000180000L);
+      case 69:
+      case 101:
+         return jjMoveStringLiteralDfa2_0(active0, 0x84021e00000L);
+      case 72:
+      case 104:
+         return jjMoveStringLiteralDfa2_0(active0, 0xc000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa2_0(active0, 0x40000000000L);
+      case 76:
+      case 108:
+         return jjMoveStringLiteralDfa2_0(active0, 0x6012000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa2_0(active0, 0x10000000000L);
+      case 78:
+      case 110:
+         if ((active0 & 0x800000000L) != 0L)
+            return jjStartNfaWithStates_0(1, 35, 25);
+         return jjMoveStringLiteralDfa2_0(active0, 0x100018000000L);
+      case 79:
+      case 111:
+         return jjMoveStringLiteralDfa2_0(active0, 0x80c0021000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa2_0(active0, 0x3000040000L);
+      case 85:
+      case 117:
+         return jjMoveStringLiteralDfa2_0(active0, 0x700000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(0, active0);
+}
+private final int jjMoveStringLiteralDfa2_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(0, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(1, active0);
+      return 2;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa3_0(active0, 0x1000000c000L);
+      case 66:
+      case 98:
+         return jjMoveStringLiteralDfa3_0(active0, 0x20000000000L);
+      case 67:
+      case 99:
+         if ((active0 & 0x200000L) != 0L)
+         {
+            jjmatchedKind = 21;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x40400000L);
+      case 69:
+      case 101:
+         return jjMoveStringLiteralDfa3_0(active0, 0x1000040000L);
+      case 70:
+      case 102:
+         return jjMoveStringLiteralDfa3_0(active0, 0x4000800000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa3_0(active0, 0x102000000000L);
+      case 76:
+      case 108:
+         return jjMoveStringLiteralDfa3_0(active0, 0x101000000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa3_0(active0, 0xc0600020000L);
+      case 79:
+      case 111:
+         return jjMoveStringLiteralDfa3_0(active0, 0x6013000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa3_0(active0, 0x600000000000L);
+      case 84:
+      case 116:
+         if ((active0 & 0x8000000L) != 0L)
+         {
+            jjmatchedKind = 27;
+            jjmatchedPos = 2;
+         }
+         else if ((active0 & 0x80000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 31, 25);
+         return jjMoveStringLiteralDfa3_0(active0, 0x10180000L);
+      case 87:
+      case 119:
+         return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L);
+      case 89:
+      case 121:
+         if ((active0 & 0x20000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 29, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(1, active0);
+}
+private final int jjMoveStringLiteralDfa3_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(1, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(2, active0);
+      return 3;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa4_0(active0, 0x42840000L);
+      case 66:
+      case 98:
+         if ((active0 & 0x2000L) != 0L)
+            return jjStartNfaWithStates_0(3, 13, 25);
+         else if ((active0 & 0x10000L) != 0L)
+            return jjStartNfaWithStates_0(3, 16, 25);
+         return jjMoveStringLiteralDfa4_0(active0, 0x204000000L);
+      case 67:
+      case 99:
+         return jjMoveStringLiteralDfa4_0(active0, 0x600000000000L);
+      case 69:
+      case 101:
+         if ((active0 & 0x80000L) != 0L)
+         {
+            jjmatchedKind = 19;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x44411100000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa4_0(active0, 0x400000L);
+      case 76:
+      case 108:
+         if ((active0 & 0x100000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 32, 25);
+         return jjMoveStringLiteralDfa4_0(active0, 0x30000001000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa4_0(active0, 0x2000020000L);
+      case 80:
+      case 112:
+         return jjMoveStringLiteralDfa4_0(active0, 0x80000000000L);
+      case 81:
+      case 113:
+         return jjMoveStringLiteralDfa4_0(active0, 0x100000000000L);
+      case 82:
+      case 114:
+         if ((active0 & 0x4000L) != 0L)
+         {
+            jjmatchedKind = 14;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x8000L);
+      case 83:
+      case 115:
+         if ((active0 & 0x8000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 39, 25);
+         return jjMoveStringLiteralDfa4_0(active0, 0x1000000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(2, active0);
+}
+private final int jjMoveStringLiteralDfa4_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(2, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(3, active0);
+      return 4;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa5_0(active0, 0x2004008000L);
+      case 69:
+      case 101:
+         if ((active0 & 0x20000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 41, 25);
+         return jjMoveStringLiteralDfa5_0(active0, 0x1200001000L);
+      case 71:
+      case 103:
+         return jjMoveStringLiteralDfa5_0(active0, 0x10000000L);
+      case 72:
+      case 104:
+         return jjMoveStringLiteralDfa5_0(active0, 0x600000000000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa5_0(active0, 0x20000L);
+      case 76:
+      case 108:
+         if ((active0 & 0x40000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 30, 25);
+         return jjMoveStringLiteralDfa5_0(active0, 0x10000000000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa5_0(active0, 0x400000L);
+      case 79:
+      case 111:
+         return jjMoveStringLiteralDfa5_0(active0, 0x80000000000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa5_0(active0, 0x4400000000L);
+      case 83:
+      case 115:
+         return jjMoveStringLiteralDfa5_0(active0, 0x40000000000L);
+      case 84:
+      case 116:
+         if ((active0 & 0x2000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 25, 25);
+         return jjMoveStringLiteralDfa5_0(active0, 0x1140000L);
+      case 85:
+      case 117:
+         return jjMoveStringLiteralDfa5_0(active0, 0x100000800000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(3, active0);
+}
+private final int jjMoveStringLiteralDfa5_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(3, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(4, active0);
+      return 5;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa6_0(active0, 0x600000401000L);
+      case 67:
+      case 99:
+         return jjMoveStringLiteralDfa6_0(active0, 0x8000L);
+      case 69:
+      case 101:
+         if ((active0 & 0x40000L) != 0L)
+            return jjStartNfaWithStates_0(5, 18, 25);
+         else if ((active0 & 0x1000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 24, 25);
+         else if ((active0 & 0x100000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 44, 25);
+         return jjMoveStringLiteralDfa6_0(active0, 0x4010000000L);
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa6_0(active0, 0x10400100000L);
+      case 76:
+      case 108:
+         if ((active0 & 0x4000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 26, 25);
+         return jjMoveStringLiteralDfa6_0(active0, 0x800000L);
+      case 82:
+      case 114:
+         if ((active0 & 0x200000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 33, 25);
+         return jjMoveStringLiteralDfa6_0(active0, 0x83000000000L);
+      case 84:
+      case 116:
+         if ((active0 & 0x20000L) != 0L)
+            return jjStartNfaWithStates_0(5, 17, 25);
+         return jjMoveStringLiteralDfa6_0(active0, 0x40000000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(4, active0);
+}
+private final int jjMoveStringLiteralDfa6_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(4, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(5, active0);
+      return 6;
+   }
+   switch(curChar)
+   {
+      case 65:
+      case 97:
+         return jjMoveStringLiteralDfa7_0(active0, 0xc0000000000L);
+      case 67:
+      case 99:
+         if ((active0 & 0x400000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 34, 25);
+         break;
+      case 76:
+      case 108:
+         if ((active0 & 0x400000L) != 0L)
+            return jjStartNfaWithStates_0(6, 22, 25);
+         break;
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa7_0(active0, 0x100000L);
+      case 78:
+      case 110:
+         if ((active0 & 0x1000L) != 0L)
+            return jjStartNfaWithStates_0(6, 12, 25);
+         return jjMoveStringLiteralDfa7_0(active0, 0x14000000000L);
+      case 82:
+      case 114:
+         if ((active0 & 0x10000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 28, 25);
+         else if ((active0 & 0x200000000000L) != 0L)
+         {
+            jjmatchedKind = 45;
+            jjmatchedPos = 6;
+         }
+         return jjMoveStringLiteralDfa7_0(active0, 0x400000000000L);
+      case 84:
+      case 116:
+         if ((active0 & 0x800000L) != 0L)
+            return jjStartNfaWithStates_0(6, 23, 25);
+         return jjMoveStringLiteralDfa7_0(active0, 0x8000L);
+      case 86:
+      case 118:
+         return jjMoveStringLiteralDfa7_0(active0, 0x1000000000L);
+      case 89:
+      case 121:
+         if ((active0 & 0x2000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 37, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(5, active0);
+}
+private final int jjMoveStringLiteralDfa7_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(5, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(6, active0);
+      return 7;
+   }
+   switch(curChar)
+   {
+      case 50:
+         if ((active0 & 0x400000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 46, 24);
+         break;
+      case 67:
+      case 99:
+         return jjMoveStringLiteralDfa8_0(active0, 0x4000000000L);
+      case 69:
+      case 101:
+         if ((active0 & 0x100000L) != 0L)
+            return jjStartNfaWithStates_0(7, 20, 25);
+         else if ((active0 & 0x1000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 36, 25);
+         return jjMoveStringLiteralDfa8_0(active0, 0x8000L);
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa8_0(active0, 0x40000000000L);
+      case 82:
+      case 114:
+         return jjMoveStringLiteralDfa8_0(active0, 0x80000000000L);
+      case 84:
+      case 116:
+         if ((active0 & 0x10000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 40, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(6, active0);
+}
+private final int jjMoveStringLiteralDfa8_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(6, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(7, active0);
+      return 8;
+   }
+   switch(curChar)
+   {
+      case 69:
+      case 101:
+         return jjMoveStringLiteralDfa9_0(active0, 0x4000000000L);
+      case 80:
+      case 112:
+         if ((active0 & 0x40000000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 42, 25);
+         break;
+      case 82:
+      case 114:
+         if ((active0 & 0x8000L) != 0L)
+            return jjStartNfaWithStates_0(8, 15, 25);
+         break;
+      case 89:
+      case 121:
+         if ((active0 & 0x80000000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 43, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(7, active0);
+}
+private final int jjMoveStringLiteralDfa9_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(7, old0); 
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(8, active0);
+      return 9;
+   }
+   switch(curChar)
+   {
+      case 83:
+      case 115:
+         if ((active0 & 0x4000000000L) != 0L)
+            return jjStartNfaWithStates_0(9, 38, 25);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(8, active0);
+}
+private final void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private final void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private final void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+private final void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+private final void jjCheckNAddStates(int start)
+{
+   jjCheckNAdd(jjnextStates[start]);
+   jjCheckNAdd(jjnextStates[start + 1]);
+}
+static final long[] jjbitVec0 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+private final int jjMoveNfa_0(int startState, int curPos)
+{
+   int[] nextStates;
+   int startsAt = 0;
+   jjnewStateCnt = 25;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int j, kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         MatchLoop: do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x3ff000000000000L & l) != 0L)
+                  {
+                     if (kind > 48)
+                        kind = 48;
+                     jjCheckNAddStates(0, 4);
+                  }
+                  else if (curChar == 46)
+                     jjCheckNAdd(7);
+                  else if (curChar == 39)
+                     jjCheckNAddStates(5, 7);
+                  break;
+               case 25:
+               case 24:
+                  if ((0x3ff001800000000L & l) == 0L)
+                     break;
+                  if (kind > 51)
+                     kind = 51;
+                  jjCheckNAdd(24);
+                  break;
+               case 1:
+                  if ((0xffffff7fffffffffL & l) != 0L)
+                     jjCheckNAddStates(5, 7);
+                  break;
+               case 2:
+                  if (curChar == 39)
+                     jjCheckNAddStates(8, 10);
+                  break;
+               case 3:
+                  if (curChar == 39)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  break;
+               case 4:
+                  if ((0xffffff7fffffffffL & l) != 0L)
+                     jjCheckNAddStates(8, 10);
+                  break;
+               case 5:
+                  if (curChar == 39 && kind > 47)
+                     kind = 47;
+                  break;
+               case 6:
+                  if (curChar == 46)
+                     jjCheckNAdd(7);
+                  break;
+               case 7:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 49)
+                     kind = 49;
+                  jjCheckNAddTwoStates(7, 8);
+                  break;
+               case 9:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(10);
+                  break;
+               case 10:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 49)
+                     kind = 49;
+                  jjCheckNAdd(10);
+                  break;
+               case 11:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 48)
+                     kind = 48;
+                  jjCheckNAddStates(0, 4);
+                  break;
+               case 12:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 48)
+                     kind = 48;
+                  jjCheckNAdd(12);
+                  break;
+               case 13:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(13, 14);
+                  break;
+               case 14:
+                  if (curChar == 46)
+                     jjCheckNAdd(15);
+                  break;
+               case 15:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 49)
+                     kind = 49;
+                  jjCheckNAddTwoStates(15, 16);
+                  break;
+               case 17:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(18);
+                  break;
+               case 18:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 49)
+                     kind = 49;
+                  jjCheckNAdd(18);
+                  break;
+               case 19:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 49)
+                     kind = 49;
+                  jjCheckNAddTwoStates(19, 20);
+                  break;
+               case 21:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(22);
+                  break;
+               case 22:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 49)
+                     kind = 49;
+                  jjCheckNAdd(22);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         MatchLoop: do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 23:
+                  if ((0x7fffffe07fffffeL & l) == 0L)
+                     break;
+                  if (kind > 51)
+                     kind = 51;
+                  jjCheckNAddTwoStates(23, 24);
+                  break;
+               case 25:
+                  if ((0x7fffffe87fffffeL & l) != 0L)
+                  {
+                     if (kind > 51)
+                        kind = 51;
+                     jjCheckNAdd(24);
+                  }
+                  if ((0x7fffffe07fffffeL & l) != 0L)
+                  {
+                     if (kind > 51)
+                        kind = 51;
+                     jjCheckNAddTwoStates(23, 24);
+                  }
+                  break;
+               case 1:
+                  jjCheckNAddStates(5, 7);
+                  break;
+               case 4:
+                  jjCheckNAddStates(8, 10);
+                  break;
+               case 8:
+                  if ((0x2000000020L & l) != 0L)
+                     jjAddStates(11, 12);
+                  break;
+               case 16:
+                  if ((0x2000000020L & l) != 0L)
+                     jjAddStates(13, 14);
+                  break;
+               case 20:
+                  if ((0x2000000020L & l) != 0L)
+                     jjAddStates(15, 16);
+                  break;
+               case 24:
+                  if ((0x7fffffe87fffffeL & l) == 0L)
+                     break;
+                  if (kind > 51)
+                     kind = 51;
+                  jjCheckNAdd(24);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         MatchLoop: do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 1:
+                  if ((jjbitVec0[i2] & l2) != 0L)
+                     jjCheckNAddStates(5, 7);
+                  break;
+               case 4:
+                  if ((jjbitVec0[i2] & l2) != 0L)
+                     jjCheckNAddStates(8, 10);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 25 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private final int jjMoveStringLiteralDfa0_2()
+{
+   switch(curChar)
+   {
+      case 10:
+         return jjStopAtPos(0, 10);
+      default :
+         return 1;
+   }
+}
+private final int jjMoveStringLiteralDfa0_1()
+{
+   switch(curChar)
+   {
+      case 42:
+         return jjMoveStringLiteralDfa1_1(0x80L);
+      default :
+         return 1;
+   }
+}
+private final int jjMoveStringLiteralDfa1_1(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 47:
+         if ((active0 & 0x80L) != 0L)
+            return jjStopAtPos(1, 7);
+         break;
+      default :
+         return 2;
+   }
+   return 2;
+}
+static final int[] jjnextStates = {
+   12, 13, 14, 19, 20, 1, 3, 5, 3, 4, 5, 9, 10, 17, 18, 21, 
+   22, 
+};
+public static final String[] jjstrLiteralImages = {
+"", null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, "\51", 
+"\54", "\56", "\50", "\73", };
+public static final String[] lexStateNames = {
+   "DEFAULT", 
+   "WithinComment", 
+   "WithinLineComment", 
+};
+public static final int[] jjnewLexState = {
+   -1, -1, -1, -1, -1, -1, 1, 0, -1, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+};
+static final long[] jjtoToken = {
+   0x7fbfffffffff001L, 
+};
+static final long[] jjtoSkip = {
+   0x6feL, 
+};
+static final long[] jjtoSpecial = {
+   0x6c0L, 
+};
+static final long[] jjtoMore = {
+   0x900L, 
+};
+protected SimpleCharStream input_stream;
+private final int[] jjrounds = new int[25];
+private final int[] jjstateSet = new int[50];
+StringBuffer image;
+int jjimageLen;
+int lengthOfMatch;
+protected char curChar;
+public DDL2CloverTokenManager(SimpleCharStream stream){
+   if (SimpleCharStream.staticFlag)
+      throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
+   input_stream = stream;
+}
+public DDL2CloverTokenManager(SimpleCharStream stream, int lexState){
+   this(stream);
+   SwitchTo(lexState);
+}
+public void ReInit(SimpleCharStream stream)
+{
+   jjmatchedPos = jjnewStateCnt = 0;
+   curLexState = defaultLexState;
+   input_stream = stream;
+   ReInitRounds();
+}
+private final void ReInitRounds()
+{
+   int i;
+   jjround = 0x80000001;
+   for (i = 25; i-- > 0;)
+      jjrounds[i] = 0x80000000;
+}
+public void ReInit(SimpleCharStream stream, int lexState)
+{
+   ReInit(stream);
+   SwitchTo(lexState);
+}
+public void SwitchTo(int lexState)
+{
+   if (lexState >= 3 || lexState < 0)
+      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
+   else
+      curLexState = lexState;
+}
+
+protected Token jjFillToken()
+{
+   Token t = Token.newToken(jjmatchedKind);
+   t.kind = jjmatchedKind;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   t.image = (im == null) ? input_stream.GetImage() : im;
+   t.beginLine = input_stream.getBeginLine();
+   t.beginColumn = input_stream.getBeginColumn();
+   t.endLine = input_stream.getEndLine();
+   t.endColumn = input_stream.getEndColumn();
+   return t;
+}
+
+int curLexState = 0;
+int defaultLexState = 0;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+public Token getNextToken() 
+{
+  int kind;
+  Token specialToken = null;
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {   
+   try   
+   {     
+      curChar = input_stream.BeginToken();
+   }     
+   catch(java.io.IOException e)
+   {        
+      jjmatchedKind = 0;
+      matchedToken = jjFillToken();
+      matchedToken.specialToken = specialToken;
+      return matchedToken;
+   }
+   image = null;
+   jjimageLen = 0;
+
+   for (;;)
+   {
+     switch(curLexState)
+     {
+       case 0:
+         try { input_stream.backup(0);
+            while (curChar <= 32 && (0x100002200L & (1L << curChar)) != 0L)
+               curChar = input_stream.BeginToken();
+         }
+         catch (java.io.IOException e1) { continue EOFLoop; }
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_0();
+         break;
+       case 1:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_1();
+         if (jjmatchedPos == 0 && jjmatchedKind > 8)
+         {
+            jjmatchedKind = 8;
+         }
+         break;
+       case 2:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_2();
+         if (jjmatchedPos == 0 && jjmatchedKind > 11)
+         {
+            jjmatchedKind = 11;
+         }
+         break;
+     }
+     if (jjmatchedKind != 0x7fffffff)
+     {
+        if (jjmatchedPos + 1 < curPos)
+           input_stream.backup(curPos - jjmatchedPos - 1);
+        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           matchedToken = jjFillToken();
+           matchedToken.specialToken = specialToken;
+       if (jjnewLexState[jjmatchedKind] != -1)
+         curLexState = jjnewLexState[jjmatchedKind];
+           return matchedToken;
+        }
+        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+           {
+              matchedToken = jjFillToken();
+              if (specialToken == null)
+                 specialToken = matchedToken;
+              else
+              {
+                 matchedToken.specialToken = specialToken;
+                 specialToken = (specialToken.next = matchedToken);
+              }
+              SkipLexicalActions(matchedToken);
+           }
+           else 
+              SkipLexicalActions(null);
+         if (jjnewLexState[jjmatchedKind] != -1)
+           curLexState = jjnewLexState[jjmatchedKind];
+           continue EOFLoop;
+        }
+        jjimageLen += jjmatchedPos + 1;
+      if (jjnewLexState[jjmatchedKind] != -1)
+        curLexState = jjnewLexState[jjmatchedKind];
+        curPos = 0;
+        jjmatchedKind = 0x7fffffff;
+        try {
+           curChar = input_stream.readChar();
+           continue;
+        }
+        catch (java.io.IOException e1) { }
+     }
+     int error_line = input_stream.getEndLine();
+     int error_column = input_stream.getEndColumn();
+     String error_after = null;
+     boolean EOFSeen = false;
+     try { input_stream.readChar(); input_stream.backup(1); }
+     catch (java.io.IOException e1) {
+        EOFSeen = true;
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+        if (curChar == '\n' || curChar == '\r') {
+           error_line++;
+           error_column = 0;
+        }
+        else
+           error_column++;
+     }
+     if (!EOFSeen) {
+        input_stream.backup(1);
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+     }
+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+   }
+  }
+}
+
+void SkipLexicalActions(Token matchedToken)
+{
+   switch(jjmatchedKind)
+   {
+      default :
+         break;
+   }
+}
+}

Deleted: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2Clover.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2Clover.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2Clover.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -1,881 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. DML2Clover.java */
-package org.jetel.util.dml2clover;
-
-import java.util.*;
-import java.io.*;
-import org.jetel.metadata.*;
-import java.math.*;
-
-public class DML2Clover implements DML2CloverConstants {
-
-        /**
-		 * The class parses sql script containing only create statements. Output is a DataRecordMetadata List.
-		 */
-
-        private List<DataRecordMetadata> list = new LinkedList<DataRecordMetadata>();
-        private String fieldDelimiter;
-        private String recordDelimiter;
-
-        private static final Long booleanLenght = Long.valueOf(5); // false / true
-        private static final Long byteLenght = Long.valueOf(String.valueOf(Byte.MIN_VALUE).length());
-        private static final Long integerLenght = Long.valueOf(String.valueOf(Integer.MIN_VALUE).length());
-        private static final Long longLenght = Long.valueOf(String.valueOf(Long.MIN_VALUE).length());
-        private static final Long floatLenght = Long.valueOf(String.valueOf(7));
-        private static final Long doubleLenght = Long.valueOf(String.valueOf(15));
-        private static final Long dateLenght = Long.valueOf(10); // "10.10.2007"
-        private static final Long dateTimeLenght = Long.valueOf(24); // "10.10.2007 23:10:10.111"
-
-        public static void main(String args[]) throws ParseException, FileNotFoundException {
-                DML2Clover parser = new DML2Clover(new FileInputStream(new File("text.txt")));
-                parser.getDataRecordMetadataList(";", "\n");
-                parser.testPrint(parser.list);
-                System.out.println("Ok");
-        }
-
-        public List<DataRecordMetadata> getDataRecordMetadataList() throws ParseException {
-                return getDataRecordMetadataList(null, null);
-        }
-
-        public List<DataRecordMetadata> getDataRecordMetadataList(String fieldDelimiter, String recordDelimiter) throws ParseException {
-                this.fieldDelimiter = fieldDelimiter;
-                this.recordDelimiter = recordDelimiter;
-                while (!isEOF()) {
-                        list.add(createTableStatement());
-                }
-                return list;
-        }
-
-        private void testPrint(List<DataRecordMetadata> list) {
-                DataRecordMetadataXMLReaderWriter writer = new DataRecordMetadataXMLReaderWriter();
-                for (DataRecordMetadata dataRecordMetadata : list) {
-                        writer.write(dataRecordMetadata, System.out);
-                        System.out.println();
-                }
-        }
-
-/*******************************************************************
- * The SQL syntatic grammar starts here
- *******************************************************************/
-  final public DataRecordMetadata createTableStatement() throws ParseException {
-        DataRecordMetadata dataRecordMetadata;
-        List<DataFieldMetadata> list;
-    jj_consume_token(CREATE);
-    switch (jj_nt.kind) {
-    case GLOBAL:
-    case LOCAL:
-    case TEMPORARY:
-      tableScope();
-      break;
-    default:
-      jj_la1[0] = jj_gen;
-      ;
-    }
-    jj_consume_token(TABLE);
-    if (jj_2_1(2)) {
-      jj_consume_token(IDENTIFIER);
-      jj_consume_token(DOT);
-    } else {
-      ;
-    }
-                                                                           dataRecordMetadata = new DataRecordMetadata(identifier());
-                        list = tableElementList();
-                        for (DataFieldMetadata field : list) {
-                                dataRecordMetadata.addField(field);
-                        }
-    switch (jj_nt.kind) {
-    case ON:
-      jj_consume_token(ON);
-      jj_consume_token(COMMIT);
-      switch (jj_nt.kind) {
-      case DELETE:
-      case PRESERVE:
-        switch (jj_nt.kind) {
-        case PRESERVE:
-          jj_consume_token(PRESERVE);
-          break;
-        case DELETE:
-          jj_consume_token(DELETE);
-          break;
-        default:
-          jj_la1[1] = jj_gen;
-          jj_consume_token(-1);
-          throw new ParseException();
-        }
-        break;
-      default:
-        jj_la1[2] = jj_gen;
-        ;
-      }
-      jj_consume_token(ROWS);
-      break;
-    default:
-      jj_la1[3] = jj_gen;
-      ;
-    }
-    jj_consume_token(SEMICOLON);
-                if (fieldDelimiter != null && recordDelimiter != null) {
-                        dataRecordMetadata.setRecType(DataRecordMetadata.DELIMITED_RECORD);
-                } else if (fieldDelimiter == null && recordDelimiter == null) {
-                        dataRecordMetadata.setRecType(DataRecordMetadata.FIXEDLEN_RECORD);
-                }
-          {if (true) return dataRecordMetadata;}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public List<DataFieldMetadata> tableElementList() throws ParseException {
-        List<DataFieldMetadata> list = new LinkedList<DataFieldMetadata>();
-        DataFieldMetadata ret;
-    jj_consume_token(OPENPAREN);
-    ret = tableElement();
-                ret.setDelimiter(fieldDelimiter);
-                list.add(ret);
-    label_1:
-    while (true) {
-      switch (jj_nt.kind) {
-      case COMA:
-        ;
-        break;
-      default:
-        jj_la1[4] = jj_gen;
-        break label_1;
-      }
-      jj_consume_token(COMA);
-      ret = tableElement();
-                ret.setDelimiter(fieldDelimiter);
-                list.add(ret);
-    }
-         ret.setDelimiter(recordDelimiter);
-    jj_consume_token(CLOSEPAREN);
-          {if (true) return list;}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public void tableScope() throws ParseException {
-    switch (jj_nt.kind) {
-    case GLOBAL:
-    case LOCAL:
-      switch (jj_nt.kind) {
-      case GLOBAL:
-        jj_consume_token(GLOBAL);
-        break;
-      case LOCAL:
-        jj_consume_token(LOCAL);
-        break;
-      default:
-        jj_la1[5] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-      break;
-    default:
-      jj_la1[6] = jj_gen;
-      ;
-    }
-    jj_consume_token(TEMPORARY);
-  }
-
-  final public boolean isEOF() throws ParseException {
-        boolean isEof = false;
-    switch (jj_nt.kind) {
-    case 0:
-      jj_consume_token(0);
-      isEof = t();
-      break;
-    default:
-      jj_la1[7] = jj_gen;
-      ;
-    }
-         {if (true) return isEof;}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public boolean t() throws ParseException {
-         {if (true) return true;}
-    throw new Error("Missing return statement in function");
-  }
-
-//+
-  final public void columnConstraintDefinition() throws ParseException {
-    switch (jj_nt.kind) {
-    case NOT:
-      jj_consume_token(NOT);
-      jj_consume_token(NULL);
-      break;
-    case UNIQUE:
-      jj_consume_token(UNIQUE);
-      break;
-    case PRIMARY:
-      jj_consume_token(PRIMARY);
-      jj_consume_token(KEY);
-      break;
-    case REFERENCES:
-      jj_consume_token(REFERENCES);
-      tableName();
-      jj_consume_token(OPENPAREN);
-      identifierList();
-      jj_consume_token(CLOSEPAREN);
-      break;
-    default:
-      jj_la1[8] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-  }
-
-//+
-  final public DataFieldMetadata columnDefinition() throws ParseException {
-        DataFieldMetadata dataFieldMetadata;
-        String name;
-        DataType type;
-        Object value = null;
-    name = columnName();
-    type = dataType();
-    switch (jj_nt.kind) {
-    case DEFAULT_:
-      jj_consume_token(DEFAULT_);
-      value = defaultValue();
-      break;
-    default:
-      jj_la1[9] = jj_gen;
-      ;
-    }
-    switch (jj_nt.kind) {
-    case NOT:
-    case PRIMARY:
-    case REFERENCES:
-    case UNIQUE:
-      columnConstraintDefinition();
-      break;
-    default:
-      jj_la1[10] = jj_gen;
-      ;
-    }
-          if (type.length == null) {
-                dataFieldMetadata = new DataFieldMetadata(name, type.type, null);
-          } else {
-                //dataFieldMetadata = new DataFieldMetadata(name, type.type, type.length.shortValue());
-                dataFieldMetadata = new DataFieldMetadata(name, type.type, type.length.shortValue());
-          }
-          dataFieldMetadata.setDefaultValue(value);
-          {if (true) return dataFieldMetadata;}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public DataFieldMetadata tableElement() throws ParseException {
-        DataFieldMetadata ret = null;
-    ret = columnDefinition();
-          {if (true) return ret;}
-    throw new Error("Missing return statement in function");
-  }
-
-//+
-  final public String columnName() throws ParseException {
-        String ret;
-    if (jj_2_2(2)) {
-      identifier();
-      jj_consume_token(DOT);
-    } else {
-      ;
-    }
-    ret = identifier();
-          {if (true) return ret;}
-    throw new Error("Missing return statement in function");
-  }
-
-//+TODO dodelat dalsi typu jako DATE, VARCHAR,...
-  final public DataType dataType() throws ParseException {
-        char type;
-        Long temp;
-        Long lenght = null;
-        Long scale = null;
-    switch (jj_nt.kind) {
-    case BOOLEAN:
-      jj_consume_token(BOOLEAN);
-                            type = DataFieldMetadata.INTEGER_FIELD;             lenght = integerLenght;
-      break;
-    case BLOB:
-      jj_consume_token(BLOB);
-                         type = DataFieldMetadata.BYTE_FIELD;
-      switch (jj_nt.kind) {
-      case OPENPAREN:
-        jj_consume_token(OPENPAREN);
-        temp = integerLiteral();
-        jj_consume_token(CLOSEPAREN);
-                                                                                                                                    lenght = temp;
-        break;
-      default:
-        jj_la1[11] = jj_gen;
-        ;
-      }
-      break;
-    case CHAR:
-      jj_consume_token(CHAR);
-                         type = DataFieldMetadata.STRING_FIELD;
-      switch (jj_nt.kind) {
-      case OPENPAREN:
-        jj_consume_token(OPENPAREN);
-        temp = integerLiteral();
-        jj_consume_token(CLOSEPAREN);
-                                                                                                                                    lenght = temp;
-        break;
-      default:
-        jj_la1[12] = jj_gen;
-        ;
-      }
-      break;
-    case CHARACTER:
-      jj_consume_token(CHARACTER);
-                              type = DataFieldMetadata.STRING_FIELD;
-      switch (jj_nt.kind) {
-      case OPENPAREN:
-        jj_consume_token(OPENPAREN);
-        temp = integerLiteral();
-        jj_consume_token(CLOSEPAREN);
-                                                                                                                            lenght = temp;
-        break;
-      default:
-        jj_la1[13] = jj_gen;
-        ;
-      }
-      break;
-    case CLOB:
-      jj_consume_token(CLOB);
-                         type = DataFieldMetadata.BYTE_FIELD;
-      switch (jj_nt.kind) {
-      case OPENPAREN:
-        jj_consume_token(OPENPAREN);
-        temp = integerLiteral();
-        jj_consume_token(CLOSEPAREN);
-                                                                                                                                    lenght = temp;
-        break;
-      default:
-        jj_la1[14] = jj_gen;
-        ;
-      }
-      break;
-    case DATE:
-      jj_consume_token(DATE);
-                         type = DataFieldMetadata.DATE_FIELD;                   lenght = dateLenght;
-      break;
-    case DATETIME:
-      jj_consume_token(DATETIME);
-                             type = DataFieldMetadata.DATE_FIELD;           lenght = dateTimeLenght;
-      break;
-    case DEC:
-      jj_consume_token(DEC);
-                        type = DataFieldMetadata.DECIMAL_FIELD;
-      switch (jj_nt.kind) {
-      case OPENPAREN:
-        jj_consume_token(OPENPAREN);
-        temp = integerLiteral();
-        switch (jj_nt.kind) {
-        case COMA:
-          jj_consume_token(COMA);
-          scale = integerLiteral();
-          break;
-        default:
-          jj_la1[15] = jj_gen;
-          ;
-        }
-        jj_consume_token(CLOSEPAREN);
-                                                                                                                                                                        lenght = temp;
-        break;
-      default:
-        jj_la1[16] = jj_gen;
-        ;
-      }
-      break;
-    case DECIMAL:
-      jj_consume_token(DECIMAL);
-                            type = DataFieldMetadata.DECIMAL_FIELD;
-      switch (jj_nt.kind) {
-      case OPENPAREN:
-        jj_consume_token(OPENPAREN);
-        temp = integerLiteral();
-        switch (jj_nt.kind) {
-        case COMA:
-          jj_consume_token(COMA);
-          scale = integerLiteral();
-          break;
-        default:
-          jj_la1[17] = jj_gen;
-          ;
-        }
-        jj_consume_token(CLOSEPAREN);
-                                                                                                                                                                lenght = temp;
-        break;
-      default:
-        jj_la1[18] = jj_gen;
-        ;
-      }
-      break;
-    case FLOAT:
-      jj_consume_token(FLOAT);
-                          type = DataFieldMetadata.NUMERIC_FIELD;               lenght = floatLenght;
-      break;
-    case INT:
-      jj_consume_token(INT);
-                        type = DataFieldMetadata.INTEGER_FIELD;                 lenght = integerLenght;
-      break;
-    case INTEGER:
-      jj_consume_token(INTEGER);
-                            type = DataFieldMetadata.INTEGER_FIELD;     lenght = integerLenght;
-      break;
-    case SMALLINT:
-      jj_consume_token(SMALLINT);
-                             type = DataFieldMetadata.INTEGER_FIELD;    lenght = integerLenght;
-      break;
-    case TIMESTAMP:
-      jj_consume_token(TIMESTAMP);
-                              type = DataFieldMetadata.DATE_FIELD;              lenght = dateTimeLenght;
-      break;
-    case NUMERIC:
-      jj_consume_token(NUMERIC);
-                            type = DataFieldMetadata.DECIMAL_FIELD;
-      switch (jj_nt.kind) {
-      case OPENPAREN:
-        jj_consume_token(OPENPAREN);
-        temp = integerLiteral();
-        switch (jj_nt.kind) {
-        case COMA:
-          jj_consume_token(COMA);
-          scale = integerLiteral();
-          break;
-        default:
-          jj_la1[19] = jj_gen;
-          ;
-        }
-        jj_consume_token(CLOSEPAREN);
-                                                                                                                                                                lenght = temp;
-        break;
-      default:
-        jj_la1[20] = jj_gen;
-        ;
-      }
-      break;
-    case VARCHAR:
-      jj_consume_token(VARCHAR);
-                            type = DataFieldMetadata.STRING_FIELD;
-      jj_consume_token(OPENPAREN);
-      temp = integerLiteral();
-      jj_consume_token(CLOSEPAREN);
-                                                                                                                           lenght = temp;
-      break;
-    case VARCHAR2:
-      jj_consume_token(VARCHAR2);
-                             type = DataFieldMetadata.STRING_FIELD;
-      jj_consume_token(OPENPAREN);
-      temp = integerLiteral();
-      jj_consume_token(CLOSEPAREN);
-                                                                                                                           lenght = temp;
-      break;
-    default:
-      jj_la1[21] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-          {if (true) return new DataType(type, lenght, scale);}
-    throw new Error("Missing return statement in function");
-  }
-
-//+
-  final public Object defaultValue() throws ParseException {
-        Object ret;
-    switch (jj_nt.kind) {
-    case STRING_LITERAL:
-    case INTEGER_LITERAL:
-    case FLOAT_LITERAL:
-      ret = literal();
-      break;
-    case NULL:
-      ret = nullLiteral();
-      break;
-    default:
-      jj_la1[22] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-          {if (true) return ret;}
-    throw new Error("Missing return statement in function");
-  }
-
-//+
-  final public BigDecimal floatLiteral() throws ParseException {
-    jj_consume_token(FLOAT_LITERAL);
-                          {if (true) return new BigDecimal(token.image);}
-    throw new Error("Missing return statement in function");
-  }
-
-//+
-  final public String identifier() throws ParseException {
-    jj_consume_token(IDENTIFIER);
-          {if (true) return token.image;}
-    throw new Error("Missing return statement in function");
-  }
-
-//+
-  final public void identifierList() throws ParseException {
-    identifier();
-    label_2:
-    while (true) {
-      switch (jj_nt.kind) {
-      case COMA:
-        ;
-        break;
-      default:
-        jj_la1[23] = jj_gen;
-        break label_2;
-      }
-      jj_consume_token(COMA);
-      identifier();
-    }
-  }
-
-//+
-  final public Object literal() throws ParseException {
-        Object ret;
-    switch (jj_nt.kind) {
-    case INTEGER_LITERAL:
-      ret = integerLiteral();
-      break;
-    case FLOAT_LITERAL:
-      ret = floatLiteral();
-      break;
-    case STRING_LITERAL:
-      ret = stringLiteral();
-      break;
-    default:
-      jj_la1[24] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-          {if (true) return ret;}
-    throw new Error("Missing return statement in function");
-  }
-
-//+
-  final public Long integerLiteral() throws ParseException {
-    jj_consume_token(INTEGER_LITERAL);
-                            {if (true) return new Long(token.image);}
-    throw new Error("Missing return statement in function");
-  }
-
-//+
-  final public Object nullLiteral() throws ParseException {
-    jj_consume_token(NULL);
-                 {if (true) return null;}
-    throw new Error("Missing return statement in function");
-  }
-
-//+
-  final public String stringLiteral() throws ParseException {
-    jj_consume_token(STRING_LITERAL);
-                String value = token.image.intern();
-                {if (true) return value.substring(1, value.length() - 1);}
-    throw new Error("Missing return statement in function");
-  }
-
-//+
-  final public void tableName() throws ParseException {
-    jj_consume_token(IDENTIFIER);
-  }
-
-  final private boolean jj_2_1(int xla) {
-    jj_la = xla; jj_lastpos = jj_scanpos = token;
-    try { return !jj_3_1(); }
-    catch(LookaheadSuccess ls) { return true; }
-    finally { jj_save(0, xla); }
-  }
-
-  final private boolean jj_2_2(int xla) {
-    jj_la = xla; jj_lastpos = jj_scanpos = token;
-    try { return !jj_3_2(); }
-    catch(LookaheadSuccess ls) { return true; }
-    finally { jj_save(1, xla); }
-  }
-
-  final private boolean jj_3R_3() {
-    if (jj_scan_token(IDENTIFIER)) return true;
-    return false;
-  }
-
-  final private boolean jj_3_2() {
-    if (jj_3R_3()) return true;
-    if (jj_scan_token(DOT)) return true;
-    return false;
-  }
-
-  final private boolean jj_3_1() {
-    if (jj_scan_token(IDENTIFIER)) return true;
-    if (jj_scan_token(DOT)) return true;
-    return false;
-  }
-
-  public DML2CloverTokenManager token_source;
-  SimpleCharStream jj_input_stream;
-  public Token token, jj_nt;
-  private Token jj_scanpos, jj_lastpos;
-  private int jj_la;
-  public boolean lookingAhead = false;
-  private boolean jj_semLA;
-  private int jj_gen;
-  final private int[] jj_la1 = new int[25];
-  static private int[] jj_la1_0;
-  static private int[] jj_la1_1;
-  static {
-      jj_la1_0();
-      jj_la1_1();
-   }
-   private static void jj_la1_0() {
-      jj_la1_0 = new int[] {0x44000000,0x1000000,0x1000000,0x0,0x0,0x44000000,0x44000000,0x1,0x80000000,0x800000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1a79f000,0x0,0x0,0x0,};
-   }
-   private static void jj_la1_1() {
-      jj_la1_1 = new int[] {0x800,0x10,0x10,0x8,0x800000,0x0,0x0,0x0,0x1060,0x0,0x1060,0x2000000,0x2000000,0x2000000,0x2000000,0x800000,0x2000000,0x800000,0x2000000,0x800000,0x2000000,0x6504,0x38001,0x800000,0x38000,};
-   }
-  final private JJCalls[] jj_2_rtns = new JJCalls[2];
-  private boolean jj_rescan = false;
-  private int jj_gc = 0;
-
-  public DML2Clover(java.io.InputStream stream) {
-     this(stream, null);
-  }
-  public DML2Clover(java.io.InputStream stream, String encoding) {
-    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
-    token_source = new DML2CloverTokenManager(jj_input_stream);
-    token = new Token();
-    token.next = jj_nt = token_source.getNextToken();
-    jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  public void ReInit(java.io.InputStream stream) {
-     ReInit(stream, null);
-  }
-  public void ReInit(java.io.InputStream stream, String encoding) {
-    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
-    token_source.ReInit(jj_input_stream);
-    token = new Token();
-    token.next = jj_nt = token_source.getNextToken();
-    jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  public DML2Clover(java.io.Reader stream) {
-    jj_input_stream = new SimpleCharStream(stream, 1, 1);
-    token_source = new DML2CloverTokenManager(jj_input_stream);
-    token = new Token();
-    token.next = jj_nt = token_source.getNextToken();
-    jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  public void ReInit(java.io.Reader stream) {
-    jj_input_stream.ReInit(stream, 1, 1);
-    token_source.ReInit(jj_input_stream);
-    token = new Token();
-    token.next = jj_nt = token_source.getNextToken();
-    jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  public DML2Clover(DML2CloverTokenManager tm) {
-    token_source = tm;
-    token = new Token();
-    token.next = jj_nt = token_source.getNextToken();
-    jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  public void ReInit(DML2CloverTokenManager tm) {
-    token_source = tm;
-    token = new Token();
-    token.next = jj_nt = token_source.getNextToken();
-    jj_gen = 0;
-    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  final private Token jj_consume_token(int kind) throws ParseException {
-    Token oldToken = token;
-    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
-    else jj_nt = jj_nt.next = token_source.getNextToken();
-    if (token.kind == kind) {
-      jj_gen++;
-      if (++jj_gc > 100) {
-        jj_gc = 0;
-        for (int i = 0; i < jj_2_rtns.length; i++) {
-          JJCalls c = jj_2_rtns[i];
-          while (c != null) {
-            if (c.gen < jj_gen) c.first = null;
-            c = c.next;
-          }
-        }
-      }
-      return token;
-    }
-    jj_nt = token;
-    token = oldToken;
-    jj_kind = kind;
-    throw generateParseException();
-  }
-
-  static private final class LookaheadSuccess extends java.lang.Error { }
-  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
-  final private boolean jj_scan_token(int kind) {
-    if (jj_scanpos == jj_lastpos) {
-      jj_la--;
-      if (jj_scanpos.next == null) {
-        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
-      } else {
-        jj_lastpos = jj_scanpos = jj_scanpos.next;
-      }
-    } else {
-      jj_scanpos = jj_scanpos.next;
-    }
-    if (jj_rescan) {
-      int i = 0; Token tok = token;
-      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
-      if (tok != null) jj_add_error_token(kind, i);
-    }
-    if (jj_scanpos.kind != kind) return true;
-    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
-    return false;
-  }
-
-  final public Token getNextToken() {
-    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
-    else jj_nt = jj_nt.next = token_source.getNextToken();
-    jj_gen++;
-    return token;
-  }
-
-  final public Token getToken(int index) {
-    Token t = lookingAhead ? jj_scanpos : token;
-    for (int i = 0; i < index; i++) {
-      if (t.next != null) t = t.next;
-      else t = t.next = token_source.getNextToken();
-    }
-    return t;
-  }
-
-  private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();
-  private int[] jj_expentry;
-  private int jj_kind = -1;
-  private int[] jj_lasttokens = new int[100];
-  private int jj_endpos;
-
-  private void jj_add_error_token(int kind, int pos) {
-    if (pos >= 100) return;
-    if (pos == jj_endpos + 1) {
-      jj_lasttokens[jj_endpos++] = kind;
-    } else if (jj_endpos != 0) {
-      jj_expentry = new int[jj_endpos];
-      for (int i = 0; i < jj_endpos; i++) {
-        jj_expentry[i] = jj_lasttokens[i];
-      }
-      boolean exists = false;
-      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
-        int[] oldentry = (int[])(e.nextElement());
-        if (oldentry.length == jj_expentry.length) {
-          exists = true;
-          for (int i = 0; i < jj_expentry.length; i++) {
-            if (oldentry[i] != jj_expentry[i]) {
-              exists = false;
-              break;
-            }
-          }
-          if (exists) break;
-        }
-      }
-      if (!exists) jj_expentries.addElement(jj_expentry);
-      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
-    }
-  }
-
-  public ParseException generateParseException() {
-    jj_expentries.removeAllElements();
-    boolean[] la1tokens = new boolean[59];
-    for (int i = 0; i < 59; i++) {
-      la1tokens[i] = false;
-    }
-    if (jj_kind >= 0) {
-      la1tokens[jj_kind] = true;
-      jj_kind = -1;
-    }
-    for (int i = 0; i < 25; i++) {
-      if (jj_la1[i] == jj_gen) {
-        for (int j = 0; j < 32; j++) {
-          if ((jj_la1_0[i] & (1<<j)) != 0) {
-            la1tokens[j] = true;
-          }
-          if ((jj_la1_1[i] & (1<<j)) != 0) {
-            la1tokens[32+j] = true;
-          }
-        }
-      }
-    }
-    for (int i = 0; i < 59; i++) {
-      if (la1tokens[i]) {
-        jj_expentry = new int[1];
-        jj_expentry[0] = i;
-        jj_expentries.addElement(jj_expentry);
-      }
-    }
-    jj_endpos = 0;
-    jj_rescan_token();
-    jj_add_error_token(0, 0);
-    int[][] exptokseq = new int[jj_expentries.size()][];
-    for (int i = 0; i < jj_expentries.size(); i++) {
-      exptokseq[i] = (int[])jj_expentries.elementAt(i);
-    }
-    return new ParseException(token, exptokseq, tokenImage);
-  }
-
-  final public void enable_tracing() {
-  }
-
-  final public void disable_tracing() {
-  }
-
-  final private void jj_rescan_token() {
-    jj_rescan = true;
-    for (int i = 0; i < 2; i++) {
-    try {
-      JJCalls p = jj_2_rtns[i];
-      do {
-        if (p.gen > jj_gen) {
-          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
-          switch (i) {
-            case 0: jj_3_1(); break;
-            case 1: jj_3_2(); break;
-          }
-        }
-        p = p.next;
-      } while (p != null);
-      } catch(LookaheadSuccess ls) { }
-    }
-    jj_rescan = false;
-  }
-
-  final private void jj_save(int index, int xla) {
-    JJCalls p = jj_2_rtns[index];
-    while (p.gen > jj_gen) {
-      if (p.next == null) { p = p.next = new JJCalls(); break; }
-      p = p.next;
-    }
-    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
-  }
-
-  static final class JJCalls {
-    int gen;
-    Token first;
-    int arg;
-    JJCalls next;
-  }
-
-}

Modified: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2Clover.jj
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2Clover.jj	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2Clover.jj	2007-02-20 14:44:00 UTC (rev 2494)
@@ -10,15 +10,15 @@
 	IGNORE_CASE=true;
 }
 
-PARSER_BEGIN(DML2Clover)
-package org.jetel.util.dml2clover;
+PARSER_BEGIN(DDL2Clover)
+package org.jetel.util.ddl2clover;
 
 import java.util.*;
 import java.io.*;
 import org.jetel.metadata.*;
 import java.math.*;
 
-public class DML2Clover {
+public class DDL2Clover {
 
 	/**
 		 * The class parses sql script containing only create statements. Output is a DataRecordMetadata List.
@@ -38,7 +38,7 @@
 	private static final Long dateTimeLenght = Long.valueOf(24); // "10.10.2007 23:10:10.111"
 	
 	public static void main(String args[]) throws ParseException, FileNotFoundException {
-		DML2Clover parser = new DML2Clover(new FileInputStream(new File("text.txt")));
+		DDL2Clover parser = new DDL2Clover(new FileInputStream(new File("text.txt")));
 		parser.getDataRecordMetadataList(";", "\n");
 		parser.testPrint(parser.list);
 		System.out.println("Ok");
@@ -67,7 +67,7 @@
 	
 }
 
-PARSER_END(DML2Clover)
+PARSER_END(DDL2Clover)
 
 // The SQL lexical grammar
 

Deleted: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2CloverConstants.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverConstants.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2CloverConstants.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -1,121 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. DML2CloverConstants.java */
-package org.jetel.util.dml2clover;
-
-public interface DML2CloverConstants {
-
-  int EOF = 0;
-  int BOOLEAN = 12;
-  int BLOB = 13;
-  int CHAR = 14;
-  int CHARACTER = 15;
-  int CLOB = 16;
-  int COMMIT = 17;
-  int CREATE = 18;
-  int DATE = 19;
-  int DATETIME = 20;
-  int DEC = 21;
-  int DECIMAL = 22;
-  int DEFAULT_ = 23;
-  int DELETE = 24;
-  int FLOAT = 25;
-  int GLOBAL = 26;
-  int INT = 27;
-  int INTEGER = 28;
-  int KEY = 29;
-  int LOCAL = 30;
-  int NOT = 31;
-  int NULL = 32;
-  int NUMBER = 33;
-  int NUMERIC = 34;
-  int ON = 35;
-  int PRESERVE = 36;
-  int PRIMARY = 37;
-  int REFERENCES = 38;
-  int ROWS = 39;
-  int SMALLINT = 40;
-  int TABLE = 41;
-  int TIMESTAMP = 42;
-  int TEMPORARY = 43;
-  int UNIQUE = 44;
-  int VARCHAR = 45;
-  int VARCHAR2 = 46;
-  int STRING_LITERAL = 47;
-  int INTEGER_LITERAL = 48;
-  int FLOAT_LITERAL = 49;
-  int EXP = 50;
-  int IDENTIFIER = 51;
-  int LETTER = 52;
-  int DIGIT = 53;
-  int CLOSEPAREN = 54;
-  int COMA = 55;
-  int DOT = 56;
-  int OPENPAREN = 57;
-  int SEMICOLON = 58;
-
-  int DEFAULT = 0;
-  int WithinComment = 1;
-  int WithinLineComment = 2;
-
-  String[] tokenImage = {
-    "<EOF>",
-    "\" \"",
-    "\"\\t\"",
-    "\"\\n\"",
-    "\"\\r\"",
-    "\"\\n\\r\"",
-    "\"/*\"",
-    "\"*/\"",
-    "<token of kind 8>",
-    "\"//\"",
-    "\"\\n\"",
-    "<token of kind 11>",
-    "\"boolean\"",
-    "\"blob\"",
-    "\"char\"",
-    "\"character\"",
-    "\"clob\"",
-    "\"commit\"",
-    "\"create\"",
-    "\"date\"",
-    "\"datetime\"",
-    "\"dec\"",
-    "\"decimal\"",
-    "\"default\"",
-    "\"delete\"",
-    "\"float\"",
-    "\"global\"",
-    "\"int\"",
-    "\"integer\"",
-    "\"key\"",
-    "\"local\"",
-    "\"not\"",
-    "\"null\"",
-    "\"number\"",
-    "\"numeric\"",
-    "\"on\"",
-    "\"preserve\"",
-    "\"primary\"",
-    "\"references\"",
-    "\"rows\"",
-    "\"smallint\"",
-    "\"table\"",
-    "\"timestamp\"",
-    "\"TEMPORARY\"",
-    "\"unique\"",
-    "\"varchar\"",
-    "\"varchar2\"",
-    "<STRING_LITERAL>",
-    "<INTEGER_LITERAL>",
-    "<FLOAT_LITERAL>",
-    "<EXP>",
-    "<IDENTIFIER>",
-    "<LETTER>",
-    "<DIGIT>",
-    "\")\"",
-    "\",\"",
-    "\".\"",
-    "\"(\"",
-    "\";\"",
-  };
-
-}

Deleted: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2CloverTokenManager.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DML2CloverTokenManager.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DML2CloverTokenManager.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -1,1197 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. DML2CloverTokenManager.java */
-package org.jetel.util.dml2clover;
-import java.util.*;
-import java.io.*;
-import org.jetel.metadata.*;
-import java.math.*;
-
-public class DML2CloverTokenManager implements DML2CloverConstants
-{
-  public  java.io.PrintStream debugStream = System.out;
-  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
-private final int jjStopStringLiteralDfa_0(int pos, long active0)
-{
-   switch (pos)
-   {
-      case 0:
-         if ((active0 & 0x7ffffffff000L) != 0L)
-         {
-            jjmatchedKind = 51;
-            return 25;
-         }
-         if ((active0 & 0x100000000000000L) != 0L)
-            return 7;
-         return -1;
-      case 1:
-         if ((active0 & 0x7ff7fffff000L) != 0L)
-         {
-            jjmatchedKind = 51;
-            jjmatchedPos = 1;
-            return 25;
-         }
-         if ((active0 & 0x800000000L) != 0L)
-            return 25;
-         return -1;
-      case 2:
-         if ((active0 & 0x7ff7479ff000L) != 0L)
-         {
-            if (jjmatchedPos != 2)
-            {
-               jjmatchedKind = 51;
-               jjmatchedPos = 2;
-            }
-            return 25;
-         }
-         if ((active0 & 0xb8600000L) != 0L)
-            return 25;
-         return -1;
-      case 3:
-         if ((active0 & 0x7f7657c61000L) != 0L)
-         {
-            if (jjmatchedPos != 3)
-            {
-               jjmatchedKind = 51;
-               jjmatchedPos = 3;
-            }
-            return 25;
-         }
-         if ((active0 & 0x810019e000L) != 0L)
-            return 25;
-         return -1;
-      case 4:
-         if ((active0 & 0x20042000000L) != 0L)
-            return 25;
-         if ((active0 & 0x7d7615d69000L) != 0L)
-         {
-            jjmatchedKind = 51;
-            jjmatchedPos = 4;
-            return 25;
-         }
-         return -1;
-      case 5:
-         if ((active0 & 0x6d7410d09000L) != 0L)
-         {
-            jjmatchedKind = 51;
-            jjmatchedPos = 5;
-            return 25;
-         }
-         if ((active0 & 0x100205060000L) != 0L)
-            return 25;
-         return -1;
-      case 6:
-         if ((active0 & 0xd5000108000L) != 0L)
-         {
-            if (jjmatchedPos != 6)
-            {
-               jjmatchedKind = 51;
-               jjmatchedPos = 6;
-            }
-            return 25;
-         }
-         if ((active0 & 0x602410c01000L) != 0L)
-            return 25;
-         return -1;
-      case 7:
-         if ((active0 & 0x400000000000L) != 0L)
-            return 24;
-         if ((active0 & 0x11000100000L) != 0L)
-            return 25;
-         if ((active0 & 0xc4000008000L) != 0L)
-         {
-            jjmatchedKind = 51;
-            jjmatchedPos = 7;
-            return 25;
-         }
-         return -1;
-      case 8:
-         if ((active0 & 0x4000000000L) != 0L)
-         {
-            jjmatchedKind = 51;
-            jjmatchedPos = 8;
-            return 25;
-         }
-         if ((active0 & 0xc0000008000L) != 0L)
-            return 25;
-         return -1;
-      default :
-         return -1;
-   }
-}
-private final int jjStartNfa_0(int pos, long active0)
-{
-   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
-}
-private final int jjStopAtPos(int pos, int kind)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   return pos + 1;
-}
-private final int jjStartNfaWithStates_0(int pos, int kind, int state)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_0(state, pos + 1);
-}
-private final int jjMoveStringLiteralDfa0_0()
-{
-   switch(curChar)
-   {
-      case 10:
-         jjmatchedKind = 3;
-         return jjMoveStringLiteralDfa1_0(0x20L);
-      case 40:
-         return jjStopAtPos(0, 57);
-      case 41:
-         return jjStopAtPos(0, 54);
-      case 44:
-         return jjStopAtPos(0, 55);
-      case 46:
-         return jjStartNfaWithStates_0(0, 56, 7);
-      case 47:
-         return jjMoveStringLiteralDfa1_0(0x240L);
-      case 59:
-         return jjStopAtPos(0, 58);
-      case 66:
-      case 98:
-         return jjMoveStringLiteralDfa1_0(0x3000L);
-      case 67:
-      case 99:
-         return jjMoveStringLiteralDfa1_0(0x7c000L);
-      case 68:
-      case 100:
-         return jjMoveStringLiteralDfa1_0(0x1f80000L);
-      case 70:
-      case 102:
-         return jjMoveStringLiteralDfa1_0(0x2000000L);
-      case 71:
-      case 103:
-         return jjMoveStringLiteralDfa1_0(0x4000000L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa1_0(0x18000000L);
-      case 75:
-      case 107:
-         return jjMoveStringLiteralDfa1_0(0x20000000L);
-      case 76:
-      case 108:
-         return jjMoveStringLiteralDfa1_0(0x40000000L);
-      case 78:
-      case 110:
-         return jjMoveStringLiteralDfa1_0(0x780000000L);
-      case 79:
-      case 111:
-         return jjMoveStringLiteralDfa1_0(0x800000000L);
-      case 80:
-      case 112:
-         return jjMoveStringLiteralDfa1_0(0x3000000000L);
-      case 82:
-      case 114:
-         return jjMoveStringLiteralDfa1_0(0xc000000000L);
-      case 83:
-      case 115:
-         return jjMoveStringLiteralDfa1_0(0x10000000000L);
-      case 84:
-      case 116:
-         return jjMoveStringLiteralDfa1_0(0xe0000000000L);
-      case 85:
-      case 117:
-         return jjMoveStringLiteralDfa1_0(0x100000000000L);
-      case 86:
-      case 118:
-         return jjMoveStringLiteralDfa1_0(0x600000000000L);
-      default :
-         return jjMoveNfa_0(0, 0);
-   }
-}
-private final int jjMoveStringLiteralDfa1_0(long active0)
-{
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(0, active0);
-      return 1;
-   }
-   switch(curChar)
-   {
-      case 13:
-         if ((active0 & 0x20L) != 0L)
-            return jjStopAtPos(1, 5);
-         break;
-      case 42:
-         if ((active0 & 0x40L) != 0L)
-            return jjStopAtPos(1, 6);
-         break;
-      case 47:
-         if ((active0 & 0x200L) != 0L)
-            return jjStopAtPos(1, 9);
-         break;
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa2_0(active0, 0x620000180000L);
-      case 69:
-      case 101:
-         return jjMoveStringLiteralDfa2_0(active0, 0x84021e00000L);
-      case 72:
-      case 104:
-         return jjMoveStringLiteralDfa2_0(active0, 0xc000L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa2_0(active0, 0x40000000000L);
-      case 76:
-      case 108:
-         return jjMoveStringLiteralDfa2_0(active0, 0x6012000L);
-      case 77:
-      case 109:
-         return jjMoveStringLiteralDfa2_0(active0, 0x10000000000L);
-      case 78:
-      case 110:
-         if ((active0 & 0x800000000L) != 0L)
-            return jjStartNfaWithStates_0(1, 35, 25);
-         return jjMoveStringLiteralDfa2_0(active0, 0x100018000000L);
-      case 79:
-      case 111:
-         return jjMoveStringLiteralDfa2_0(active0, 0x80c0021000L);
-      case 82:
-      case 114:
-         return jjMoveStringLiteralDfa2_0(active0, 0x3000040000L);
-      case 85:
-      case 117:
-         return jjMoveStringLiteralDfa2_0(active0, 0x700000000L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(0, active0);
-}
-private final int jjMoveStringLiteralDfa2_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(0, old0); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(1, active0);
-      return 2;
-   }
-   switch(curChar)
-   {
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa3_0(active0, 0x1000000c000L);
-      case 66:
-      case 98:
-         return jjMoveStringLiteralDfa3_0(active0, 0x20000000000L);
-      case 67:
-      case 99:
-         if ((active0 & 0x200000L) != 0L)
-         {
-            jjmatchedKind = 21;
-            jjmatchedPos = 2;
-         }
-         return jjMoveStringLiteralDfa3_0(active0, 0x40400000L);
-      case 69:
-      case 101:
-         return jjMoveStringLiteralDfa3_0(active0, 0x1000040000L);
-      case 70:
-      case 102:
-         return jjMoveStringLiteralDfa3_0(active0, 0x4000800000L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa3_0(active0, 0x102000000000L);
-      case 76:
-      case 108:
-         return jjMoveStringLiteralDfa3_0(active0, 0x101000000L);
-      case 77:
-      case 109:
-         return jjMoveStringLiteralDfa3_0(active0, 0xc0600020000L);
-      case 79:
-      case 111:
-         return jjMoveStringLiteralDfa3_0(active0, 0x6013000L);
-      case 82:
-      case 114:
-         return jjMoveStringLiteralDfa3_0(active0, 0x600000000000L);
-      case 84:
-      case 116:
-         if ((active0 & 0x8000000L) != 0L)
-         {
-            jjmatchedKind = 27;
-            jjmatchedPos = 2;
-         }
-         else if ((active0 & 0x80000000L) != 0L)
-            return jjStartNfaWithStates_0(2, 31, 25);
-         return jjMoveStringLiteralDfa3_0(active0, 0x10180000L);
-      case 87:
-      case 119:
-         return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L);
-      case 89:
-      case 121:
-         if ((active0 & 0x20000000L) != 0L)
-            return jjStartNfaWithStates_0(2, 29, 25);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(1, active0);
-}
-private final int jjMoveStringLiteralDfa3_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(1, old0); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(2, active0);
-      return 3;
-   }
-   switch(curChar)
-   {
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa4_0(active0, 0x42840000L);
-      case 66:
-      case 98:
-         if ((active0 & 0x2000L) != 0L)
-            return jjStartNfaWithStates_0(3, 13, 25);
-         else if ((active0 & 0x10000L) != 0L)
-            return jjStartNfaWithStates_0(3, 16, 25);
-         return jjMoveStringLiteralDfa4_0(active0, 0x204000000L);
-      case 67:
-      case 99:
-         return jjMoveStringLiteralDfa4_0(active0, 0x600000000000L);
-      case 69:
-      case 101:
-         if ((active0 & 0x80000L) != 0L)
-         {
-            jjmatchedKind = 19;
-            jjmatchedPos = 3;
-         }
-         return jjMoveStringLiteralDfa4_0(active0, 0x44411100000L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa4_0(active0, 0x400000L);
-      case 76:
-      case 108:
-         if ((active0 & 0x100000000L) != 0L)
-            return jjStartNfaWithStates_0(3, 32, 25);
-         return jjMoveStringLiteralDfa4_0(active0, 0x30000001000L);
-      case 77:
-      case 109:
-         return jjMoveStringLiteralDfa4_0(active0, 0x2000020000L);
-      case 80:
-      case 112:
-         return jjMoveStringLiteralDfa4_0(active0, 0x80000000000L);
-      case 81:
-      case 113:
-         return jjMoveStringLiteralDfa4_0(active0, 0x100000000000L);
-      case 82:
-      case 114:
-         if ((active0 & 0x4000L) != 0L)
-         {
-            jjmatchedKind = 14;
-            jjmatchedPos = 3;
-         }
-         return jjMoveStringLiteralDfa4_0(active0, 0x8000L);
-      case 83:
-      case 115:
-         if ((active0 & 0x8000000000L) != 0L)
-            return jjStartNfaWithStates_0(3, 39, 25);
-         return jjMoveStringLiteralDfa4_0(active0, 0x1000000000L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(2, active0);
-}
-private final int jjMoveStringLiteralDfa4_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(2, old0); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(3, active0);
-      return 4;
-   }
-   switch(curChar)
-   {
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa5_0(active0, 0x2004008000L);
-      case 69:
-      case 101:
-         if ((active0 & 0x20000000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 41, 25);
-         return jjMoveStringLiteralDfa5_0(active0, 0x1200001000L);
-      case 71:
-      case 103:
-         return jjMoveStringLiteralDfa5_0(active0, 0x10000000L);
-      case 72:
-      case 104:
-         return jjMoveStringLiteralDfa5_0(active0, 0x600000000000L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa5_0(active0, 0x20000L);
-      case 76:
-      case 108:
-         if ((active0 & 0x40000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 30, 25);
-         return jjMoveStringLiteralDfa5_0(active0, 0x10000000000L);
-      case 77:
-      case 109:
-         return jjMoveStringLiteralDfa5_0(active0, 0x400000L);
-      case 79:
-      case 111:
-         return jjMoveStringLiteralDfa5_0(active0, 0x80000000000L);
-      case 82:
-      case 114:
-         return jjMoveStringLiteralDfa5_0(active0, 0x4400000000L);
-      case 83:
-      case 115:
-         return jjMoveStringLiteralDfa5_0(active0, 0x40000000000L);
-      case 84:
-      case 116:
-         if ((active0 & 0x2000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 25, 25);
-         return jjMoveStringLiteralDfa5_0(active0, 0x1140000L);
-      case 85:
-      case 117:
-         return jjMoveStringLiteralDfa5_0(active0, 0x100000800000L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(3, active0);
-}
-private final int jjMoveStringLiteralDfa5_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(3, old0); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(4, active0);
-      return 5;
-   }
-   switch(curChar)
-   {
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa6_0(active0, 0x600000401000L);
-      case 67:
-      case 99:
-         return jjMoveStringLiteralDfa6_0(active0, 0x8000L);
-      case 69:
-      case 101:
-         if ((active0 & 0x40000L) != 0L)
-            return jjStartNfaWithStates_0(5, 18, 25);
-         else if ((active0 & 0x1000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 24, 25);
-         else if ((active0 & 0x100000000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 44, 25);
-         return jjMoveStringLiteralDfa6_0(active0, 0x4010000000L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa6_0(active0, 0x10400100000L);
-      case 76:
-      case 108:
-         if ((active0 & 0x4000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 26, 25);
-         return jjMoveStringLiteralDfa6_0(active0, 0x800000L);
-      case 82:
-      case 114:
-         if ((active0 & 0x200000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 33, 25);
-         return jjMoveStringLiteralDfa6_0(active0, 0x83000000000L);
-      case 84:
-      case 116:
-         if ((active0 & 0x20000L) != 0L)
-            return jjStartNfaWithStates_0(5, 17, 25);
-         return jjMoveStringLiteralDfa6_0(active0, 0x40000000000L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(4, active0);
-}
-private final int jjMoveStringLiteralDfa6_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(4, old0); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(5, active0);
-      return 6;
-   }
-   switch(curChar)
-   {
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa7_0(active0, 0xc0000000000L);
-      case 67:
-      case 99:
-         if ((active0 & 0x400000000L) != 0L)
-            return jjStartNfaWithStates_0(6, 34, 25);
-         break;
-      case 76:
-      case 108:
-         if ((active0 & 0x400000L) != 0L)
-            return jjStartNfaWithStates_0(6, 22, 25);
-         break;
-      case 77:
-      case 109:
-         return jjMoveStringLiteralDfa7_0(active0, 0x100000L);
-      case 78:
-      case 110:
-         if ((active0 & 0x1000L) != 0L)
-            return jjStartNfaWithStates_0(6, 12, 25);
-         return jjMoveStringLiteralDfa7_0(active0, 0x14000000000L);
-      case 82:
-      case 114:
-         if ((active0 & 0x10000000L) != 0L)
-            return jjStartNfaWithStates_0(6, 28, 25);
-         else if ((active0 & 0x200000000000L) != 0L)
-         {
-            jjmatchedKind = 45;
-            jjmatchedPos = 6;
-         }
-         return jjMoveStringLiteralDfa7_0(active0, 0x400000000000L);
-      case 84:
-      case 116:
-         if ((active0 & 0x800000L) != 0L)
-            return jjStartNfaWithStates_0(6, 23, 25);
-         return jjMoveStringLiteralDfa7_0(active0, 0x8000L);
-      case 86:
-      case 118:
-         return jjMoveStringLiteralDfa7_0(active0, 0x1000000000L);
-      case 89:
-      case 121:
-         if ((active0 & 0x2000000000L) != 0L)
-            return jjStartNfaWithStates_0(6, 37, 25);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(5, active0);
-}
-private final int jjMoveStringLiteralDfa7_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(5, old0); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(6, active0);
-      return 7;
-   }
-   switch(curChar)
-   {
-      case 50:
-         if ((active0 & 0x400000000000L) != 0L)
-            return jjStartNfaWithStates_0(7, 46, 24);
-         break;
-      case 67:
-      case 99:
-         return jjMoveStringLiteralDfa8_0(active0, 0x4000000000L);
-      case 69:
-      case 101:
-         if ((active0 & 0x100000L) != 0L)
-            return jjStartNfaWithStates_0(7, 20, 25);
-         else if ((active0 & 0x1000000000L) != 0L)
-            return jjStartNfaWithStates_0(7, 36, 25);
-         return jjMoveStringLiteralDfa8_0(active0, 0x8000L);
-      case 77:
-      case 109:
-         return jjMoveStringLiteralDfa8_0(active0, 0x40000000000L);
-      case 82:
-      case 114:
-         return jjMoveStringLiteralDfa8_0(active0, 0x80000000000L);
-      case 84:
-      case 116:
-         if ((active0 & 0x10000000000L) != 0L)
-            return jjStartNfaWithStates_0(7, 40, 25);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(6, active0);
-}
-private final int jjMoveStringLiteralDfa8_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(6, old0); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(7, active0);
-      return 8;
-   }
-   switch(curChar)
-   {
-      case 69:
-      case 101:
-         return jjMoveStringLiteralDfa9_0(active0, 0x4000000000L);
-      case 80:
-      case 112:
-         if ((active0 & 0x40000000000L) != 0L)
-            return jjStartNfaWithStates_0(8, 42, 25);
-         break;
-      case 82:
-      case 114:
-         if ((active0 & 0x8000L) != 0L)
-            return jjStartNfaWithStates_0(8, 15, 25);
-         break;
-      case 89:
-      case 121:
-         if ((active0 & 0x80000000000L) != 0L)
-            return jjStartNfaWithStates_0(8, 43, 25);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(7, active0);
-}
-private final int jjMoveStringLiteralDfa9_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(7, old0); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(8, active0);
-      return 9;
-   }
-   switch(curChar)
-   {
-      case 83:
-      case 115:
-         if ((active0 & 0x4000000000L) != 0L)
-            return jjStartNfaWithStates_0(9, 38, 25);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(8, active0);
-}
-private final void jjCheckNAdd(int state)
-{
-   if (jjrounds[state] != jjround)
-   {
-      jjstateSet[jjnewStateCnt++] = state;
-      jjrounds[state] = jjround;
-   }
-}
-private final void jjAddStates(int start, int end)
-{
-   do {
-      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
-   } while (start++ != end);
-}
-private final void jjCheckNAddTwoStates(int state1, int state2)
-{
-   jjCheckNAdd(state1);
-   jjCheckNAdd(state2);
-}
-private final void jjCheckNAddStates(int start, int end)
-{
-   do {
-      jjCheckNAdd(jjnextStates[start]);
-   } while (start++ != end);
-}
-private final void jjCheckNAddStates(int start)
-{
-   jjCheckNAdd(jjnextStates[start]);
-   jjCheckNAdd(jjnextStates[start + 1]);
-}
-static final long[] jjbitVec0 = {
-   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
-};
-private final int jjMoveNfa_0(int startState, int curPos)
-{
-   int[] nextStates;
-   int startsAt = 0;
-   jjnewStateCnt = 25;
-   int i = 1;
-   jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
-   for (;;)
-   {
-      if (++jjround == 0x7fffffff)
-         ReInitRounds();
-      if (curChar < 64)
-      {
-         long l = 1L << curChar;
-         MatchLoop: do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-                  if ((0x3ff000000000000L & l) != 0L)
-                  {
-                     if (kind > 48)
-                        kind = 48;
-                     jjCheckNAddStates(0, 4);
-                  }
-                  else if (curChar == 46)
-                     jjCheckNAdd(7);
-                  else if (curChar == 39)
-                     jjCheckNAddStates(5, 7);
-                  break;
-               case 25:
-               case 24:
-                  if ((0x3ff001800000000L & l) == 0L)
-                     break;
-                  if (kind > 51)
-                     kind = 51;
-                  jjCheckNAdd(24);
-                  break;
-               case 1:
-                  if ((0xffffff7fffffffffL & l) != 0L)
-                     jjCheckNAddStates(5, 7);
-                  break;
-               case 2:
-                  if (curChar == 39)
-                     jjCheckNAddStates(8, 10);
-                  break;
-               case 3:
-                  if (curChar == 39)
-                     jjstateSet[jjnewStateCnt++] = 2;
-                  break;
-               case 4:
-                  if ((0xffffff7fffffffffL & l) != 0L)
-                     jjCheckNAddStates(8, 10);
-                  break;
-               case 5:
-                  if (curChar == 39 && kind > 47)
-                     kind = 47;
-                  break;
-               case 6:
-                  if (curChar == 46)
-                     jjCheckNAdd(7);
-                  break;
-               case 7:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 49)
-                     kind = 49;
-                  jjCheckNAddTwoStates(7, 8);
-                  break;
-               case 9:
-                  if ((0x280000000000L & l) != 0L)
-                     jjCheckNAdd(10);
-                  break;
-               case 10:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 49)
-                     kind = 49;
-                  jjCheckNAdd(10);
-                  break;
-               case 11:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 48)
-                     kind = 48;
-                  jjCheckNAddStates(0, 4);
-                  break;
-               case 12:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 48)
-                     kind = 48;
-                  jjCheckNAdd(12);
-                  break;
-               case 13:
-                  if ((0x3ff000000000000L & l) != 0L)
-                     jjCheckNAddTwoStates(13, 14);
-                  break;
-               case 14:
-                  if (curChar == 46)
-                     jjCheckNAdd(15);
-                  break;
-               case 15:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 49)
-                     kind = 49;
-                  jjCheckNAddTwoStates(15, 16);
-                  break;
-               case 17:
-                  if ((0x280000000000L & l) != 0L)
-                     jjCheckNAdd(18);
-                  break;
-               case 18:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 49)
-                     kind = 49;
-                  jjCheckNAdd(18);
-                  break;
-               case 19:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 49)
-                     kind = 49;
-                  jjCheckNAddTwoStates(19, 20);
-                  break;
-               case 21:
-                  if ((0x280000000000L & l) != 0L)
-                     jjCheckNAdd(22);
-                  break;
-               case 22:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 49)
-                     kind = 49;
-                  jjCheckNAdd(22);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else if (curChar < 128)
-      {
-         long l = 1L << (curChar & 077);
-         MatchLoop: do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-               case 23:
-                  if ((0x7fffffe07fffffeL & l) == 0L)
-                     break;
-                  if (kind > 51)
-                     kind = 51;
-                  jjCheckNAddTwoStates(23, 24);
-                  break;
-               case 25:
-                  if ((0x7fffffe87fffffeL & l) != 0L)
-                  {
-                     if (kind > 51)
-                        kind = 51;
-                     jjCheckNAdd(24);
-                  }
-                  if ((0x7fffffe07fffffeL & l) != 0L)
-                  {
-                     if (kind > 51)
-                        kind = 51;
-                     jjCheckNAddTwoStates(23, 24);
-                  }
-                  break;
-               case 1:
-                  jjCheckNAddStates(5, 7);
-                  break;
-               case 4:
-                  jjCheckNAddStates(8, 10);
-                  break;
-               case 8:
-                  if ((0x2000000020L & l) != 0L)
-                     jjAddStates(11, 12);
-                  break;
-               case 16:
-                  if ((0x2000000020L & l) != 0L)
-                     jjAddStates(13, 14);
-                  break;
-               case 20:
-                  if ((0x2000000020L & l) != 0L)
-                     jjAddStates(15, 16);
-                  break;
-               case 24:
-                  if ((0x7fffffe87fffffeL & l) == 0L)
-                     break;
-                  if (kind > 51)
-                     kind = 51;
-                  jjCheckNAdd(24);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else
-      {
-         int i2 = (curChar & 0xff) >> 6;
-         long l2 = 1L << (curChar & 077);
-         MatchLoop: do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 1:
-                  if ((jjbitVec0[i2] & l2) != 0L)
-                     jjCheckNAddStates(5, 7);
-                  break;
-               case 4:
-                  if ((jjbitVec0[i2] & l2) != 0L)
-                     jjCheckNAddStates(8, 10);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      if (kind != 0x7fffffff)
-      {
-         jjmatchedKind = kind;
-         jjmatchedPos = curPos;
-         kind = 0x7fffffff;
-      }
-      ++curPos;
-      if ((i = jjnewStateCnt) == (startsAt = 25 - (jjnewStateCnt = startsAt)))
-         return curPos;
-      try { curChar = input_stream.readChar(); }
-      catch(java.io.IOException e) { return curPos; }
-   }
-}
-private final int jjMoveStringLiteralDfa0_2()
-{
-   switch(curChar)
-   {
-      case 10:
-         return jjStopAtPos(0, 10);
-      default :
-         return 1;
-   }
-}
-private final int jjMoveStringLiteralDfa0_1()
-{
-   switch(curChar)
-   {
-      case 42:
-         return jjMoveStringLiteralDfa1_1(0x80L);
-      default :
-         return 1;
-   }
-}
-private final int jjMoveStringLiteralDfa1_1(long active0)
-{
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      return 1;
-   }
-   switch(curChar)
-   {
-      case 47:
-         if ((active0 & 0x80L) != 0L)
-            return jjStopAtPos(1, 7);
-         break;
-      default :
-         return 2;
-   }
-   return 2;
-}
-static final int[] jjnextStates = {
-   12, 13, 14, 19, 20, 1, 3, 5, 3, 4, 5, 9, 10, 17, 18, 21, 
-   22, 
-};
-public static final String[] jjstrLiteralImages = {
-"", null, null, null, null, null, null, null, null, null, null, null, null, 
-null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
-null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
-null, null, null, null, null, null, null, null, null, null, null, null, null, "\51", 
-"\54", "\56", "\50", "\73", };
-public static final String[] lexStateNames = {
-   "DEFAULT", 
-   "WithinComment", 
-   "WithinLineComment", 
-};
-public static final int[] jjnewLexState = {
-   -1, -1, -1, -1, -1, -1, 1, 0, -1, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-};
-static final long[] jjtoToken = {
-   0x7fbfffffffff001L, 
-};
-static final long[] jjtoSkip = {
-   0x6feL, 
-};
-static final long[] jjtoSpecial = {
-   0x6c0L, 
-};
-static final long[] jjtoMore = {
-   0x900L, 
-};
-protected SimpleCharStream input_stream;
-private final int[] jjrounds = new int[25];
-private final int[] jjstateSet = new int[50];
-StringBuffer image;
-int jjimageLen;
-int lengthOfMatch;
-protected char curChar;
-public DML2CloverTokenManager(SimpleCharStream stream){
-   if (SimpleCharStream.staticFlag)
-      throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
-   input_stream = stream;
-}
-public DML2CloverTokenManager(SimpleCharStream stream, int lexState){
-   this(stream);
-   SwitchTo(lexState);
-}
-public void ReInit(SimpleCharStream stream)
-{
-   jjmatchedPos = jjnewStateCnt = 0;
-   curLexState = defaultLexState;
-   input_stream = stream;
-   ReInitRounds();
-}
-private final void ReInitRounds()
-{
-   int i;
-   jjround = 0x80000001;
-   for (i = 25; i-- > 0;)
-      jjrounds[i] = 0x80000000;
-}
-public void ReInit(SimpleCharStream stream, int lexState)
-{
-   ReInit(stream);
-   SwitchTo(lexState);
-}
-public void SwitchTo(int lexState)
-{
-   if (lexState >= 3 || lexState < 0)
-      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
-   else
-      curLexState = lexState;
-}
-
-protected Token jjFillToken()
-{
-   Token t = Token.newToken(jjmatchedKind);
-   t.kind = jjmatchedKind;
-   String im = jjstrLiteralImages[jjmatchedKind];
-   t.image = (im == null) ? input_stream.GetImage() : im;
-   t.beginLine = input_stream.getBeginLine();
-   t.beginColumn = input_stream.getBeginColumn();
-   t.endLine = input_stream.getEndLine();
-   t.endColumn = input_stream.getEndColumn();
-   return t;
-}
-
-int curLexState = 0;
-int defaultLexState = 0;
-int jjnewStateCnt;
-int jjround;
-int jjmatchedPos;
-int jjmatchedKind;
-
-public Token getNextToken() 
-{
-  int kind;
-  Token specialToken = null;
-  Token matchedToken;
-  int curPos = 0;
-
-  EOFLoop :
-  for (;;)
-  {   
-   try   
-   {     
-      curChar = input_stream.BeginToken();
-   }     
-   catch(java.io.IOException e)
-   {        
-      jjmatchedKind = 0;
-      matchedToken = jjFillToken();
-      matchedToken.specialToken = specialToken;
-      return matchedToken;
-   }
-   image = null;
-   jjimageLen = 0;
-
-   for (;;)
-   {
-     switch(curLexState)
-     {
-       case 0:
-         try { input_stream.backup(0);
-            while (curChar <= 32 && (0x100002200L & (1L << curChar)) != 0L)
-               curChar = input_stream.BeginToken();
-         }
-         catch (java.io.IOException e1) { continue EOFLoop; }
-         jjmatchedKind = 0x7fffffff;
-         jjmatchedPos = 0;
-         curPos = jjMoveStringLiteralDfa0_0();
-         break;
-       case 1:
-         jjmatchedKind = 0x7fffffff;
-         jjmatchedPos = 0;
-         curPos = jjMoveStringLiteralDfa0_1();
-         if (jjmatchedPos == 0 && jjmatchedKind > 8)
-         {
-            jjmatchedKind = 8;
-         }
-         break;
-       case 2:
-         jjmatchedKind = 0x7fffffff;
-         jjmatchedPos = 0;
-         curPos = jjMoveStringLiteralDfa0_2();
-         if (jjmatchedPos == 0 && jjmatchedKind > 11)
-         {
-            jjmatchedKind = 11;
-         }
-         break;
-     }
-     if (jjmatchedKind != 0x7fffffff)
-     {
-        if (jjmatchedPos + 1 < curPos)
-           input_stream.backup(curPos - jjmatchedPos - 1);
-        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
-        {
-           matchedToken = jjFillToken();
-           matchedToken.specialToken = specialToken;
-       if (jjnewLexState[jjmatchedKind] != -1)
-         curLexState = jjnewLexState[jjmatchedKind];
-           return matchedToken;
-        }
-        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
-        {
-           if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
-           {
-              matchedToken = jjFillToken();
-              if (specialToken == null)
-                 specialToken = matchedToken;
-              else
-              {
-                 matchedToken.specialToken = specialToken;
-                 specialToken = (specialToken.next = matchedToken);
-              }
-              SkipLexicalActions(matchedToken);
-           }
-           else 
-              SkipLexicalActions(null);
-         if (jjnewLexState[jjmatchedKind] != -1)
-           curLexState = jjnewLexState[jjmatchedKind];
-           continue EOFLoop;
-        }
-        jjimageLen += jjmatchedPos + 1;
-      if (jjnewLexState[jjmatchedKind] != -1)
-        curLexState = jjnewLexState[jjmatchedKind];
-        curPos = 0;
-        jjmatchedKind = 0x7fffffff;
-        try {
-           curChar = input_stream.readChar();
-           continue;
-        }
-        catch (java.io.IOException e1) { }
-     }
-     int error_line = input_stream.getEndLine();
-     int error_column = input_stream.getEndColumn();
-     String error_after = null;
-     boolean EOFSeen = false;
-     try { input_stream.readChar(); input_stream.backup(1); }
-     catch (java.io.IOException e1) {
-        EOFSeen = true;
-        error_after = curPos <= 1 ? "" : input_stream.GetImage();
-        if (curChar == '\n' || curChar == '\r') {
-           error_line++;
-           error_column = 0;
-        }
-        else
-           error_column++;
-     }
-     if (!EOFSeen) {
-        input_stream.backup(1);
-        error_after = curPos <= 1 ? "" : input_stream.GetImage();
-     }
-     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
-   }
-  }
-}
-
-void SkipLexicalActions(Token matchedToken)
-{
-   switch(jjmatchedKind)
-   {
-      default :
-         break;
-   }
-}
-}

Modified: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DataType.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/DataType.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/DataType.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -1,4 +1,4 @@
-package org.jetel.util.dml2clover;
+package org.jetel.util.ddl2clover;
 public final class DataType {
 
     /** Data type, based on java.sql.Types */

Modified: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/ParseException.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/ParseException.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/ParseException.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -1,5 +1,5 @@
 /* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */
-package org.jetel.util.dml2clover;
+package org.jetel.util.ddl2clover;
 
 /**
  * This exception is thrown when parse errors are encountered.

Modified: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/SimpleCharStream.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/SimpleCharStream.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/SimpleCharStream.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -1,5 +1,5 @@
 /* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.0 */
-package org.jetel.util.dml2clover;
+package org.jetel.util.ddl2clover;
 
 /**
  * An implementation of interface CharStream, where the stream is assumed to

Modified: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/Token.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/Token.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/Token.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -1,5 +1,5 @@
 /* Generated By:JavaCC: Do not edit this line. Token.java Version 3.0 */
-package org.jetel.util.dml2clover;
+package org.jetel.util.ddl2clover;
 
 /**
  * Describes the input token stream.

Modified: trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/TokenMgrError.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/dml2clover/TokenMgrError.java	2007-02-20 13:57:34 UTC (rev 2493)
+++ trunk/cloveretl.engine/src/org/jetel/util/ddl2clover/TokenMgrError.java	2007-02-20 14:44:00 UTC (rev 2494)
@@ -1,5 +1,5 @@
 /* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 3.0 */
-package org.jetel.util.dml2clover;
+package org.jetel.util.ddl2clover;
 
 public class TokenMgrError extends Error
 {



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 20 16:47:47 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 20 Feb 2007 16:47:47 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2496 -
	trunk/cloveretl.engine/src/org/jetel/util
Message-ID: <200702201547.l1KFllXV000838@sheep.berlios.de>

Author: dpavlis
Date: 2007-02-20 16:47:45 +0100 (Tue, 20 Feb 2007)
New Revision: 2496

Modified:
   trunk/cloveretl.engine/src/org/jetel/util/ByteBufferUtils.java
Log:
MINOR:remove unneccessary initialization

Modified: trunk/cloveretl.engine/src/org/jetel/util/ByteBufferUtils.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/ByteBufferUtils.java	2007-02-20 14:45:19 UTC (rev 2495)
+++ trunk/cloveretl.engine/src/org/jetel/util/ByteBufferUtils.java	2007-02-20 15:47:45 UTC (rev 2496)
@@ -157,7 +157,7 @@
      */
     public static final int decodeLength(ByteBuffer buffer){
         int length=0; 
-        int size=0;
+        int size;
         int offset = 0;
         
         size = buffer.get();



From cloveretl-svn-commits at lists.berlios.de  Wed Feb 21 11:13:36 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 21 Feb 2007 11:13:36 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2497 -
	trunk/cloveretl.component/src/org/jetel/component
Message-ID: <200702211013.l1LADa21005179@sheep.berlios.de>

Author: jausperger
Date: 2007-02-21 11:13:34 +0100 (Wed, 21 Feb 2007)
New Revision: 2497

Modified:
   trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
Log:
UPDATE: numRecord, skip, WritableByteChannel

Modified: trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-20 15:47:45 UTC (rev 2496)
+++ trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-21 10:13:34 UTC (rev 2497)
@@ -29,7 +29,6 @@
 import org.jetel.data.Defaults;
 import org.jetel.data.formatter.DataFormatter;
 import org.jetel.exception.ComponentNotReadyException;
-import org.jetel.exception.ConfigurationProblem;
 import org.jetel.exception.ConfigurationStatus;
 import org.jetel.exception.XMLConfigurationException;
 import org.jetel.graph.InputPort;
@@ -94,8 +93,8 @@
     private static final String XML_OUTPUT_FIELD_NAMES = "outputFieldNames";
 	private static final String XML_RECORDS_PER_FILE = "recordsPerFile";
 	private static final String XML_BYTES_PER_FILE = "bytesPerFile";
-	public static final String XML_RECORD_SKIP_ATTRIBUTE = "recordSkip";
-	public static final String XML_RECORD_COUNT_ATTRIBUTE = "recordCount";
+	private static final String XML_RECORD_SKIP_ATTRIBUTE = "recordSkip";
+	private static final String XML_RECORD_COUNT_ATTRIBUTE = "recordCount";
 	private String fileURL;
 	private boolean appendData;
 	private DataFormatter formatter;
@@ -106,6 +105,7 @@
 	private WritableByteChannel writableByteChannel;
     private int skip;
 	private int numRecords;
+	private String charset;
 
 	static Log logger = LogFactory.getLog(DataWriter.class);
 
@@ -124,6 +124,7 @@
 		super(id);
 		this.fileURL = fileURL;
 		this.appendData = appendData;
+		this.charset = charset;
 		formatter = new DataFormatter(charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
 	}
 	
@@ -131,6 +132,7 @@
 		super(id);
 		this.writableByteChannel = writableByteChannel;
 		this.appendData = appendData;
+		this.charset = charset;
 		formatter = new DataFormatter(charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
 	}
 
@@ -179,6 +181,7 @@
         writer.setRecordsPerFile(recordsPerFile);
         writer.setAppendData(appendData);
         writer.setSkip(skip);
+        writer.setCharset(charset);
         writer.setNumRecords(numRecords);
         if(outputFieldNames) {
             writer.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());

Modified: trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-20 15:47:45 UTC (rev 2496)
+++ trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-21 10:13:34 UTC (rev 2497)
@@ -19,13 +19,16 @@
 */
 
 package org.jetel.component;
+import java.nio.channels.Channels;
+import java.nio.channels.WritableByteChannel;
+import java.util.Iterator;
+
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.jetel.data.DataRecord;
 import org.jetel.data.Defaults;
 import org.jetel.data.formatter.DelimitedDataFormatter;
 import org.jetel.exception.ComponentNotReadyException;
-import org.jetel.exception.ConfigurationProblem;
 import org.jetel.exception.ConfigurationStatus;
 import org.jetel.exception.XMLConfigurationException;
 import org.jetel.graph.InputPort;
@@ -35,7 +38,6 @@
 import org.jetel.util.ComponentXMLAttributes;
 import org.jetel.util.FileUtils;
 import org.jetel.util.MultiFileWriter;
-import org.jetel.util.StringUtils;
 import org.jetel.util.SynchronizeUtils;
 import org.w3c.dom.Element;
 
@@ -89,6 +91,8 @@
 	private static final String XML_OUTPUT_FIELD_NAMES = "outputFieldNames";
 	private static final String XML_RECORDS_PER_FILE = "recordsPerFile";
 	private static final String XML_BYTES_PER_FILE = "bytesPerFile";
+	private static final String XML_RECORD_SKIP_ATTRIBUTE = "recordSkip";
+	private static final String XML_RECORD_COUNT_ATTRIBUTE = "recordCount";
 	
 	private static final boolean APPEND_DATA_AS_DEFAULT = false;
 	
@@ -100,7 +104,10 @@
 	private int recordsPerFile;
 	private int bytesPerFile;
 	private String charset;
-    
+    private int skip;
+	private int numRecords;
+	private WritableByteChannel writableByteChannel;
+
 	static Log logger = LogFactory.getLog(DelimitedDataWriter.class);
 
 	public final static String COMPONENT_TYPE = "DELIMITED_DATA_WRITER";
@@ -121,6 +128,12 @@
 		formatter = new DelimitedDataFormatter();
 	}
 
+	public DelimitedDataWriter(String id, WritableByteChannel writableByteChannel) {
+		super(id);
+		this.writableByteChannel = writableByteChannel;
+		formatter = new DelimitedDataFormatter();
+	}
+
 	public DelimitedDataWriter(String id, String fileURL, String charset, boolean appendData) {
 		super(id);
 		this.fileURL = fileURL;
@@ -129,7 +142,14 @@
 		formatter = new DelimitedDataFormatter(charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
 	}
 
+	public DelimitedDataWriter(String id, WritableByteChannel writableByteChannel, String charset) {
+		super(id);
+		this.writableByteChannel = writableByteChannel;
+        this.charset = charset;
+		formatter = new DelimitedDataFormatter(charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
+	}
 
+
 	@Override
 	public Result execute() throws Exception {
 		InputPort inPort = getInputPort(READ_FROM_PORT);
@@ -164,12 +184,21 @@
 		}
         
         // initialize multifile writer based on prepared formatter
-        writer = new MultiFileWriter(formatter, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
+		if (fileURL != null) {
+	        writer = new MultiFileWriter(formatter, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
+		} else {
+			if (writableByteChannel == null) {
+		        writableByteChannel = Channels.newChannel(System.out);
+			}
+	        writer = new MultiFileWriter(formatter, new WritableByteChannelIterator(writableByteChannel));
+		}
         writer.setLogger(logger);
         writer.setBytesPerFile(bytesPerFile);
         writer.setRecordsPerFile(recordsPerFile);
         writer.setAppendData(appendData);
         writer.setCharset(charset);
+        writer.setSkip(skip);
+        writer.setNumRecords(numRecords);
         if(outputFieldNames) {
             writer.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
         }
@@ -216,6 +245,12 @@
 		if (bytesPerFile > 0) {
 			xmlElement.setAttribute(XML_BYTES_PER_FILE, Integer.toString(bytesPerFile));
 		}
+		if (skip != 0){
+			xmlElement.setAttribute(XML_RECORD_SKIP_ATTRIBUTE, String.valueOf(skip));
+		}
+		if (numRecords != 0){
+			xmlElement.setAttribute(XML_RECORD_COUNT_ATTRIBUTE,String.valueOf(numRecords));
+		}
 	}
 
 	
@@ -244,6 +279,12 @@
             if(xattribs.exists(XML_BYTES_PER_FILE)) {
                 aDelimitedDataWriterNIO.setBytesPerFile(xattribs.getInteger(XML_BYTES_PER_FILE));
             }
+			if (xattribs.exists(XML_RECORD_SKIP_ATTRIBUTE)){
+				aDelimitedDataWriterNIO.setSkip(Integer.parseInt(xattribs.getString(XML_RECORD_SKIP_ATTRIBUTE)));
+			}
+			if (xattribs.exists(XML_RECORD_COUNT_ATTRIBUTE)){
+				aDelimitedDataWriterNIO.setNumRecords(Integer.parseInt(xattribs.getString(XML_RECORD_COUNT_ATTRIBUTE)));
+			}
 		}catch(Exception ex){
 	           throw new XMLConfigurationException(COMPONENT_TYPE + ":" + xattribs.getString(XML_ID_ATTRIBUTE," unknown ID ") + ":" + ex.getMessage(),ex);
 		}
@@ -275,5 +316,40 @@
     public void setRecordsPerFile(int recordsPerFile) {
         this.recordsPerFile = recordsPerFile;
     }
+    
+    /**
+     * Sets number of skipped records in next call of getNext() method.
+     * @param skip
+     */
+    public void setSkip(int skip) {
+        this.skip = skip;
+    }
+
+    /**
+     * Sets number of written records.
+     * @param numRecords
+     */
+    public void setNumRecords(int numRecords) {
+        this.numRecords = numRecords;
+    }
+
+    private class WritableByteChannelIterator implements Iterator<WritableByteChannel> {
+    	WritableByteChannel writableByteChannel;
+    	
+    	public WritableByteChannelIterator(WritableByteChannel writableByteChannel) {
+    		this.writableByteChannel = writableByteChannel;
+    	}
+    	
+		public boolean hasNext() {
+			return true;
+		}
+
+		public WritableByteChannel next() {
+			return writableByteChannel;
+		}
+
+		public void remove() {}
+    }
+
 }
 

Modified: trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-20 15:47:45 UTC (rev 2496)
+++ trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-21 10:13:34 UTC (rev 2497)
@@ -18,13 +18,16 @@
 *
 */
 package org.jetel.component;
+import java.nio.channels.Channels;
+import java.nio.channels.WritableByteChannel;
+import java.util.Iterator;
+
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.jetel.data.DataRecord;
 import org.jetel.data.Defaults;
 import org.jetel.data.formatter.FixLenDataFormatter;
 import org.jetel.exception.ComponentNotReadyException;
-import org.jetel.exception.ConfigurationProblem;
 import org.jetel.exception.ConfigurationStatus;
 import org.jetel.exception.XMLConfigurationException;
 import org.jetel.graph.InputPort;
@@ -93,6 +96,8 @@
 	private static final String XML_RECORD_FILLER = "filler";
 	private static final String XML_RECORDS_PER_FILE = "recordsPerFile";
 	private static final String XML_BYTES_PER_FILE = "bytesPerFile";
+	private static final String XML_RECORD_SKIP_ATTRIBUTE = "recordSkip";
+	private static final String XML_RECORD_COUNT_ATTRIBUTE = "recordCount";
 	
 	private static final boolean DEFAULT_APPEND=false;
 	
@@ -103,6 +108,10 @@
 	private boolean outputFieldNames=false;
 	private int recordsPerFile;
 	private int bytesPerFile;
+    private int skip;
+	private int numRecords;
+	private String charset;
+	private WritableByteChannel writableByteChannel;
 
 	static Log logger = LogFactory.getLog(FixLenDataWriter.class);
 
@@ -123,9 +132,17 @@
 		super(id);
 		this.fileURL = fileURL;
 		this.appendData = appendData;
+        this.charset = charset;
 		formatter = new FixLenDataFormatter(charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
 	}
 
+	public FixLenDataWriter(String id, WritableByteChannel writableByteChannel, String charset) {
+		super(id);
+		this.writableByteChannel = writableByteChannel;
+        this.charset = charset;
+		formatter = new FixLenDataFormatter(charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
+	}
+
 	@Override
 	public Result execute() throws Exception {
 		InputPort inPort = getInputPort(READ_FROM_PORT);
@@ -157,12 +174,24 @@
 	public void init() throws ComponentNotReadyException {
 		super.init();
         // initialize multifile writer based on prepared formatter
-        writer = new MultiFileWriter(formatter, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
+		if (fileURL != null) {
+	        writer = new MultiFileWriter(formatter, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
+		} else {
+			if (writableByteChannel == null) {
+		        writableByteChannel = Channels.newChannel(System.out);
+			}
+	        writer = new MultiFileWriter(formatter, new WritableByteChannelIterator(writableByteChannel));
+		}
         writer.setLogger(logger);
         writer.setBytesPerFile(bytesPerFile);
         writer.setRecordsPerFile(recordsPerFile);
         writer.setAppendData(appendData);
-        //TODO kokon - outputFiledNames
+        writer.setCharset(charset);
+        writer.setSkip(skip);
+        writer.setNumRecords(numRecords);
+        if(outputFieldNames) {
+            writer.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
+        }
         writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}
 	
@@ -197,6 +226,12 @@
 		if (bytesPerFile > 0) {
 			xmlElement.setAttribute(XML_BYTES_PER_FILE, Integer.toString(bytesPerFile));
 		}
+		if (skip != 0){
+			xmlElement.setAttribute(XML_RECORD_SKIP_ATTRIBUTE, String.valueOf(skip));
+		}
+		if (numRecords != 0){
+			xmlElement.setAttribute(XML_RECORD_COUNT_ATTRIBUTE,String.valueOf(numRecords));
+		}
 		
 	}
 
@@ -236,6 +271,12 @@
             if(xattribs.exists(XML_BYTES_PER_FILE)) {
                 aFixLenDataWriterNIO.setBytesPerFile(xattribs.getInteger(XML_BYTES_PER_FILE));
             }
+			if (xattribs.exists(XML_RECORD_SKIP_ATTRIBUTE)){
+				aFixLenDataWriterNIO.setSkip(Integer.parseInt(xattribs.getString(XML_RECORD_SKIP_ATTRIBUTE)));
+			}
+			if (xattribs.exists(XML_RECORD_COUNT_ATTRIBUTE)){
+				aFixLenDataWriterNIO.setNumRecords(Integer.parseInt(xattribs.getString(XML_RECORD_COUNT_ATTRIBUTE)));
+			}
 		}catch(Exception ex){
 	           throw new XMLConfigurationException(COMPONENT_TYPE + ":" + xattribs.getString(XML_ID_ATTRIBUTE," unknown ID ") + ":" + ex.getMessage(),ex);
 		}
@@ -305,5 +346,40 @@
     public void setRecordsPerFile(int recordsPerFile) {
         this.recordsPerFile = recordsPerFile;
     }
+    
+    /**
+     * Sets number of skipped records in next call of getNext() method.
+     * @param skip
+     */
+    public void setSkip(int skip) {
+        this.skip = skip;
+    }
+
+    /**
+     * Sets number of written records.
+     * @param numRecords
+     */
+    public void setNumRecords(int numRecords) {
+        this.numRecords = numRecords;
+    }
+
+    private class WritableByteChannelIterator implements Iterator<WritableByteChannel> {
+    	WritableByteChannel writableByteChannel;
+    	
+    	public WritableByteChannelIterator(WritableByteChannel writableByteChannel) {
+    		this.writableByteChannel = writableByteChannel;
+    	}
+    	
+		public boolean hasNext() {
+			return true;
+		}
+
+		public WritableByteChannel next() {
+			return writableByteChannel;
+		}
+
+		public void remove() {}
+    }
+
 }
 



From cloveretl-svn-commits at lists.berlios.de  Wed Feb 21 14:29:05 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 21 Feb 2007 14:29:05 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2498 - in trunk:
	cloveretl.component/src/org/jetel/component
	cloveretl.engine/src/org/jetel/util
Message-ID: <200702211329.l1LDT5sd029104@sheep.berlios.de>

Author: jausperger
Date: 2007-02-21 14:29:03 +0100 (Wed, 21 Feb 2007)
New Revision: 2498

Added:
   trunk/cloveretl.engine/src/org/jetel/util/WritableByteChannelIterator.java
Modified:
   trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
Log:
UPDATE: numRecord, skip, WritableByteChannel

Modified: trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-21 10:13:34 UTC (rev 2497)
+++ trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-21 13:29:03 UTC (rev 2498)
@@ -21,7 +21,6 @@
 package org.jetel.component;
 import java.nio.channels.Channels;
 import java.nio.channels.WritableByteChannel;
-import java.util.Iterator;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -39,6 +38,7 @@
 import org.jetel.util.FileUtils;
 import org.jetel.util.MultiFileWriter;
 import org.jetel.util.SynchronizeUtils;
+import org.jetel.util.WritableByteChannelIterator;
 import org.w3c.dom.Element;
 
 /**
@@ -128,10 +128,9 @@
 		formatter = new DataFormatter(charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
 	}
 	
-	public DataWriter(String id, WritableByteChannel writableByteChannel, String charset, boolean appendData) {
+	public DataWriter(String id, WritableByteChannel writableByteChannel, String charset) {
 		super(id);
 		this.writableByteChannel = writableByteChannel;
-		this.appendData = appendData;
 		this.charset = charset;
 		formatter = new DataFormatter(charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
 	}
@@ -322,22 +321,4 @@
         this.numRecords = numRecords;
     }
 	
-    private class WritableByteChannelIterator implements Iterator<WritableByteChannel> {
-    	WritableByteChannel writableByteChannel;
-    	
-    	public WritableByteChannelIterator(WritableByteChannel writableByteChannel) {
-    		this.writableByteChannel = writableByteChannel;
-    	}
-    	
-		public boolean hasNext() {
-			return true;
-		}
-
-		public WritableByteChannel next() {
-			return writableByteChannel;
-		}
-
-		public void remove() {}
-    }
-    
 }

Modified: trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-21 10:13:34 UTC (rev 2497)
+++ trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-21 13:29:03 UTC (rev 2498)
@@ -21,7 +21,6 @@
 package org.jetel.component;
 import java.nio.channels.Channels;
 import java.nio.channels.WritableByteChannel;
-import java.util.Iterator;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -39,6 +38,7 @@
 import org.jetel.util.FileUtils;
 import org.jetel.util.MultiFileWriter;
 import org.jetel.util.SynchronizeUtils;
+import org.jetel.util.WritableByteChannelIterator;
 import org.w3c.dom.Element;
 
 /**
@@ -75,6 +75,8 @@
  *  <tr><td><b>outputFieldNames</b><br><i>optional</i></td><td>print names of individual fields into output file - as a first row (values: true/false, default:false)</td> 
  *  <tr><td><b>recordsPerFile</b></td><td>max number of records in one output file</td>
  *  <tr><td><b>bytesPerFile</b></td><td>Max size of output files. To avoid splitting a record to two files, max size could be slightly overreached.</td>
+ *  <tr><td><b>recordSkip</b></td><td>number of skipped records</td>
+ *  <tr><td><b>recordCount</b></td><td>number of written records</td>
  *  </tr>
  *  </table>  
  *
@@ -333,23 +335,5 @@
         this.numRecords = numRecords;
     }
 
-    private class WritableByteChannelIterator implements Iterator<WritableByteChannel> {
-    	WritableByteChannel writableByteChannel;
-    	
-    	public WritableByteChannelIterator(WritableByteChannel writableByteChannel) {
-    		this.writableByteChannel = writableByteChannel;
-    	}
-    	
-		public boolean hasNext() {
-			return true;
-		}
-
-		public WritableByteChannel next() {
-			return writableByteChannel;
-		}
-
-		public void remove() {}
-    }
-
 }
 

Modified: trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-21 10:13:34 UTC (rev 2497)
+++ trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-21 13:29:03 UTC (rev 2498)
@@ -20,7 +20,6 @@
 package org.jetel.component;
 import java.nio.channels.Channels;
 import java.nio.channels.WritableByteChannel;
-import java.util.Iterator;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -37,6 +36,7 @@
 import org.jetel.util.ComponentXMLAttributes;
 import org.jetel.util.FileUtils;
 import org.jetel.util.MultiFileWriter;
+import org.jetel.util.WritableByteChannelIterator;
 import org.w3c.dom.Element;
 
 /**
@@ -75,6 +75,8 @@
  *  <tr><td><b>recordFiller</b><br><i>optional</i></td><td>allows specifying what character will be used for padding gaps between fields in output records. Default is "."></td>
  *  <tr><td><b>recordsPerFile</b></td><td>max number of records in one output file</td>
  *  <tr><td><b>bytesPerFile</b></td><td>Max size of output files. To avoid splitting a record to two files, max size could be slightly overreached.</td>
+ *  <tr><td><b>recordSkip</b></td><td>number of skipped records</td>
+ *  <tr><td><b>recordCount</b></td><td>number of written records</td>
  *  </table>
  *
  * <h4>Example:</h4>
@@ -363,23 +365,5 @@
         this.numRecords = numRecords;
     }
 
-    private class WritableByteChannelIterator implements Iterator<WritableByteChannel> {
-    	WritableByteChannel writableByteChannel;
-    	
-    	public WritableByteChannelIterator(WritableByteChannel writableByteChannel) {
-    		this.writableByteChannel = writableByteChannel;
-    	}
-    	
-		public boolean hasNext() {
-			return true;
-		}
-
-		public WritableByteChannel next() {
-			return writableByteChannel;
-		}
-
-		public void remove() {}
-    }
-
 }
 

Added: trunk/cloveretl.engine/src/org/jetel/util/WritableByteChannelIterator.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/WritableByteChannelIterator.java	2007-02-21 10:13:34 UTC (rev 2497)
+++ trunk/cloveretl.engine/src/org/jetel/util/WritableByteChannelIterator.java	2007-02-21 13:29:03 UTC (rev 2498)
@@ -0,0 +1,28 @@
+package org.jetel.util;
+
+import java.nio.channels.WritableByteChannel;
+import java.util.Iterator;
+
+/**
+ * Channel iterator class.
+ * It is used in MultiFileWriter.
+ * 
+ * @author ausperger
+ */
+public class WritableByteChannelIterator implements Iterator<WritableByteChannel> {
+	private WritableByteChannel writableByteChannel;
+	
+	public WritableByteChannelIterator(WritableByteChannel writableByteChannel) {
+		this.writableByteChannel = writableByteChannel;
+	}
+	
+	public boolean hasNext() {
+		return true;
+	}
+
+	public WritableByteChannel next() {
+		return writableByteChannel;
+	}
+
+	public void remove() {}
+}



From cloveretl-svn-commits at lists.berlios.de  Thu Feb 22 11:23:19 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 22 Feb 2007 11:23:19 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2499 -
	trunk/cloveretl.component/src/org/jetel/component
Message-ID: <200702221023.l1MANJXM013626@sheep.berlios.de>

Author: agad
Date: 2007-02-22 11:23:18 +0100 (Thu, 22 Feb 2007)
New Revision: 2499

Modified:
   trunk/cloveretl.component/src/org/jetel/component/XLSReader.java
Log:
UPDATE:XLSReader - attributes standartization

Modified: trunk/cloveretl.component/src/org/jetel/component/XLSReader.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/XLSReader.java	2007-02-21 13:29:03 UTC (rev 2498)
+++ trunk/cloveretl.component/src/org/jetel/component/XLSReader.java	2007-02-22 10:23:18 UTC (rev 2499)
@@ -21,8 +21,6 @@
 
 package org.jetel.component;
 
-import java.io.FileInputStream;
-import java.io.IOException;
 import java.security.InvalidParameterException;
 
 import org.apache.commons.logging.Log;
@@ -43,6 +41,7 @@
 import org.jetel.graph.Result;
 import org.jetel.graph.TransformationGraph;
 import org.jetel.util.ComponentXMLAttributes;
+import org.jetel.util.MultiFileReader;
 import org.jetel.util.StringUtils;
 import org.jetel.util.SynchronizeUtils;
 import org.w3c.dom.Element;
@@ -132,6 +131,7 @@
 	/** XML attribute names */
 	public static final String XML_STARTROW_ATTRIBUTE = "startRow";
 	public static final String XML_FINALROW_ATTRIBUTE = "finalRow";
+	public static final String XML_NUMRECORDS_ATTRIBUTE = "numRecords";
 	public static final String XML_MAXERRORCOUNT_ATTRIBUTE = "maxErrorCount";
 	public final static String XML_FILE_ATTRIBUTE = "fileURL";
 	public final static String XML_DATAPOLICY_ATTRIBUTE = "dataPolicy";
@@ -149,9 +149,11 @@
 	private String fileURL;
 	private int startRow = 0;
 	private int finalRow = -1;
+	private int numRecords = -1;
 	private int maxErrorCount = -1;
     
 	private XLSParser parser;
+	private MultiFileReader reader;
 	private PolicyType policyType = PolicyType.STRICT;
 	
 	private String sheetName;
@@ -159,7 +161,7 @@
 	private int metadataRow = 0;
 	private String[][] fieldMap;
 	
-	public final static boolean usePOI = true;
+	public final static boolean usePOI = false;
 
 	/**
 	 * @param id
@@ -199,11 +201,10 @@
 		DataRecord record = new DataRecord(getOutputPort(OUTPUT_PORT).getMetadata());
 		record.init();
 		int errorCount = 0;
-		int diffRow = (startRow != -1) ? finalRow - startRow +1: finalRow ;
 		try {
 			while (((record) != null) && runIt) {
 				try {
-					record = parser.getNext(record);
+					record = reader.getNext(record);
 					if (record!=null){
 						writeRecordBroadcast(record);
 					}
@@ -218,9 +219,6 @@
 			            }
 			        }
 				}
-				if(finalRow != -1 && parser.getRecordCount() > diffRow) {
-					break;
-				}
 				SynchronizeUtils.cloverYield();
 			}
 		} catch (Exception e) {
@@ -291,6 +289,9 @@
 			if (xattribs.exists(XML_FINALROW_ATTRIBUTE)){
 				aXLSReader.setFinalRow(xattribs.getInteger(XML_FINALROW_ATTRIBUTE));
 			}
+			if (xattribs.exists(XML_NUMRECORDS_ATTRIBUTE)){
+				aXLSReader.setNumRecords(xattribs.getInteger(XML_NUMRECORDS_ATTRIBUTE));
+			}
 			if (xattribs.exists(XML_MAXERRORCOUNT_ATTRIBUTE)){
 				aXLSReader.setMaxErrorCount(xattribs.getInteger(XML_MAXERRORCOUNT_ATTRIBUTE));
 			}
@@ -388,6 +389,7 @@
 			throw new InvalidParameterException("Invalid finalRow parameter.");
 		}
 		this.finalRow = finalRecord;
+		parser.setLastRow(finalRow);
 	}
 
 	/**
@@ -450,12 +452,21 @@
 		}else{
 			parser.setMappingType(XLSDataParser.NO_METADATA_INFO);
 		}
-		try {
-			parser.init(getOutputPort(OUTPUT_PORT).getMetadata());
-            parser.setDataSource(new FileInputStream(fileURL));
-		} catch (IOException ex) {
-			throw new ComponentNotReadyException(getId() + "IOError: " + ex.getMessage());
-		}
+//		try {
+//			parser.init(getOutputPort(OUTPUT_PORT).getMetadata());
+//            parser.setDataSource(new FileInputStream(fileURL));
+//		} catch (IOException ex) {
+//			throw new ComponentNotReadyException(getId() + "IOError: " + ex.getMessage());
+//		}
+            reader = new MultiFileReader(parser, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
+	        reader.setLogger(logger);
+	        reader.setNumRecords(numRecords);
+	        try {
+	            reader.init(getOutputPort(OUTPUT_PORT).getMetadata());
+	        } catch(ComponentNotReadyException e) {
+	            e.setAttributeName(XML_FILE_ATTRIBUTE);
+	            throw e;
+	        }
 	}
 
 	private void setSheetName(String sheetName) {
@@ -470,4 +481,8 @@
 		this.sheetNumber = sheetNumber;
 	}
 
+	public void setNumRecords(int numRecords) {
+		this.numRecords = numRecords;
+	}
+
 }



From cloveretl-svn-commits at lists.berlios.de  Thu Feb 22 11:27:28 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 22 Feb 2007 11:27:28 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2500 -
	trunk/cloveretl.engine/src/org/jetel/component
Message-ID: <200702221027.l1MARSQ9014502@sheep.berlios.de>

Author: agad
Date: 2007-02-22 11:27:27 +0100 (Thu, 22 Feb 2007)
New Revision: 2500

Modified:
   trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java
Log:
BUGFIX:CustomizedRecordTransform - called method DataFieldFactory.createDataField(targetMetadata[recNo].getField(fieldNo), false) instead of DataFieldFactory.createDataField(targetMetadata[recNo].getField(fieldNo), true)

Modified: trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java	2007-02-22 10:23:18 UTC (rev 2499)
+++ trunk/cloveretl.engine/src/org/jetel/component/CustomizedRecordTransform.java	2007-02-22 10:27:27 UTC (rev 2500)
@@ -1917,7 +1917,7 @@
 			PolicyType policy) throws ComponentNotReadyException {
 			//used temporary data field for checking constant
 			DataField tmp = DataFieldFactory.createDataField(
-					targetMetadata[recNo].getField(fieldNo), true);
+					targetMetadata[recNo].getField(fieldNo), false);
 			if (source != null) {
 				try {
 					tmp.fromString(source);
@@ -2002,7 +2002,7 @@
 			}
 			//use temporary field to check if the value can be set to given data field
 			DataField tmp = DataFieldFactory.createDataField(
-					targetMetadata[recNo].getField(fieldNo), true);
+					targetMetadata[recNo].getField(fieldNo), false);
 			try{
 				tmp.fromString(paramValue);
 				value = tmp.getValue();



From cloveretl-svn-commits at lists.berlios.de  Thu Feb 22 11:29:18 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 22 Feb 2007 11:29:18 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2501 -
	trunk/cloveretl.engine/src/org/jetel/data/parser
Message-ID: <200702221029.l1MATIDs014712@sheep.berlios.de>

Author: agad
Date: 2007-02-22 11:29:18 +0100 (Thu, 22 Feb 2007)
New Revision: 2501

Modified:
   trunk/cloveretl.engine/src/org/jetel/data/parser/FixLenDataParser.java
Log:
UPDATE:FixLenDataParser - method fillXHandler throws BadDataFormatException instead of RuntimeException

Modified: trunk/cloveretl.engine/src/org/jetel/data/parser/FixLenDataParser.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/parser/FixLenDataParser.java	2007-02-22 10:27:27 UTC (rev 2500)
+++ trunk/cloveretl.engine/src/org/jetel/data/parser/FixLenDataParser.java	2007-02-22 10:29:18 UTC (rev 2501)
@@ -201,7 +201,7 @@
 		exception.setRecordNumber(recordIdx);
 		
 		if (exceptionHandler == null) { // no handler available
-			throw new RuntimeException(exception.getMessage());			
+			throw exception;			
 		}
 		// set handler
 		exceptionHandler.populateHandler(exception.getMessage(), record, recordIdx - 1,



From cloveretl-svn-commits at lists.berlios.de  Thu Feb 22 11:30:09 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 22 Feb 2007 11:30:09 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2502 -
	trunk/cloveretl.engine/src/org/jetel/data/parser
Message-ID: <200702221030.l1MAU9iw014827@sheep.berlios.de>

Author: agad
Date: 2007-02-22 11:30:08 +0100 (Thu, 22 Feb 2007)
New Revision: 2502

Modified:
   trunk/cloveretl.engine/src/org/jetel/data/parser/JExcelXLSDataParser.java
   trunk/cloveretl.engine/src/org/jetel/data/parser/XLSDataParser.java
   trunk/cloveretl.engine/src/org/jetel/data/parser/XLSParser.java
Log:
UPDATE:XLSReader - attributes standartization

Modified: trunk/cloveretl.engine/src/org/jetel/data/parser/JExcelXLSDataParser.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/parser/JExcelXLSDataParser.java	2007-02-22 10:29:18 UTC (rev 2501)
+++ trunk/cloveretl.engine/src/org/jetel/data/parser/JExcelXLSDataParser.java	2007-02-22 10:30:08 UTC (rev 2502)
@@ -22,6 +22,8 @@
 package org.jetel.data.parser;
 
 import java.io.InputStream;
+import java.nio.channels.Channels;
+import java.nio.channels.ReadableByteChannel;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.Map;
@@ -222,12 +224,20 @@
 	@Override
 	public void setDataSource(Object inputDataSource)
 			throws ComponentNotReadyException {
-        recordCounter = 1;
+		if (wb != null) {
+			wb.close();
+		}
         WorkbookSettings settings = new WorkbookSettings();
 		settings.setEncoding(charset);
+		InputStream input;
+		if (inputDataSource instanceof InputStream) {
+			input = (InputStream)inputDataSource;
+		}else{
+			input = Channels.newInputStream((ReadableByteChannel)inputDataSource);
+		}
 		//creating workbook from input stream 
         try {
-            wb = Workbook.getWorkbook((InputStream)inputDataSource,settings);
+            wb = Workbook.getWorkbook(input,settings);
        }catch(Exception ex){
             throw new ComponentNotReadyException(ex);
         }
@@ -245,8 +255,10 @@
             throw new ComponentNotReadyException("There is no sheet with name \"" + sheetName +"\"");
         }
         currentRow = firstRow;
-        lastRow = sheet.getRows();
-        if (metadata != null) {
+		if (lastRow == -1) {
+			lastRow = sheet.getRows();
+		}        
+		if (metadata != null) {
         	fieldNumber = new int[metadata.getNumFields()][2];
         	mapFields();
         }

Modified: trunk/cloveretl.engine/src/org/jetel/data/parser/XLSDataParser.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/parser/XLSDataParser.java	2007-02-22 10:29:18 UTC (rev 2501)
+++ trunk/cloveretl.engine/src/org/jetel/data/parser/XLSDataParser.java	2007-02-22 10:30:08 UTC (rev 2502)
@@ -23,6 +23,8 @@
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.channels.Channels;
+import java.nio.channels.ReadableByteChannel;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.Map;
@@ -168,10 +170,15 @@
      * @see org.jetel.data.parser.Parser#setDataSource(java.lang.Object)
      */
     public void setDataSource(Object in) throws ComponentNotReadyException {
-        recordCounter = 1;
-        //creating workbook from input stream 
+		InputStream input;
+		if (in instanceof InputStream) {
+			input = (InputStream)in;
+		}else{
+			input = Channels.newInputStream((ReadableByteChannel)in);
+		}
+      //creating workbook from input stream 
         try {
-            wb = new HSSFWorkbook((InputStream)in);
+            wb = new HSSFWorkbook(input);
         }catch(IOException ex){
             throw new ComponentNotReadyException(ex);
         }
@@ -190,8 +197,10 @@
         }
         format = wb.createDataFormat();
         currentRow = firstRow;
-        lastRow = sheet.getLastRowNum();
-        if (metadata != null) {
+		if (lastRow == -1) {
+			lastRow = sheet.getLastRowNum();
+		}        
+		if (metadata != null) {
         	fieldNumber = new int[metadata.getNumFields()][2];
         	mapFields();
         }

Modified: trunk/cloveretl.engine/src/org/jetel/data/parser/XLSParser.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/parser/XLSParser.java	2007-02-22 10:29:18 UTC (rev 2501)
+++ trunk/cloveretl.engine/src/org/jetel/data/parser/XLSParser.java	2007-02-22 10:30:08 UTC (rev 2502)
@@ -71,10 +71,10 @@
 	protected IParserExceptionHandler exceptionHandler;
 	protected String sheetName = null;
 	protected int sheetNumber = 0;
-	protected int recordCounter;
+	protected int recordCounter = 1;
 	protected int firstRow = 0;
 	protected int currentRow;
-	protected int lastRow;
+	protected int lastRow = -1;
 	protected int metadataRow = -1;
 	protected String[] cloverFields = null;
 	protected String[] xlsFields = null;
@@ -193,8 +193,8 @@
 	protected String getErrorMessage(String exceptionMessage, int recNo, int fieldNo) {
 		StringBuffer message = new StringBuffer();
 		message.append(exceptionMessage);
-		message.append(" when parsing record #");
-		message.append(recordCounter);
+		message.append(" when parsing record from row ");
+		message.append(currentRow);
 		message.append(" field ");
 		message.append(metadata.getField(fieldNo).getName());
 		return message.toString();
@@ -421,4 +421,12 @@
 	 */
 	public abstract String[] getNames();
 
+	public int getLastRow() {
+		return lastRow;
+	}
+
+	public void setLastRow(int lastRow) {
+		this.lastRow = lastRow;
+	}
+
 }



From cloveretl-svn-commits at lists.berlios.de  Thu Feb 22 11:38:52 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Thu, 22 Feb 2007 11:38:52 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2503 -
	trunk/cloveretl.engine/src/org/jetel/util
Message-ID: <200702221038.l1MAcqvo016245@sheep.berlios.de>

Author: agad
Date: 2007-02-22 11:38:52 +0100 (Thu, 22 Feb 2007)
New Revision: 2503

Modified:
   trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java
Log:
UPDATE:added method  public static boolean isNumber(CharSequence str)

Modified: trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java	2007-02-22 10:30:08 UTC (rev 2502)
+++ trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java	2007-02-22 10:38:52 UTC (rev 2503)
@@ -566,6 +566,26 @@
     	return length;
     }
 
+    /**
+     * This method checks if given string can be parse to number
+     * 
+     * @param str string to check
+     * @return true if input represents number, false in another case
+     */
+    public static boolean isNumber(CharSequence str){
+    	boolean point = false;
+    	for (int i=0;i<str.length();i++) {
+    		if (!Character.isDigit(str.charAt(i))) {
+    			if (str.charAt(i) == '.' && !point){
+    				point = true;
+    			}else {
+    				return false;
+    			}
+    		}
+    	}
+    	return true;
+    }
+    
 }
 
 



From cloveretl-svn-commits at lists.berlios.de  Mon Feb 26 15:42:29 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Mon, 26 Feb 2007 15:42:29 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2504 -
	trunk/cloveretl.engine/src/org/jetel/util
Message-ID: <200702261442.l1QEgTGJ022466@sheep.berlios.de>

Author: dpavlis
Date: 2007-02-26 15:42:29 +0100 (Mon, 26 Feb 2007)
New Revision: 2504

Modified:
   trunk/cloveretl.engine/src/org/jetel/util/ByteBufferUtils.java
Log:
UPDATE:encodeLength() method returns how many bytes were needed to encode length info

Modified: trunk/cloveretl.engine/src/org/jetel/util/ByteBufferUtils.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/ByteBufferUtils.java	2007-02-22 10:38:52 UTC (rev 2503)
+++ trunk/cloveretl.engine/src/org/jetel/util/ByteBufferUtils.java	2007-02-26 14:42:29 UTC (rev 2504)
@@ -131,10 +131,13 @@
      * least space
      * 
      * @param buffer    ByteBuffer to which encode length
-     * @param length    
+     * @param length    value which should be encoded
+     * @return          number of bytes (in buffer) needed to encode the length
      * @since 21.11.2006
      */
-    public static final void encodeLength(ByteBuffer buffer,int length){
+    
+    public static final int encodeLength(ByteBuffer buffer,int length){
+        int position=buffer.position(); 
         if (length <= Byte.MAX_VALUE) {
             buffer.put((byte) length);
         } else {
@@ -145,6 +148,7 @@
             } while ((length >> 7) > 0);
             buffer.put((byte) length);
         }
+        return buffer.position()-position;
     }
     
     /**



From cloveretl-svn-commits at lists.berlios.de  Mon Feb 26 18:45:07 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Mon, 26 Feb 2007 18:45:07 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2505 -
	trunk/cloveretl.component/src/org/jetel/component
Message-ID: <200702261745.l1QHj7D2030615@sheep.berlios.de>

Author: agad
Date: 2007-02-26 18:45:05 +0100 (Mon, 26 Feb 2007)
New Revision: 2505

Modified:
   trunk/cloveretl.component/src/org/jetel/component/XLSReader.java
Log:
UPDATE:XLSReader can now read from more sheets

Modified: trunk/cloveretl.component/src/org/jetel/component/XLSReader.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/XLSReader.java	2007-02-26 14:42:29 UTC (rev 2504)
+++ trunk/cloveretl.component/src/org/jetel/component/XLSReader.java	2007-02-26 17:45:05 UTC (rev 2505)
@@ -81,11 +81,9 @@
  *  <tr><td><b>startRow</b></td><td>index of first parsed record</td>
  *  <tr><td><b>finalRow</b></td><td>index of final parsed record</td>
  *  <tr><td><b>maxErrorCount</b></td><td>count of tolerated error records in input file</td>
- *  <tr><td><b>sheetName</b></td><td>name of sheet for reading data. If it is not set data
- *   are read from first sheet</td>
- *  <tr><td><b>sheetNumber</b></td><td>number of sheet for reading data (starting from 0).
- *   If it is not set data are read from first sheet. If sheetName and sheetNumber are both
- *    set, sheetNumber is ignored</td>
+ *  <tr><td><b>sheetName</b></td><td>name of sheet for reading data. </td>
+ *  <tr><td><b>sheetNumber</b></td><td>number of sheet for reading data (starting from 0). 
+ *  This attribute has higher priority then sheetName. One of theese atributes has to be set.</td>
  *  <tr><td><b>metadataRow</b></td><td>number of row where are names of columns</td>
  *  <tr><td><b>fieldMap</b></td><td>Pairs of clover fields and xls columns
  *   (cloverField=xlsColumn) separated by :;| {colon, semicolon, pipe}.
@@ -156,12 +154,12 @@
 	private MultiFileReader reader;
 	private PolicyType policyType = PolicyType.STRICT;
 	
-	private String sheetName;
-	private int sheetNumber = -1;
+	private String sheetName = null;
+	private String sheetNumber = null;
 	private int metadataRow = 0;
 	private String[][] fieldMap;
 	
-	public final static boolean usePOI = false;
+	public final static boolean usePOI = true;
 
 	/**
 	 * @param id
@@ -247,16 +245,17 @@
         checkInputPorts(status, 0, 0);
         checkOutputPorts(status, 1, Integer.MAX_VALUE);
 
-        try {
-            init();
-            free();
-        } catch (ComponentNotReadyException e) {
-            ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
-            if(!StringUtils.isEmpty(e.getAttributeName())) {
-                problem.setAttributeName(e.getAttributeName());
-            }
-            status.add(problem);
-        }
+    	//TODO
+//        try {
+//            init();
+//            free();
+//        } catch (ComponentNotReadyException e) {
+//            ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
+//            if(!StringUtils.isEmpty(e.getAttributeName())) {
+//                problem.setAttributeName(e.getAttributeName());
+//            }
+//            status.add(problem);
+//        }
         
         return status;
     }
@@ -298,7 +297,7 @@
 			if (xattribs.exists(XML_SHEETNAME_ATTRIBUTE)){
 				aXLSReader.setSheetName(xattribs.getString(XML_SHEETNAME_ATTRIBUTE));
 			}else if (xattribs.exists(XML_SHEETNUMBER_ATTRIBUTE)){
-				aXLSReader.setSheetNumber(xattribs.getInteger(XML_SHEETNUMBER_ATTRIBUTE));
+				aXLSReader.setSheetNumber(xattribs.getString(XML_SHEETNUMBER_ATTRIBUTE));
 			}
 			if (xattribs.exists(XML_METADATAROW_ATTRIBUTE)){
 				aXLSReader.setMetadataRow(xattribs.getInteger(XML_METADATAROW_ATTRIBUTE));
@@ -389,7 +388,7 @@
 			throw new InvalidParameterException("Invalid finalRow parameter.");
 		}
 		this.finalRow = finalRecord;
-		parser.setLastRow(finalRow);
+		parser.setLastRow(finalRow - 1);
 	}
 
 	/**
@@ -414,7 +413,7 @@
 		if (sheetName != null){
 			parser.setSheetName(sheetName);
 		}
-		if (sheetNumber > -1){
+		if (sheetNumber != null){
 			parser.setSheetNumber(sheetNumber);
 		}
 		if (metadataRow != 0){
@@ -452,12 +451,6 @@
 		}else{
 			parser.setMappingType(XLSDataParser.NO_METADATA_INFO);
 		}
-//		try {
-//			parser.init(getOutputPort(OUTPUT_PORT).getMetadata());
-//            parser.setDataSource(new FileInputStream(fileURL));
-//		} catch (IOException ex) {
-//			throw new ComponentNotReadyException(getId() + "IOError: " + ex.getMessage());
-//		}
             reader = new MultiFileReader(parser, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
 	        reader.setLogger(logger);
 	        reader.setNumRecords(numRecords);
@@ -477,7 +470,7 @@
 		this.metadataRow = metadaRow;
 	}
 
-	public void setSheetNumber(int sheetNumber) {
+	public void setSheetNumber(String sheetNumber) {
 		this.sheetNumber = sheetNumber;
 	}
 



From cloveretl-svn-commits at lists.berlios.de  Mon Feb 26 18:46:50 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Mon, 26 Feb 2007 18:46:50 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2506 -
	trunk/cloveretl.engine/src/org/jetel/data/parser
Message-ID: <200702261746.l1QHko6Q031748@sheep.berlios.de>

Author: agad
Date: 2007-02-26 18:46:49 +0100 (Mon, 26 Feb 2007)
New Revision: 2506

Modified:
   trunk/cloveretl.engine/src/org/jetel/data/parser/JExcelXLSDataParser.java
   trunk/cloveretl.engine/src/org/jetel/data/parser/XLSDataParser.java
   trunk/cloveretl.engine/src/org/jetel/data/parser/XLSParser.java
Log:
UPDATE:XLSReader can now read from more sheets

Modified: trunk/cloveretl.engine/src/org/jetel/data/parser/JExcelXLSDataParser.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/parser/JExcelXLSDataParser.java	2007-02-26 17:45:05 UTC (rev 2505)
+++ trunk/cloveretl.engine/src/org/jetel/data/parser/JExcelXLSDataParser.java	2007-02-26 17:46:49 UTC (rev 2506)
@@ -44,6 +44,7 @@
 import org.jetel.exception.JetelException;
 import org.jetel.metadata.DataFieldMetadata;
 import org.jetel.util.StringUtils;
+import org.jetel.util.WcardPattern;
 
 /**
  * Parsing data from xls file using JExcelAPI.
@@ -61,6 +62,7 @@
 	private Sheet sheet;
 	private Cell cell;
 	private String charset = null;
+	private short sheetCounter;
 	
 	/**
 	 * Default constructor
@@ -241,28 +243,50 @@
        }catch(Exception ex){
             throw new ComponentNotReadyException(ex);
         }
-        //setting sheet for reading data
-        if (sheetName!=null){
-            sheet = wb.getSheet(sheetName);
-        }else{
-            try {
-                sheet = wb.getSheet(sheetNumber);
-            }catch(IndexOutOfBoundsException ex){
-                throw new ComponentNotReadyException("There is no sheet with number \"" +   sheetNumber +"\"");
-            }
+         currentRow = firstRow;
+         sheetCounter = -1;
+         if (sheetNumber != null){
+        	 sheetNumberIterator = new NumberIterator(sheetNumber);
+         }
+        if (!getNextSheet()) {
+        	throw new ComponentNotReadyException("There is no sheet conforming sheet name nor sheet number pattern");
         }
-        if (sheet == null) {
-            throw new ComponentNotReadyException("There is no sheet with name \"" + sheetName +"\"");
-        }
-        currentRow = firstRow;
-		if (lastRow == -1) {
-			lastRow = sheet.getRows();
-		}        
 		if (metadata != null) {
         	fieldNumber = new int[metadata.getNumFields()][2];
         	mapFields();
         }
 	}
+	
+	@Override
+	public boolean getNextSheet() {
+    	if (sheetNumberIterator != null){
+    		if (!sheetNumberIterator.hasNext()){
+    			return false;
+    		}
+    		try{
+    			sheet = wb.getSheet(sheetNumberIterator.next());
+    		}catch(IndexOutOfBoundsException e){
+    			return false;
+    		}
+    	}else{
+    		boolean found = false;
+    		while (!found){
+    			try {
+					sheet = wb.getSheet(++sheetCounter);
+				} catch (IndexOutOfBoundsException e) {
+					return false;
+				}
+				if (WcardPattern.checkName(sheetName, sheet.getName())) {
+					found = true;
+				}
+    		}
+    	}
+        currentRow = firstRow;
+		if (lastRow == -1 || lastRow > sheet.getRows()) {
+			lastRow = sheet.getRows();
+		}       
+		return true;
+	}
 
 	public String getCharset() {
 		return charset;

Modified: trunk/cloveretl.engine/src/org/jetel/data/parser/XLSDataParser.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/parser/XLSDataParser.java	2007-02-26 17:45:05 UTC (rev 2505)
+++ trunk/cloveretl.engine/src/org/jetel/data/parser/XLSDataParser.java	2007-02-26 17:46:49 UTC (rev 2506)
@@ -28,6 +28,7 @@
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.Map;
+import java.util.regex.Pattern;
 
 import org.apache.poi.hssf.usermodel.HSSFCell;
 import org.apache.poi.hssf.usermodel.HSSFDataFormat;
@@ -41,6 +42,7 @@
 import org.jetel.exception.JetelException;
 import org.jetel.metadata.DataFieldMetadata;
 import org.jetel.util.StringUtils;
+import org.jetel.util.WcardPattern;
 
 /**
  * Parsing data from xls file using POI library.
@@ -58,6 +60,7 @@
 	private HSSFRow row;
 	private HSSFCell cell;
 	private HSSFDataFormat format;
+	private short sheetCounter;
 	
 	/**
 	 * This method gets string representation of cell value 
@@ -182,30 +185,50 @@
         }catch(IOException ex){
             throw new ComponentNotReadyException(ex);
         }
-        //setting sheet for reading data
-        if (sheetName!=null){
-            sheet = wb.getSheet(sheetName);
-        }else{
-            try {
-                sheet = wb.getSheetAt(sheetNumber);
-            }catch(IndexOutOfBoundsException ex){
-                throw new ComponentNotReadyException("There is no sheet with number \"" +   sheetNumber +"\"");
-            }
+        format = wb.createDataFormat();
+         sheetCounter = -1;
+         if (sheetNumber != null){
+        	 sheetNumberIterator = new NumberIterator(sheetNumber);
+         }
+        if (!getNextSheet()) {
+        	throw new ComponentNotReadyException("There is no sheet conforming sheet name nor sheet number pattern");
         }
-        if (sheet == null) {
-            throw new ComponentNotReadyException("There is no sheet with name \"" + sheetName +"\"");
-        }
-        format = wb.createDataFormat();
-        currentRow = firstRow;
-		if (lastRow == -1) {
-			lastRow = sheet.getLastRowNum();
-		}        
 		if (metadata != null) {
         	fieldNumber = new int[metadata.getNumFields()][2];
         	mapFields();
         }
     }
 
+    @Override
+    public boolean getNextSheet() {
+    	if (sheetNumberIterator != null){
+    		if (!sheetNumberIterator.hasNext()){
+    			return false;
+    		}
+    		try{
+    			sheet = wb.getSheetAt(sheetNumberIterator.next());
+    		}catch(IndexOutOfBoundsException e){
+    			return false;
+    		}
+    	}else{
+    		boolean found = false;
+    		while (!found){
+    			try {
+					sheet = wb.getSheetAt(++sheetCounter);
+				} catch (IndexOutOfBoundsException e) {
+					return false;
+				}
+				if (WcardPattern.checkName(sheetName, wb.getSheetName(sheetCounter))) {
+					found = true;
+				}
+    		}
+    	}
+        currentRow = firstRow;
+		if (lastRow == -1 || lastRow > sheet.getLastRowNum()) {
+			lastRow = sheet.getLastRowNum();
+		}       
+		return true;
+    }
 	
 	/**
 	 * If clover fields and xls colums are set there is made mapping between coresponding fields and cells
@@ -306,3 +329,4 @@
 	}
 
 }
+

Modified: trunk/cloveretl.engine/src/org/jetel/data/parser/XLSParser.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/parser/XLSParser.java	2007-02-26 17:45:05 UTC (rev 2505)
+++ trunk/cloveretl.engine/src/org/jetel/data/parser/XLSParser.java	2007-02-26 17:46:49 UTC (rev 2506)
@@ -21,7 +21,9 @@
 
 package org.jetel.data.parser;
 
+import java.util.Iterator;
 import java.util.Map;
+import java.util.regex.Pattern;
 
 import javax.naming.InvalidNameException;
 
@@ -34,6 +36,7 @@
 import org.jetel.exception.JetelException;
 import org.jetel.exception.PolicyType;
 import org.jetel.metadata.DataRecordMetadata;
+import org.jetel.util.StringUtils;
 
 /**
  * Parses data from xls file. Order of method calling:
@@ -70,7 +73,8 @@
 	protected DataRecordMetadata metadata = null;
 	protected IParserExceptionHandler exceptionHandler;
 	protected String sheetName = null;
-	protected int sheetNumber = 0;
+	protected String sheetNumber = null;
+	protected NumberIterator sheetNumberIterator = null;
 	protected int recordCounter = 1;
 	protected int firstRow = 0;
 	protected int currentRow;
@@ -115,14 +119,7 @@
 
 		record.init();
 
-		record = parseNext(record);
-		if(exceptionHandler != null ) {  //use handler only if configured
-			while(exceptionHandler.isExceptionThrowed()) {
-                exceptionHandler.handleException();
-				record = parseNext(record);
-			}
-		}
-		return record;
+		return getNext(record);
 	}
 
 	/**
@@ -145,9 +142,22 @@
 				record = parseNext(record);
 			}
 		}
+		if (record == null) {//record from current sheet
+			if (getNextSheet()) {
+				record = getNext();
+			}
+		}
 		return record;
 	}
 
+	/**
+	 * This method checks if there is next sheet with name conforming with 
+	 * sheetName or sheetNumber pattern
+	 * 
+	 * @return
+	 */
+	public abstract boolean getNextSheet();
+	
 	/* (non-Javadoc)
 	 * @see org.jetel.data.parser.Parser#getPolicyType()
 	 */
@@ -326,7 +336,7 @@
 	 * 
 	 * @return
 	 */
-	public int getSheetNumber() {
+	public String getSheetNumber() {
 		return sheetNumber;
 	}
 
@@ -375,7 +385,7 @@
 	 * 
 	 * @param sheetNumber
 	 */
-	public void setSheetNumber(int sheetNumber) {
+	public void setSheetNumber(String sheetNumber) {
 		this.sheetNumber = sheetNumber;
 	}
 
@@ -430,3 +440,120 @@
 	}
 
 }
+/**
+ * Class for resolving integer number from given mask.<br>
+ * Mask can be in form: 
+ * <ul><li>*</li>
+ * <li>number</li>
+ * <li>minNuber-maxNumber</li>
+ * <li>*-maxNumber</li>
+ * <li>minNumber-*</li>
+ * or as their combination separated by comma, eg. 1,3,5-7,9-*
+ * 
+ * @author avackova (agata.vackova at javlinconsulting.cz) ; 
+ * (c) JavlinConsulting s.r.o.
+ *  www.javlinconsulting.cz
+ *
+ * @since Feb 23, 2007
+ *
+ */
+class NumberIterator implements Iterator<Integer>{
+	
+	private String pattern;
+	private String subPattern;
+	private int index = 0;
+	private int comaIndex;
+	private int next = 0;
+	private PositiveIntervalIterator intervalIterator = null;
+	
+	/**
+	 * Constructor from given mask
+	 * 
+	 * @param pattern
+	 */
+	public NumberIterator(String pattern){
+		this.pattern = pattern.trim();
+	}
+	
+	public boolean hasNext() {
+		if (pattern.equals("*")) {
+			subPattern = pattern;
+			return true;
+		}		
+		if (intervalIterator != null) {
+			return intervalIterator.hasNext();
+		}
+		if (index == pattern.length()) {
+			return false;
+		}
+		comaIndex = pattern.indexOf(',', index);
+		if (comaIndex == -1) {
+			subPattern = pattern.substring(index).trim();
+			index = pattern.length();
+		}else{
+			subPattern = pattern.substring(index,comaIndex).trim();
+			index = comaIndex + 1;
+		}
+		if (StringUtils.isInteger(subPattern)) {
+			intervalIterator = null;
+			return true;
+		}else {
+			intervalIterator = new PositiveIntervalIterator(subPattern);
+			return intervalIterator.hasNext();
+		}
+	}
+	
+	public Integer next() {
+		if (intervalIterator != null) {
+			return intervalIterator.next();
+		}else{
+			if (StringUtils.isInteger(subPattern)) {
+				return Integer.parseInt(subPattern);
+			}else{
+				return next++;
+			}
+		}
+	}
+	
+	public void remove() {
+		throw new UnsupportedOperationException();
+	}
+	
+	private class PositiveIntervalIterator implements Iterator<Integer>{
+		
+		private final static int FIRST_ELEMENT = 0;
+		
+		private String firstPattern;
+		private String lastPattern;
+		private int next = 0;
+		private int last = FIRST_ELEMENT - 1;
+		
+		PositiveIntervalIterator(String pattern) {
+			if (!Pattern.matches("[0-9]*-[0-9]*|[0-9]*-\\*|\\*-[0-9]*", pattern)){
+				throw new IllegalArgumentException("Wrong pattern");
+			}
+			firstPattern = pattern.substring(0,pattern.indexOf('-')).trim();
+			lastPattern = pattern.substring(pattern.indexOf('-') + 1).trim();
+			if (!firstPattern.equals("*")) {
+				next = Integer.parseInt(firstPattern);
+			}
+			if (!lastPattern.equals("*")){
+				last = Integer.parseInt(lastPattern);
+			}
+		}
+		
+		public boolean hasNext() {
+			return (last == FIRST_ELEMENT -1 || next <= last);
+		}
+
+		public Integer next() {
+			return hasNext() ? next++ : null;
+		}
+		
+		public void remove() {
+			throw new UnsupportedOperationException();
+		}
+		
+	}
+	
+}
\ No newline at end of file



From cloveretl-svn-commits at lists.berlios.de  Mon Feb 26 18:47:46 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Mon, 26 Feb 2007 18:47:46 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2507 -
	trunk/cloveretl.engine/src/org/jetel/util
Message-ID: <200702261747.l1QHlkGR032389@sheep.berlios.de>

Author: agad
Date: 2007-02-26 18:47:35 +0100 (Mon, 26 Feb 2007)
New Revision: 2507

Modified:
   trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java
Log:
UPDATE:StringUtils new method isInteger

Modified: trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java	2007-02-26 17:46:49 UTC (rev 2506)
+++ trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java	2007-02-26 17:47:35 UTC (rev 2507)
@@ -586,6 +586,21 @@
     	return true;
     }
     
+    /**
+     * This method checks if given string can be integer to number
+     * 
+     * @param str string to check
+     * @return true if input represents number, false in another case
+     */
+    public static boolean isInteger(CharSequence str){
+     	for (int i=0;i<str.length();i++) {
+    		if (!Character.isDigit(str.charAt(i))) {
+    			return false;
+     		}
+    	}
+    	return true;
+    }
+    
 }
 
 



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 10:01:52 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 10:01:52 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2508 -
	trunk/cloveretl.component/src/org/jetel/component
Message-ID: <200702270901.l1R91qrM024193@sheep.berlios.de>

Author: otasanek
Date: 2007-02-27 10:01:52 +0100 (Tue, 27 Feb 2007)
New Revision: 2508

Modified:
   trunk/cloveretl.component/src/org/jetel/component/DataReader.java
Log:
FIX: better error handling in DataReader component.

Modified: trunk/cloveretl.component/src/org/jetel/component/DataReader.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DataReader.java	2007-02-26 17:47:35 UTC (rev 2507)
+++ trunk/cloveretl.component/src/org/jetel/component/DataReader.java	2007-02-27 09:01:52 UTC (rev 2508)
@@ -196,12 +196,12 @@
 									.getMessage());
 							writeRecord(LOG_PORT, logRecord);
 						} else {
-							logger.info(bdfe.getMessage());
+							logger.warn(bdfe.getMessage());
 						}
 						if (maxErrorCount != -1 && ++errorCount > maxErrorCount) {
 							logger.error("DataParser (" + getName()
 									+ "): Max error count exceeded.");
-							break;
+							return Result.ERROR;
 						}
 					}
 				}



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 10:14:37 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 10:14:37 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2509 -
	trunk/cloveretl.engine/src/org/jetel/util
Message-ID: <200702270914.l1R9Ebkv025462@sheep.berlios.de>

Author: otasanek
Date: 2007-02-27 10:14:36 +0100 (Tue, 27 Feb 2007)
New Revision: 2509

Modified:
   trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java
Log:
FIX: StringUtils.specCharToString() method handles null as parameter.

Modified: trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java	2007-02-27 09:01:52 UTC (rev 2508)
+++ trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java	2007-02-27 09:14:36 UTC (rev 2509)
@@ -47,7 +47,9 @@
 	 * @since                 July 25, 2002
 	 */
 	public static String specCharToString(CharSequence controlString) {
-		StringBuffer copy = new StringBuffer();
+        if(controlString == null) return null;
+
+        StringBuffer copy = new StringBuffer();
 		char character;
 		for (int i = 0; i < controlString.length(); i++) {
 			character = controlString.charAt(i);
@@ -86,10 +88,9 @@
 	 * @since                 July 25, 2002
 	 */
 	public static String stringToSpecChar(CharSequence controlString) {
-		if(isEmpty(controlString)) {
-			return null;
-		}
-		StringBuffer copy = new StringBuffer();
+		if(controlString == null) return null;
+
+        StringBuffer copy = new StringBuffer();
 		char character;
 		boolean isBackslash = false;
 		for (int i = 0; i < controlString.length(); i++) {



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 10:19:55 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 10:19:55 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2510 -
	trunk/cloveretl.component/src/org/jetel/component
Message-ID: <200702270919.l1R9Jtvk025691@sheep.berlios.de>

Author: agad
Date: 2007-02-27 10:19:01 +0100 (Tue, 27 Feb 2007)
New Revision: 2510

Modified:
   trunk/cloveretl.component/src/org/jetel/component/XLSReader.java
Log:
UPDATE:XLSReader - change method checkConfig to show proper attributes errors

Modified: trunk/cloveretl.component/src/org/jetel/component/XLSReader.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/XLSReader.java	2007-02-27 09:14:36 UTC (rev 2509)
+++ trunk/cloveretl.component/src/org/jetel/component/XLSReader.java	2007-02-27 09:19:01 UTC (rev 2510)
@@ -22,6 +22,7 @@
 package org.jetel.component;
 
 import java.security.InvalidParameterException;
+import java.util.Iterator;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -42,6 +43,7 @@
 import org.jetel.graph.TransformationGraph;
 import org.jetel.util.ComponentXMLAttributes;
 import org.jetel.util.MultiFileReader;
+import org.jetel.util.NumberIterator;
 import org.jetel.util.StringUtils;
 import org.jetel.util.SynchronizeUtils;
 import org.w3c.dom.Element;
@@ -81,8 +83,14 @@
  *  <tr><td><b>startRow</b></td><td>index of first parsed record</td>
  *  <tr><td><b>finalRow</b></td><td>index of final parsed record</td>
  *  <tr><td><b>maxErrorCount</b></td><td>count of tolerated error records in input file</td>
- *  <tr><td><b>sheetName</b></td><td>name of sheet for reading data. </td>
- *  <tr><td><b>sheetNumber</b></td><td>number of sheet for reading data (starting from 0). 
+ *  <tr><td><b>sheetName</b></td><td>name of sheet for reading data. Can be used with wild cards as '?' and '*'</td>
+ *  <tr><td><b>sheetNumber</b></td><td>number of sheet for reading data (starting from 0). Can be set as mask: 
+ * <ul><li>*</li>
+ * <li>number</li>
+ * <li>minNumber-maxNumber</li>
+ * <li>*-maxNumber</li>
+ * <li>minNumber-*</li></ul>
+ * or as their combination separated by comma, eg. 1,3,5-7,9-*<br>
  *  This attribute has higher priority then sheetName. One of theese atributes has to be set.</td>
  *  <tr><td><b>metadataRow</b></td><td>number of row where are names of columns</td>
  *  <tr><td><b>fieldMap</b></td><td>Pairs of clover fields and xls columns
@@ -110,10 +118,10 @@
  *  id="XLS_READER1" metadataRow="1" type="XLS_READER" /&gt;
  *  
  *  <pre>&lt;Node fieldMap="ORDER;CUSTOMERID=;EMPLOYEEID;ORDERDATE;SHIPCOUNTR" 
- *  fileURL="ORDERS.xls" id="XLS_READER1"type="XLS_READER" /&gt;
+ *  fileURL="*.xls" sheetNumber="*" id="XLS_READER1" type="XLS_READER" /&gt;
  *
  * <pre>&lt;Node dataPolicy="strict" fileURL="example.xls" id="XLS_READER0" metadataRow="1" 
- * startRow="2" type="XLS_READER"/&gt;
+ * startRow="2" sheetName="Sheet?" type="XLS_READER"/&gt;
  * 
 /**
 * @author avackova <agata.vackova at javlinconsulting.cz> ; 
@@ -231,7 +239,7 @@
 	@Override
 	public void free() {
 		super.free();
-		parser.close();
+		reader.close();
 	}
 	/*
 	 * (non-Javadoc)
@@ -245,19 +253,26 @@
         checkInputPorts(status, 0, 0);
         checkOutputPorts(status, 1, Integer.MAX_VALUE);
 
-    	//TODO
-//        try {
-//            init();
-//            free();
-//        } catch (ComponentNotReadyException e) {
-//            ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
-//            if(!StringUtils.isEmpty(e.getAttributeName())) {
-//                problem.setAttributeName(e.getAttributeName());
-//            }
-//            status.add(problem);
-//        }
-        
-        return status;
+        try {//check sheetNumber parameter
+			if (sheetNumber != null) {
+				Iterator<Integer> number = new NumberIterator(sheetNumber);
+				number.hasNext();
+			}            
+	        try{//sheet number OK, check file name
+	            reader = new MultiFileReader(parser, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
+	            reader.init(getOutputPort(OUTPUT_PORT).getMetadata());
+	            reader.close();
+	        }catch(ComponentNotReadyException e){
+	            ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
+	            problem.setAttributeName(XML_FILE_ATTRIBUTE);
+	            status.add(problem);
+	        }
+        } catch (IllegalArgumentException e) {
+            ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
+            problem.setAttributeName(XML_SHEETNUMBER_ATTRIBUTE);
+            status.add(problem);
+        }
+         return status;
     }
 
 	public static Node fromXML(TransformationGraph graph, Element nodeXML) throws XMLConfigurationException {
@@ -294,10 +309,10 @@
 			if (xattribs.exists(XML_MAXERRORCOUNT_ATTRIBUTE)){
 				aXLSReader.setMaxErrorCount(xattribs.getInteger(XML_MAXERRORCOUNT_ATTRIBUTE));
 			}
-			if (xattribs.exists(XML_SHEETNAME_ATTRIBUTE)){
+			if (xattribs.exists(XML_SHEETNUMBER_ATTRIBUTE)){
+				aXLSReader.setSheetNumber(xattribs.getString(XML_SHEETNUMBER_ATTRIBUTE));
+			}else if (xattribs.exists(XML_SHEETNAME_ATTRIBUTE)){
 				aXLSReader.setSheetName(xattribs.getString(XML_SHEETNAME_ATTRIBUTE));
-			}else if (xattribs.exists(XML_SHEETNUMBER_ATTRIBUTE)){
-				aXLSReader.setSheetNumber(xattribs.getString(XML_SHEETNUMBER_ATTRIBUTE));
 			}
 			if (xattribs.exists(XML_METADATAROW_ATTRIBUTE)){
 				aXLSReader.setMetadataRow(xattribs.getInteger(XML_METADATAROW_ATTRIBUTE));
@@ -407,19 +422,7 @@
 	@Override
 	public void init() throws ComponentNotReadyException {
 		super.init();
-        if (outPorts.size() < 1) {
-            throw new ComponentNotReadyException(getId() + ": at least one output port can be defined!");
-        }
-		if (sheetName != null){
-			parser.setSheetName(sheetName);
-		}
-		if (sheetNumber != null){
-			parser.setSheetNumber(sheetNumber);
-		}
-		if (metadataRow != 0){
-			parser.setMetadataRow(metadataRow-1);
-		}
-		//set proper mapping type beetwen clover and xls fields
+ 		//set proper mapping type beetwen clover and xls fields
 		if (fieldMap != null){
 			String[] cloverFields = new String[fieldMap.length];
 			String[] xlsFields = new String[fieldMap.length];
@@ -451,27 +454,29 @@
 		}else{
 			parser.setMappingType(XLSDataParser.NO_METADATA_INFO);
 		}
-            reader = new MultiFileReader(parser, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
-	        reader.setLogger(logger);
-	        reader.setNumRecords(numRecords);
-	        try {
-	            reader.init(getOutputPort(OUTPUT_PORT).getMetadata());
-	        } catch(ComponentNotReadyException e) {
-	            e.setAttributeName(XML_FILE_ATTRIBUTE);
-	            throw e;
-	        }
+        reader = new MultiFileReader(parser, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
+        reader.setLogger(logger);
+        reader.setNumRecords(numRecords);
+        reader.init(getOutputPort(OUTPUT_PORT).getMetadata());
 	}
 
 	private void setSheetName(String sheetName) {
 		this.sheetName = sheetName;
+		parser.setSheetName(sheetName);
 	}
 
 	private void setMetadataRow(int metadaRow) {
 		this.metadataRow = metadaRow;
+		try {
+			parser.setMetadataRow(metadataRow - 1);
+		} catch (ComponentNotReadyException e) {
+			throw new InvalidParameterException("Invalid metadaRow parameter.");
+		}
 	}
 
 	public void setSheetNumber(String sheetNumber) {
 		this.sheetNumber = sheetNumber;
+		parser.setSheetNumber(sheetNumber);
 	}
 
 	public void setNumRecords(int numRecords) {



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 10:24:27 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 10:24:27 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2511 - in
	trunk/cloveretl.engine/src/org/jetel: data/parser util
Message-ID: <200702270924.l1R9OR5u025897@sheep.berlios.de>

Author: agad
Date: 2007-02-27 10:24:24 +0100 (Tue, 27 Feb 2007)
New Revision: 2511

Added:
   trunk/cloveretl.engine/src/org/jetel/util/NumberIterator.java
Modified:
   trunk/cloveretl.engine/src/org/jetel/data/parser/JExcelXLSDataParser.java
   trunk/cloveretl.engine/src/org/jetel/data/parser/XLSDataParser.java
   trunk/cloveretl.engine/src/org/jetel/data/parser/XLSParser.java
Log:
CHANGE:NumberIterator class moved to sparated file

Modified: trunk/cloveretl.engine/src/org/jetel/data/parser/JExcelXLSDataParser.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/parser/JExcelXLSDataParser.java	2007-02-27 09:19:01 UTC (rev 2510)
+++ trunk/cloveretl.engine/src/org/jetel/data/parser/JExcelXLSDataParser.java	2007-02-27 09:24:24 UTC (rev 2511)
@@ -43,6 +43,7 @@
 import org.jetel.exception.ComponentNotReadyException;
 import org.jetel.exception.JetelException;
 import org.jetel.metadata.DataFieldMetadata;
+import org.jetel.util.NumberIterator;
 import org.jetel.util.StringUtils;
 import org.jetel.util.WcardPattern;
 
@@ -257,9 +258,12 @@
         }
 	}
 	
+	/* (non-Javadoc)
+	 * @see org.jetel.data.parser.XLSParser#getNextSheet()
+	 */
 	@Override
 	public boolean getNextSheet() {
-    	if (sheetNumberIterator != null){
+    	if (sheetNumberIterator != null){//get next sheet conforming sheetNumber attribute
     		if (!sheetNumberIterator.hasNext()){
     			return false;
     		}
@@ -268,7 +272,7 @@
     		}catch(IndexOutOfBoundsException e){
     			return false;
     		}
-    	}else{
+    	}else{//get next sheet conforming sheetName attribute
     		boolean found = false;
     		while (!found){
     			try {
@@ -282,9 +286,12 @@
     		}
     	}
         currentRow = firstRow;
-		if (lastRow == -1 || lastRow > sheet.getRows()) {
+        //set last row to read on set attribute or to last row in current sheet
+		if (lastRowAttribute == -1 || lastRowAttribute > sheet.getRows()) {
 			lastRow = sheet.getRows();
-		}       
+		}else{
+			lastRow = lastRowAttribute;
+		}
 		return true;
 	}
 

Modified: trunk/cloveretl.engine/src/org/jetel/data/parser/XLSDataParser.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/parser/XLSDataParser.java	2007-02-27 09:19:01 UTC (rev 2510)
+++ trunk/cloveretl.engine/src/org/jetel/data/parser/XLSDataParser.java	2007-02-27 09:24:24 UTC (rev 2511)
@@ -28,7 +28,6 @@
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.Map;
-import java.util.regex.Pattern;
 
 import org.apache.poi.hssf.usermodel.HSSFCell;
 import org.apache.poi.hssf.usermodel.HSSFDataFormat;
@@ -41,6 +40,7 @@
 import org.jetel.exception.ComponentNotReadyException;
 import org.jetel.exception.JetelException;
 import org.jetel.metadata.DataFieldMetadata;
+import org.jetel.util.NumberIterator;
 import org.jetel.util.StringUtils;
 import org.jetel.util.WcardPattern;
 
@@ -199,9 +199,12 @@
         }
     }
 
+    /* (non-Javadoc)
+     * @see org.jetel.data.parser.XLSParser#getNextSheet()
+     */
     @Override
     public boolean getNextSheet() {
-    	if (sheetNumberIterator != null){
+    	if (sheetNumberIterator != null){//get next sheet conforming sheetNumber attribute
     		if (!sheetNumberIterator.hasNext()){
     			return false;
     		}
@@ -210,7 +213,7 @@
     		}catch(IndexOutOfBoundsException e){
     			return false;
     		}
-    	}else{
+    	}else{//get next sheet conforming sheetName attribute
     		boolean found = false;
     		while (!found){
     			try {
@@ -224,9 +227,12 @@
     		}
     	}
         currentRow = firstRow;
-		if (lastRow == -1 || lastRow > sheet.getLastRowNum()) {
+        //set last row to read on set attribute or to last row in current sheet
+		if (lastRowAttribute == -1 || lastRowAttribute > sheet.getLastRowNum()) {
 			lastRow = sheet.getLastRowNum();
-		}       
+		}else{
+			lastRow = lastRowAttribute;
+		}
 		return true;
     }
 	

Modified: trunk/cloveretl.engine/src/org/jetel/data/parser/XLSParser.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/parser/XLSParser.java	2007-02-27 09:19:01 UTC (rev 2510)
+++ trunk/cloveretl.engine/src/org/jetel/data/parser/XLSParser.java	2007-02-27 09:24:24 UTC (rev 2511)
@@ -36,6 +36,7 @@
 import org.jetel.exception.JetelException;
 import org.jetel.exception.PolicyType;
 import org.jetel.metadata.DataRecordMetadata;
+import org.jetel.util.NumberIterator;
 import org.jetel.util.StringUtils;
 
 /**
@@ -79,6 +80,7 @@
 	protected int firstRow = 0;
 	protected int currentRow;
 	protected int lastRow = -1;
+	protected int lastRowAttribute = -1;
 	protected int metadataRow = -1;
 	protected String[] cloverFields = null;
 	protected String[] xlsFields = null;
@@ -436,124 +438,7 @@
 	}
 
 	public void setLastRow(int lastRow) {
-		this.lastRow = lastRow;
+		this.lastRowAttribute = lastRow;
 	}
 
 }
-/**
- * Class for resolving integer number from given mask.<br>
- * Mask can be in form: 
- * <ul><li>*</li>
- * <li>number</li>
- * <li>minNuber-maxNumber</li>
- * <li>*-maxNumber</li>
- * <li>minNumber-*</li>
- * or as their combination separated by comma, eg. 1,3,5-7,9-*
- * 
- * @author avackova (agata.vackova at javlinconsulting.cz) ; 
- * (c) JavlinConsulting s.r.o.
- *  www.javlinconsulting.cz
- *
- * @since Feb 23, 2007
- *
- */
-class NumberIterator implements Iterator<Integer>{
-	
-	private String pattern;
-	private String subPattern;
-	private int index = 0;
-	private int comaIndex;
-	private int next = 0;
-	private PositiveIntervalIterator intervalIterator = null;
-	
-	/**
-	 * Constructor from given mask
-	 * 
-	 * @param pattern
-	 */
-	public NumberIterator(String pattern){
-		this.pattern = pattern.trim();
-	}
-	
-	public boolean hasNext() {
-		if (pattern.equals("*")) {
-			subPattern = pattern;
-			return true;
-		}		
-		if (intervalIterator != null) {
-			return intervalIterator.hasNext();
-		}
-		if (index == pattern.length()) {
-			return false;
-		}
-		comaIndex = pattern.indexOf(',', index);
-		if (comaIndex == -1) {
-			subPattern = pattern.substring(index).trim();
-			index = pattern.length();
-		}else{
-			subPattern = pattern.substring(index,comaIndex).trim();
-			index = comaIndex + 1;
-		}
-		if (StringUtils.isInteger(subPattern)) {
-			intervalIterator = null;
-			return true;
-		}else {
-			intervalIterator = new PositiveIntervalIterator(subPattern);
-			return intervalIterator.hasNext();
-		}
-	}
-	
-	public Integer next() {
-		if (intervalIterator != null) {
-			return intervalIterator.next();
-		}else{
-			if (StringUtils.isInteger(subPattern)) {
-				return Integer.parseInt(subPattern);
-			}else{
-				return next++;
-			}
-		}
-	}
-	
-	public void remove() {
-		throw new UnsupportedOperationException();
-	}
-	
-	private class PositiveIntervalIterator implements Iterator<Integer>{
-		
-		private final static int FIRST_ELEMENT = 0;
-		
-		private String firstPattern;
-		private String lastPattern;
-		private int next = 0;
-		private int last = FIRST_ELEMENT - 1;
-		
-		PositiveIntervalIterator(String pattern) {
-			if (!Pattern.matches("[0-9]*-[0-9]*|[0-9]*-\\*|\\*-[0-9]*", pattern)){
-				throw new IllegalArgumentException("Wrong pattern");
-			}
-			firstPattern = pattern.substring(0,pattern.indexOf('-')).trim();
-			lastPattern = pattern.substring(pattern.indexOf('-') + 1).trim();
-			if (!firstPattern.equals("*")) {
-				next = Integer.parseInt(firstPattern);
-			}
-			if (!lastPattern.equals("*")){
-				last = Integer.parseInt(lastPattern);
-			}
-		}
-		
-		public boolean hasNext() {
-			return (last == FIRST_ELEMENT -1 || next <= last);
-		}
-
-		public Integer next() {
-			return hasNext() ? next++ : null;
-		}
-		
-		public void remove() {
-			throw new UnsupportedOperationException();
-		}
-		
-	}
-	
-}
\ No newline at end of file

Added: trunk/cloveretl.engine/src/org/jetel/util/NumberIterator.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/NumberIterator.java	2007-02-27 09:19:01 UTC (rev 2510)
+++ trunk/cloveretl.engine/src/org/jetel/util/NumberIterator.java	2007-02-27 09:24:24 UTC (rev 2511)
@@ -0,0 +1,152 @@
+package org.jetel.util;
+
+import java.util.Iterator;
+import java.util.regex.Pattern;
+
+
+/**
+ * Class for resolving integer number from given mask.<br>
+ * Mask can be in form: 
+ * <ul><li>*</li>
+ * <li>number</li>
+ * <li>minNumber-maxNumber</li>
+ * <li>*-maxNumber</li>
+ * <li>minNumber-*</li>
+ * or as their combination separated by comma, eg. 1,3,5-7,9-*
+ * 
+ * @author avackova (agata.vackova at javlinconsulting.cz) ; 
+ * (c) JavlinConsulting s.r.o.
+ *  www.javlinconsulting.cz
+ *
+ * @since Feb 23, 2007
+ *
+ */
+public class NumberIterator implements Iterator<Integer>{
+	
+	private final static int FIRST_ELEMENT = 0;
+
+	private String pattern;
+	private String subPattern;
+	private int index = 0;
+	private int comaIndex;
+	private int next = FIRST_ELEMENT;
+	private PositiveIntervalIterator intervalIterator = null;
+	
+	/**
+	 * Constructor from given mask
+	 * 
+	 * @param pattern
+	 */
+	public NumberIterator(String pattern){
+		this.pattern = pattern.trim();
+		if (pattern.equals("*")) {
+			subPattern = pattern;
+		}
+	}
+	
+	/* (non-Javadoc)
+	 * @see java.util.Iterator#hasNext()
+	 */
+	public boolean hasNext() {
+		if (pattern.equals("*")) {
+			return true;
+		}		
+		//check if in current interval there is more numbers
+		if (intervalIterator != null && intervalIterator.hasNext() ) {
+			return true;
+		}
+		//get next part of pattern
+		if (index == pattern.length()) {//end of mask
+			return false;
+		}
+		comaIndex = pattern.indexOf(',', index);
+		if (comaIndex == -1) {
+			subPattern = pattern.substring(index).trim();
+			index = pattern.length();
+		}else{
+			subPattern = pattern.substring(index,comaIndex).trim();
+			index = comaIndex + 1;
+		}
+		if (StringUtils.isInteger(subPattern)) {
+			intervalIterator = null;
+			return true;
+		}else {
+			intervalIterator = new PositiveIntervalIterator(subPattern);
+			return intervalIterator.hasNext();
+		}
+	}
+	
+	/* (non-Javadoc)
+	 * @see java.util.Iterator#next()
+	 */
+	public Integer next() {
+		if (intervalIterator != null) {//next from current interval
+			return intervalIterator.next();
+		}else{//subPattern is number or "*"
+			if (StringUtils.isInteger(subPattern)) {
+				return Integer.parseInt(subPattern);
+			}else{
+				return next++;
+			}
+		}
+	}
+	
+	public void remove() {
+		throw new UnsupportedOperationException();
+	}
+	
+	/**
+	 * Class for resolving integer number from given mask. Mask has to be in form: 
+	 * minNuber-maxNumber, when minNumber, maxNumber are integers or "*"
+	 * 
+	 * 
+	 * @author avackova (agata.vackova at javlinconsulting.cz) ; 
+	 * (c) JavlinConsulting s.r.o.
+	 *  www.javlinconsulting.cz
+	 *
+	 * @since Feb 23, 2007
+	 *
+	 */
+	private class PositiveIntervalIterator implements Iterator<Integer>{
+		
+		private final static int FIRST_ELEMENT = 0;
+		
+		private String firstPattern;
+		private String lastPattern;
+		private int next = FIRST_ELEMENT;
+		private int last = FIRST_ELEMENT - 1;
+		
+		/**
+		 * Constructor from given pattern
+		 * 
+		 * @param pattern
+		 */
+		PositiveIntervalIterator(String pattern) {
+			if (!Pattern.matches("[0-9]*-[0-9]*|[0-9]*-\\*|\\*-[0-9]*", pattern)){
+				throw new IllegalArgumentException("Not positive integer interval: " + pattern);
+			}
+			firstPattern = pattern.substring(0,pattern.indexOf('-')).trim();
+			lastPattern = pattern.substring(pattern.indexOf('-') + 1).trim();
+			if (!firstPattern.equals("*")) {
+				next = Integer.parseInt(firstPattern);
+			}
+			if (!lastPattern.equals("*")){
+				last = Integer.parseInt(lastPattern);
+			}
+		}
+		
+		public boolean hasNext() {
+			return (last == FIRST_ELEMENT -1 || next <= last);
+		}
+
+		public Integer next() {
+			return hasNext() ? next++ : null;
+		}
+		
+		public void remove() {
+			throw new UnsupportedOperationException();
+		}
+		
+	}
+	
+}
\ No newline at end of file



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 10:31:18 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 10:31:18 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2512 - in trunk:
	cloveretl.component/src/org/jetel/component
	cloveretl.engine/src/org/jetel/data/formatter
	cloveretl.engine/src/org/jetel/util
Message-ID: <200702270931.l1R9VIFG026414@sheep.berlios.de>

Author: jausperger
Date: 2007-02-27 10:31:10 +0100 (Tue, 27 Feb 2007)
New Revision: 2512

Modified:
   trunk/cloveretl.component/src/org/jetel/component/CloverDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java
   trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java
   trunk/cloveretl.component/src/org/jetel/component/Trash.java
   trunk/cloveretl.component/src/org/jetel/component/XLSWriter.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/CloverDataFormatter.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/DataFormatter.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/DelimitedDataFormatter.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/FixLenDataFormatter.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/Formatter.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/JExcelXLSDataFormatter.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/StructureFormatter.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/TextTableFormatter.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/XLSDataFormatter.java
   trunk/cloveretl.engine/src/org/jetel/util/MultiFileWriter.java
   trunk/cloveretl.engine/src/org/jetel/util/WritableByteChannelIterator.java
Log:
UPDATE: writer unification (added countRecord, skip, multifilewriter, ...)

Modified: trunk/cloveretl.component/src/org/jetel/component/CloverDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/CloverDataWriter.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.component/src/org/jetel/component/CloverDataWriter.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -87,6 +87,8 @@
  *  <tr><td><b>compressLevel</b><br><i>optional</i></td><td>Sets the compression level. The default
  *   setting is to compress using default ZIP compression level. 
  *  </tr>
+ *  <tr><td><b>recordSkip</b></td><td>number of skipped records</td>
+ *  <tr><td><b>recordCount</b></td><td>number of written records</td>
  *  </table>
  *
  *  <h4>Example:</h4>
@@ -112,6 +114,8 @@
 	private static final String XML_SAVEINDEX_ATRRIBUTE = "saveIndex";
 	private static final String XML_SAVEMETADATA_ATTRIBUTE = "saveMetadata";
 	private static final String XML_COMPRESSLEVEL_ATTRIBUTE = "compressLevel";
+	private static final String XML_RECORD_SKIP_ATTRIBUTE = "recordSkip";
+	private static final String XML_RECORD_COUNT_ATTRIBUTE = "recordCount";
 
 	public final static String COMPONENT_TYPE = "CLOVER_WRITER";
 	private final static int READ_FROM_PORT = 0;
@@ -125,6 +129,8 @@
 	private InputPort inPort;
 	private int compressLevel;
 	String fileName;
+    private int skip;
+	private int numRecords = -1;
 	
     static Log logger = LogFactory.getLog(CloverDataWriter.class);
 
@@ -170,10 +176,14 @@
 	@Override
 	public Result execute() throws Exception {
 		DataRecord record = new DataRecord(metadata);
+		long iRec = 0;
+		int recordTo = numRecords < 0 ? Integer.MAX_VALUE : (skip <= 0 ? numRecords+1 : skip+1 + numRecords);
 		record.init();
 		try {
 			while (record != null && runIt) {
+				iRec++;
 				record = inPort.readRecord(record);
+				if (skip >= iRec || recordTo <= iRec) continue;
 				if (record != null) {
 					formatter.write(record);
 				}
@@ -284,6 +294,12 @@
 			aDataWriter.setAppend(xattribs.getBoolean(XML_APPEND_ATTRIBUTE,false));
 			aDataWriter.setSaveMetadata(xattribs.getBoolean(XML_SAVEMETADATA_ATTRIBUTE,false));
 			aDataWriter.setCompressLevel(xattribs.getInteger(XML_COMPRESSLEVEL_ATTRIBUTE,-1));
+			if (xattribs.exists(XML_RECORD_SKIP_ATTRIBUTE)){
+				aDataWriter.setSkip(Integer.parseInt(xattribs.getString(XML_RECORD_SKIP_ATTRIBUTE)));
+			}
+			if (xattribs.exists(XML_RECORD_COUNT_ATTRIBUTE)){
+				aDataWriter.setNumRecords(Integer.parseInt(xattribs.getString(XML_RECORD_COUNT_ATTRIBUTE)));
+			}
 		}catch(Exception ex){
 			System.err.println(COMPONENT_TYPE + ":" + xattribs.getString(Node.XML_ID_ATTRIBUTE,"unknown ID") + ":" + ex.getMessage());
 			return null;
@@ -304,6 +320,12 @@
 		if (compressLevel > -1){
 			xmlElement.setAttribute(XML_COMPRESSLEVEL_ATTRIBUTE,String.valueOf(compressLevel));
 		}
+		if (skip != 0){
+			xmlElement.setAttribute(XML_RECORD_SKIP_ATTRIBUTE, String.valueOf(skip));
+		}
+		if (numRecords != 0){
+			xmlElement.setAttribute(XML_RECORD_COUNT_ATTRIBUTE,String.valueOf(numRecords));
+		}
 	}
 
 	public void setSaveMetadata(boolean saveMetadata) {
@@ -319,5 +341,20 @@
 		formatter.setAppend(append);
 	}
 
+    /**
+     * Sets number of skipped records in next call of getNext() method.
+     * @param skip
+     */
+    public void setSkip(int skip) {
+        this.skip = skip;
+    }
 
+    /**
+     * Sets number of written records.
+     * @param numRecords
+     */
+    public void setNumRecords(int numRecords) {
+        this.numRecords = numRecords;
+    }
+
 }

Modified: trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -105,7 +105,6 @@
 	private WritableByteChannel writableByteChannel;
     private int skip;
 	private int numRecords;
-	private String charset;
 
 	static Log logger = LogFactory.getLog(DataWriter.class);
 
@@ -124,14 +123,12 @@
 		super(id);
 		this.fileURL = fileURL;
 		this.appendData = appendData;
-		this.charset = charset;
 		formatter = new DataFormatter(charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
 	}
 	
 	public DataWriter(String id, WritableByteChannel writableByteChannel, String charset) {
 		super(id);
 		this.writableByteChannel = writableByteChannel;
-		this.charset = charset;
 		formatter = new DataFormatter(charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
 	}
 
@@ -180,10 +177,9 @@
         writer.setRecordsPerFile(recordsPerFile);
         writer.setAppendData(appendData);
         writer.setSkip(skip);
-        writer.setCharset(charset);
         writer.setNumRecords(numRecords);
         if(outputFieldNames) {
-            writer.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
+        	formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
         }
         writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}

Modified: trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -105,7 +105,6 @@
 	private boolean outputFieldNames=false;
 	private int recordsPerFile;
 	private int bytesPerFile;
-	private String charset;
     private int skip;
 	private int numRecords;
 	private WritableByteChannel writableByteChannel;
@@ -140,14 +139,12 @@
 		super(id);
 		this.fileURL = fileURL;
 		this.appendData = appendData;
-        this.charset = charset;
 		formatter = new DelimitedDataFormatter(charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
 	}
 
 	public DelimitedDataWriter(String id, WritableByteChannel writableByteChannel, String charset) {
 		super(id);
 		this.writableByteChannel = writableByteChannel;
-        this.charset = charset;
 		formatter = new DelimitedDataFormatter(charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
 	}
 
@@ -198,14 +195,12 @@
         writer.setBytesPerFile(bytesPerFile);
         writer.setRecordsPerFile(recordsPerFile);
         writer.setAppendData(appendData);
-        writer.setCharset(charset);
         writer.setSkip(skip);
         writer.setNumRecords(numRecords);
         if(outputFieldNames) {
-            writer.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
+        	formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
         }
         writer.init(getInputPort(READ_FROM_PORT).getMetadata());
-        
 	}
 	
 	public ConfigurationStatus checkConfig(ConfigurationStatus status) {
@@ -304,6 +299,7 @@
     public boolean isOutputFieldNames() {
         return outputFieldNames;
     }
+    
     /**
      * @param outputFieldNames The outputFieldNames to set.
      */

Modified: trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -112,7 +112,6 @@
 	private int bytesPerFile;
     private int skip;
 	private int numRecords;
-	private String charset;
 	private WritableByteChannel writableByteChannel;
 
 	static Log logger = LogFactory.getLog(FixLenDataWriter.class);
@@ -134,14 +133,12 @@
 		super(id);
 		this.fileURL = fileURL;
 		this.appendData = appendData;
-        this.charset = charset;
 		formatter = new FixLenDataFormatter(charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
 	}
 
 	public FixLenDataWriter(String id, WritableByteChannel writableByteChannel, String charset) {
 		super(id);
 		this.writableByteChannel = writableByteChannel;
-        this.charset = charset;
 		formatter = new FixLenDataFormatter(charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
 	}
 
@@ -188,11 +185,10 @@
         writer.setBytesPerFile(bytesPerFile);
         writer.setRecordsPerFile(recordsPerFile);
         writer.setAppendData(appendData);
-        writer.setCharset(charset);
         writer.setSkip(skip);
         writer.setNumRecords(numRecords);
         if(outputFieldNames) {
-            writer.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
+        	formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
         }
         writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}

Modified: trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -21,26 +21,25 @@
 
 package org.jetel.component;
 
-import java.io.IOException;
-import java.nio.ByteBuffer;
 import java.nio.channels.Channels;
 import java.nio.channels.WritableByteChannel;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.jetel.data.DataRecord;
 import org.jetel.data.Defaults;
 import org.jetel.data.formatter.StructureFormatter;
 import org.jetel.exception.ComponentNotReadyException;
-import org.jetel.exception.ConfigurationProblem;
 import org.jetel.exception.ConfigurationStatus;
 import org.jetel.graph.InputPort;
 import org.jetel.graph.Node;
 import org.jetel.graph.Result;
 import org.jetel.graph.TransformationGraph;
-import org.jetel.util.ByteBufferUtils;
 import org.jetel.util.ComponentXMLAttributes;
 import org.jetel.util.FileUtils;
-import org.jetel.util.StringUtils;
+import org.jetel.util.MultiFileWriter;
 import org.jetel.util.SynchronizeUtils;
+import org.jetel.util.WritableByteChannelIterator;
 import org.w3c.dom.Element;
 
 /**
@@ -81,6 +80,8 @@
  *  where field1 ,.., fieldn are record's fields from metadata</td>
  *  <tr><td><b>header</b></td><td>text to write before records</td>
  *  <tr><td><b>footer</b></td><td>text to write after records</td>
+ *  <tr><td><b>recordsPerFile</b></td><td>max number of records in one output file</td>
+ *  <tr><td><b>bytesPerFile</b></td><td>Max size of output files. To avoid splitting a record to two files, max size could be slightly overreached.</td>
  *  <tr><td><b>recordSkip</b></td><td>number of skipped records</td>
  *  <tr><td><b>recordCount</b></td><td>number of written records</td>
  *  </tr>
@@ -117,18 +118,23 @@
 	public static final String XML_FOOTER_ATTRIBUTE = "footer";
 	public static final String XML_RECORD_SKIP_ATTRIBUTE = "recordSkip";
 	public static final String XML_RECORD_COUNT_ATTRIBUTE = "recordCount";
+	private static final String XML_RECORDS_PER_FILE = "recordsPerFile";
+	private static final String XML_BYTES_PER_FILE = "bytesPerFile";
 
 	private String fileURL;
 	private boolean appendData;
 	private StructureFormatter formatter;
 	private String header = null;
 	private String footer = null;
-	private WritableByteChannel writer;
-	private ByteBuffer buffer;
-	private String charset;
+	private MultiFileWriter writer;
     private int skip;
 	private int numRecords;
+	private WritableByteChannel writableByteChannel;
+	private int recordsPerFile;
+	private int bytesPerFile;
 
+	private static Log logger = LogFactory.getLog(StructureWriter.class);
+
 	public final static String COMPONENT_TYPE = "STRUCTURE_WRITER";
 	private final static int READ_FROM_PORT = 0;
 
@@ -146,9 +152,7 @@
 		super(id);
 		this.fileURL = fileURL;
 		this.appendData = appendData;
-		this.charset = charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER;
-		formatter = charset == null ? new StructureFormatter() : 
-			new StructureFormatter(charset);
+		formatter = new StructureFormatter(charset != null ? charset : Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
 		formatter.setMask(mask);
 	}
 
@@ -162,38 +166,20 @@
 
 	@Override
 	public Result execute() throws Exception {
-		//write header
-		if (header != null ){
-			buffer.put(header.getBytes(charset));
-			ByteBufferUtils.flush(buffer,writer);
-		}
 		InputPort inPort = getInputPort(READ_FROM_PORT);
 		DataRecord record = new DataRecord(inPort.getMetadata());
-		int iRec = 0;
-		int recordTo = numRecords < 0 ? Integer.MAX_VALUE : (skip <= 0 ? numRecords+1 : skip+1 + numRecords);
 		record.init();
-		//write records
 		try {
 			while (record != null && runIt) {
-				iRec++;
 				record = inPort.readRecord(record);
-				if (skip >= iRec || recordTo <= iRec) continue;
 				if (record != null) {
-					formatter.write(record);
+			        writer.write(record);
 				}
 				SynchronizeUtils.cloverYield();
 			}
-			formatter.flush();
-			//write footer
-			if (footer != null ){
-				buffer.clear();
-				buffer.put(footer.getBytes(charset));
-				ByteBufferUtils.flush(buffer,writer);
-			}
 		} catch (Exception e) {
 			throw e;
 		}finally{
-			//close output
 			writer.close();
 		}
         return runIt ? Result.FINISHED_OK : Result.ABORTED;
@@ -232,14 +218,23 @@
 	public void init() throws ComponentNotReadyException {
 		super.init();
 		// based on file mask, create/open output file
-		try {
-			writer = fileURL == null ? Channels.newChannel(System.out) : FileUtils.getWritableChannel(getGraph() != null ? getGraph().getProjectURL() : null, fileURL, appendData);
-			buffer = ByteBuffer.allocateDirect(StringUtils.getMaxLength(header,footer));
-			formatter.init(getInputPort(READ_FROM_PORT).getMetadata());
-            formatter.setDataTarget(writer);
-		} catch (IOException ex) {
-			throw new ComponentNotReadyException(getId() + "IOError: " + ex.getMessage());
+		if (fileURL != null) {
+	        writer = new MultiFileWriter(formatter, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
+		} else {
+			if (writableByteChannel == null) {
+		        writableByteChannel = Channels.newChannel(System.out);
+			}
+	        writer = new MultiFileWriter(formatter, new WritableByteChannelIterator(writableByteChannel));
 		}
+        writer.setLogger(logger);
+        writer.setBytesPerFile(bytesPerFile);
+        writer.setRecordsPerFile(recordsPerFile);
+        writer.setAppendData(appendData);
+        writer.setSkip(skip);
+        writer.setNumRecords(numRecords);
+        formatter.setHeader(header);
+        formatter.setFooter(footer);
+        writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}
 
 	/* (non-Javadoc)
@@ -267,6 +262,12 @@
 			if (xattribs.exists(XML_RECORD_COUNT_ATTRIBUTE)){
 				aDataWriter.setNumRecords(Integer.parseInt(xattribs.getString(XML_RECORD_COUNT_ATTRIBUTE)));
 			}
+            if(xattribs.exists(XML_RECORDS_PER_FILE)) {
+            	aDataWriter.setRecordsPerFile(xattribs.getInteger(XML_RECORDS_PER_FILE));
+            }
+            if(xattribs.exists(XML_BYTES_PER_FILE)) {
+            	aDataWriter.setBytesPerFile(xattribs.getInteger(XML_BYTES_PER_FILE));
+            }
 		}catch(Exception ex){
 			System.err.println(COMPONENT_TYPE + ":" + xattribs.getString(Node.XML_ID_ATTRIBUTE,"unknown ID") + ":" + ex.getMessage());
 			return null;
@@ -298,6 +299,12 @@
 		if (numRecords != 0){
 			xmlElement.setAttribute(XML_RECORD_COUNT_ATTRIBUTE,String.valueOf(numRecords));
 		}
+		if (recordsPerFile > 0) {
+			xmlElement.setAttribute(XML_RECORDS_PER_FILE, Integer.toString(recordsPerFile));
+		}
+		if (bytesPerFile > 0) {
+			xmlElement.setAttribute(XML_BYTES_PER_FILE, Integer.toString(bytesPerFile));
+		}
 	}
 	
 	public void setFooter(String footer) {
@@ -324,4 +331,12 @@
         this.numRecords = numRecords;
     }
 
+    public void setBytesPerFile(int bytesPerFile) {
+        this.bytesPerFile = bytesPerFile;
+    }
+
+    public void setRecordsPerFile(int recordsPerFile) {
+        this.recordsPerFile = recordsPerFile;
+    }
+
 }

Modified: trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.component/src/org/jetel/component/TextTableWriter.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -21,15 +21,15 @@
 
 package org.jetel.component;
 
-import java.io.IOException;
 import java.nio.channels.Channels;
 import java.nio.channels.WritableByteChannel;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.jetel.data.DataRecord;
 import org.jetel.data.Defaults;
 import org.jetel.data.formatter.TextTableFormatter;
 import org.jetel.exception.ComponentNotReadyException;
-import org.jetel.exception.ConfigurationProblem;
 import org.jetel.exception.ConfigurationStatus;
 import org.jetel.graph.InputPort;
 import org.jetel.graph.Node;
@@ -37,8 +37,9 @@
 import org.jetel.graph.TransformationGraph;
 import org.jetel.util.ComponentXMLAttributes;
 import org.jetel.util.FileUtils;
-import org.jetel.util.StringUtils;
+import org.jetel.util.MultiFileWriter;
 import org.jetel.util.SynchronizeUtils;
+import org.jetel.util.WritableByteChannelIterator;
 import org.w3c.dom.Element;
 
 /**
@@ -71,6 +72,8 @@
  *  minimal length of the number. Name without wildcard specifies only one file.</td>
  *  <tr><td><b>charset</b></td><td>character encoding of the output file (if not specified, then ISO-8859-1 is used)</td>
  *  <tr><td><b>append</b></td><td>whether to append data at the end if output file exists or replace it (values: true/false)</td>
+ *  <tr><td><b>recordsPerFile</b></td><td>max number of records in one output file</td>
+ *  <tr><td><b>bytesPerFile</b></td><td>Max size of output files. To avoid splitting a record to two files, max size could be slightly overreached.</td>
  *  <tr><td><b>recordSkip</b></td><td>number of skipped records</td>
  *  <tr><td><b>recordCount</b></td><td>number of written records</td>
  *  </tr>
@@ -91,25 +94,32 @@
  */
 public class TextTableWriter extends Node {
 
-	public static final String XML_APPEND_ATTRIBUTE = "append";
-	public static final String XML_FILEURL_ATTRIBUTE = "fileURL";
-	public static final String XML_CHARSET_ATTRIBUTE = "charset";
-	public static final String XML_MASK_ATTRIBUTE = "mask";
-	public static final String XML_HEADER_ATTRIBUTE = "header";
-	public static final String XML_RECORD_SKIP_ATTRIBUTE = "recordSkip";
-	public static final String XML_RECORD_COUNT_ATTRIBUTE = "recordCount";
+	private static final String XML_APPEND_ATTRIBUTE = "append";
+	private static final String XML_FILEURL_ATTRIBUTE = "fileURL";
+	private static final String XML_CHARSET_ATTRIBUTE = "charset";
+	private static final String XML_MASK_ATTRIBUTE = "mask";
+	private static final String XML_RECORD_SKIP_ATTRIBUTE = "recordSkip";
+	private static final String XML_RECORD_COUNT_ATTRIBUTE = "recordCount";
+	private static final String XML_OUTPUT_FIELD_NAMES = "outputFieldNames";
+	private static final String XML_RECORDS_PER_FILE = "recordsPerFile";
+	private static final String XML_BYTES_PER_FILE = "bytesPerFile";
 
 	private String fileURL;
 	private boolean appendData;
 	private TextTableFormatter formatter;
-	private boolean header = true;
-	private WritableByteChannel writer;
+	private MultiFileWriter writer;
     private int skip;
 	private int numRecords;
+	private WritableByteChannel writableByteChannel;
+	private boolean outputFieldNames=true;
+	private int recordsPerFile;
+	private int bytesPerFile;
 	
 	public final static String COMPONENT_TYPE = "TEXT_TABLE_WRITER";
 	private final static int READ_FROM_PORT = 0;
 
+	private static Log logger = LogFactory.getLog(TextTableWriter.class);
+
 	/**
 	 * Constructor
 	 * 
@@ -117,7 +127,7 @@
 	 * @param fileURL
 	 * @param charset
 	 * @param appendData
-	 * @param mask
+	 * @param fields
 	 */
 	public TextTableWriter(String id, String fileURL, String charset, 
 			boolean appendData, String[] fields) {
@@ -127,6 +137,24 @@
 		formatter = charset == null ? new TextTableFormatter(Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER) : new TextTableFormatter(charset);
 		formatter.setMask(fields);
 	}
+	
+	/**
+	 * Constructor
+	 * 
+	 * @param id
+	 * @param writableByteChannel
+	 * @param charset
+	 * @param appendData
+	 * @param fields
+	 */
+	public TextTableWriter(String id, WritableByteChannel writableByteChannel, String charset, 
+			boolean appendData, String[] fields) {
+		super(id);
+		this.writableByteChannel = writableByteChannel;
+		this.appendData = appendData;
+		formatter = charset == null ? new TextTableFormatter(Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER) : new TextTableFormatter(charset);
+		formatter.setMask(fields);
+	}
 
 	/* (non-Javadoc)
 	 * @see org.jetel.graph.Node#getType()
@@ -138,28 +166,20 @@
 
 	@Override
 	public Result execute() throws Exception {
-		//write header
 		InputPort inPort = getInputPort(READ_FROM_PORT);
 		DataRecord record = new DataRecord(inPort.getMetadata());
-		long iRec = 0;
-		int recordTo = numRecords < 0 ? Integer.MAX_VALUE : (skip <= 0 ? numRecords+1 : skip+1 + numRecords);
 		record.init();
-		//write records
 		try {
 			while (record != null && runIt) {
-				iRec++;
 				record = inPort.readRecord(record);
-				if (skip >= iRec || recordTo <= iRec) continue;
 				if (record != null) {
-					formatter.write(record);
+			        writer.write(record);
 				}
 				SynchronizeUtils.cloverYield();
 			}
-			formatter.eof();
 		} catch (Exception e) {
 			throw e;
 		}finally{
-			//close output
 			writer.close();
 		}
         return runIt ? Result.FINISHED_OK : Result.ABORTED;
@@ -198,14 +218,22 @@
 	public void init() throws ComponentNotReadyException {
 		super.init();
 		// based on file mask, create/open output file
-		try {
-			writer = fileURL == null ? Channels.newChannel(System.out) : FileUtils.getWritableChannel(getGraph().getProjectURL(), fileURL, appendData);
-			formatter.init(getInputPort(READ_FROM_PORT).getMetadata());
-            formatter.setDataTarget(writer);
-            formatter.setHeader(header);
-		} catch (IOException ex) {
-			throw new ComponentNotReadyException(getId() + "IOError: " + ex.getMessage());
+		if (fileURL != null) {
+	        writer = new MultiFileWriter(formatter, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
+		} else {
+			if (writableByteChannel == null) {
+		        writableByteChannel = Channels.newChannel(System.out);
+			}
+	        writer = new MultiFileWriter(formatter, new WritableByteChannelIterator(writableByteChannel));
 		}
+        writer.setLogger(logger);
+        writer.setBytesPerFile(bytesPerFile);
+        writer.setRecordsPerFile(recordsPerFile);
+        writer.setAppendData(appendData);
+        writer.setSkip(skip);
+        writer.setNumRecords(numRecords);
+       	formatter.setOutputFieldNames(outputFieldNames);
+        writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}
 
 	/* (non-Javadoc)
@@ -223,15 +251,21 @@
 									xattribs.getString(XML_CHARSET_ATTRIBUTE,null),
 									xattribs.getBoolean(XML_APPEND_ATTRIBUTE, false),
 									aFields);
-			if (xattribs.exists(XML_HEADER_ATTRIBUTE)){
-				aDataWriter.setHeader(Boolean.parseBoolean(xattribs.getString(XML_HEADER_ATTRIBUTE)));
-			}
 			if (xattribs.exists(XML_RECORD_SKIP_ATTRIBUTE)){
 				aDataWriter.setSkip(Integer.parseInt(xattribs.getString(XML_RECORD_SKIP_ATTRIBUTE)));
 			}
 			if (xattribs.exists(XML_RECORD_COUNT_ATTRIBUTE)){
 				aDataWriter.setNumRecords(Integer.parseInt(xattribs.getString(XML_RECORD_COUNT_ATTRIBUTE)));
 			}
+			if (xattribs.exists(XML_OUTPUT_FIELD_NAMES)){
+				aDataWriter.setOutputFieldNames(xattribs.getBoolean(XML_OUTPUT_FIELD_NAMES));
+			}
+            if(xattribs.exists(XML_RECORDS_PER_FILE)) {
+            	aDataWriter.setRecordsPerFile(xattribs.getInteger(XML_RECORDS_PER_FILE));
+            }
+            if(xattribs.exists(XML_BYTES_PER_FILE)) {
+            	aDataWriter.setBytesPerFile(xattribs.getInteger(XML_BYTES_PER_FILE));
+            }
 		}catch(Exception ex){
 			System.err.println(COMPONENT_TYPE + ":" + xattribs.getString(Node.XML_ID_ATTRIBUTE,"unknown ID") + ":" + ex.getMessage());
 			return null;
@@ -251,19 +285,23 @@
 			xmlElement.setAttribute(XML_CHARSET_ATTRIBUTE, this.formatter.getCharsetName());
 		}
 		xmlElement.setAttribute(XML_APPEND_ATTRIBUTE, String.valueOf(this.appendData));
-		xmlElement.setAttribute(XML_HEADER_ATTRIBUTE,String.valueOf(header));
 		if (skip != 0){
 			xmlElement.setAttribute(XML_RECORD_SKIP_ATTRIBUTE, String.valueOf(skip));
 		}
 		if (numRecords != 0){
 			xmlElement.setAttribute(XML_RECORD_COUNT_ATTRIBUTE,String.valueOf(numRecords));
 		}
+		if (outputFieldNames){
+		    xmlElement.setAttribute(XML_OUTPUT_FIELD_NAMES, Boolean.toString(outputFieldNames));
+		}
+		if (recordsPerFile > 0) {
+			xmlElement.setAttribute(XML_RECORDS_PER_FILE, Integer.toString(recordsPerFile));
+		}
+		if (bytesPerFile > 0) {
+			xmlElement.setAttribute(XML_BYTES_PER_FILE, Integer.toString(bytesPerFile));
+		}
 	}
 	
-	public void setHeader(boolean header) {
-		this.header = header;
-	}
-
     /**
      * Sets number of skipped records in next call of getNext() method.
      * @param skip
@@ -280,4 +318,19 @@
         this.numRecords = numRecords;
     }
 
+    /**
+     * @param outputFieldNames The outputFieldNames to set.
+     */
+    public void setOutputFieldNames(boolean outputFieldNames) {
+        this.outputFieldNames = outputFieldNames;
+    }
+
+    public void setBytesPerFile(int bytesPerFile) {
+        this.bytesPerFile = bytesPerFile;
+    }
+
+    public void setRecordsPerFile(int recordsPerFile) {
+        this.recordsPerFile = recordsPerFile;
+    }
+
 }

Modified: trunk/cloveretl.component/src/org/jetel/component/Trash.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/Trash.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.component/src/org/jetel/component/Trash.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -20,23 +20,24 @@
 package org.jetel.component;
 
 import java.io.IOException;
-import java.io.PrintWriter;
-import java.nio.ByteBuffer;
 import java.nio.channels.Channels;
+import java.nio.channels.WritableByteChannel;
 
 import org.jetel.data.DataRecord;
 import org.jetel.data.Defaults;
+import org.jetel.data.formatter.TextTableFormatter;
 import org.jetel.exception.ComponentNotReadyException;
 import org.jetel.exception.ConfigurationStatus;
-import org.jetel.exception.JetelException;
 import org.jetel.exception.XMLConfigurationException;
-import org.jetel.graph.InputPortDirect;
+import org.jetel.graph.InputPort;
 import org.jetel.graph.Node;
 import org.jetel.graph.Result;
 import org.jetel.graph.TransformationGraph;
 import org.jetel.util.ComponentXMLAttributes;
 import org.jetel.util.FileUtils;
+import org.jetel.util.MultiFileWriter;
 import org.jetel.util.SynchronizeUtils;
+import org.jetel.util.WritableByteChannelIterator;
 import org.w3c.dom.Element;
 
 /**
@@ -88,11 +89,11 @@
 	private final static int READ_FROM_PORT = 0;
 	private boolean debugPrint;
 	private String debugFilename;
-	private PrintWriter outStream;
 
-	private ByteBuffer recordBuffer;
+	private TextTableFormatter formatter;
+	private MultiFileWriter writer;
+	private WritableByteChannel writableByteChannel;
 
-
 	/**
 	 *Constructor for the Trash object
 	 *
@@ -102,8 +103,6 @@
 		super(id);
 		debugPrint = false;
 		debugFilename = null;
-		outStream = null;
-
 	}
 
 
@@ -132,39 +131,23 @@
 
 	@Override
 	public Result execute() throws Exception {
-		int recCounter = 0;
-		InputPortDirect inPort = (InputPortDirect) getInputPort(READ_FROM_PORT);
-		boolean isData = true;
-		DataRecord dataRecord = null;
-		if (outStream != null) {
-			dataRecord = new DataRecord(getInputPort(READ_FROM_PORT).getMetadata());
-			dataRecord.init();
-		}
-		String resultMsg = null;
+		InputPort inPort = getInputPort(READ_FROM_PORT);
+		DataRecord record = new DataRecord(inPort.getMetadata());
+		record.init();
 		try {
-			while (isData && runIt) {
-				isData = inPort.readRecordDirect(recordBuffer);
-				if (outStream != null && isData) {
-					dataRecord.deserialize(recordBuffer);
-					outStream.println("*** Record# " + recCounter++ + " ***");
-					outStream.print(dataRecord);
+			while (record != null && runIt) {
+				record = inPort.readRecord(record);
+				if (writer != null && record != null) {
+			        writer.write(record);
 					if (debugFilename == null)
-						outStream.flush(); // if we debug into stdout
+						formatter.flush(); // if we debug into stdout
 				}
 				SynchronizeUtils.cloverYield();
 			}
-		} catch (Exception ex) {
-			resultMsg = ex.getClass().getName() + " : " + ex.getMessage();
-			throw new JetelException(resultMsg);
-		} finally {
-	        // close debug file
-			if (outStream != null && debugFilename != null) { // debug is
-																// routed into
-																// file
-				outStream.println("EOF with result " + resultMsg == null ? "OK"
-						: resultMsg);
-				outStream.close();
-			}
+		} catch (Exception e) {
+			throw e;
+		}finally{
+			if (writer != null) writer.close();
 			broadcastEOF();
 		}
         return runIt ? Result.FINISHED_OK : Result.ABORTED;
@@ -178,22 +161,27 @@
 	 */
 	public void init() throws ComponentNotReadyException {
 		super.init();
-		// test that we have at least one input port and one output
-		recordBuffer = ByteBuffer.allocateDirect(Defaults.Record.MAX_RECORD_SIZE);
-		if (recordBuffer == null) {
-			throw new ComponentNotReadyException("Can NOT allocate internal record buffer ! Required size:" +
-					Defaults.Record.MAX_RECORD_SIZE);
-		}
 		if (debugPrint) {
             if(debugFilename != null) {
-          		try {
-    				outStream = new PrintWriter(Channels.newWriter(FileUtils.getWritableChannel(getGraph() != null ? getGraph().getProjectURL() : null, debugFilename, false), Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER));
-    			} catch (IOException ex) {
-    				throw new ComponentNotReadyException(ex.getMessage());
-    			}
+        		formatter = new TextTableFormatter(Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
+       	        try {
+					writer = new MultiFileWriter(formatter, new WritableByteChannelIterator(
+							FileUtils.getWritableChannel(getGraph() != null ? getGraph().getProjectURL() : null, debugFilename, false)
+					));
+				} catch (IOException e) {
+					e.printStackTrace();
+				}
             } else {
-                outStream = new PrintWriter(System.out);
+    			if (writableByteChannel == null) {
+    				formatter = new TextTableFormatter(Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
+    		        writableByteChannel = Channels.newChannel(System.out);
+        	        writer = new MultiFileWriter(formatter, new WritableByteChannelIterator(writableByteChannel));
+    			}
             }
+            if (writer != null) {
+            	formatter.showCounter("Record", "### ");
+                writer.init(getInputPort(READ_FROM_PORT).getMetadata());
+            }
 		}
 	}
 
@@ -251,14 +239,6 @@
     		checkInputPorts(status, 1, 1);
             checkOutputPorts(status, 0, 0);
 
-    		recordBuffer = ByteBuffer.allocateDirect(Defaults.Record.MAX_RECORD_SIZE);
-    		if (recordBuffer == null) {
-                status.add("Can NOT allocate internal record buffer ! Required size:" + Defaults.Record.MAX_RECORD_SIZE, 
-                		ConfigurationStatus.Severity.ERROR, this, 
-                		ConfigurationStatus.Priority.NORMAL);
-    		}
-    		recordBuffer = null;
-
     		if (debugPrint && debugFilename != null) {
                 try {
                 	FileUtils.canWrite(getGraph() != null ? 

Modified: trunk/cloveretl.component/src/org/jetel/component/XLSWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/XLSWriter.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.component/src/org/jetel/component/XLSWriter.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -21,8 +21,11 @@
 
 package org.jetel.component;
 
-import java.io.File;
+import java.nio.channels.Channels;
+import java.nio.channels.WritableByteChannel;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.jetel.data.DataRecord;
 import org.jetel.data.formatter.JExcelXLSDataFormatter;
 import org.jetel.data.formatter.XLSDataFormatter;
@@ -36,8 +39,10 @@
 import org.jetel.graph.Result;
 import org.jetel.graph.TransformationGraph;
 import org.jetel.util.ComponentXMLAttributes;
+import org.jetel.util.MultiFileWriter;
 import org.jetel.util.StringUtils;
 import org.jetel.util.SynchronizeUtils;
+import org.jetel.util.WritableByteChannelIterator;
 import org.w3c.dom.Element;
 
 /**
@@ -73,6 +78,9 @@
  *  <tr><td><b>firstDataRow</b></td><td>index of row, where to write first data record</td>
  *  <tr><td><b>firstColumn</b></td><td>code of column from which data will be written</td>
  *  <tr><td><b>sheetName</b></td><td>name of sheet for writing data. If it is not set data
+ *  <tr><td><b>recordSkip</b></td><td>number of skipped records</td>
+ *  <tr><td><b>recordCount</b></td><td>number of written records</td>
+ *  <tr><td><b>recordsPerFile</b></td><td>max number of records in one output file</td>
  *   new sheet with default name is created</td>
  *  <tr><td><b>sheetNumber</b></td><td>number of sheet for writing data (starting from 0).
  *   If it is not set new sheet with default name is created. If sheetName and sheetNumber 
@@ -108,12 +116,22 @@
 	private static final String XML_FIRSTDATAROW_ATTRIBUTE = "firstDataRow";
 	private static final String XML_FIRSTCOLUMN_ATTRIBUTE = "firstColumn";
 	private static final String XML_NAMESROW_ATTRIBUTE = "namesRow";
+	private static final String XML_RECORD_SKIP_ATTRIBUTE = "recordSkip";
+	private static final String XML_RECORD_COUNT_ATTRIBUTE = "recordCount";
+	private static final String XML_RECORDS_PER_FILE = "recordsPerFile";
 
 	public final static String COMPONENT_TYPE = "XLS_WRITER";
 	private final static int READ_FROM_PORT = 0;
 
+	private static Log logger = LogFactory.getLog(XLSWriter.class);
+
 	private String fileURL;
 	private XLSFormatter formatter;
+	private MultiFileWriter writer;
+    private int skip;
+	private int numRecords;
+	private WritableByteChannel writableByteChannel;
+	private int recordsPerFile;
 	
 	private boolean usePOI = true;
 
@@ -148,19 +166,18 @@
 		InputPort inPort = getInputPort(READ_FROM_PORT);
 		DataRecord record = new DataRecord(inPort.getMetadata());
 		record.init();
-		formatter.prepareSheet();
 		try {
 			while (record != null && runIt) {
 				record = inPort.readRecord(record);
 				if (record != null) {
-					formatter.write(record);
+					writer.write(record);
 				}
 				SynchronizeUtils.cloverYield();
 			}
 		} catch (Exception e) {
 			throw e;
 		}finally{
-			formatter.close();
+			writer.close();
 		}
         return runIt ? Result.FINISHED_OK : Result.ABORTED;
 	}
@@ -201,9 +218,21 @@
 	@Override
 	public void init() throws ComponentNotReadyException {
 		super.init();
-		File out = new File(fileURL);
-		formatter.init(getInputPort(READ_FROM_PORT).getMetadata());
-		formatter.setDataTarget(out);
+		if (fileURL != null) {
+	        writer = new MultiFileWriter(formatter, getGraph() != null ? getGraph().getProjectURL() : null, fileURL);
+		} else {
+			if (writableByteChannel == null) {
+		        writableByteChannel = Channels.newChannel(System.out);
+			}
+	        writer = new MultiFileWriter(formatter, new WritableByteChannelIterator(writableByteChannel));
+		}
+        writer.setLogger(logger);
+        writer.setRecordsPerFile(recordsPerFile);
+        writer.setAppendData(false);
+        writer.setSkip(skip);
+        writer.setNumRecords(numRecords);
+		//formatter.prepareSheet();
+        writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}
 
 	public static Node fromXML(TransformationGraph graph, Element nodeXML) throws XMLConfigurationException {
@@ -222,6 +251,15 @@
 			xlsWriter.setFirstColumn(xattribs.getString(XML_FIRSTCOLUMN_ATTRIBUTE,"A"));
 			xlsWriter.setFirstRow(xattribs.getInteger(XML_FIRSTDATAROW_ATTRIBUTE,1));
 			xlsWriter.setNamesRow(xattribs.getInteger(XML_NAMESROW_ATTRIBUTE,0));
+			if (xattribs.exists(XML_RECORD_SKIP_ATTRIBUTE)){
+				xlsWriter.setSkip(Integer.parseInt(xattribs.getString(XML_RECORD_SKIP_ATTRIBUTE)));
+			}
+			if (xattribs.exists(XML_RECORD_COUNT_ATTRIBUTE)){
+				xlsWriter.setNumRecords(Integer.parseInt(xattribs.getString(XML_RECORD_COUNT_ATTRIBUTE)));
+			}
+            if(xattribs.exists(XML_RECORDS_PER_FILE)) {
+            	xlsWriter.setRecordsPerFile(xattribs.getInteger(XML_RECORDS_PER_FILE));
+            }
 			return xlsWriter;
 		} catch (Exception ex) {
 		    throw new XMLConfigurationException(COMPONENT_TYPE + ":" + xattribs.getString(XML_ID_ATTRIBUTE," unknown ID ") + ":" + ex.getMessage(),ex);
@@ -244,6 +282,15 @@
 		if (formatter.getSheetName() != null) {
 			xmlElement.setAttribute(XML_SHEETNAME_ATTRIBUTE,formatter.getSheetName());
 		}
+		if (skip != 0){
+			xmlElement.setAttribute(XML_RECORD_SKIP_ATTRIBUTE, String.valueOf(skip));
+		}
+		if (numRecords != 0){
+			xmlElement.setAttribute(XML_RECORD_COUNT_ATTRIBUTE,String.valueOf(numRecords));
+		}
+		if (recordsPerFile > 0) {
+			xmlElement.setAttribute(XML_RECORDS_PER_FILE, Integer.toString(recordsPerFile));
+		}
 	}
 
 	private void setSheetName(String sheetName) {
@@ -265,4 +312,25 @@
 	private void setNamesRow(int namesRow){
 		formatter.setNamesRow(namesRow-1);
 	}
+	
+    /**
+     * Sets number of skipped records in next call of getNext() method.
+     * @param skip
+     */
+    public void setSkip(int skip) {
+        this.skip = skip;
+    }
+
+    /**
+     * Sets number of written records.
+     * @param numRecords
+     */
+    public void setNumRecords(int numRecords) {
+        this.numRecords = numRecords;
+    }
+
+    public void setRecordsPerFile(int recordsPerFile) {
+        this.recordsPerFile = recordsPerFile;
+    }
+
 }

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/CloverDataFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/CloverDataFormatter.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/CloverDataFormatter.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -77,6 +77,8 @@
 	private ReadableByteChannel idxReader;
 	private boolean append;
 	private boolean isOpen = false;
+	private ByteBuffer footer; 
+	private ByteBuffer header; 
 	
 	private final static short LEN_SIZE_SPECIFIER = 4;
 	private final static int SHORT_SIZE_BYTES = 2;
@@ -286,8 +288,30 @@
 		this.append = append;
 	}
 
-	/**
-	 * @param index
-	 */
+	public int writeFooter() throws IOException {
+		if (footer != null) {
+			buffer.put(footer);
+			footer.rewind();
+			return footer.remaining();
+		} else
+			return 0;
+	}
 
+	public int writeHeader() throws IOException {
+		if (header != null) {
+			buffer.put(header);
+			header.rewind();
+			return header.remaining();
+		} else 
+			return 0;
+	}
+
+    public void setFooter(String footer) {
+		this.footer = ByteBuffer.wrap(footer.getBytes());
+    }
+
+    public void setHeader(String header) {
+    	this.header = ByteBuffer.wrap(header.getBytes());
+    }
+
 }

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/DataFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/DataFormatter.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/DataFormatter.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -55,7 +55,9 @@
     private boolean isRecordDelimiter;
     private byte[] recordDelimiter;
 	private ByteBuffer dataBuffer;
-
+	private ByteBuffer footer; 
+	private ByteBuffer header; 
+	
 	// use space (' ') to fill/pad field
 	private final static char DEFAULT_FILLER_CHAR = ' ';
 
@@ -227,5 +229,30 @@
 		}
 	}
 
-	
+	public int writeFooter() throws IOException {
+		if (footer != null) {
+			dataBuffer.put(footer);
+			footer.rewind();
+			return footer.remaining();
+		} else
+			return 0;
+	}
+
+	public int writeHeader() throws IOException {
+		if (header != null) {
+			dataBuffer.put(header);
+			header.rewind();
+			return header.remaining();
+		} else 
+			return 0;
+	}
+
+    public void setFooter(String footer) {
+    	this.footer = ByteBuffer.wrap(footer.getBytes());
+    }
+
+    public void setHeader(String header) {
+    	this.header = ByteBuffer.wrap(header.getBytes());
+    }
+
 }

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/DelimitedDataFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/DelimitedDataFormatter.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/DelimitedDataFormatter.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -58,6 +58,8 @@
 	private int numFields;
 	private boolean isRecordDelimiter;
     private String recordDelimiter;
+	private ByteBuffer footer; 
+	private ByteBuffer header; 
     
 	private static String NEW_LINE_STR;
 
@@ -260,6 +262,32 @@
 	public String getCharsetName() {
 		return(this.charSet);
 	}
+
+	public int writeFooter() throws IOException {
+		if (footer != null) {
+			dataBuffer.put(footer);
+			footer.rewind();
+			return footer.remaining();
+		} else
+			return 0;
+	}
+
+	public int writeHeader() throws IOException {
+		if (header != null) {
+			dataBuffer.put(header);
+			header.rewind();
+			return header.remaining();
+		} else 
+			return 0;
+	}
+
+    public void setFooter(String footer) {
+    	this.footer = ByteBuffer.wrap(footer.getBytes());
+    }
+
+    public void setHeader(String header) {
+    	this.header = ByteBuffer.wrap(header.getBytes());
+    }
 	
 }
 /*

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/FixLenDataFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/FixLenDataFormatter.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/FixLenDataFormatter.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -29,7 +29,6 @@
 import java.nio.charset.CharsetEncoder;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.List;
 import java.util.SortedMap;
 import java.util.TreeMap;
 
@@ -63,6 +62,8 @@
 	private String charSet = null;
     private boolean isRecordDelimiter;
     private byte[] recordDelimiter;
+	private ByteBuffer footer; 
+	private ByteBuffer header; 
 
     private int fieldCnt;
     private int[] fieldStart;
@@ -352,6 +353,32 @@
 		return(this.charSet);
 	}
 	
+	public int writeFooter() throws IOException {
+		if (footer != null) {
+			dataBuffer.put(footer);
+			footer.rewind();
+			return footer.remaining();
+		} else
+			return 0;
+	}
+
+	public int writeHeader() throws IOException {
+		if (header != null) {
+			dataBuffer.put(header);
+			header.rewind();
+			return header.remaining();
+		} else 
+			return 0;
+	}
+
+    public void setFooter(String footer) {
+    	this.footer = ByteBuffer.wrap(footer.getBytes());
+    }
+
+    public void setHeader(String header) {
+    	this.header = ByteBuffer.wrap(header.getBytes());
+    }
+
 }
 /*
  *  end class FixLenDataFormatter

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/Formatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/Formatter.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/Formatter.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -66,8 +66,22 @@
 	 */
 	public int write(DataRecord record) throws IOException;
 
+	
+	/**
+	 *  Formats header based on provided metadata
+	 * @throws IOException
+	 */
+	public int writeHeader() throws IOException;
 
+	
 	/**
+	 *  Formats footer based on provided metadata
+	 * @throws IOException
+	 */
+	public int writeFooter() throws IOException;
+
+
+	/**
 	 *  Flush any unwritten data into output stream
 	 * @throws IOException
 	 */

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/JExcelXLSDataFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/JExcelXLSDataFormatter.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/JExcelXLSDataFormatter.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -22,6 +22,7 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.nio.ByteBuffer;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 
@@ -221,10 +222,6 @@
 	 * @see org.jetel.data.formatter.Formatter#write(org.jetel.data.DataRecord)
 	 */
 	public int write(DataRecord record) throws IOException {
-		if (!savedNames){
-			saveNames();
-			return 0;
-		}
 		char metaType;//metadata field type
 		Object value;//field value
 		Object valueXls = null;//value to set
@@ -302,6 +299,17 @@
         
         return 0;
 	}
+
+	public int writeFooter() throws IOException {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	public int writeHeader() throws IOException {
+		if (!savedNames){
+			saveNames();
+		}
+		return 0;
+	}
 	
-
 }

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/StructureFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/StructureFormatter.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/StructureFormatter.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -63,6 +63,8 @@
 	private ByteBuffer dataBuffer;
 	private CharsetEncoder encoder;
 	private String charSet = null;
+	private ByteBuffer footer; 
+	private ByteBuffer header; 
 	
 
 	/**
@@ -241,5 +243,32 @@
 		}
 	}
 	
+	public int writeFooter() throws IOException {
+		if (footer != null) {
+			dataBuffer.put(footer);
+			footer.rewind();
+			return footer.remaining();
+		} else
+			return 0;
+	}
+
+	public int writeHeader() throws IOException {
+		if (header != null) {
+			dataBuffer.put(header);
+			header.rewind();
+			return header.remaining();
+		} else 
+			return 0;
+	}
+
+    public void setFooter(String footer) {
+    	this.footer = ByteBuffer.wrap(footer.getBytes());
+    }
+
+    public void setHeader(String header) {
+    	this.header = ByteBuffer.wrap(header.getBytes());
+    }
+
+	
 }
 

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/TextTableFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/TextTableFormatter.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/TextTableFormatter.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -22,6 +22,7 @@
 package org.jetel.data.formatter;
 
 import java.io.IOException;
+import java.io.UnsupportedEncodingException;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.channels.WritableByteChannel;
@@ -54,9 +55,6 @@
 	
 	private DataRecordMetadata metadata;
 	private WritableByteChannel writer;
-	private int[] maskIndex;
-	private int lastIndex;
-	private String fieldName;
 	private ByteBuffer fieldBuffer; 
 	private ByteBuffer dataBuffer;
 	private CharsetEncoder encoder;
@@ -65,17 +63,27 @@
 	private List<DataRecord> dataRecords;
 	private CharBuffer blank;
 	private CharBuffer horizontal;
-	private boolean header = true;
+	private boolean setOutputFieldNames = true;
 	private int rowSize = 0;
 	private int leftBytes = 0;
 	private DataFieldParams[] maskAnalize;
 	private String[] mask;
+	private boolean writeHeader = false;
+	private boolean showCounter;
+	private int counter;
+	private byte[] header;
+	private byte[] prefix;
+	private String sCounter;
+	private int counterLenght;
+	private int prefixOffset; 
+	private int headerOffset; 
 
 	private static final int MAX_COUNT_ANALYZED_COUNT = 20;
 	private static final int PADDING_SPACE = 3;
 
 	private static final byte[] TABLE_CORNER = new byte[] {('+')};
-	private static final byte[] TABLE_HORIZONTAL = new byte[] {('-')};
+	private static final char TABLE_HORIZONTAL = '-';
+	private static final char TABLE_BLANK = ' ';
 	private static final byte[] TABLE_VERTICAL = new byte[] {('|')};
 	private static final byte[] NL = new byte[] {('\n')};
 	
@@ -121,16 +129,12 @@
 			}
 			maskAnalize = new DataFieldParams[mask.length];
 			for (int i=0;i<mask.length;i++){
+				if (map.get(mask[i]) == null)
+					throw new ComponentNotReadyException("Exception: Field '" + mask[i] + "' not found.");
 				maskAnalize[i] = new DataFieldParams(mask[i], map.get(mask[i]), 0);
 			}
 		}
 		dataRecords = new LinkedList<DataRecord>();
-		/*try {
-			maskBytes = mask.getBytes(charSet != null ? charSet
-					: Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER);
-		} catch (UnsupportedEncodingException e) {
-			throw new ComponentNotReadyException(e);
-		}*/
 	}
 
     /* (non-Javadoc)
@@ -164,6 +168,31 @@
         int mark;
         
         sentBytes += writeString(TABLE_VERTICAL);
+
+        if (showCounter) {
+            counter++;
+            sCounter = Integer.toString(counter);
+            
+			if (dataBuffer.remaining() < fieldBuffer.limit()){
+				directFlush();
+			}
+			//change field value to bytes
+			fieldBuffer.clear();
+			fieldBuffer.put(prefix);
+			fieldBuffer.put(sCounter.getBytes());
+			fieldBuffer.flip();
+            
+			blank.clear();
+			blank.limit(prefixOffset - fieldBuffer.limit());
+            mark=dataBuffer.position();
+
+			//put field value to data buffer
+			dataBuffer.put(fieldBuffer);
+			dataBuffer.put(encoder.encode(blank));
+            
+            sentBytes+=dataBuffer.position()-mark;
+            sentBytes += writeString(TABLE_VERTICAL);
+        }
         
 		//for each record field which is in mask change its name to value
 		for (int i=0;i<maskAnalize.length;i++){
@@ -176,7 +205,7 @@
 			fieldBuffer.flip();
             
 			blank.clear();
-			blank.limit(maskAnalize[i].length - (fieldBuffer.limit()));
+			blank.limit(maskAnalize[i].length - (new String(record.getField(maskAnalize[i].index).getValue().toString().getBytes(encoder.charset().displayName())).length())); // fieldBuffer.limit() is wrong - encoding
             mark=dataBuffer.position();
 
 			//put field value to data buffer
@@ -184,16 +213,23 @@
 			dataBuffer.put(encoder.encode(blank));
             
             sentBytes+=dataBuffer.position()-mark;
-
             sentBytes += writeString(TABLE_VERTICAL);
 		}
         sentBytes += writeString(NL);
         return sentBytes;
 	}
 
-	private int writeHeader() throws IOException {
+	public int writeHeader() throws IOException {
+		if (!setOutputFieldNames || !writeHeader) return 0; // writeHeader depends on MAX_COUNT_ANALYZED_COUNT
+		if (!isMaskAnalized()) {
+			analyzeRows(dataRecords, setOutputFieldNames);
+		}
         int sentBytes=0;
         sentBytes += writeString(TABLE_CORNER);
+        if (showCounter) {
+        	sentBytes += writeString(horizontal, counterLenght);
+            sentBytes += writeString(TABLE_CORNER);
+        }
         for (int i=0; i<maskAnalize.length; i++) {
         	sentBytes += writeString(horizontal, maskAnalize[i].length);
             sentBytes += writeString(TABLE_CORNER);
@@ -203,6 +239,11 @@
 		DataFieldMetadata[] fMetadata = metadata.getFields();
 		String fName;
         sentBytes += writeString(TABLE_VERTICAL);
+        if (showCounter) {
+        	sentBytes += writeString(header);
+        	sentBytes += writeString(blank, headerOffset-header.length); // TODO ?
+            sentBytes += writeString(TABLE_VERTICAL);
+        }
         for (int i=0; i<maskAnalize.length; i++) {
         	fName = fMetadata[maskAnalize[i].index].getName();
         	sentBytes += writeString(fName.getBytes());
@@ -212,18 +253,35 @@
         sentBytes += writeString(NL);
         
         sentBytes += writeString(TABLE_CORNER);
+        if (showCounter) {
+        	sentBytes += writeString(horizontal, counterLenght);
+            sentBytes += writeString(TABLE_CORNER);
+        }
         for (int i=0; i<maskAnalize.length; i++) {
         	sentBytes += writeString(horizontal, maskAnalize[i].length);
             sentBytes += writeString(TABLE_CORNER);
         }
         sentBytes += writeString(NL);
 
-		return sentBytes;
+        return sentBytes;
 	}
 	
-	private int writeFooter() throws IOException {
+	public int writeFooter() throws IOException {
+		if (!setOutputFieldNames) return 0;
+		if (!writeHeader) {
+			writeHeader = true;
+			writeHeader();
+			writeHeader = false;
+		}
+		if (!isMaskAnalized()) {
+			flush();
+		}
         int sentBytes=0;
         sentBytes += writeString(TABLE_CORNER);
+        if (showCounter) {
+        	sentBytes += writeString(horizontal, counterLenght);
+            sentBytes += writeString(TABLE_CORNER);
+        }
         for (int i=0; i<maskAnalize.length; i++) {
         	sentBytes += writeString(horizontal, maskAnalize[i].length);
             sentBytes += writeString(TABLE_CORNER);
@@ -234,16 +292,15 @@
 	}
 	
 	private int writeString(byte[] buffer) throws IOException {
-        int sentBytes=0;
-        int mark;
+        //int sentBytes=0;
+        //int mark;
 		if (dataBuffer.remaining() < buffer.length){
 			directFlush();
 		}
-        mark=dataBuffer.position();
+        //mark=dataBuffer.position();
         dataBuffer.put(buffer);
-        sentBytes+=dataBuffer.position()-mark;
-		
-		return sentBytes;
+        //sentBytes+=dataBuffer.position()-mark;
+		return new String(buffer).getBytes(encoder.charset().displayName()).length; // encoding
 	}
 	
 	private int writeString(CharBuffer buffer, int lenght) throws IOException {
@@ -264,6 +321,7 @@
 	
 	/**
 	 * Writes record as 'write' function, but likewise can better format the rows.
+	 * For MAX_COUNT_ANALYZED_COUNT rows return 0. Then returns count of all written rows.
 	 * 
 	 * @param record
 	 * @throws IOException 
@@ -272,11 +330,12 @@
 		int size;
 		if (dataRecords != null) {
 			dataRecords.add(record.duplicate());
+			writeHeader = true;
 			if (dataRecords.size() < MAX_COUNT_ANALYZED_COUNT) {
 				return 0;
 			}
-			analyzeRows(dataRecords, header);
-			size = header ? writeHeader() : 0;
+			analyzeRows(dataRecords, setOutputFieldNames);
+			size = writeHeader();
 			for (DataRecord dataRecord : dataRecords) {
 				size += writeRecord(dataRecord);
 			}
@@ -292,11 +351,15 @@
 	}
 	
 	private void analyzeRows(List<DataRecord> dataRecords, boolean header) {
-		int lenght;
+		int lenght = 0;
 		int max = 0;
 		for (DataRecord dataRecord : dataRecords) {
 			for (int i=0; i<maskAnalize.length; i++) {
-				lenght = dataRecord.getField(maskAnalize[i].index).getValue().toString().length(); //getSizeSerialized()
+				try {
+					lenght = new String(dataRecord.getField(maskAnalize[i].index).getValue().toString().getBytes(encoder.charset().displayName())).length(); // encoding
+				} catch (UnsupportedEncodingException e) {
+					e.printStackTrace();
+				}
 				maskAnalize[i].length = maskAnalize[i].length < lenght ? lenght : maskAnalize[i].length;
 			}
 		}
@@ -319,8 +382,8 @@
 		StringBuilder sb = new StringBuilder();
 		StringBuilder sb2 = new StringBuilder();
 		for (int i = 0; i < max; i++) {
-			sb.append(' ');
-			sb2.append('-');
+			sb.append(TABLE_BLANK);
+			sb2.append(TABLE_HORIZONTAL);
 		}
 		blank = CharBuffer.wrap(sb.toString());
 		horizontal = CharBuffer.wrap(sb2.toString());
@@ -331,8 +394,9 @@
 	 */
 	public void flush() throws IOException {
 		if (dataRecords != null) {
-			analyzeRows(dataRecords, header);
-			leftBytes = header ? writeHeader() : 0;
+			analyzeRows(dataRecords, setOutputFieldNames);
+			ByteBufferUtils.flush(dataBuffer,writer);
+			leftBytes = writeHeader();
 			for (DataRecord dataRecord : dataRecords) {
 				leftBytes += writeRecord(dataRecord);
 			}
@@ -341,12 +405,6 @@
 		ByteBufferUtils.flush(dataBuffer,writer);
 	}
 	
-	public void eof() throws IOException {
-		flush();
-		leftBytes += writeFooter();
-		directFlush();
-	}
-	
 	private void directFlush() throws IOException {
 		ByteBufferUtils.flush(dataBuffer,writer);
 	}
@@ -367,10 +425,31 @@
 		return(this.charSet);
 	}
 
-	public void setHeader(boolean header) {
-		this.header = header;
+	public void setOutputFieldNames(boolean setOutputFieldNames) {
+		this.setOutputFieldNames = setOutputFieldNames;
 	}
 	
+	private boolean isMaskAnalized() {
+		for (DataFieldParams params: maskAnalize) {
+			if (params.length > 0) {
+				return true;
+			}
+		}
+		return false;
+	}
+	
+	public void showCounter(String header, String prefix) {
+		this.showCounter = true;
+		this.header = header.getBytes();
+		this.prefix = prefix.getBytes();
+		//int iMax = Integer.toString(Integer.MAX_VALUE).length();
+		int iHeader = header.length();
+		int iPrefix = prefix.length();
+		counterLenght = iHeader > iPrefix + 5 ? iHeader : iPrefix + 5;
+		prefixOffset = counterLenght + this.prefix.length - prefix.length();
+		headerOffset = counterLenght + this.header.length - header.length();
+	}
+	
 	/**
 	 * Private class for storing data field name, its andex and lenght in mask
 	 */

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/XLSDataFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/XLSDataFormatter.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/XLSDataFormatter.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -82,6 +82,7 @@
         }catch(IOException ex){
             throw new RuntimeException(ex);
         }
+        prepareSheet();
     }
     
     /* (non-Javadoc)
@@ -186,10 +187,6 @@
 	 * @see org.jetel.data.formatter.Formatter#write(org.jetel.data.DataRecord)
 	 */
 	public int write(DataRecord record) throws IOException {
-		if (!savedNames){
-			saveNames();
-			return 0;
-		}
 		row = sheet.createRow(recCounter);
 		char metaType;//metadata field type
 		Object value;//field value
@@ -238,7 +235,18 @@
 	 */
 	public void flush() throws IOException {
 		// TODO Auto-generated method stub
+	}
 
+	public int writeFooter() throws IOException {
+		// TODO Auto-generated method stub
+		return 0;
 	}
 
+	public int writeHeader() throws IOException {
+		if (!savedNames){
+			saveNames();
+		}
+		return 0;
+	}
+
 }

Modified: trunk/cloveretl.engine/src/org/jetel/util/MultiFileWriter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/MultiFileWriter.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.engine/src/org/jetel/util/MultiFileWriter.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -19,11 +19,10 @@
 */
 package org.jetel.util;
 
+import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
 import java.net.URL;
-import java.nio.ByteBuffer;
 import java.nio.channels.WritableByteChannel;
 import java.util.Iterator;
 
@@ -58,14 +57,11 @@
     private Formatter formatter;
     private URL contextURL;
     private String fileURL;
-    private String charset;
     private int recordsPerFile;
     private int bytesPerFile;
     private int records;
     private int bytes;
     private boolean appendData;
-    private ByteBuffer header;
-    private ByteBuffer footer;
     private Iterator<String> fileNames;
     private Iterator<WritableByteChannel> channels;
     private WritableByteChannel byteChannel;
@@ -118,32 +114,29 @@
     	if (channels != null && !channels.hasNext()) {
             logger.warn("Unable to open new output stream. Size of last output stream will exceed specified limit.");
             return;
-        }      	
+        }
 
         //write footer to the previous destination if it is not first call of this method
         if(byteChannel != null) {
-            writeFooter();
+        	formatter.writeFooter();
         }
-        byteChannel = fileNames != null ? FileUtils.getWritableChannel(contextURL, fileNames.next(), appendData) : channels.next();
+        if (fileNames != null) {
+            String fName = fileNames.next();
+        	byteChannel = FileUtils.getWritableChannel(contextURL, fName, appendData);
+        	// FIXME this is unreachable code
+        	try {
+                formatter.setDataTarget(byteChannel);
+        	} catch (Exception e) {
+                formatter.setDataTarget(new File(fName));
+        	}
+        } else {
+        	byteChannel = channels.next();
+            formatter.setDataTarget(byteChannel);
+        }
         //write header
-        writeHeader();
-        formatter.setDataTarget(byteChannel);
+        formatter.writeHeader();
     }
 
-    private void writeHeader() throws IOException {
-        if(header != null) {
-            byteChannel.write(header);
-            header.rewind();
-        }
-    }
-    
-    private void writeFooter() throws IOException {
-        if(footer != null) {
-            byteChannel.write(footer);
-            footer.rewind();
-        }
-    }
-    
     /**
      * Writes given record via formatter into destination file(s).
      * @param record
@@ -176,6 +169,11 @@
      * Closes underlying formatter.
      */
     public void close() {
+    	try {
+			formatter.writeFooter();
+		} catch (IOException e) {
+			logger.error(e);
+		}
         formatter.close();
     }
     
@@ -203,36 +201,6 @@
         this.appendData = appendData;
     }
 
-    public void setFooter(String footer) {
-        if(charset != null) {
-            try {
-                this.footer = ByteBuffer.wrap(footer.getBytes(charset));
-                return;
-            } catch (UnsupportedEncodingException e) {
-                logger.warn(e);
-                charset = null;
-            }
-        }
-        this.footer = ByteBuffer.wrap(footer.getBytes());
-    }
-
-    public void setHeader(String header) {
-        if(charset != null) {
-            try {
-                this.header = ByteBuffer.wrap(header.getBytes(charset));
-                return;
-            } catch (UnsupportedEncodingException e) {
-                logger.warn(e);
-                charset = null;
-            }
-        }
-        this.header = ByteBuffer.wrap(header.getBytes());
-    }
-
-    public void setCharset(String charset) {
-        this.charset = charset;
-    }
-
     /**
      * Sets number of skipped records in next call of getNext() method.
      * @param skip

Modified: trunk/cloveretl.engine/src/org/jetel/util/WritableByteChannelIterator.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/WritableByteChannelIterator.java	2007-02-27 09:24:24 UTC (rev 2511)
+++ trunk/cloveretl.engine/src/org/jetel/util/WritableByteChannelIterator.java	2007-02-27 09:31:10 UTC (rev 2512)
@@ -4,24 +4,30 @@
 import java.util.Iterator;
 
 /**
- * Channel iterator class.
+ * Channel iterator class. Returns channel for first call, then null. 
  * It is used in MultiFileWriter.
  * 
  * @author ausperger
  */
 public class WritableByteChannelIterator implements Iterator<WritableByteChannel> {
 	private WritableByteChannel writableByteChannel;
+	private boolean hasNext = true;
 	
 	public WritableByteChannelIterator(WritableByteChannel writableByteChannel) {
 		this.writableByteChannel = writableByteChannel;
 	}
 	
 	public boolean hasNext() {
-		return true;
+		return hasNext;
 	}
 
 	public WritableByteChannel next() {
-		return writableByteChannel;
+		if(hasNext) {
+			hasNext = false;
+			return writableByteChannel;
+		} else { 
+			return null;
+		}
 	}
 
 	public void remove() {}



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 12:02:26 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 12:02:26 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2513 -
	trunk/cloveretl.engine/src/org/jetel/data/formatter
Message-ID: <200702271102.l1RB2QKG002065@sheep.berlios.de>

Author: jausperger
Date: 2007-02-27 12:02:25 +0100 (Tue, 27 Feb 2007)
New Revision: 2513

Modified:
   trunk/cloveretl.engine/src/org/jetel/data/formatter/CloverDataFormatter.java
Log:
UPDATE: setHeader/Footer is empty now

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/CloverDataFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/CloverDataFormatter.java	2007-02-27 09:31:10 UTC (rev 2512)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/CloverDataFormatter.java	2007-02-27 11:02:25 UTC (rev 2513)
@@ -77,8 +77,6 @@
 	private ReadableByteChannel idxReader;
 	private boolean append;
 	private boolean isOpen = false;
-	private ByteBuffer footer; 
-	private ByteBuffer header; 
 	
 	private final static short LEN_SIZE_SPECIFIER = 4;
 	private final static int SHORT_SIZE_BYTES = 2;
@@ -289,29 +287,11 @@
 	}
 
 	public int writeFooter() throws IOException {
-		if (footer != null) {
-			buffer.put(footer);
-			footer.rewind();
-			return footer.remaining();
-		} else
-			return 0;
+		return 0;
 	}
 
 	public int writeHeader() throws IOException {
-		if (header != null) {
-			buffer.put(header);
-			header.rewind();
-			return header.remaining();
-		} else 
-			return 0;
+		return 0;
 	}
 
-    public void setFooter(String footer) {
-		this.footer = ByteBuffer.wrap(footer.getBytes());
-    }
-
-    public void setHeader(String header) {
-    	this.header = ByteBuffer.wrap(header.getBytes());
-    }
-
 }



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 15:12:49 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 15:12:49 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2514 -
	trunk/cloveretl.component/src/org/jetel/component
Message-ID: <200702271412.l1RECn5w007457@sheep.berlios.de>

Author: agad
Date: 2007-02-27 15:12:46 +0100 (Tue, 27 Feb 2007)
New Revision: 2514

Modified:
   trunk/cloveretl.component/src/org/jetel/component/XLSReader.java
Log:
UPDATE:NumberIterator can now handle negative numbers too

Modified: trunk/cloveretl.component/src/org/jetel/component/XLSReader.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/XLSReader.java	2007-02-27 11:02:25 UTC (rev 2513)
+++ trunk/cloveretl.component/src/org/jetel/component/XLSReader.java	2007-02-27 14:12:46 UTC (rev 2514)
@@ -255,7 +255,7 @@
 
         try {//check sheetNumber parameter
 			if (sheetNumber != null) {
-				Iterator<Integer> number = new NumberIterator(sheetNumber);
+				Iterator<Integer> number = new NumberIterator(sheetNumber,0,Integer.MAX_VALUE);
 				number.hasNext();
 			}            
 	        try{//sheet number OK, check file name



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 15:16:02 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 15:16:02 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2515 -
	trunk/cloveretl.engine/src/org/jetel/data/parser
Message-ID: <200702271416.l1REG2ds007889@sheep.berlios.de>

Author: agad
Date: 2007-02-27 15:15:59 +0100 (Tue, 27 Feb 2007)
New Revision: 2515

Modified:
   trunk/cloveretl.engine/src/org/jetel/data/parser/JExcelXLSDataParser.java
   trunk/cloveretl.engine/src/org/jetel/data/parser/XLSDataParser.java
Log:
UPDATE:NumberIterator can now handle negative numbers too

Modified: trunk/cloveretl.engine/src/org/jetel/data/parser/JExcelXLSDataParser.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/parser/JExcelXLSDataParser.java	2007-02-27 14:12:46 UTC (rev 2514)
+++ trunk/cloveretl.engine/src/org/jetel/data/parser/JExcelXLSDataParser.java	2007-02-27 14:15:59 UTC (rev 2515)
@@ -247,7 +247,7 @@
          currentRow = firstRow;
          sheetCounter = -1;
          if (sheetNumber != null){
-        	 sheetNumberIterator = new NumberIterator(sheetNumber);
+        	 sheetNumberIterator = new NumberIterator(sheetNumber,0,Integer.MAX_VALUE);
          }
         if (!getNextSheet()) {
         	throw new ComponentNotReadyException("There is no sheet conforming sheet name nor sheet number pattern");

Modified: trunk/cloveretl.engine/src/org/jetel/data/parser/XLSDataParser.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/parser/XLSDataParser.java	2007-02-27 14:12:46 UTC (rev 2514)
+++ trunk/cloveretl.engine/src/org/jetel/data/parser/XLSDataParser.java	2007-02-27 14:15:59 UTC (rev 2515)
@@ -188,7 +188,7 @@
         format = wb.createDataFormat();
          sheetCounter = -1;
          if (sheetNumber != null){
-        	 sheetNumberIterator = new NumberIterator(sheetNumber);
+        	 sheetNumberIterator = new NumberIterator(sheetNumber,0,Integer.MAX_VALUE);
          }
         if (!getNextSheet()) {
         	throw new ComponentNotReadyException("There is no sheet conforming sheet name nor sheet number pattern");



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 15:17:19 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 15:17:19 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2516 -
	trunk/cloveretl.engine/src/org/jetel/util
Message-ID: <200702271417.l1REHJvL008161@sheep.berlios.de>

Author: agad
Date: 2007-02-27 15:17:15 +0100 (Tue, 27 Feb 2007)
New Revision: 2516

Modified:
   trunk/cloveretl.engine/src/org/jetel/util/NumberIterator.java
Log:
UPDATE:NumberIterator can now handle negative numbers too

Modified: trunk/cloveretl.engine/src/org/jetel/util/NumberIterator.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/NumberIterator.java	2007-02-27 14:15:59 UTC (rev 2515)
+++ trunk/cloveretl.engine/src/org/jetel/util/NumberIterator.java	2007-02-27 14:17:15 UTC (rev 2516)
@@ -1,7 +1,7 @@
 package org.jetel.util;
 
 import java.util.Iterator;
-import java.util.regex.Pattern;
+import java.util.NoSuchElementException;
 
 
 /**
@@ -23,41 +23,46 @@
  */
 public class NumberIterator implements Iterator<Integer>{
 	
-	private final static int FIRST_ELEMENT = 0;
-
 	private String pattern;
 	private String subPattern;
 	private int index = 0;
 	private int comaIndex;
-	private int next = FIRST_ELEMENT;
-	private PositiveIntervalIterator intervalIterator = null;
+	private int last;
+	private int first;
+	private IntervalIterator intervalIterator = null;
+	private Integer next = null;
+	private Integer tmp;
 	
 	/**
 	 * Constructor from given mask
 	 * 
 	 * @param pattern
 	 */
-	public NumberIterator(String pattern){
+	public NumberIterator(String pattern, int first,int last){
+		this.first = first;
+		this.last = last;
 		this.pattern = pattern.trim();
 		if (pattern.equals("*")) {
 			subPattern = pattern;
 		}
+		next = getNext();
 	}
 	
-	/* (non-Javadoc)
-	 * @see java.util.Iterator#hasNext()
-	 */
-	public boolean hasNext() {
+	public NumberIterator(String pattern){
+		this(pattern, IntervalIterator.FIRST_ELEMENT, IntervalIterator.LAST_ELEMENT);
+	}
+	
+	private Integer getNext(){
 		if (pattern.equals("*")) {
-			return true;
+			return next < last ? next++ : null;
 		}		
 		//check if in current interval there is more numbers
 		if (intervalIterator != null && intervalIterator.hasNext() ) {
-			return true;
+			return intervalIterator.next();
 		}
 		//get next part of pattern
 		if (index == pattern.length()) {//end of mask
-			return false;
+			return null;
 		}
 		comaIndex = pattern.indexOf(',', index);
 		if (comaIndex == -1) {
@@ -69,26 +74,34 @@
 		}
 		if (StringUtils.isInteger(subPattern)) {
 			intervalIterator = null;
-			return true;
+			return Integer.parseInt(subPattern);
 		}else {
-			intervalIterator = new PositiveIntervalIterator(subPattern);
-			return intervalIterator.hasNext();
+			intervalIterator = new IntervalIterator(subPattern,first,last);
+			if (intervalIterator.hasNext()) {
+				return intervalIterator.next();
+			}else{
+				return getNext();
+			}
 		}
 	}
 	
 	/* (non-Javadoc)
+	 * @see java.util.Iterator#hasNext()
+	 */
+	public boolean hasNext() {
+		return next != null;
+	}
+	
+	/* (non-Javadoc)
 	 * @see java.util.Iterator#next()
 	 */
 	public Integer next() {
-		if (intervalIterator != null) {//next from current interval
-			return intervalIterator.next();
-		}else{//subPattern is number or "*"
-			if (StringUtils.isInteger(subPattern)) {
-				return Integer.parseInt(subPattern);
-			}else{
-				return next++;
-			}
+		tmp = new Integer(next);
+		if (next == null) {
+			throw new NoSuchElementException();
 		}
+		next = getNext();
+		return tmp;
 	}
 	
 	public void remove() {
@@ -107,36 +120,51 @@
 	 * @since Feb 23, 2007
 	 *
 	 */
-	private class PositiveIntervalIterator implements Iterator<Integer>{
+	private class IntervalIterator implements Iterator<Integer>{
 		
-		private final static int FIRST_ELEMENT = 0;
+		public final static int FIRST_ELEMENT = Integer.MIN_VALUE;
+		public final static int LAST_ELEMENT = Integer.MAX_VALUE;
 		
+		private final static char DASH = '-';
+		
 		private String firstPattern;
 		private String lastPattern;
-		private int next = FIRST_ELEMENT;
-		private int last = FIRST_ELEMENT - 1;
+		private int next;
+		private Integer last;
 		
 		/**
 		 * Constructor from given pattern
 		 * 
 		 * @param pattern
 		 */
-		PositiveIntervalIterator(String pattern) {
-			if (!Pattern.matches("[0-9]*-[0-9]*|[0-9]*-\\*|\\*-[0-9]*", pattern)){
-				throw new IllegalArgumentException("Not positive integer interval: " + pattern);
+		IntervalIterator(String pattern) {
+			this(pattern,FIRST_ELEMENT,LAST_ELEMENT);
+		}
+		
+		IntervalIterator(String pattern, int first, int last) {
+			next = first;
+			this.last = last;
+			int dashIndex= pattern.trim().indexOf(DASH);
+			if (dashIndex == -1) {
+				throw new IllegalArgumentException("Not integer interval: " + pattern);
+			}else if (dashIndex == 0) {
+				dashIndex = pattern.indexOf(DASH, 1);
+				if (dashIndex == -1) {
+					throw new IllegalArgumentException("Not integer interval: " + pattern);
+				}
 			}
-			firstPattern = pattern.substring(0,pattern.indexOf('-')).trim();
-			lastPattern = pattern.substring(pattern.indexOf('-') + 1).trim();
+			firstPattern = pattern.substring(0,dashIndex).trim();
+			lastPattern = pattern.substring(dashIndex + 1).trim();
 			if (!firstPattern.equals("*")) {
 				next = Integer.parseInt(firstPattern);
 			}
 			if (!lastPattern.equals("*")){
-				last = Integer.parseInt(lastPattern);
+				this.last = Integer.parseInt(lastPattern);
 			}
 		}
 		
 		public boolean hasNext() {
-			return (last == FIRST_ELEMENT -1 || next <= last);
+			return (next <= last);
 		}
 
 		public Integer next() {



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 15:18:35 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 15:18:35 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2517 -
	trunk/cloveretl.engine/src/org/jetel/util
Message-ID: <200702271418.l1REIZwd008328@sheep.berlios.de>

Author: agad
Date: 2007-02-27 15:18:33 +0100 (Tue, 27 Feb 2007)
New Revision: 2517

Modified:
   trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java
Log:
FIX:StringUtils method isInteger checks negative numbers too

Modified: trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java	2007-02-27 14:17:15 UTC (rev 2516)
+++ trunk/cloveretl.engine/src/org/jetel/util/StringUtils.java	2007-02-27 14:18:33 UTC (rev 2517)
@@ -588,13 +588,17 @@
     }
     
     /**
-     * This method checks if given string can be integer to number
+     * This method checks if given string can be parse to integer number
      * 
      * @param str string to check
      * @return true if input represents number, false in another case
      */
     public static boolean isInteger(CharSequence str){
-     	for (int i=0;i<str.length();i++) {
+    	int start = 0;
+    	if (str.charAt(start) == '-') {
+    		start = 1;
+    	}
+     	for (int i=start;i<str.length();i++) {
     		if (!Character.isDigit(str.charAt(i))) {
     			return false;
      		}



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 15:21:38 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 15:21:38 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2518 -
	trunk/cloveretl.engine/test/org/jetel/util
Message-ID: <200702271421.l1RELc1W008789@sheep.berlios.de>

Author: agad
Date: 2007-02-27 15:21:35 +0100 (Tue, 27 Feb 2007)
New Revision: 2518

Added:
   trunk/cloveretl.engine/test/org/jetel/util/NumberIteratorTest.java
Log:
UPDATE:NumberIterator can now handle negative numbers too

Added: trunk/cloveretl.engine/test/org/jetel/util/NumberIteratorTest.java
===================================================================
--- trunk/cloveretl.engine/test/org/jetel/util/NumberIteratorTest.java	2007-02-27 14:18:33 UTC (rev 2517)
+++ trunk/cloveretl.engine/test/org/jetel/util/NumberIteratorTest.java	2007-02-27 14:21:35 UTC (rev 2518)
@@ -0,0 +1,33 @@
+package org.jetel.util;
+
+import junit.framework.TestCase;
+
+public class NumberIteratorTest extends TestCase {
+	
+	NumberIterator numbers;
+	
+	@Override
+	protected void setUp() throws Exception {
+		super.setUp();
+    	numbers = new NumberIterator("*--9,-7--5,-3,-1,1-3,5,7,9-*",-10,10);
+	}
+	
+	
+    public void test_1(){
+    	while (numbers.hasNext()){
+    		System.out.print(numbers.next() + ",");
+    	}
+     }
+
+    public void test_2(){
+    	for (int i=0;i<14;i++){
+    		System.out.print(numbers.next() + ",");
+    	}
+     }
+
+    @Override
+    protected void tearDown() throws Exception {
+    	super.tearDown();
+    	System.out.println();
+    }
+}



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 16:16:54 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 16:16:54 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2519 -
	trunk/cloveretl.engine/src/org/jetel/data/parser
Message-ID: <200702271516.l1RFGstW015940@sheep.berlios.de>

Author: otasanek
Date: 2007-02-27 16:16:53 +0100 (Tue, 27 Feb 2007)
New Revision: 2519

Modified:
   trunk/cloveretl.engine/src/org/jetel/data/parser/AhoCorasick.java
Log:
FIX: Char in AhoCorasick algorithm has 65356 values.

Modified: trunk/cloveretl.engine/src/org/jetel/data/parser/AhoCorasick.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/parser/AhoCorasick.java	2007-02-27 14:21:35 UTC (rev 2518)
+++ trunk/cloveretl.engine/src/org/jetel/data/parser/AhoCorasick.java	2007-02-27 15:16:53 UTC (rev 2519)
@@ -190,7 +190,7 @@
 		 * @param transition transition char from parent
 		 */
 		public NodeTrie(NodeTrie parent, char transition) {
-			children = new NodeTrie[256];
+			children = new NodeTrie[65536];
 			patterns = new HashSet();
 			this.parent = parent;
 			this.transition = transition;



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 16:38:45 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 16:38:45 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2520 - in trunk:
	cloveretl.component/src/org/jetel/component
	cloveretl.engine/src/org/jetel/data/formatter
Message-ID: <200702271538.l1RFcjjD019346@sheep.berlios.de>

Author: jausperger
Date: 2007-02-27 16:38:42 +0100 (Tue, 27 Feb 2007)
New Revision: 2520

Modified:
   trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java
   trunk/cloveretl.component/src/org/jetel/component/Trash.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/DataFormatter.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/DelimitedDataFormatter.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/FixLenDataFormatter.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/StructureFormatter.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/TextTableFormatter.java
Log:
FIX: header/footer encoding

Modified: trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-27 15:16:53 UTC (rev 2519)
+++ trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-27 15:38:42 UTC (rev 2520)
@@ -19,6 +19,7 @@
 */
 
 package org.jetel.component;
+import java.io.UnsupportedEncodingException;
 import java.nio.channels.Channels;
 import java.nio.channels.WritableByteChannel;
 
@@ -179,7 +180,11 @@
         writer.setSkip(skip);
         writer.setNumRecords(numRecords);
         if(outputFieldNames) {
-        	formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
+        	try {
+				formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
+			} catch (UnsupportedEncodingException e) {
+				logger.error(e);
+			}
         }
         writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}

Modified: trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-27 15:16:53 UTC (rev 2519)
+++ trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-27 15:38:42 UTC (rev 2520)
@@ -19,6 +19,7 @@
 */
 
 package org.jetel.component;
+import java.io.UnsupportedEncodingException;
 import java.nio.channels.Channels;
 import java.nio.channels.WritableByteChannel;
 
@@ -198,7 +199,11 @@
         writer.setSkip(skip);
         writer.setNumRecords(numRecords);
         if(outputFieldNames) {
-        	formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
+        	try {
+				formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
+			} catch (UnsupportedEncodingException e) {
+				logger.error(e);
+			}
         }
         writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}

Modified: trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-27 15:16:53 UTC (rev 2519)
+++ trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-27 15:38:42 UTC (rev 2520)
@@ -18,6 +18,7 @@
 *
 */
 package org.jetel.component;
+import java.io.UnsupportedEncodingException;
 import java.nio.channels.Channels;
 import java.nio.channels.WritableByteChannel;
 
@@ -188,7 +189,11 @@
         writer.setSkip(skip);
         writer.setNumRecords(numRecords);
         if(outputFieldNames) {
-        	formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
+        	try {
+				formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
+			} catch (UnsupportedEncodingException e) {
+				logger.error(e);
+			}
         }
         writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}

Modified: trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-27 15:16:53 UTC (rev 2519)
+++ trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-27 15:38:42 UTC (rev 2520)
@@ -21,6 +21,7 @@
 
 package org.jetel.component;
 
+import java.io.UnsupportedEncodingException;
 import java.nio.channels.Channels;
 import java.nio.channels.WritableByteChannel;
 
@@ -232,8 +233,12 @@
         writer.setAppendData(appendData);
         writer.setSkip(skip);
         writer.setNumRecords(numRecords);
-        formatter.setHeader(header);
-        formatter.setFooter(footer);
+        try {
+			formatter.setHeader(header);
+	        formatter.setFooter(footer);
+		} catch (UnsupportedEncodingException e) {
+			logger.error(e);
+		}
         writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}
 

Modified: trunk/cloveretl.component/src/org/jetel/component/Trash.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/Trash.java	2007-02-27 15:16:53 UTC (rev 2519)
+++ trunk/cloveretl.component/src/org/jetel/component/Trash.java	2007-02-27 15:38:42 UTC (rev 2520)
@@ -20,9 +20,12 @@
 package org.jetel.component;
 
 import java.io.IOException;
+import java.io.UnsupportedEncodingException;
 import java.nio.channels.Channels;
 import java.nio.channels.WritableByteChannel;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.jetel.data.DataRecord;
 import org.jetel.data.Defaults;
 import org.jetel.data.formatter.TextTableFormatter;
@@ -94,6 +97,8 @@
 	private MultiFileWriter writer;
 	private WritableByteChannel writableByteChannel;
 
+	private static Log logger = LogFactory.getLog(Trash.class);
+
 	/**
 	 *Constructor for the Trash object
 	 *
@@ -179,7 +184,11 @@
     			}
             }
             if (writer != null) {
-            	formatter.showCounter("Record", "### ");
+            	try {
+					formatter.showCounter("Record", "### ");
+				} catch (UnsupportedEncodingException e) {
+					logger.error(e);
+				}
                 writer.init(getInputPort(READ_FROM_PORT).getMetadata());
             }
 		}

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/DataFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/DataFormatter.java	2007-02-27 15:16:53 UTC (rev 2519)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/DataFormatter.java	2007-02-27 15:38:42 UTC (rev 2520)
@@ -23,6 +23,7 @@
 package org.jetel.data.formatter;
 import java.io.IOException;
 import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.channels.Channels;
@@ -35,6 +36,8 @@
 import org.jetel.data.Defaults;
 import org.jetel.metadata.DataRecordMetadata;
 
+import sun.util.logging.resources.logging;
+
 /**
  * Outputs common data record. Handles encoding of characters. Uses WriteableChannel.
  *
@@ -247,12 +250,12 @@
 			return 0;
 	}
 
-    public void setFooter(String footer) {
-    	this.footer = ByteBuffer.wrap(footer.getBytes());
+    public void setFooter(String footer) throws UnsupportedEncodingException {
+		this.footer = ByteBuffer.wrap(footer.getBytes(encoder.charset().name()));
     }
 
-    public void setHeader(String header) {
-    	this.header = ByteBuffer.wrap(header.getBytes());
+    public void setHeader(String header) throws UnsupportedEncodingException {
+    	this.header = ByteBuffer.wrap(header.getBytes(encoder.charset().name()));
     }
 
 }

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/DelimitedDataFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/DelimitedDataFormatter.java	2007-02-27 15:16:53 UTC (rev 2519)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/DelimitedDataFormatter.java	2007-02-27 15:38:42 UTC (rev 2520)
@@ -23,6 +23,7 @@
 package org.jetel.data.formatter;
 import java.io.IOException;
 import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.channels.Channels;
@@ -281,12 +282,12 @@
 			return 0;
 	}
 
-    public void setFooter(String footer) {
-    	this.footer = ByteBuffer.wrap(footer.getBytes());
+    public void setFooter(String footer) throws UnsupportedEncodingException {
+    	this.footer = ByteBuffer.wrap(footer.getBytes(encoder.charset().name()));
     }
 
-    public void setHeader(String header) {
-    	this.header = ByteBuffer.wrap(header.getBytes());
+    public void setHeader(String header) throws UnsupportedEncodingException {
+		this.header = ByteBuffer.wrap(header.getBytes(encoder.charset().name()));
     }
 	
 }

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/FixLenDataFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/FixLenDataFormatter.java	2007-02-27 15:16:53 UTC (rev 2519)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/FixLenDataFormatter.java	2007-02-27 15:38:42 UTC (rev 2520)
@@ -371,12 +371,12 @@
 			return 0;
 	}
 
-    public void setFooter(String footer) {
-    	this.footer = ByteBuffer.wrap(footer.getBytes());
+    public void setFooter(String footer) throws UnsupportedEncodingException {
+    	this.footer = ByteBuffer.wrap(footer.getBytes(encoder.charset().name()));
     }
 
-    public void setHeader(String header) {
-    	this.header = ByteBuffer.wrap(header.getBytes());
+    public void setHeader(String header) throws UnsupportedEncodingException {
+    	this.header = ByteBuffer.wrap(header.getBytes(encoder.charset().name()));
     }
 
 }

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/StructureFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/StructureFormatter.java	2007-02-27 15:16:53 UTC (rev 2519)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/StructureFormatter.java	2007-02-27 15:38:42 UTC (rev 2520)
@@ -261,12 +261,12 @@
 			return 0;
 	}
 
-    public void setFooter(String footer) {
-    	this.footer = ByteBuffer.wrap(footer.getBytes());
+    public void setFooter(String footer) throws UnsupportedEncodingException {
+    	this.footer = ByteBuffer.wrap(footer.getBytes(encoder.charset().name()));
     }
 
-    public void setHeader(String header) {
-    	this.header = ByteBuffer.wrap(header.getBytes());
+    public void setHeader(String header) throws UnsupportedEncodingException {
+    	this.header = ByteBuffer.wrap(header.getBytes(encoder.charset().name()));
     }
 
 	

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/TextTableFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/TextTableFormatter.java	2007-02-27 15:16:53 UTC (rev 2519)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/TextTableFormatter.java	2007-02-27 15:38:42 UTC (rev 2520)
@@ -438,10 +438,10 @@
 		return false;
 	}
 	
-	public void showCounter(String header, String prefix) {
+	public void showCounter(String header, String prefix) throws UnsupportedEncodingException {
 		this.showCounter = true;
-		this.header = header.getBytes();
-		this.prefix = prefix.getBytes();
+		this.header = header.getBytes(encoder.charset().name());
+		this.prefix = prefix.getBytes(encoder.charset().name());
 		//int iMax = Integer.toString(Integer.MAX_VALUE).length();
 		int iHeader = header.length();
 		int iPrefix = prefix.length();



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 17:41:24 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 17:41:24 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2521 - in trunk:
	cloveretl.component/src/org/jetel/component
	cloveretl.engine/src/org/jetel/data/formatter
Message-ID: <200702271641.l1RGfOs9027459@sheep.berlios.de>

Author: jausperger
Date: 2007-02-27 17:41:20 +0100 (Tue, 27 Feb 2007)
New Revision: 2521

Modified:
   trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java
   trunk/cloveretl.component/src/org/jetel/component/Trash.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/DataFormatter.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/DelimitedDataFormatter.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/FixLenDataFormatter.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/StructureFormatter.java
   trunk/cloveretl.engine/src/org/jetel/data/formatter/TextTableFormatter.java
Log:
FIX: encoding exception and move encoder from constructor to init

Modified: trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-27 15:38:42 UTC (rev 2520)
+++ trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-27 16:41:20 UTC (rev 2521)
@@ -19,7 +19,6 @@
 */
 
 package org.jetel.component;
-import java.io.UnsupportedEncodingException;
 import java.nio.channels.Channels;
 import java.nio.channels.WritableByteChannel;
 
@@ -180,11 +179,7 @@
         writer.setSkip(skip);
         writer.setNumRecords(numRecords);
         if(outputFieldNames) {
-        	try {
-				formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
-			} catch (UnsupportedEncodingException e) {
-				logger.error(e);
-			}
+			formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
         }
         writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}

Modified: trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-27 15:38:42 UTC (rev 2520)
+++ trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-27 16:41:20 UTC (rev 2521)
@@ -19,7 +19,6 @@
 */
 
 package org.jetel.component;
-import java.io.UnsupportedEncodingException;
 import java.nio.channels.Channels;
 import java.nio.channels.WritableByteChannel;
 
@@ -199,11 +198,7 @@
         writer.setSkip(skip);
         writer.setNumRecords(numRecords);
         if(outputFieldNames) {
-        	try {
-				formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
-			} catch (UnsupportedEncodingException e) {
-				logger.error(e);
-			}
+			formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
         }
         writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}

Modified: trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-27 15:38:42 UTC (rev 2520)
+++ trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-27 16:41:20 UTC (rev 2521)
@@ -18,7 +18,6 @@
 *
 */
 package org.jetel.component;
-import java.io.UnsupportedEncodingException;
 import java.nio.channels.Channels;
 import java.nio.channels.WritableByteChannel;
 
@@ -189,11 +188,7 @@
         writer.setSkip(skip);
         writer.setNumRecords(numRecords);
         if(outputFieldNames) {
-        	try {
-				formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
-			} catch (UnsupportedEncodingException e) {
-				logger.error(e);
-			}
+        	formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
         }
         writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}

Modified: trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-27 15:38:42 UTC (rev 2520)
+++ trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-27 16:41:20 UTC (rev 2521)
@@ -21,7 +21,6 @@
 
 package org.jetel.component;
 
-import java.io.UnsupportedEncodingException;
 import java.nio.channels.Channels;
 import java.nio.channels.WritableByteChannel;
 
@@ -233,12 +232,8 @@
         writer.setAppendData(appendData);
         writer.setSkip(skip);
         writer.setNumRecords(numRecords);
-        try {
-			formatter.setHeader(header);
-	        formatter.setFooter(footer);
-		} catch (UnsupportedEncodingException e) {
-			logger.error(e);
-		}
+        formatter.setHeader(header);
+        formatter.setFooter(footer);
         writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}
 

Modified: trunk/cloveretl.component/src/org/jetel/component/Trash.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/Trash.java	2007-02-27 15:38:42 UTC (rev 2520)
+++ trunk/cloveretl.component/src/org/jetel/component/Trash.java	2007-02-27 16:41:20 UTC (rev 2521)
@@ -20,12 +20,9 @@
 package org.jetel.component;
 
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
 import java.nio.channels.Channels;
 import java.nio.channels.WritableByteChannel;
 
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
 import org.jetel.data.DataRecord;
 import org.jetel.data.Defaults;
 import org.jetel.data.formatter.TextTableFormatter;
@@ -97,8 +94,6 @@
 	private MultiFileWriter writer;
 	private WritableByteChannel writableByteChannel;
 
-	private static Log logger = LogFactory.getLog(Trash.class);
-
 	/**
 	 *Constructor for the Trash object
 	 *
@@ -184,11 +179,7 @@
     			}
             }
             if (writer != null) {
-            	try {
-					formatter.showCounter("Record", "### ");
-				} catch (UnsupportedEncodingException e) {
-					logger.error(e);
-				}
+            	formatter.showCounter("Record", "### ");
                 writer.init(getInputPort(READ_FROM_PORT).getMetadata());
             }
 		}

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/DataFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/DataFormatter.java	2007-02-27 15:38:42 UTC (rev 2520)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/DataFormatter.java	2007-02-27 16:41:20 UTC (rev 2521)
@@ -30,14 +30,13 @@
 import java.nio.channels.WritableByteChannel;
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetEncoder;
+import java.nio.charset.UnsupportedCharsetException;
 import java.util.Arrays;
 
 import org.jetel.data.DataRecord;
 import org.jetel.data.Defaults;
 import org.jetel.metadata.DataRecordMetadata;
 
-import sun.util.logging.resources.logging;
-
 /**
  * Outputs common data record. Handles encoding of characters. Uses WriteableChannel.
  *
@@ -71,9 +70,7 @@
 	public DataFormatter(){
 		dataBuffer = ByteBuffer.allocateDirect(Defaults.DEFAULT_INTERNAL_IO_BUFFER_SIZE);
 		fieldBuffer = ByteBuffer.allocateDirect(Defaults.DataFormatter.FIELD_BUFFER_LENGTH);
-		encoder = Charset.forName(Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER).newEncoder();
-		initFieldFiller();
-		encoder.reset();
+		charSet = Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER;
 		metadata = null;
 	}
 	
@@ -81,9 +78,6 @@
 		dataBuffer = ByteBuffer.allocateDirect(Defaults.DEFAULT_INTERNAL_IO_BUFFER_SIZE);
 		fieldBuffer = ByteBuffer.allocateDirect(Defaults.DataFormatter.FIELD_BUFFER_LENGTH);
 		charSet = charEncoder;
-		encoder = Charset.forName(charEncoder).newEncoder();
-		initFieldFiller();
-		encoder.reset();
 		metadata = null;
 	}
 	
@@ -94,6 +88,9 @@
 		// create array of delimiters & initialize them
 		// create array of field sizes & initialize them
 		metadata = _metadata;
+		encoder = Charset.forName(charSet).newEncoder();
+		initFieldFiller();
+		encoder.reset();
 		delimiters = new byte[metadata.getNumFields()][];
         delimiterLength = new int[metadata.getNumFields()];
 		fieldLengths = new int[metadata.getNumFields()];
@@ -250,12 +247,20 @@
 			return 0;
 	}
 
-    public void setFooter(String footer) throws UnsupportedEncodingException {
-		this.footer = ByteBuffer.wrap(footer.getBytes(encoder.charset().name()));
+    public void setFooter(String footer) {
+		try {
+			this.footer = ByteBuffer.wrap(footer.getBytes(encoder.charset().name()));
+		} catch (UnsupportedEncodingException e) {
+			throw new UnsupportedCharsetException(encoder.charset().name());
+		}
     }
 
-    public void setHeader(String header) throws UnsupportedEncodingException {
-    	this.header = ByteBuffer.wrap(header.getBytes(encoder.charset().name()));
+    public void setHeader(String header) {
+    	try {
+			this.header = ByteBuffer.wrap(header.getBytes(encoder.charset().name()));
+		} catch (UnsupportedEncodingException e) {
+			throw new UnsupportedCharsetException(encoder.charset().name());
+		}
     }
 
 }

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/DelimitedDataFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/DelimitedDataFormatter.java	2007-02-27 15:38:42 UTC (rev 2520)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/DelimitedDataFormatter.java	2007-02-27 16:41:20 UTC (rev 2521)
@@ -31,6 +31,7 @@
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetEncoder;
 import java.nio.charset.CoderResult;
+import java.nio.charset.UnsupportedCharsetException;
 
 import org.jetel.data.DataRecord;
 import org.jetel.data.Defaults;
@@ -72,8 +73,7 @@
 		writer = null;
 		dataBuffer = ByteBuffer.allocateDirect(Defaults.DEFAULT_INTERNAL_IO_BUFFER_SIZE);
 		charBuffer = CharBuffer.allocate(Defaults.DEFAULT_INTERNAL_IO_BUFFER_SIZE);
-		encoder = Charset.forName(Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER).newEncoder();
-		encoder.reset();
+		charSet = Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER;
 		NEW_LINE_STR=System.getProperty(DELIMITER_SYSTEM_PROPERTY_NAME,"\n");
 		metadata = null;
 	}
@@ -83,8 +83,6 @@
 		dataBuffer = ByteBuffer.allocateDirect(Defaults.DEFAULT_INTERNAL_IO_BUFFER_SIZE);
 		charBuffer = CharBuffer.allocate(Defaults.DEFAULT_INTERNAL_IO_BUFFER_SIZE);
 		charSet = charEncoder;
-		encoder = Charset.forName(charEncoder).newEncoder();
-		encoder.reset();
 		NEW_LINE_STR=System.getProperty(DELIMITER_SYSTEM_PROPERTY_NAME,"\n");
 		metadata = null;
 	}
@@ -94,6 +92,8 @@
 	 */
 	public void init(DataRecordMetadata metadata) {
 		this.metadata = metadata;
+		encoder = Charset.forName(charSet).newEncoder();
+		encoder.reset();
 
 		// create array of delimiters & initialize them
 		delimiters = new String[metadata.getNumFields()];
@@ -282,12 +282,20 @@
 			return 0;
 	}
 
-    public void setFooter(String footer) throws UnsupportedEncodingException {
-    	this.footer = ByteBuffer.wrap(footer.getBytes(encoder.charset().name()));
+    public void setFooter(String footer) {
+    	try {
+			this.footer = ByteBuffer.wrap(footer.getBytes(encoder.charset().name()));
+		} catch (UnsupportedEncodingException e) {
+			throw new UnsupportedCharsetException(encoder.charset().name());
+		}
     }
 
-    public void setHeader(String header) throws UnsupportedEncodingException {
-		this.header = ByteBuffer.wrap(header.getBytes(encoder.charset().name()));
+    public void setHeader(String header) {
+		try {
+			this.header = ByteBuffer.wrap(header.getBytes(encoder.charset().name()));
+		} catch (UnsupportedEncodingException e) {
+			throw new UnsupportedCharsetException(encoder.charset().name());
+		}
     }
 	
 }

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/FixLenDataFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/FixLenDataFormatter.java	2007-02-27 15:38:42 UTC (rev 2520)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/FixLenDataFormatter.java	2007-02-27 16:41:20 UTC (rev 2521)
@@ -27,6 +27,7 @@
 import java.nio.channels.WritableByteChannel;
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetEncoder;
+import java.nio.charset.UnsupportedCharsetException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.SortedMap;
@@ -85,10 +86,7 @@
 	public FixLenDataFormatter() {
 		writer = null;
 		dataBuffer = ByteBuffer.allocateDirect(Defaults.DEFAULT_INTERNAL_IO_BUFFER_SIZE);
-		encoder = Charset.forName(Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER ).newEncoder();
-		initFieldFiller(DEFAULT_FIELDFILLER_CHAR);
-		initRecordFiller(DEFAULT_RECORDFILLER_CHAR);
-		encoder.reset();
+		charSet = Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER;
 		metadata = null;
 		recordCounter = 0;
 	}
@@ -104,10 +102,6 @@
 		writer = null;
 		charSet = charEncoder;
 		dataBuffer = ByteBuffer.allocateDirect(Defaults.DEFAULT_INTERNAL_IO_BUFFER_SIZE);
-		encoder = Charset.forName(charEncoder).newEncoder();
-		initFieldFiller(DEFAULT_FIELDFILLER_CHAR);
-		initRecordFiller(DEFAULT_RECORDFILLER_CHAR);
-		encoder.reset();
 		metadata = null;
 		recordCounter = 0;
 	}
@@ -176,6 +170,10 @@
 		// create array of field sizes & initialize them
 		this.metadata = metadata;
         
+		encoder = Charset.forName(charSet).newEncoder();
+		initFieldFiller(DEFAULT_FIELDFILLER_CHAR);
+		initRecordFiller(DEFAULT_RECORDFILLER_CHAR);
+		encoder.reset();
         isRecordDelimiter = metadata.isSpecifiedRecordDelimiter();
         if(isRecordDelimiter) {
             try {
@@ -371,12 +369,20 @@
 			return 0;
 	}
 
-    public void setFooter(String footer) throws UnsupportedEncodingException {
-    	this.footer = ByteBuffer.wrap(footer.getBytes(encoder.charset().name()));
+    public void setFooter(String footer) {
+    	try {
+			this.footer = ByteBuffer.wrap(footer.getBytes(encoder.charset().name()));
+		} catch (UnsupportedEncodingException e) {
+			throw new UnsupportedCharsetException(encoder.charset().name());
+		}
     }
 
-    public void setHeader(String header) throws UnsupportedEncodingException {
-    	this.header = ByteBuffer.wrap(header.getBytes(encoder.charset().name()));
+    public void setHeader(String header) {
+    	try {
+			this.header = ByteBuffer.wrap(header.getBytes(encoder.charset().name()));
+		} catch (UnsupportedEncodingException e) {
+			throw new UnsupportedCharsetException(encoder.charset().name());
+		}
     }
 
 }

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/StructureFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/StructureFormatter.java	2007-02-27 15:38:42 UTC (rev 2520)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/StructureFormatter.java	2007-02-27 16:41:20 UTC (rev 2521)
@@ -27,6 +27,7 @@
 import java.nio.channels.WritableByteChannel;
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetEncoder;
+import java.nio.charset.UnsupportedCharsetException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -71,8 +72,7 @@
 	 * Constructor without parameters
 	 */
 	public StructureFormatter(){
-		encoder = Charset.forName(Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER).newEncoder();
-		encoder.reset();
+		charSet = Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER;
 	}
 	
 	/**
@@ -82,8 +82,6 @@
 	 */
 	public StructureFormatter(String charEncoder){
 		charSet = charEncoder;
-		encoder = Charset.forName(charEncoder).newEncoder();
-		encoder.reset();
 	}
 
 	/* (non-Javadoc)
@@ -92,6 +90,8 @@
 	public void init(DataRecordMetadata _metadata)
 			throws ComponentNotReadyException {
 		this.metadata = _metadata;
+		encoder = Charset.forName(charSet).newEncoder();
+		encoder.reset();
 
 		// create buffered output stream writer and buffers 
 		dataBuffer = ByteBuffer.allocateDirect(Defaults.DEFAULT_INTERNAL_IO_BUFFER_SIZE);
@@ -261,12 +261,20 @@
 			return 0;
 	}
 
-    public void setFooter(String footer) throws UnsupportedEncodingException {
-    	this.footer = ByteBuffer.wrap(footer.getBytes(encoder.charset().name()));
+    public void setFooter(String footer) {
+    	try {
+			this.footer = ByteBuffer.wrap(footer.getBytes(encoder.charset().name()));
+		} catch (UnsupportedEncodingException e) {
+			throw new UnsupportedCharsetException(encoder.charset().name());
+		}
     }
 
-    public void setHeader(String header) throws UnsupportedEncodingException {
-    	this.header = ByteBuffer.wrap(header.getBytes(encoder.charset().name()));
+    public void setHeader(String header) {
+    	try {
+			this.header = ByteBuffer.wrap(header.getBytes(encoder.charset().name()));
+		} catch (UnsupportedEncodingException e) {
+			throw new UnsupportedCharsetException(encoder.charset().name());
+		}
     }
 
 	

Modified: trunk/cloveretl.engine/src/org/jetel/data/formatter/TextTableFormatter.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/formatter/TextTableFormatter.java	2007-02-27 15:38:42 UTC (rev 2520)
+++ trunk/cloveretl.engine/src/org/jetel/data/formatter/TextTableFormatter.java	2007-02-27 16:41:20 UTC (rev 2521)
@@ -28,6 +28,7 @@
 import java.nio.channels.WritableByteChannel;
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetEncoder;
+import java.nio.charset.UnsupportedCharsetException;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
@@ -91,8 +92,7 @@
 	 * Constructor without parameters
 	 */
 	public TextTableFormatter(){
-		encoder = Charset.forName(Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER).newEncoder();
-		encoder.reset();
+		charSet = Defaults.DataFormatter.DEFAULT_CHARSET_ENCODER;
 	}
 	
 	/**
@@ -102,8 +102,6 @@
 	 */
 	public TextTableFormatter(String charEncoder){
 		charSet = charEncoder;
-		encoder = Charset.forName(charEncoder).newEncoder();
-		encoder.reset();
 	}
 
 	/* (non-Javadoc)
@@ -112,6 +110,8 @@
 	public void init(DataRecordMetadata _metadata)
 			throws ComponentNotReadyException {
 		this.metadata = _metadata;
+		encoder = Charset.forName(charSet).newEncoder();
+		encoder.reset();
 
 		// create buffered output stream writer and buffers 
 		dataBuffer = ByteBuffer.allocateDirect(Defaults.DEFAULT_INTERNAL_IO_BUFFER_SIZE);
@@ -241,7 +241,7 @@
         sentBytes += writeString(TABLE_VERTICAL);
         if (showCounter) {
         	sentBytes += writeString(header);
-        	sentBytes += writeString(blank, headerOffset-header.length); // TODO ?
+        	sentBytes += writeString(blank, headerOffset-header.length);
             sentBytes += writeString(TABLE_VERTICAL);
         }
         for (int i=0; i<maskAnalize.length; i++) {
@@ -438,10 +438,14 @@
 		return false;
 	}
 	
-	public void showCounter(String header, String prefix) throws UnsupportedEncodingException {
+	public void showCounter(String header, String prefix) {
 		this.showCounter = true;
-		this.header = header.getBytes(encoder.charset().name());
-		this.prefix = prefix.getBytes(encoder.charset().name());
+		try {
+			this.header = header.getBytes(encoder.charset().name());
+			this.prefix = prefix.getBytes(encoder.charset().name());
+		} catch (UnsupportedEncodingException e) {
+			throw new UnsupportedCharsetException(encoder.charset().name());
+		}
 		//int iMax = Integer.toString(Integer.MAX_VALUE).length();
 		int iHeader = header.length();
 		int iPrefix = prefix.length();



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 17:55:35 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 17:55:35 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2522 -
	trunk/cloveretl.engine/src/org/jetel/data
Message-ID: <200702271655.l1RGtZEr030099@sheep.berlios.de>

Author: dpavlis
Date: 2007-02-27 17:55:33 +0100 (Tue, 27 Feb 2007)
New Revision: 2522

Modified:
   trunk/cloveretl.engine/src/org/jetel/data/Defaults.java
Log:
UPDATE:added getBooleanProperty(), added Record.USE_FIELDS_NULL_INDICATORS option

Modified: trunk/cloveretl.engine/src/org/jetel/data/Defaults.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/Defaults.java	2007-02-27 16:41:20 UTC (rev 2521)
+++ trunk/cloveretl.engine/src/org/jetel/data/Defaults.java	2007-02-27 16:55:33 UTC (rev 2522)
@@ -62,6 +62,10 @@
 		return properties.getProperty(key, def);
 	}
 
+    private static boolean getBooleanProperties(String key, boolean def) {
+        return new Boolean(properties.getProperty(key, Boolean.toString(def))).booleanValue();
+    }
+    
 	public static void init() {
 		initProperties();
 		
@@ -135,6 +139,7 @@
 		public static void init() {
 			MAX_RECORD_SIZE = getIntProperties("Record.MAX_RECORD_SIZE", 8192);
 			DEFAULT_COMPRESSION_LEVEL = getIntProperties("Record.DEFAULT_COMPRESSION_LEVEL", Deflater.DEFAULT_COMPRESSION);
+            USE_FIELDS_NULL_INDICATORS = getBooleanProperties("Record.USE_FIELDS_NULL_INDICATORS",false);
 		}
 		
 		/**
@@ -148,6 +153,18 @@
 		 * Should be set to a value from interval 0-9.
 		 */
 		public static int DEFAULT_COMPRESSION_LEVEL;// = Deflater.DEFAULT_COMPRESSION;
+        
+        /** 
+         *  Switch- shall we handle differently (during serialization) NULLable records (record
+         *  which has at least one field NULLable ?)<br>
+         *  If true then during serialization of record, first is saved
+         *  array of bits (one bit for each field which can be NULLable) and
+         *  bits are set depending of NULL status of the field being serialized.<br>
+         *  This may speed serialization of record contains many fields with
+         *  mostly NULL value assigned.
+         */
+        public static boolean USE_FIELDS_NULL_INDICATORS; // = false;
+        
 	}
 
 	/**
@@ -378,6 +395,7 @@
         public static int DIRECT_EDGE_FAST_PROPAGATE_NUM_INTERNAL_BUFFERS;
 	}
 
+
 }
 
 



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 17:57:44 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 17:57:44 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2523 -
	trunk/cloveretl.engine/src/org/jetel/data
Message-ID: <200702271657.l1RGviOg030388@sheep.berlios.de>

Author: dpavlis
Date: 2007-02-27 17:57:44 +0100 (Tue, 27 Feb 2007)
New Revision: 2523

Modified:
   trunk/cloveretl.engine/src/org/jetel/data/DataRecord.java
Log:
UPDATE:added new variant of (de)serialize()

Modified: trunk/cloveretl.engine/src/org/jetel/data/DataRecord.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/DataRecord.java	2007-02-27 16:55:33 UTC (rev 2522)
+++ trunk/cloveretl.engine/src/org/jetel/data/DataRecord.java	2007-02-27 16:57:44 UTC (rev 2523)
@@ -46,18 +46,7 @@
     private static final long serialVersionUID = 2497808992091497225L;
 
 
-    // switch- shall we handle differently NULLable records (record
-    // which has at least one field NULLable ?)
-    private static final boolean HANDLE_NULLABLE = false;
-    
-    
-	/**
-     * Currently not used
-	 * @since
-	 */
-	// private transient String codeClassName;
-
-	/**
+    /**
      * Array for holding data fields
      * 
 	 * @since
@@ -253,7 +242,7 @@
 	 * @since          April 23, 2002
 	 */
 	public void deserialize(ByteBuffer buffer) {
-        if (HANDLE_NULLABLE && metadata.isNullable()) {
+        if (Defaults.Record.USE_FIELDS_NULL_INDICATORS && metadata.isNullable()) {
             final int base = buffer.position();
             BitArray nullSwitches = metadata.getFieldsNullSwitches();
             final int numNullBytes = BitArray.bitsLength2Bytes(metadata
@@ -282,6 +271,12 @@
         }
     }
 
+    public void deserialize(ByteBuffer buffer,int[] whichFields) {
+        for(int i:whichFields){
+            fields[i].deserialize(buffer);
+        }
+    }
+    
 
 	/**
 	 *  Test two DataRecords for equality. Records must have the same metadata (be
@@ -343,16 +338,7 @@
         }
 	}
 
-	/**
-	 *  Gets the codeClassName attribute of the DataRecord object
-	 *
-	 * @return    The codeClassName value
-	 */
-	public String getCodeClassName() {
-		return ""; //codeClassName;
-	}
 
-
 	/**
 	 *  An operation that returns DataField with
      *  specified order number.
@@ -435,7 +421,7 @@
 	 * @since          April 23, 2002
 	 */
 	public void serialize(ByteBuffer buffer) {
-        if (HANDLE_NULLABLE && metadata.isNullable()) {
+        if (Defaults.Record.USE_FIELDS_NULL_INDICATORS && metadata.isNullable()) {
             final int base = buffer.position();
             BitArray nullSwitches = metadata.getFieldsNullSwitches();
             final int numNullBytes = BitArray.bitsLength2Bytes(metadata
@@ -464,17 +450,21 @@
         }
     }
 
+    /**
+     * Serializes this record's content into ByteBuffer.<br>
+     * Asume only fields which indexes are in fields array
+     * 
+     * @param buffer
+     * @param whichFields
+     * @since 27.2.2007
+     */
+    public void serialize(ByteBuffer buffer,int[] whichFields) {
+        for(int i:whichFields){
+            fields[i].serialize(buffer);
+        }
+    }
 
-	/**
-	 *  Sets the codeClassName attribute of the DataRecord object
-	 *
-	 * @param  codeClassName  The new codeClassName value
-	 */
-	public void setCodeClassName(String codeClassName) {
-		// this.codeClassName = codeClassName;
-	}
 
-
 	/**
 	 *  Assigns new metadata to this DataRecord. If the new
 	 * metadata is not equal to the current metadata, the record's
@@ -585,7 +575,7 @@
 	 */
 	public int getSizeSerialized() {
         int size=0;
-        if (HANDLE_NULLABLE && metadata.isNullable()){
+        if (Defaults.Record.USE_FIELDS_NULL_INDICATORS && metadata.isNullable()){
             for (int i = 0; i < fields.length;i++){
                 if (!fields[i].isNull()){
                     size+=fields[i].getSizeSerialized(); 



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 17:58:38 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 17:58:38 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2524 -
	trunk/cloveretl.engine/src/org/jetel/graph/runtime
Message-ID: <200702271658.l1RGwcqO030520@sheep.berlios.de>

Author: dpavlis
Date: 2007-02-27 17:58:37 +0100 (Tue, 27 Feb 2007)
New Revision: 2524

Added:
   trunk/cloveretl.engine/src/org/jetel/graph/runtime/PhaseTrackingDetail.java
Log:
INIT:initial check-in

Added: trunk/cloveretl.engine/src/org/jetel/graph/runtime/PhaseTrackingDetail.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/graph/runtime/PhaseTrackingDetail.java	2007-02-27 16:57:44 UTC (rev 2523)
+++ trunk/cloveretl.engine/src/org/jetel/graph/runtime/PhaseTrackingDetail.java	2007-02-27 16:58:37 UTC (rev 2524)
@@ -0,0 +1,83 @@
+/*
+ *    jETeL/Clover - Java based ETL application framework.
+ *    Copyright (C) 2002-07  David Pavlis <david.pavlis at centrum.cz> and others.
+ *    
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License as published by the Free Software Foundation; either
+ *    version 2.1 of the License, or (at your option) any later version.
+ *    
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
+ *    Lesser General Public License for more details.
+ *    
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Created on 26.2.2007
+ *
+ * TODO To change the template for this generated file go to
+ * Window - Preferences - Java - Code Style - Code Templates
+ */
+package org.jetel.graph.runtime;
+
+import java.io.Serializable;
+
+public class PhaseTrackingDetail implements Serializable {
+    
+    private static final long serialVersionUID = -6140687882226805507L;
+    
+    private int execTime;
+    private long memUtilization;
+
+    
+    public PhaseTrackingDetail(int execTime,long memUtilization) {
+        this.execTime=execTime;
+        this.memUtilization=memUtilization;
+    }
+
+    /**
+     * @return the phaseExecTime in milliseconds
+     * @since 27.2.2007
+     */
+    public int getExecTime() {
+        return execTime;
+    }
+    
+    /**
+     * @return the phaseExecTime in seconds
+     * @since 27.2.2007
+     */
+    public int getExecTimeSec() {
+        return execTime/1000;
+    }
+    
+    /**
+     * @param phaseExecTime the phaseExecTime to set
+     * @since 27.2.2007
+     */
+    public void setExecTime(int phaseExecTime) {
+        this.execTime = phaseExecTime;
+    }
+    /**
+     * @return the phaseMemUtilization in kilobytes (KB)
+     * @since 27.2.2007
+     */
+    public long getMemUtilization() {
+        return memUtilization;
+    }
+    
+    public int getMemUtilizationKB() {
+        return (int)memUtilization/1024;
+    }
+    
+    /**
+     * @param phaseMemUtilization the phaseMemUtilization to set
+     * @since 27.2.2007
+     */
+    public void setMemUtilization(long phaseMemUtilization) {
+        this.memUtilization = phaseMemUtilization;
+    }
+}



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 17:59:01 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 17:59:01 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2525 -
	trunk/cloveretl.engine/src/org/jetel/graph/runtime
Message-ID: <200702271659.l1RGx152030587@sheep.berlios.de>

Author: dpavlis
Date: 2007-02-27 17:59:00 +0100 (Tue, 27 Feb 2007)
New Revision: 2525

Modified:
   trunk/cloveretl.engine/src/org/jetel/graph/runtime/CloverJMX.java
   trunk/cloveretl.engine/src/org/jetel/graph/runtime/CloverJMXMBean.java
   trunk/cloveretl.engine/src/org/jetel/graph/runtime/WatchDog.java
Log:
UPDATE:extended tracking info (on nodes & phases)

Modified: trunk/cloveretl.engine/src/org/jetel/graph/runtime/CloverJMX.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/graph/runtime/CloverJMX.java	2007-02-27 16:58:37 UTC (rev 2524)
+++ trunk/cloveretl.engine/src/org/jetel/graph/runtime/CloverJMX.java	2007-02-27 16:59:00 UTC (rev 2525)
@@ -29,6 +29,8 @@
 
 import javax.management.*; 
 
+import org.jetel.graph.Phase;
+
 public class CloverJMX extends NotificationBroadcasterSupport  implements CloverJMXMBean {
 
     private long sequenceNumber = 1;
@@ -66,6 +68,16 @@
         return runTimeMS;
     }
 
+    
+    public int[] getPhaseList() {
+        Phase[] phases=watchDog.getTransformationGraph().getPhases();
+        int[] phaseNums=new int[phases.length];
+        for (int i=0;i<phaseNums.length;i++) {
+            phaseNums[i]=phases[i].getPhaseNum();
+        }
+        return phaseNums;
+    }
+    
     public int getRunningPhase() {
         return runingPhase;
     }
@@ -79,6 +91,15 @@
         
     }
     
+    public TrackingDetail getTrackingDetail(int phase,String nodeID) {
+        return watchDog.getTransformationGraph().getPhase(phase).getTracking().get(nodeID);
+    }
+    
+    public PhaseTrackingDetail getPhaseTracking(int phase) {
+        return watchDog.getTransformationGraph().getPhase(phase).getPhaseTracking();
+    }
+    
+    
     public String getTrackingDetailString(String nodeID){
         TrackingDetail detail=trackingMap.get(nodeID);
         if (detail!=null){

Modified: trunk/cloveretl.engine/src/org/jetel/graph/runtime/CloverJMXMBean.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/graph/runtime/CloverJMXMBean.java	2007-02-27 16:58:37 UTC (rev 2524)
+++ trunk/cloveretl.engine/src/org/jetel/graph/runtime/CloverJMXMBean.java	2007-02-27 16:59:00 UTC (rev 2525)
@@ -27,19 +27,37 @@
 
 public interface CloverJMXMBean {
   
+    /**
+     * @return String containing info about which version of CloverETL
+     * is running
+     * @since 26.2.2007
+     */
     public String getCloverVersion();
     
     public int getUpdateInterval();
     public void setUpdateInterval(int updateInterval);
     
+    /**
+     * @return  number of phase being executed
+     * @since 26.2.2007
+     */
     public int getRunningPhase();
+    
+    public int[] getPhaseList();
+    
     public String getRunningGraphName();
     public long getRunningGraphTime();
     
     public int getRunningNodesCount();
     public String[] getNodesList();
     
+
+    public PhaseTrackingDetail getPhaseTracking(int phase);
+    
     public TrackingDetail getTrackingDetail(String nodeID);
+    public TrackingDetail getTrackingDetail(int phase,String nodeID);
+    
+    
     public String getTrackingDetailString(String nodeID);
     
     public void stopGraphExecution();

Modified: trunk/cloveretl.engine/src/org/jetel/graph/runtime/WatchDog.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/graph/runtime/WatchDog.java	2007-02-27 16:58:37 UTC (rev 2524)
+++ trunk/cloveretl.engine/src/org/jetel/graph/runtime/WatchDog.java	2007-02-27 16:59:00 UTC (rev 2525)
@@ -73,7 +73,6 @@
 	private Phase currentPhase;
 	private int currentPhaseNum;
 	private Runtime javaRuntime;
-	private int usedMemoryStampKB;
     private MemoryMXBean memMXB;
     private ThreadMXBean threadMXB;
     private BlockingQueue <Message> inMsgQueue;
@@ -109,7 +108,6 @@
 		watchDogStatus = Result.READY;
 		javaRuntime = Runtime.getRuntime();
         memMXB=ManagementFactory.getMemoryMXBean();
-		usedMemoryStampKB = (int) memMXB.getHeapMemoryUsage().getUsed() /1024;
         threadMXB= ManagementFactory.getThreadMXBean();
         
         inMsgQueue=new PriorityBlockingQueue<Message>();
@@ -153,16 +151,15 @@
 //        trackingThread.start();
         
 		for (currentPhaseNum = 0; currentPhaseNum < phases.length; currentPhaseNum++) {
-			switch( executePhase(phases[currentPhaseNum]) ){
+			switch( (executePhase(phases[currentPhaseNum])) ){
             case ABORTED:
-                watchDogStatus = Result.ABORTED;
                 logger.error("!!! Phase execution aborted !!!");
                 return;
             case ERROR:
-                watchDogStatus = Result.ERROR;
 				logger.error("!!! Phase finished with error - stopping graph run !!!");
 				return;
             }
+            
 			// force running of garbage collector
 			logger.info("Forcing garbage collection ...");
 			javaRuntime.runFinalization();
@@ -171,7 +168,6 @@
 
         //disabled by Kokon
 //        trackingThread.interrupt();
-		watchDogStatus = Result.FINISHED_OK;
 		printPhasesSummary();
 	}
 
@@ -263,7 +259,7 @@
 	 * @since             July 29, 2002
 	 */
 	public Result watch(Phase phase) throws InterruptedException {
-		int phaseMemUtilizationMaxKB;
+		long phaseMemUtilizationMax;
 		Iterator leafNodesIterator;
         Message message;
 		int ticker = Defaults.WatchDog.NUMBER_OF_TICKS_BETWEEN_STATUS_CHECKS;
@@ -280,7 +276,7 @@
         phase.setTracking(tracking);
             
 		//get current memory utilization
-		phaseMemUtilizationMaxKB=(int)memMXB.getHeapMemoryUsage().getUsed()/1024;
+		phaseMemUtilizationMax=memMXB.getHeapMemoryUsage().getUsed();
 		//let's take timestamp so we can measure processing
 		startTimestamp = lastTimestamp = System.currentTimeMillis();
         // also let's take nanotime to measure how much CPU we spend processing
@@ -321,10 +317,10 @@
             
             // is there any node running ?
 			if (leafNodes.isEmpty()) {
-				phase.setPhaseMemUtilization(phaseMemUtilizationMaxKB);
-				phase.setPhaseExecTime((int) (System.currentTimeMillis() - startTimestamp));
+                PhaseTrackingDetail phaseTracking=new PhaseTrackingDetail((int) (System.currentTimeMillis() - startTimestamp)
+                                                    ,phaseMemUtilizationMax);
 				logger.info("Execution of phase [" + phase.getPhaseNum() + "] successfully finished - elapsed time(sec): "
-						+ phase.getPhaseExecTime() / 1000);
+						+ phaseTracking.getExecTime() / 1000);
 				//printProcessingStatus(phase.getNodes().iterator(), phase.getPhaseNum());
                 printTracking.execute();// print tracking
 				return Result.FINISHED_OK;
@@ -352,9 +348,8 @@
                 // reinitialize ticker
                 ticker = Defaults.WatchDog.NUMBER_OF_TICKS_BETWEEN_STATUS_CHECKS;
                 // get memory usage mark
-                phaseMemUtilizationMaxKB = (int) Math.max(
-                        phaseMemUtilizationMaxKB, memMXB.getHeapMemoryUsage()
-                                .getUsed() / 1024);
+                phaseMemUtilizationMax = Math.max(
+                        phaseMemUtilizationMax, memMXB.getHeapMemoryUsage().getUsed() );
                 }
             
                 long elapsedNano=System.nanoTime()-startTimeNano;
@@ -439,9 +434,9 @@
 	void printPhasesSummary() {
 		logger.info("-----------------------** Summary of Phases execution **---------------------");
 		logger.info("Phase#            Finished Status         RunTime(sec)    MemoryAllocation(KB)");
-		for (int i = 0; i < phases.length; i++) {
-			Object nodeInfo[] = {new Integer(phases[i].getPhaseNum()), new Integer(0),
-					new Integer(phases[i].getPhaseExecTime()/1000), new Integer(phases[i].getPhaseMemUtilization())};
+		for (Phase phase : phases) {
+			Object nodeInfo[] = {new Integer(phase.getPhaseNum()), phase.getResult().message(),
+					new Integer(phase.getPhaseTracking().getExecTimeSec()), new Integer(phase.getPhaseTracking().getMemUtilizationKB())};
 			int nodeSizes[] = {-18, -24, 12, 18};
 			logger.info(StringUtils.formatString(nodeInfo, nodeSizes));
 		}
@@ -526,7 +521,7 @@
 		
         //end of phase, destroy it
 		phase.free();
-        
+        phase.setResult(watchDogStatus);
 		return watchDogStatus;
 	}
 
@@ -615,11 +610,11 @@
             trackingLogger.info("Time: "
                 + DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM, Locale.FRANCE).
                     format(Calendar.getInstance().getTime()));
-            trackingLogger.info("Node                   Status     Port      #Records         #KB  Rec/s   KB/s");
+            trackingLogger.info("Node                   Status     Port      #Records         #KB  Rec/s    KB/s");
             trackingLogger.info("----------------------------------------------------------------------------------");
             for (TrackingDetail nodeDetail : tracking.values()){
                 Object nodeInfo[] = {nodeDetail.getNodeId(), nodeDetail.getResult().message()};
-                int nodeSizes[] = {-23, -10};
+                int nodeSizes[] = {-23, -15};
                 trackingLogger.info(StringUtils.formatString(nodeInfo, nodeSizes));
                 //in ports
                 Object portInfo[];
@@ -628,13 +623,14 @@
                 for(int i=0;i<nodeDetail.getNumInputPorts();i++){
                     if (i==0){
                         cpuPrinted=true;
-                        portInfo = new Object[] {"%CPU:",Float.toString(nodeDetail.getUsageCPU()),
+                        final float cpuUsage=nodeDetail.getUsageCPU();
+                        portInfo = new Object[] {" %cpu:",cpuUsage>=0.01f ? Float.toString(cpuUsage) : "..",
                                 "In:", Integer.toString(i), 
                                 Integer.toString(nodeDetail.getTotalRows(TrackingDetail.IN_PORT, i)),
                                 Long.toString(nodeDetail.getTotalBytes(TrackingDetail.IN_PORT, i)>>10),
                                 Integer.toString(nodeDetail.getAvgRows(TrackingDetail.IN_PORT, i)),
                                 Integer.toString(nodeDetail.getAvgBytes(TrackingDetail.IN_PORT, i)>>10)};
-                        portSizes = new int[] {-5,-4,29, -5, 9,12,7,8};
+                        portSizes = new int[] {-6,-4,28, -5, 9,12,7,8};
                     }else{
                             portInfo = new Object[] {"In:", Integer.toString(i), 
                             Integer.toString(nodeDetail.getTotalRows(TrackingDetail.IN_PORT, i)),
@@ -648,13 +644,14 @@
                 //out ports
                 for(int i=0;i<nodeDetail.getNumOutputPorts();i++){
                     if (i==0 && !cpuPrinted){
-                        portInfo = new Object[] {"%CPU:",Float.toString(nodeDetail.getUsageCPU()),
+                        final float cpuUsage=nodeDetail.getUsageCPU();
+                        portInfo = new Object[] {" %cpu:",cpuUsage>=0.01f ? Float.toString(cpuUsage) : "..",
                                 "Out:", Integer.toString(i), 
                                 Integer.toString(nodeDetail.getTotalRows(TrackingDetail.OUT_PORT, i)),
                                 Long.toString(nodeDetail.getTotalBytes(TrackingDetail.OUT_PORT, i)>>10),
                                 Integer.toString(nodeDetail.getAvgRows(TrackingDetail.OUT_PORT, i)),
                                 Integer.toString(nodeDetail.getAvgBytes(TrackingDetail.OUT_PORT, i)>>10)};
-                        portSizes = new int[] {-5,-4,29, -5, 9,12,7,8};
+                        portSizes = new int[] {-6,-4,28, -5, 9,12,7,8};
                     }else{
                         portInfo = new Object[] {"Out:", Integer.toString(i), 
                             Integer.toString(nodeDetail.getTotalRows(TrackingDetail.OUT_PORT, i)),
@@ -743,6 +740,15 @@
     public void stopRun() {
         this.runIt = false;
     }
+
+
+    /**
+     * @return the graph
+     * @since 26.2.2007
+     */
+    public TransformationGraph getTransformationGraph() {
+        return graph;
+    }
     
     
 }



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 17:59:42 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 17:59:42 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2526 -
	trunk/cloveretl.engine/src/org/jetel/graph
Message-ID: <200702271659.l1RGxg7J030664@sheep.berlios.de>

Author: dpavlis
Date: 2007-02-27 17:59:41 +0100 (Tue, 27 Feb 2007)
New Revision: 2526

Modified:
   trunk/cloveretl.engine/src/org/jetel/graph/Phase.java
Log:
UPDATE:changed to keep phase tracking in separate class

Modified: trunk/cloveretl.engine/src/org/jetel/graph/Phase.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/graph/Phase.java	2007-02-27 16:59:00 UTC (rev 2525)
+++ trunk/cloveretl.engine/src/org/jetel/graph/Phase.java	2007-02-27 16:59:41 UTC (rev 2526)
@@ -29,6 +29,7 @@
 import org.jetel.exception.ConfigurationStatus;
 import org.jetel.exception.GraphConfigurationException;
 import org.jetel.graph.runtime.NodeTrackingDetail;
+import org.jetel.graph.runtime.PhaseTrackingDetail;
 import org.jetel.graph.runtime.TrackingDetail;
 
 /**
@@ -55,8 +56,8 @@
 	// specifies the order of this phase within graph
 	private int phaseNum;
 
-	private int phaseExecTime;
-	private int phaseMemUtilization;
+	private PhaseTrackingDetail phaseTracking;
+    
 	private Result result;
     private boolean isCheckPoint;
     private Map<String,TrackingDetail> tracking;
@@ -122,7 +123,6 @@
 		Edge edge;
 		Iterator nodeIterator = nodesInPhase.iterator();
 		Iterator edgeIterator = edgesInPhase.iterator();
-		phaseExecTime = phaseMemUtilization = 0;
 
         // list of leaf nodes -will be filled later
         leafNodes = new LinkedList<Node>();
@@ -330,43 +330,24 @@
         }
     }
     
-	/**
-	 *  Sets the phaseExecTime attribute of the Phase object
-	 *
-	 * @param  time  The new phaseExecTime value
-	 */
-	public void setPhaseExecTime(int time) {
-		phaseExecTime = time;
-	}
 
-
 	/**
-	 *  Sets the phaseMemUtilization attribute of the Phase object
+	 *  Gets the phase execution time in milliseconds
 	 *
-	 * @param  mem  The new phaseMemUtilization value
-	 */
-	public void setPhaseMemUtilization(int mem) {
-		phaseMemUtilization = mem;
-	}
-
-
-	/**
-	 *  Gets the phaseExecTime attribute of the Phase object
-	 *
 	 * @return    The phaseExecTime value
 	 */
-	public int getPhaseExecTime() {
-		return phaseExecTime;
+	@Deprecated public int getPhaseExecTime() {
+		return phaseTracking.getExecTime();
 	}
 
 
 	/**
-	 *  Gets the phaseMemUtilization attribute of the Phase object
+	 *  Gets the phase memory utilization in KB (kilobytes)
 	 *
 	 * @return    The phaseMemUtilization value
 	 */
-	public int getPhaseMemUtilization() {
-		return phaseMemUtilization;
+	@Deprecated public int getPhaseMemUtilization() {
+		return phaseTracking.getMemUtilizationKB();
 	}
 
 
@@ -425,6 +406,24 @@
     public void setTracking(Map<String, TrackingDetail> tracking) {
         this.tracking = tracking;
     }
+
+
+    /**
+     * @return the phaseTracking
+     * @since 26.2.2007
+     */
+    public PhaseTrackingDetail getPhaseTracking() {
+        return phaseTracking;
+    }
+
+
+    /**
+     * @param phaseTracking the phaseTracking to set
+     * @since 26.2.2007
+     */
+    public void setPhaseTracking(PhaseTrackingDetail phaseTracking) {
+        this.phaseTracking = phaseTracking;
+    }
 }
 /*
  *  end class Phase



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 17:59:55 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 17:59:55 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2527 -
	trunk/cloveretl.engine/src/org/jetel/graph
Message-ID: <200702271659.l1RGxtue030717@sheep.berlios.de>

Author: dpavlis
Date: 2007-02-27 17:59:54 +0100 (Tue, 27 Feb 2007)
New Revision: 2527

Modified:
   trunk/cloveretl.engine/src/org/jetel/graph/TransformationGraph.java
Log:
UPDATE:added getPhase(int) method

Modified: trunk/cloveretl.engine/src/org/jetel/graph/TransformationGraph.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/graph/TransformationGraph.java	2007-02-27 16:59:41 UTC (rev 2526)
+++ trunk/cloveretl.engine/src/org/jetel/graph/TransformationGraph.java	2007-02-27 16:59:54 UTC (rev 2527)
@@ -329,6 +329,19 @@
         Arrays.sort(array);
 		return array; 
 	}
+    
+    /**
+     * Return phase with specified phase number.<br>
+     * <i>Note:Phases in graph can go out-of-sequence !</i>
+     * 
+     * @param phaseNum
+     * @return
+     * @since 26.2.2007
+     */
+    public Phase getPhase(int phaseNum) {
+        return phases.get(new Integer(phaseNum));
+    }
+    
 	/**
 	 * An operation that starts execution of graph
 	 *



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 18:11:54 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 18:11:54 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2528 -
	trunk/cloveretl.component/src/org/jetel/component
Message-ID: <200702271711.l1RHBsQY032008@sheep.berlios.de>

Author: jausperger
Date: 2007-02-27 18:11:53 +0100 (Tue, 27 Feb 2007)
New Revision: 2528

Modified:
   trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
   trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java
   trunk/cloveretl.component/src/org/jetel/component/Trash.java
Log:
FIX: fix encoding exception in init phase

Modified: trunk/cloveretl.component/src/org/jetel/component/DataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-27 16:59:54 UTC (rev 2527)
+++ trunk/cloveretl.component/src/org/jetel/component/DataWriter.java	2007-02-27 17:11:53 UTC (rev 2528)
@@ -178,10 +178,10 @@
         writer.setAppendData(appendData);
         writer.setSkip(skip);
         writer.setNumRecords(numRecords);
+        writer.init(getInputPort(READ_FROM_PORT).getMetadata());
         if(outputFieldNames) {
 			formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
         }
-        writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}
 	
 	/**

Modified: trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-27 16:59:54 UTC (rev 2527)
+++ trunk/cloveretl.component/src/org/jetel/component/DelimitedDataWriter.java	2007-02-27 17:11:53 UTC (rev 2528)
@@ -197,10 +197,10 @@
         writer.setAppendData(appendData);
         writer.setSkip(skip);
         writer.setNumRecords(numRecords);
+        writer.init(getInputPort(READ_FROM_PORT).getMetadata());
         if(outputFieldNames) {
 			formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
         }
-        writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}
 	
 	public ConfigurationStatus checkConfig(ConfigurationStatus status) {

Modified: trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-27 16:59:54 UTC (rev 2527)
+++ trunk/cloveretl.component/src/org/jetel/component/FixLenDataWriter.java	2007-02-27 17:11:53 UTC (rev 2528)
@@ -187,10 +187,10 @@
         writer.setAppendData(appendData);
         writer.setSkip(skip);
         writer.setNumRecords(numRecords);
+        writer.init(getInputPort(READ_FROM_PORT).getMetadata());
         if(outputFieldNames) {
         	formatter.setHeader(getInputPort(READ_FROM_PORT).getMetadata().getFieldNamesHeader());
         }
-        writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}
 	
 	/**

Modified: trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-27 16:59:54 UTC (rev 2527)
+++ trunk/cloveretl.component/src/org/jetel/component/StructureWriter.java	2007-02-27 17:11:53 UTC (rev 2528)
@@ -232,9 +232,9 @@
         writer.setAppendData(appendData);
         writer.setSkip(skip);
         writer.setNumRecords(numRecords);
+        writer.init(getInputPort(READ_FROM_PORT).getMetadata());
         formatter.setHeader(header);
         formatter.setFooter(footer);
-        writer.init(getInputPort(READ_FROM_PORT).getMetadata());
 	}
 
 	/* (non-Javadoc)

Modified: trunk/cloveretl.component/src/org/jetel/component/Trash.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/Trash.java	2007-02-27 16:59:54 UTC (rev 2527)
+++ trunk/cloveretl.component/src/org/jetel/component/Trash.java	2007-02-27 17:11:53 UTC (rev 2528)
@@ -179,8 +179,8 @@
     			}
             }
             if (writer != null) {
-            	formatter.showCounter("Record", "### ");
                 writer.init(getInputPort(READ_FROM_PORT).getMetadata());
+            	formatter.showCounter("Record", "# ");
             }
 		}
 	}



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 20:36:40 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 20:36:40 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2529 -
	trunk/cloveretl.engine/src/org/jetel/data
Message-ID: <200702271936.l1RJaeVB031016@sheep.berlios.de>

Author: dpavlis
Date: 2007-02-27 20:36:38 +0100 (Tue, 27 Feb 2007)
New Revision: 2529

Modified:
   trunk/cloveretl.engine/src/org/jetel/data/RecordKey.java
Log:
UPDATE:added serialization of key fields

Modified: trunk/cloveretl.engine/src/org/jetel/data/RecordKey.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/RecordKey.java	2007-02-27 17:11:53 UTC (rev 2528)
+++ trunk/cloveretl.engine/src/org/jetel/data/RecordKey.java	2007-02-27 19:36:38 UTC (rev 2529)
@@ -21,7 +21,12 @@
 
 import java.nio.ByteBuffer;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 import org.jetel.metadata.DataRecordMetadata;
 
@@ -139,6 +144,26 @@
 		return keyFields;
 	}
 
+    
+    /**
+     * Gets fields (indexes) which are not part of the key
+     * 
+     * @return
+     * @since 31.1.2007
+     */
+    public int[] getNonKeyFields(){
+        Set<Integer> allFields=new LinkedHashSet<Integer>();
+        for(int i=0;i<metadata.getNumFields();i++){
+            allFields.add(new Integer(i));
+        }
+        allFields.removeAll(Arrays.asList(keyFields));
+        int[] nonKey=new int[allFields.size()];
+        int counter=0;
+        for(Integer index : allFields){
+            nonKey[counter++]=index.intValue();
+        }
+        return nonKey;
+    }
 
 	/**
 	 * Gets number of fields defined by this key.
@@ -255,7 +280,7 @@
 	
 
 	/**
-	 * This method serializes (saves) content of key fields (for specified record) into
+	 * This method serializes (saves) content of key fields only (for specified record) into
 	 * buffer.
 	 * 
 	 * @param buffer ByteBuffer into which serialize key fields
@@ -267,6 +292,21 @@
 		}
 	}
 	
+    /**
+     *  This method deserializes (restores) content of key fields only (for specified record) from
+     * buffer.
+     * 
+     * @param buffer ByteBuffer from which deserialize key fields
+     * @param record data record whose key fields will be deserialized from ByteBuffer
+     * @since 29.1.2007
+     */
+    public void deserializeKeyFileds(ByteBuffer buffer,DataRecord record){
+        for (int i = 0; i < keyFields.length; i++) {
+            record.getField(keyFields[i]).deserialize(buffer);
+        }
+    }
+    
+    
 	/**
 	 * This method creates DataRecordMetadata object which represents fields composing this key. It can
 	 * be used for creating data record composed from key fields only.



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 20:37:13 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 20:37:13 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2530 -
	trunk/cloveretl.engine/src/org/jetel/data
Message-ID: <200702271937.l1RJbDPM031058@sheep.berlios.de>

Author: dpavlis
Date: 2007-02-27 20:37:08 +0100 (Tue, 27 Feb 2007)
New Revision: 2530

Modified:
   trunk/cloveretl.engine/src/org/jetel/data/RecordComparator.java
Log:
UPDATE:reworked compare() methods

Modified: trunk/cloveretl.engine/src/org/jetel/data/RecordComparator.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/RecordComparator.java	2007-02-27 19:36:38 UTC (rev 2529)
+++ trunk/cloveretl.engine/src/org/jetel/data/RecordComparator.java	2007-02-27 19:37:08 UTC (rev 2530)
@@ -19,6 +19,7 @@
 */
 package org.jetel.data;
 
+import java.nio.ByteBuffer;
 import java.text.Collator;
 import java.text.RuleBasedCollator;
 import java.util.Comparator;
@@ -42,6 +43,7 @@
 
 	protected int keyFields[];
     protected RuleBasedCollator collator;
+    private boolean equalNULLs = false; // specifies whether two NULLs are deemed equal
 	
 	/**
 	 *  Constructor for the RecordComparator object
@@ -83,8 +85,8 @@
 	 */
 	public int compare(Object o1, Object o2) {
         int compResult;
-        DataRecord record1 = (DataRecord) o1;
-        DataRecord record2 = (DataRecord) o2;
+        final DataRecord record1 = (DataRecord) o1;
+        final DataRecord record2 = (DataRecord) o2;
         /*
          * by D.Pavlis following check has been "relaxed" to speed up
          * processing. if (record1.getMetadata() != record2.getMetadata()) {
@@ -93,24 +95,42 @@
          */
         if (collator != null) {
             for (int i = 0; i < keyFields.length; i++) {
-                DataField field1 = record1.getField(keyFields[i]);
+                final DataField field1 = record1.getField(keyFields[i]);
                 if (field1.getType() == DataFieldMetadata.STRING_FIELD) {
-                    if ((compResult = ((StringDataField) field1).compareTo(
-                            record2.getField(keyFields[i]), collator)) != 0)
-                        return compResult;
+                    compResult = ((StringDataField) field1).compareTo(
+                            record2.getField(keyFields[i]), collator);
                 } else {
-                    if ((compResult = field1.compareTo(record2
-                            .getField(keyFields[i]))) != 0)
-                        return compResult;
+                    compResult = field1.compareTo(record2
+                            .getField(keyFields[i]));
                 }
+                if (compResult != 0) {
+                    if (equalNULLs) {
+                        if (!(record1.getField(keyFields[i]).isNull && record2
+                                .getField(keyFields[i]).isNull)) {
+                            return compResult;
+                        }
+                        continue;
+                    }
+                    return compResult;
+                }
             }
 
         } else {
 
             for (int i = 0; i < keyFields.length; i++) {
-                if ((compResult = record1.getField(keyFields[i]).compareTo(
-                        record2.getField(keyFields[i]))) != 0)
+                compResult = record1.getField(keyFields[i]).compareTo(
+                        record2.getField(keyFields[i]));
+
+                if (compResult != 0) {
+                    if (equalNULLs) {
+                        if (!(record1.getField(keyFields[i]).isNull && record2
+                                .getField(keyFields[i]).isNull)) {
+                            return compResult;
+                        }
+                        continue;
+                    }
                     return compResult;
+                }
             }
         }
         return 0;
@@ -119,15 +139,18 @@
 
 
 	/**
-	 *  Compares two records (can have different layout) based on defined key-fields 
-	 *  and returns (-1;0;1) if (< ; = ; >).<br>
-	 *  The particular fields to be compared have to be of the same type !
-	 *
-	 *@param  secondKey  RecordKey defined for the second record
-	 *@param  record1    First record
-	 *@param  record2    Second record
-	 *@return            -1 ; 0 ; 1
-	 */
+     * Compares two records (can have different layout) based on defined
+     * key-fields and returns (-1;0;1) if (< ; = ; >).<br>
+     * The particular fields to be compared have to be of the same type !
+     * 
+     * @param secondKey
+     *            RecordKey defined for the second record
+     * @param record1
+     *            First record
+     * @param record2
+     *            Second record
+     * @return -1 ; 0 ; 1
+     */
 	public int compare(RecordKey secondKey, DataRecord record1, DataRecord record2) {
 		int compResult;
 		int[] record2KeyFields = secondKey.getKeyFields();
@@ -137,27 +160,46 @@
         
          if (collator != null) {
              for (int i = 0; i < keyFields.length; i++) {
-                 DataField field1 = record1.getField(keyFields[i]);
+                 final DataField field1 = record1.getField(keyFields[i]);
                  if (field1.getType() == DataFieldMetadata.STRING_FIELD) {
-                     if ((compResult = ((StringDataField) field1).compareTo(
-                             record2.getField(record2KeyFields[i]),collator)) != 0)
-                         return compResult;
+                    compResult = ((StringDataField) field1).compareTo(
+                             record2.getField(record2KeyFields[i]),collator);
                  }else{
-                     if ((compResult = field1.compareTo(
-                             record2.getField(record2KeyFields[i]))) != 0)
-                         return compResult;
+                     compResult = field1.compareTo(
+                             record2.getField(record2KeyFields[i]));
                  }
+                 
+                 if (compResult != 0) {
+                     if (equalNULLs) {
+                         if (!(record1.getField(keyFields[i]).isNull && record2
+                                 .getField(record2KeyFields[i]).isNull)) {
+                             return compResult;
+                         }
+                         continue;
+                     }
+                     return compResult;
+                 }
+                 
             }             
              
          }else{
         
 		for (int i = 0; i < keyFields.length; i++) {
-			compResult = record1.getField(keyFields[i]).compareTo(record2.getField(record2KeyFields[i]));
-			if (compResult != 0) {
-				return compResult;
-			}
-		}
-         }
+                compResult = record1.getField(keyFields[i]).compareTo(
+                        record2.getField(record2KeyFields[i]));
+                
+                if (compResult != 0) {
+                    if (equalNULLs) {
+                        if (!(record1.getField(keyFields[i]).isNull && record2
+                                .getField(record2KeyFields[i]).isNull)) {
+                            return compResult;
+                        }
+                        continue;
+                    }
+                    return compResult;
+                }
+            }
+        }
 		return 0;
 		// seem to be the same
 	}
@@ -180,6 +222,53 @@
     public void setCollator(RuleBasedCollator collator) {
         this.collator = collator;
     }
+    
+    /**
+     * True if two NULL values (fields with NULL flag set) are considered equal
+     * 
+     * @return Returns the equalNULLs.
+     */
+    public boolean isEqualNULLs() {
+        return equalNULLs;
+    }
+    /**
+     * Sets whether two NULL values (fields with NULL flag set) are considered equal.<br>
+     * Default is false.
+     * 
+     * @param equalNULLs The equalNULLs to set.
+     */
+    public void setEqualNULLs(boolean equalNULLs) {
+        this.equalNULLs = equalNULLs;
+    }
+    
+    /**
+     * This method serializes (saves) content of key fields only (for specified record) into
+     * buffer.
+     * 
+     * @param buffer ByteBuffer into which serialize key fields
+     * @param record data record from which key fields will be serialized into ByteBuffer
+     */
+    public void serializeKeyFields(ByteBuffer buffer,DataRecord record) {
+        for (int i = 0; i < keyFields.length; i++) {
+            record.getField(keyFields[i]).serialize(buffer);
+        }
+    }
+    
+    /**
+     *  This method deserializes (restores) content of key fields only (for specified record) from
+     * buffer.
+     * 
+     * @param buffer ByteBuffer from which deserialize key fields
+     * @param record data record whose key fields will be deserialized from ByteBuffer
+     * @since 29.1.2007
+     */
+    public void deserializeKeyFileds(ByteBuffer buffer,DataRecord record){
+        for (int i = 0; i < keyFields.length; i++) {
+            record.getField(keyFields[i]).deserialize(buffer);
+        }
+    }
+    
+    
 }
 // end RecordKey
 



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 20:40:08 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 20:40:08 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2531 -
	trunk/cloveretl.engine/src/org/jetel/data/tape
Message-ID: <200702271940.l1RJe8ex031472@sheep.berlios.de>

Author: dpavlis
Date: 2007-02-27 20:39:58 +0100 (Tue, 27 Feb 2007)
New Revision: 2531

Modified:
   trunk/cloveretl.engine/src/org/jetel/data/tape/DataRecordTape.java
Log:
UPDATE:added reget() methods

Modified: trunk/cloveretl.engine/src/org/jetel/data/tape/DataRecordTape.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/data/tape/DataRecordTape.java	2007-02-27 19:37:08 UTC (rev 2530)
+++ trunk/cloveretl.engine/src/org/jetel/data/tape/DataRecordTape.java	2007-02-27 19:39:58 UTC (rev 2531)
@@ -33,6 +33,7 @@
 import org.apache.commons.logging.LogFactory;
 import org.jetel.data.DataRecord;
 import org.jetel.data.Defaults;
+import org.jetel.util.ByteBufferUtils;
 
 
 /**
@@ -79,7 +80,7 @@
 	
 	private DataChunk currentDataChunk;
 	private int currentDataChunkIndex;
-	
+    
 	// size of BUFFER - used for push & shift operations
 	private final static int DEFAULT_BUFFER_SIZE = Defaults.DEFAULT_INTERNAL_IO_BUFFER_SIZE; 
 
@@ -308,9 +309,40 @@
 	    
 	}
 	
+	/**
+     * Returns number of chunks this tape contains.
+     * 
+	 * @return
+	 * @since 1.2.2007
+	 */
 	public int getNumChunks(){
 	    return dataChunks.size();
 	}
+    
+    
+    /**
+     * For specified chunk number returns its
+     * length (in bytes).
+     * 
+     * @param chunk
+     * @return
+     * @since 1.2.2007
+     */
+    public long getChunkLength(int chunk) {
+        return ((DataChunk)dataChunks.get(chunk)).getLength();
+    }
+    
+    /**
+     * For specified chunk number returns how
+     * many records it contains.
+     * 
+     * @param chunk
+     * @return
+     * @since 1.2.2007
+     */
+    public int getChunkRecNum(int chunk) {
+        return ((DataChunk)dataChunks.get(chunk)).getNumRecords();
+    }
 	
 	/**
 	 * Stores data in current/active chunk. Must not be mixed with calls to
@@ -326,6 +358,26 @@
 	        throw new RuntimeException("No DataChunk has been created !");
 	    }
 	}
+    
+    
+    /**
+     * Bulk-copy of data (1 record) from one tape to the other (directly)
+     * 
+     * @param source DataRecordTape from which to copy data 
+     * @return new size of chunk or -1 in case of problem
+     */
+    public long put(DataRecordTape sourceTape) throws IOException{
+        try{
+            if (sourceTape.currentDataChunk!=null){
+                return currentDataChunk.put(sourceTape.currentDataChunk);
+            }else{
+                return -1;
+            }
+        }catch(NullPointerException ex){
+            throw new RuntimeException("No DataChunk has been created !");
+        }
+    }
+    
 	
 	/**
 	 * Stores data record in current/active chunk.
@@ -360,6 +412,22 @@
 	    }
 	}
 	
+    /**
+     * Reads again previously read record.
+     * 
+     * @param data
+     * @return
+     * @throws IOException
+     * @since 27.2.2007
+     */
+    public boolean reget(ByteBuffer data) throws IOException{
+        if (currentDataChunk!=null){
+            return currentDataChunk.reget(data);
+        }else{
+            return false;
+        }
+    }
+    
 	/**
 	 * Reads data record from current chunk
 	 * 
@@ -374,6 +442,22 @@
 	        return false;
 	    }
 	}
+    
+    /**
+     * Reads again previously read record.
+     * 
+     * @param data
+     * @return
+     * @throws IOException
+     * @since 27.2.2007
+     */
+    public boolean reget(DataRecord data) throws IOException{
+        if (currentDataChunk!=null){
+            return currentDataChunk.reget(data);
+        }else{
+            return false;
+        }
+    }
 
 	/* Returns String containing short summary of chunks stored on tape.
 	 * 
@@ -416,20 +500,19 @@
 	 * @author david
 	 * @since  20.1.2005
 	 *
-	 * TODO To change the template for this generated type comment go to
-	 * Window - Preferences - Java - Code Style - Code Templates
 	 */
 	private static class DataChunk{
 	    //	size of integer variable used to keep record length
+        // this is the maximum size, can be between 1 & 4 bytes
 	    private final static int LEN_SIZE_SPECIFIER = 4;
 	    ByteBuffer dataBuffer;
 	    FileChannel tmpFileChannel;
 	    long offsetStart;
 	    long length;
-	    long position;
 	    int recordsRead;
 	    int nRecords;
 	    boolean canRead;
+        int recordSize;
 	    
 	    private DataChunk(FileChannel channel,ByteBuffer buffer){
 	        tmpFileChannel=channel;
@@ -460,7 +543,6 @@
 	        dataBuffer.clear();
 	        tmpFileChannel.read(dataBuffer);
 	        dataBuffer.flip();
-	        position=0;
 	    }
 	    
 	    /**
@@ -472,48 +554,96 @@
 		 *@return number of bytes in the chunk after saveing data
 		 */
 		long put(ByteBuffer recordBuffer) throws IOException {
-			int recordSize = recordBuffer.remaining();
-			
+			recordSize = recordBuffer.remaining();
+			final int lengthSize=ByteBufferUtils.lengthEncoded(recordSize);
 			// check that internal buffer has enough space
-			if ((recordSize + LEN_SIZE_SPECIFIER) > dataBuffer.remaining()){
+			if ((recordSize + lengthSize) > dataBuffer.remaining()){
 					flushBuffer();
 				}
 			
 			try {
-				dataBuffer.putInt(recordSize);
-				dataBuffer.put(recordBuffer);
+			    ByteBufferUtils.encodeLength(dataBuffer, recordSize);
+                dataBuffer.put(recordBuffer);
 			} catch (BufferOverflowException ex) {
-				throw new RuntimeException("Input Buffer is not big enough to accomodate data record !");
+				throw new IOException("Input Buffer is not big enough to accomodate data record !");
 			}
 			
-			length+=(recordSize+ LEN_SIZE_SPECIFIER);
+			length+=(recordSize+ lengthSize);
 			nRecords++;
 			return length;
 		}
 
+       
+        long put(DataChunk sourceChunk) throws IOException {
+            final ByteBuffer sourceDataBuffer=sourceChunk.dataBuffer;
+            if(!sourceChunk.canRead){
+                throw new IOException("Buffer has not been rewind !");
+            }
+            
+            if (sourceChunk.nRecords > 0 && sourceChunk.recordsRead>=sourceChunk.nRecords){
+                return -1;
+            }
+            //  check that internal buffer has enough data to read data size
+            if (LEN_SIZE_SPECIFIER > sourceDataBuffer.remaining()){
+                sourceChunk.reloadBuffer();
+                if(LEN_SIZE_SPECIFIER > sourceDataBuffer.remaining()) return -1;
+            }
+            recordSize = ByteBufferUtils.decodeLength(sourceDataBuffer);
+            
+            //  check that internal buffer has enough data to read data record
+            if (recordSize > sourceDataBuffer.remaining()){
+                sourceChunk.reloadBuffer();
+                if(recordSize > sourceDataBuffer.remaining()) return -1;
+            }
+            
+            int oldLimit = sourceDataBuffer.limit();
+            sourceDataBuffer.limit(sourceDataBuffer.position() + recordSize);
+        
+            //write it here         
+            final int lengthSize=ByteBufferUtils.lengthEncoded(recordSize);
+            // check that internal buffer has enough space
+            if ((recordSize + lengthSize) > dataBuffer.remaining()){
+                    flushBuffer();
+                }
+            
+            try {
+                ByteBufferUtils.encodeLength(dataBuffer, recordSize);
+                dataBuffer.put(sourceDataBuffer);
+            } catch (BufferOverflowException ex) {
+                throw new IOException("Input Buffer is not big enough to accomodate data record !");
+            }
+            
+            // end write 
+            sourceDataBuffer.limit(oldLimit);
+            length+=(recordSize+ lengthSize);
+            nRecords++;
+            return length;            
+        }
+        
+        
 		 /**
 		  * Stores one data record into buffer / file.
 		  * 
 		 * @param data	DataRecord to be stored
-		 *@return number of bytes in the chunk after saveing data
+		 *@return number of bytes in the chunk after saving data
 		 * @throws IOException
 		 */
 		long put(DataRecord data) throws IOException {
-				int recordSize = data.getSizeSerialized();
-				
+				recordSize = data.getSizeSerialized();
+                final int lengthSize=ByteBufferUtils.lengthEncoded(recordSize);
 				// check that internal buffer has enough space
-				if ((recordSize + LEN_SIZE_SPECIFIER) > dataBuffer.remaining()){
+				if ((recordSize + lengthSize) > dataBuffer.remaining()){
 						flushBuffer();
 					}
 				
 				try {
-					dataBuffer.putInt(recordSize);
+                    ByteBufferUtils.encodeLength(dataBuffer, recordSize);
 					data.serialize(dataBuffer);
 				} catch (BufferOverflowException ex) {
-					throw new RuntimeException("Input Buffer is not big enough to accomodate data record !");
+					throw new IOException("Input Buffer is not big enough to accomodate data record !");
 				}
 				
-				length+=(recordSize+ LEN_SIZE_SPECIFIER);
+				length+=(recordSize+ lengthSize);
 				nRecords++;
 				return length;
 			}
@@ -528,9 +658,8 @@
 		 *@since                   September 17, 2002
 		 */
 		 boolean get(ByteBuffer recordBuffer) throws IOException {
-			int recordSize;
 			if(!canRead){
-				throw new RuntimeException("Buffer has not been rewind !");
+				throw new IOException("Buffer has not been rewind !");
 			}
 			
 			if (nRecords > 0 && recordsRead>=nRecords){
@@ -541,8 +670,7 @@
 			    reloadBuffer();
 			    if(LEN_SIZE_SPECIFIER > dataBuffer.remaining()) return false;
 			}
-			recordSize = dataBuffer.getInt();
-			position+=LEN_SIZE_SPECIFIER;
+			recordSize = ByteBufferUtils.decodeLength(dataBuffer);
 			
 			//	check that internal buffer has enough data to read data record
 			if (recordSize > dataBuffer.remaining()){
@@ -550,17 +678,72 @@
 			    if(recordSize > dataBuffer.remaining()) return false;
 			}
 			int oldLimit = dataBuffer.limit();
+            dataBuffer.mark(); //could be used later in reget method
 			dataBuffer.limit(dataBuffer.position() + recordSize);
             recordBuffer.clear();
 			recordBuffer.put(dataBuffer);
 			recordBuffer.flip();
 			dataBuffer.limit(oldLimit);
 			
-			position+=recordSize;
 			recordsRead++;
 			return true;
 		}
 
+         /**
+          * Read again previously read record. Use caution when calling this
+          * method as it lifts most of the safety checks. Should be used
+          * only immediately after successful get(ByteBuffer) call
+          * 
+         * @param recordBuffer
+         * @return
+         * @throws IOException
+         * @since 27.2.2007
+         */
+        boolean reget(ByteBuffer recordBuffer) throws IOException {
+                dataBuffer.reset();
+                int oldLimit = dataBuffer.limit();
+                dataBuffer.limit(dataBuffer.position() + recordSize);
+                recordBuffer.clear();
+                recordBuffer.put(dataBuffer);
+                recordBuffer.flip();
+                dataBuffer.limit(oldLimit);
+                return true;
+            }
+         
+         
+         protected ByteBuffer bulkGetStart() throws IOException {
+                final int recordSize;
+                if(!canRead){
+                    throw new IOException("Buffer has not been rewind !");
+                }
+                
+                if (nRecords > 0 && recordsRead>=nRecords){
+                    return null;
+                }
+                //  check that internal buffer has enough data to read data size
+                if (LEN_SIZE_SPECIFIER > dataBuffer.remaining()){
+                    reloadBuffer();
+                    if(LEN_SIZE_SPECIFIER > dataBuffer.remaining()) return null;
+                }
+                recordSize = ByteBufferUtils.decodeLength(dataBuffer);
+                
+                //  check that internal buffer has enough data to read data record
+                if (recordSize > dataBuffer.remaining()){
+                    reloadBuffer();
+                    if(recordSize > dataBuffer.remaining()) return null;
+                }
+                int oldLimit = dataBuffer.limit();
+                dataBuffer.limit(dataBuffer.position() + recordSize);
+                //write it here
+                
+                dataBuffer.limit(oldLimit);
+                recordsRead++;
+                return dataBuffer;
+            }
+
+       
+         
+         
 		 /**
 		  * Returns next record from the buffer - FIFO order.
 		 * @param data	DataRecord into which load the data
@@ -568,9 +751,8 @@
 		 * @throws IOException
 		 */
 		boolean get(DataRecord data) throws IOException {
-				int recordSize;
 				if(!canRead){
-					throw new RuntimeException("Buffer has not been rewind !");
+					throw new IOException("Buffer has not been rewind !");
 				}
 				
 				if (nRecords > 0 && recordsRead>=nRecords){
@@ -581,21 +763,28 @@
 				    reloadBuffer();
                     if(LEN_SIZE_SPECIFIER > dataBuffer.remaining()) return false;
 				}
-				recordSize = dataBuffer.getInt();
-				position+=LEN_SIZE_SPECIFIER;
+                recordSize = ByteBufferUtils.decodeLength(dataBuffer);
 				
 				//	check that internal buffer has enough data to read data record
 				if (recordSize > dataBuffer.remaining()){
 				    reloadBuffer();
                     if(recordSize > dataBuffer.remaining()) return false;
 				}
+                dataBuffer.mark();//could be used later for reget
 				data.deserialize(dataBuffer);
 				
-				position+=recordSize;
 				recordsRead++;
 				return true;
 			}
-		 
+		
+
+        boolean reget(DataRecord data) throws IOException {
+            dataBuffer.reset();
+            data.deserialize(dataBuffer);
+            return true;
+        }
+        
+        
 		/**
 		 *  Flushes in memory buffer into TMP file
 		 *



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 21:36:56 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 21:36:56 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2532 -
	trunk/cloveretl.component/src/org/jetel/component
Message-ID: <200702272036.l1RKauDF004335@sheep.berlios.de>

Author: dpavlis
Date: 2007-02-27 21:36:55 +0100 (Tue, 27 Feb 2007)
New Revision: 2532

Modified:
   trunk/cloveretl.component/src/org/jetel/component/Denormalizer.java
   trunk/cloveretl.component/src/org/jetel/component/Normalizer.java
Log:
MINOR:static logger initialized with class name (was HashJoin)

Modified: trunk/cloveretl.component/src/org/jetel/component/Denormalizer.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/Denormalizer.java	2007-02-27 19:39:58 UTC (rev 2531)
+++ trunk/cloveretl.component/src/org/jetel/component/Denormalizer.java	2007-02-27 20:36:55 UTC (rev 2532)
@@ -116,7 +116,7 @@
 
 	private Properties transformationParameters;
 
-	static Log logger = LogFactory.getLog(HashJoin.class);
+	static Log logger = LogFactory.getLog(Denormalizer.class);
 
 	private InputPort inPort;
 	private OutputPort outPort;

Modified: trunk/cloveretl.component/src/org/jetel/component/Normalizer.java
===================================================================
--- trunk/cloveretl.component/src/org/jetel/component/Normalizer.java	2007-02-27 19:39:58 UTC (rev 2531)
+++ trunk/cloveretl.component/src/org/jetel/component/Normalizer.java	2007-02-27 20:36:55 UTC (rev 2532)
@@ -101,7 +101,7 @@
 
 	private Properties transformationParameters;
 
-	static Log logger = LogFactory.getLog(HashJoin.class);
+	static Log logger = LogFactory.getLog(Normalizer.class);
 
 	private InputPort inPort;
 	private OutputPort outPort;



From cloveretl-svn-commits at lists.berlios.de  Tue Feb 27 22:54:27 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Tue, 27 Feb 2007 22:54:27 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2533 -
	trunk/cloveretl.engine/src/org/jetel/graph/runtime
Message-ID: <200702272154.l1RLsRRo014287@sheep.berlios.de>

Author: dpavlis
Date: 2007-02-27 22:54:26 +0100 (Tue, 27 Feb 2007)
New Revision: 2533

Modified:
   trunk/cloveretl.engine/src/org/jetel/graph/runtime/WatchDog.java
Log:
FIX:error in assigning phase tracking

Modified: trunk/cloveretl.engine/src/org/jetel/graph/runtime/WatchDog.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/graph/runtime/WatchDog.java	2007-02-27 20:36:55 UTC (rev 2532)
+++ trunk/cloveretl.engine/src/org/jetel/graph/runtime/WatchDog.java	2007-02-27 21:54:26 UTC (rev 2533)
@@ -319,7 +319,8 @@
 			if (leafNodes.isEmpty()) {
                 PhaseTrackingDetail phaseTracking=new PhaseTrackingDetail((int) (System.currentTimeMillis() - startTimestamp)
                                                     ,phaseMemUtilizationMax);
-				logger.info("Execution of phase [" + phase.getPhaseNum() + "] successfully finished - elapsed time(sec): "
+				phase.setPhaseTracking(phaseTracking);
+                logger.info("Execution of phase [" + phase.getPhaseNum() + "] successfully finished - elapsed time(sec): "
 						+ phaseTracking.getExecTime() / 1000);
 				//printProcessingStatus(phase.getNodes().iterator(), phase.getPhaseNum());
                 printTracking.execute();// print tracking



From cloveretl-svn-commits at lists.berlios.de  Wed Feb 28 09:32:54 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 28 Feb 2007 09:32:54 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2534 - in
	trunk/cloveretl.engine: src/org/jetel/util test/org/jetel/util
Message-ID: <200702280832.l1S8Ws9r010986@sheep.berlios.de>

Author: agad
Date: 2007-02-28 09:32:49 +0100 (Wed, 28 Feb 2007)
New Revision: 2534

Modified:
   trunk/cloveretl.engine/src/org/jetel/util/NumberIterator.java
   trunk/cloveretl.engine/test/org/jetel/util/NumberIteratorTest.java
Log:
BUGFIX:NumberIterator - method next throwed NullPionterException instead of NoSuchElementException

Modified: trunk/cloveretl.engine/src/org/jetel/util/NumberIterator.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/util/NumberIterator.java	2007-02-27 21:54:26 UTC (rev 2533)
+++ trunk/cloveretl.engine/src/org/jetel/util/NumberIterator.java	2007-02-28 08:32:49 UTC (rev 2534)
@@ -96,7 +96,7 @@
 	 * @see java.util.Iterator#next()
 	 */
 	public Integer next() {
-		tmp = new Integer(next);
+		tmp = next;
 		if (next == null) {
 			throw new NoSuchElementException();
 		}

Modified: trunk/cloveretl.engine/test/org/jetel/util/NumberIteratorTest.java
===================================================================
--- trunk/cloveretl.engine/test/org/jetel/util/NumberIteratorTest.java	2007-02-27 21:54:26 UTC (rev 2533)
+++ trunk/cloveretl.engine/test/org/jetel/util/NumberIteratorTest.java	2007-02-28 08:32:49 UTC (rev 2534)
@@ -1,5 +1,7 @@
 package org.jetel.util;
 
+import java.util.NoSuchElementException;
+
 import junit.framework.TestCase;
 
 public class NumberIteratorTest extends TestCase {
@@ -23,6 +25,12 @@
     	for (int i=0;i<14;i++){
     		System.out.print(numbers.next() + ",");
     	}
+    	try{
+    		numbers.next();
+    		fail("There is not next elemet!!!");
+    	}catch(NoSuchElementException e){
+    		
+    	}
      }
 
     @Override



From cloveretl-svn-commits at lists.berlios.de  Wed Feb 28 11:26:58 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 28 Feb 2007 11:26:58 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2535 -
	trunk/cloveretl.engine
Message-ID: <200702281026.l1SAQwaF021661@sheep.berlios.de>

Author: otasanek
Date: 2007-02-28 11:26:58 +0100 (Wed, 28 Feb 2007)
New Revision: 2535

Modified:
   trunk/cloveretl.engine/build.properties
Log:
UPDATE: added log4j property into build.properties file.

Modified: trunk/cloveretl.engine/build.properties
===================================================================
--- trunk/cloveretl.engine/build.properties	2007-02-28 08:32:49 UTC (rev 2534)
+++ trunk/cloveretl.engine/build.properties	2007-02-28 10:26:58 UTC (rev 2535)
@@ -13,6 +13,7 @@
 
 engine.dist=/cloveretl.engine.jar
 connection.dist=/plugins/org.jetel.connection/cloveretl.connection.jar
+component.dist=/plugins/org.jetel.component/cloveretl.component.jar
 lookup.dist=/plugins/org.jetel.lookup/cloveretl.lookup.jar
 sequence.dist=/plugins/org.jetel.sequence/cloveretl.sequence.jar
 
@@ -20,3 +21,4 @@
 jdk.home=<absolute_path_to_jdk>
 tools=${jdk.home}/lib/tools.jar
 commons-logging=<absolute_path_to_commons-logging_library>
+log4j=<absolute_path_to_log4j_library>



From cloveretl-svn-commits at lists.berlios.de  Wed Feb 28 17:18:40 2007
From: cloveretl-svn-commits at lists.berlios.de (cloveretl-svn-commits at lists.berlios.de)
Date: Wed, 28 Feb 2007 17:18:40 +0100
Subject: [Cloveretl-svn-commits] CloverETL repos r2536 -
	trunk/cloveretl.engine/src/org/jetel/graph/runtime
Message-ID: <200702281618.l1SGIeKq000625@sheep.berlios.de>

Author: dpavlis
Date: 2007-02-28 17:18:39 +0100 (Wed, 28 Feb 2007)
New Revision: 2536

Modified:
   trunk/cloveretl.engine/src/org/jetel/graph/runtime/NodeTrackingDetail.java
   trunk/cloveretl.engine/src/org/jetel/graph/runtime/TrackingDetail.java
   trunk/cloveretl.engine/src/org/jetel/graph/runtime/WatchDog.java
Log:
UPDATE:added getPhase(),getNodeName()

Modified: trunk/cloveretl.engine/src/org/jetel/graph/runtime/NodeTrackingDetail.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/graph/runtime/NodeTrackingDetail.java	2007-02-28 10:26:58 UTC (rev 2535)
+++ trunk/cloveretl.engine/src/org/jetel/graph/runtime/NodeTrackingDetail.java	2007-02-28 16:18:39 UTC (rev 2536)
@@ -35,6 +35,7 @@
     private static final long serialVersionUID = 9164050461393378702L;
     
     private String nodeId;
+    private String nodeName;
     private long timestamp;
     private int timespan;
     private Result result;
@@ -54,9 +55,12 @@
     private int avgWaitingTime;
     private int waitingRows[];
     private int avgWaitingRows[];
+    private int phase;
     
-    public NodeTrackingDetail(String id,int inputPorts,int outputPorts){
+    public NodeTrackingDetail(String id,String name,int phase,int inputPorts,int outputPorts){
         this.nodeId=id;
+        this.nodeName=name;
+        this.phase=phase;
         this.numInputPorts=inputPorts;
         this.numOutputPorts=outputPorts;
         final int ports=Math.max(inputPorts, outputPorts);
@@ -182,6 +186,14 @@
         return nodeId;
     }
 
+    public String getNodeName() {
+        return nodeName;
+    }
+    
+    public int getPhase() {
+        return phase;
+    }
+    
     /* (non-Javadoc)
      * @see org.jetel.graph.runtime.GraphTrackingDetail#getTimestamp()
      */

Modified: trunk/cloveretl.engine/src/org/jetel/graph/runtime/TrackingDetail.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/graph/runtime/TrackingDetail.java	2007-02-28 10:26:58 UTC (rev 2535)
+++ trunk/cloveretl.engine/src/org/jetel/graph/runtime/TrackingDetail.java	2007-02-28 16:18:39 UTC (rev 2536)
@@ -42,6 +42,8 @@
     public long getTotalUserTime();
     public int getTotalRows(int portType,int portNum);
     public String getNodeId();
+    public String getNodeName();
+    public int getPhase();
     public long getTimestamp();
     public int getNumInputPorts();
     public int getNumOutputPorts();

Modified: trunk/cloveretl.engine/src/org/jetel/graph/runtime/WatchDog.java
===================================================================
--- trunk/cloveretl.engine/src/org/jetel/graph/runtime/WatchDog.java	2007-02-28 10:26:58 UTC (rev 2535)
+++ trunk/cloveretl.engine/src/org/jetel/graph/runtime/WatchDog.java	2007-02-28 16:18:39 UTC (rev 2536)
@@ -361,7 +361,7 @@
                     int inPortsNum=node.getInPorts().size();
                     int outPortsNum=node.getOutPorts().size();
                     if (trackingDetail==null){
-                        trackingDetail=new NodeTrackingDetail(nodeId,inPortsNum,outPortsNum);
+                        trackingDetail=new NodeTrackingDetail(nodeId,node.getName(),phase.getPhaseNum(),inPortsNum,outPortsNum);
                         tracking.put(nodeId, trackingDetail);
                     }
                     trackingDetail.timestamp();



