<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cloveretl-svn-commits] CloverETL repos r2610 -	trunk/cloveretl.engine/examples
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cloveretl-svn-commits/2007-March/index.html" >
   <LINK REL="made" HREF="mailto:cloveretl-svn-commits%40lists.berlios.de?Subject=Re%3A%20%5BCloveretl-svn-commits%5D%20CloverETL%20repos%20r2610%20-%0A%09trunk/cloveretl.engine/examples&In-Reply-To=%3C200703130838.l2D8ckJv031512%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000245.html">
   <LINK REL="Next"  HREF="000247.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cloveretl-svn-commits] CloverETL repos r2610 -	trunk/cloveretl.engine/examples</H1>
    <B>cloveretl-svn-commits at lists.berlios.de</B> 
    <A HREF="mailto:cloveretl-svn-commits%40lists.berlios.de?Subject=Re%3A%20%5BCloveretl-svn-commits%5D%20CloverETL%20repos%20r2610%20-%0A%09trunk/cloveretl.engine/examples&In-Reply-To=%3C200703130838.l2D8ckJv031512%40sheep.berlios.de%3E"
       TITLE="[Cloveretl-svn-commits] CloverETL repos r2610 -	trunk/cloveretl.engine/examples">cloveretl-svn-commits at lists.berlios.de
       </A><BR>
    <I>Tue Mar 13 09:38:46 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000245.html">[Cloveretl-svn-commits] CloverETL repos r2609 -	trunk/cloveretl.engine/examples
</A></li>
        <LI>Next message: <A HREF="000247.html">[Cloveretl-svn-commits] CloverETL repos r2611 -	trunk/cloveretl.engine/examples
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#246">[ date ]</a>
              <a href="thread.html#246">[ thread ]</a>
              <a href="subject.html#246">[ subject ]</a>
              <a href="author.html#246">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: agad
Date: 2007-03-13 09:38:45 +0100 (Tue, 13 Mar 2007)
New Revision: 2610

Modified:
   trunk/cloveretl.engine/examples/readme.html
Log:
CHANGE:data was split and moved to data/delimited, data/fixlen or data/other

Modified: trunk/cloveretl.engine/examples/readme.html
===================================================================
--- trunk/cloveretl.engine/examples/readme.html	2007-03-13 08:38:33 UTC (rev 2609)
+++ trunk/cloveretl.engine/examples/readme.html	2007-03-13 08:38:45 UTC (rev 2610)
@@ -5,11 +5,17 @@
 	&lt;TITLE&gt;CloverETL examples&lt;/TITLE&gt;
 	&lt;META NAME=&quot;GENERATOR&quot; CONTENT=&quot;OpenOffice.org 2.0  (Linux)&quot;&gt;
 	&lt;META NAME=&quot;CREATED&quot; CONTENT=&quot;20061005;11474600&quot;&gt;
-	&lt;META NAME=&quot;CHANGED&quot; CONTENT=&quot;20061010;11064100&quot;&gt;
+	&lt;META NAME=&quot;CHANGED&quot; CONTENT=&quot;20070313;9172900&quot;&gt;
+	&lt;STYLE TYPE=&quot;text/css&quot;&gt;
+	&lt;!--
+		@page { size: 8.5in 11in }
+	--&gt;
+	&lt;/STYLE&gt;
 &lt;/HEAD&gt;
 &lt;BODY LANG=&quot;en-US&quot; DIR=&quot;LTR&quot;&gt;
 &lt;H1&gt;&lt;FONT COLOR=&quot;#008000&quot;&gt;CloverETL examples&lt;/FONT&gt;&lt;/H1&gt;
-&lt;P STYLE=&quot;margin-bottom: 0in&quot;&gt;&lt;I&gt;by David Pavlis, Last modified 
+&lt;P STYLE=&quot;margin-bottom: 0in&quot;&gt;&lt;I&gt;by David Pavlis, Agata Vackova, Last
+modified 
 &lt;SCRIPT LANGUAGE=&quot;javascript&quot;&gt;
 document.writeln(document.lastModified)
 &lt;/SCRIPT&gt;
@@ -37,13 +43,16 @@
 &lt;P&gt;In the directory with examples there is file workspace.prm with
 WORKSPACE parameter definition. You have to change this parameter to
 proper value before running graphs.&lt;/P&gt;
+&lt;P&gt;To run graphs you can use scripts (run.bat or run.sh) included in
+examples package. They assumes that environment variable JAVA_HOME is
+set to java home directory.&lt;/P&gt;
 &lt;H4&gt;Important notes&lt;/H4&gt;
 &lt;P&gt;All the examples below show how to run transformations on Linux
 (Unix) machine. If you have Windows installed, just change the &lt;TT&gt;java
 -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
 &lt;/TT&gt;into &lt;TT&gt;-cp
-&lt;TT&gt;&quot;../cloveretl.engine.jar;../lib/commons-logging.jar;../lib/log4j-1.2.12.zip;./&quot;&lt;/TT&gt;&lt;/TT&gt;
+&lt;TT&gt;&quot;../cloveretl.engine.jar;../lib/commons-logging.jar;../lib/log4j-1.2.12.zip;&lt;TT&gt;../lib/javolution.jar;javaExamples&lt;/TT&gt;&quot;&lt;/TT&gt;&lt;/TT&gt;
 - the Java classpath delimiter on Windows is &lt;TT&gt;;&lt;/TT&gt; (semicolon)
 not &lt;TT&gt;:&lt;/TT&gt; (colon). 
 &lt;/P&gt;
@@ -61,44 +70,48 @@
 receives on input port. 
 &lt;/P&gt;
 &lt;P STYLE=&quot;margin-bottom: 0in&quot;&gt;Executing:&lt;/P&gt;
-&lt;P STYLE=&quot;margin-bottom: 0in&quot;&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&lt;P STYLE=&quot;margin-bottom: 0in&quot;&gt;&lt;TT&gt;&lt;TT&gt;java -cp
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;&lt;/TT&gt;
 org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphSimpleCopy.grf&quot; TARGET=&quot;_blank&quot;&gt;graphSimpleCopy.grf&lt;/A&gt;&lt;/TT&gt;&lt;BR&gt;&lt;BR&gt;This
 is the expected output produced by the framework: 
 &lt;/P&gt;
 &lt;HR&gt;
-&lt;PRE&gt;&lt;TT&gt;***  CloverETL framework/transformation graph runner ver 1.8, (c) 2002-06 D.Pavlis, released under GNU Lesser General Public License  ***&lt;/TT&gt;
-&lt;TT&gt; Running with framework version: 2.0 build#0 compiled 25/09/2006 16:46:39&lt;/TT&gt;
+&lt;PRE&gt;&lt;TT&gt;***  CloverETL framework/transformation graph runner ver 2.1, (c) 2002-06 D.Pavlis, released under GNU Lesser General Public License  ***&lt;/TT&gt;
+&lt;TT&gt; Running with framework version: 2.1 build#385 compiled 14/02/2007 18:12:57&lt;/TT&gt;
 
 &lt;TT&gt;DEBUG [main] - Plugin org.jetel.lookup loaded.&lt;/TT&gt;
 &lt;TT&gt;        id - org.jetel.lookup&lt;/TT&gt;
-&lt;TT&gt;        version - 1.9.0&lt;/TT&gt;
+&lt;TT&gt;        version - 2.1.0&lt;/TT&gt;
 &lt;TT&gt;        provider-name - null&lt;/TT&gt;
 &lt;TT&gt;                point-id  - lookup - {className=org.jetel.lookup.SimpleLookupTable, type=simpleLookup}&lt;/TT&gt;
 &lt;TT&gt;                point-id  - lookup - {className=org.jetel.lookup.DBLookupTable, type=dbLookup}&lt;/TT&gt;
 
 &lt;TT&gt;DEBUG [main] - Plugin org.jetel.sequence loaded.&lt;/TT&gt;
 &lt;TT&gt;        id - org.jetel.sequence&lt;/TT&gt;
-&lt;TT&gt;        version - 1.9.0&lt;/TT&gt;
+&lt;TT&gt;        version - 2.1.0&lt;/TT&gt;
 &lt;TT&gt;        provider-name - null&lt;/TT&gt;
 &lt;TT&gt;                point-id  - sequence - {className=org.jetel.sequence.SimpleSequence, type=SIMPLE_SEQUENCE}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - sequence - {className=org.jetel.sequence.PrimitiveSequence, type=PRIMITIVE_SEQUENCE}&lt;/TT&gt;
 
 &lt;TT&gt;DEBUG [main] - Plugin org.jetel.thirdparty loaded.&lt;/TT&gt;
 &lt;TT&gt;        id - org.jetel.thirdparty&lt;/TT&gt;
-&lt;TT&gt;        version - 1.9.0&lt;/TT&gt;
+&lt;TT&gt;        version - 2.1.0&lt;/TT&gt;
 &lt;TT&gt;        provider-name - null&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=XML_EXTRACT, className=org.jetel.component.XMLExtract}&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=FILTER, className=org.jetel.component.Filter}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {type=LDAP_READER, className=com.linagora.component.LdapReader}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {type=LDAP_WRITER, className=com.linagora.component.LdapWriter}&lt;/TT&gt;
 
 &lt;TT&gt;DEBUG [main] - Plugin org.jetel.connection loaded.&lt;/TT&gt;
 &lt;TT&gt;        id - org.jetel.connection&lt;/TT&gt;
-&lt;TT&gt;        version - 1.9.0&lt;/TT&gt;
+&lt;TT&gt;        version - 2.1.0&lt;/TT&gt;
 &lt;TT&gt;        provider-name - null&lt;/TT&gt;
 &lt;TT&gt;                point-id  - connection - {className=org.jetel.connection.DBConnection, type=JDBC}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - connection - {className=org.jetel.connection.JmsConnection, type=JMS}&lt;/TT&gt;
 
 &lt;TT&gt;DEBUG [main] - Plugin org.jetel.component loaded.&lt;/TT&gt;
 &lt;TT&gt;        id - org.jetel.component&lt;/TT&gt;
-&lt;TT&gt;        version - 1.9.0&lt;/TT&gt;
+&lt;TT&gt;        version - 2.1.0&lt;/TT&gt;
 &lt;TT&gt;        provider-name - null&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=DATA_READER, className=org.jetel.component.DataReader}&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=DATA_WRITER, className=org.jetel.component.DataWriter}&lt;/TT&gt;
@@ -111,15 +124,17 @@
 &lt;TT&gt;                point-id  - component - {type=DB_INPUT_TABLE, className=org.jetel.component.DBInputTable}&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=SORT, className=org.jetel.component.Sort}&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=DB_OUTPUT_TABLE, className=org.jetel.component.DBOutputTable}&lt;/TT&gt;
-&lt;TT&gt;                point-id  - component - {type=FIXLEN_DATA_WRITER_NIO, className=org.jetel.component.FixLenDataWriterNIO}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {type=FIXLEN_DATA_WRITER, className=org.jetel.component.FixLenDataWriter}&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=DEDUP, className=org.jetel.component.Dedup}&lt;/TT&gt;
-&lt;TT&gt;                point-id  - component - {type=FIXLEN_DATA_READER_NIO, className=org.jetel.component.FixLenDataReaderNIO}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {type=FIXLEN_DATA_READER, className=org.jetel.component.FixLenDataReader}&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=MERGE, className=org.jetel.component.Merge}&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=MERGE_JOIN, className=org.jetel.component.MergeJoin}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {type=EXT_MERGE_JOIN, className=org.jetel.component.MergeJoin}&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=SORTED_JOIN, className=org.jetel.component.MergeJoin}&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=TRASH, className=org.jetel.component.Trash}&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=DB_EXECUTE, className=org.jetel.component.DBExecute}&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=HASH_JOIN, className=org.jetel.component.HashJoin}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {type=EXT_HASH_JOIN, className=org.jetel.component.HashJoin}&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=CHECK_FOREIGN_KEY, className=org.jetel.component.CheckForeignKey}&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=DBF_DATA_READER, className=org.jetel.component.DBFDataReader}&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=EXT_FILTER, className=org.jetel.component.ExtFilter}&lt;/TT&gt;
@@ -131,17 +146,45 @@
 &lt;TT&gt;                point-id  - component - {type=KEY_GEN, className=org.jetel.component.KeyGenerator}&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=APROX_MERGE_JOIN, className=org.jetel.component.AproxMergeJoin}&lt;/TT&gt;
 &lt;TT&gt;                point-id  - component - {type=DBJOIN, className=org.jetel.component.DBJoin}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {type=XLS_READER, className=org.jetel.component.XLSReader}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {type=XLS_WRITER, className=org.jetel.component.XLSWriter}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {type=CLOVER_WRITER, className=org.jetel.component.CloverDataWriter}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {type=CLOVER_READER, className=org.jetel.component.CloverDataReader}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {className=org.jetel.component.MysqlDataReader, type=MYSQL_DATA_READER}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {className=org.jetel.component.MysqlDataWriter, type=MYSQL_DATA_WRITER}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {className=org.jetel.component.StructureWriter, type=STRUCTURE_WRITER}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {className=org.jetel.component.Normalizer, type=NORMALIZER}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {className=org.jetel.component.Denormalizer, type=DENORMALIZER}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {className=org.jetel.component.JmsReader, type=JMS_READER}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {className=org.jetel.component.JmsWriter, type=JMS_WRITER}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {className=org.jetel.component.LookupJoin, type=LOOKUP_JOIN}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {className=org.jetel.component.LookupTableReaderWriter, type=LOOKUP_TABLE_READER_WRITER}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {className=org.jetel.component.DataGenerator, type=DATA_GENERATOR}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {className=org.jetel.component.MultiLevelReader, type=MULTI_LEVEL_READER}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {className=org.jetel.component.SequenceChecker, type=SEQUENCE_CHECKER}&lt;/TT&gt;
 
+&lt;TT&gt;DEBUG [main] - Plugin cz.opensys.oracle loaded.&lt;/TT&gt;
+&lt;TT&gt;        id - cz.opensys.oracle&lt;/TT&gt;
+&lt;TT&gt;        version - 2.1.0&lt;/TT&gt;
+&lt;TT&gt;        provider-name -&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {className=cz.opensys.oracle.component.OracleDataReader, type=ORACLE_DATA_READER}&lt;/TT&gt;
+&lt;TT&gt;                point-id  - component - {className=cz.opensys.oracle.component.OracleDataWriter, type=ORACLE_DATA_WRITER}&lt;/TT&gt;
+
 &lt;TT&gt;Graph definition file: graphSimpleCopy.grf&lt;/TT&gt;
+&lt;TT&gt;INFO  [main] - Checking graph configuration...&lt;/TT&gt;
+&lt;TT&gt;DEBUG [main] - Opening input file /home/avackova/home/eclipse/cloverETL/examples/data/delimited/employees.dat&lt;/TT&gt;
+&lt;TT&gt;DEBUG [main] - Reading input file /home/avackova/home/eclipse/cloverETL/examples/data/delimited/employees.dat&lt;/TT&gt;
 &lt;TT&gt;INFO  [main] - Starting WatchDog thread ...&lt;/TT&gt;
 &lt;TT&gt;INFO  [WatchDog] - Thread started.&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] - Running on 1 CPU(s) max available memory for JVM 1296 KB&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] - Running on 1 CPU(s) max available memory for JVM 65088 KB&lt;/TT&gt;
 &lt;TT&gt;INFO  [WatchDog] - [Clover] Initializing phase: 0&lt;/TT&gt;
 &lt;TT&gt;DEBUG [WatchDog] -  initializing edges:&lt;/TT&gt;
 &lt;TT&gt;DEBUG [WatchDog] -  all edges initialized successfully...&lt;/TT&gt;
 &lt;TT&gt;DEBUG [WatchDog] -  initializing nodes:&lt;/TT&gt;
 &lt;TT&gt;DEBUG [WatchDog] -      BROADCAST ...OK&lt;/TT&gt;
 &lt;TT&gt;DEBUG [WatchDog] -      BROADCAST2 ...OK&lt;/TT&gt;
+&lt;TT&gt;DEBUG [WatchDog] - Opening input file /home/avackova/home/eclipse/cloverETL/examples/data/delimited/employees.dat&lt;/TT&gt;
+&lt;TT&gt;DEBUG [WatchDog] - Reading input file /home/avackova/home/eclipse/cloverETL/examples/data/delimited/employees.dat&lt;/TT&gt;
 &lt;TT&gt;DEBUG [WatchDog] -      INPUT1 ...OK&lt;/TT&gt;
 &lt;TT&gt;DEBUG [WatchDog] -      TRASH1 ...OK&lt;/TT&gt;
 &lt;TT&gt;DEBUG [WatchDog] -      TRASH2 ...OK&lt;/TT&gt;
@@ -157,50 +200,50 @@
 &lt;TT&gt;INFO  [WatchDog] - Sucessfully started all nodes in phase!&lt;/TT&gt;
 &lt;TT&gt;INFO  [WatchDog] - Execution of phase [0] successfully finished - elapsed time(sec): 1&lt;/TT&gt;
 &lt;TT&gt;INFO  [WatchDog] - ---------------------** Start of tracking Log for phase [0] **-------------------&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] - Time: 05/10/06 13:53:01&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] - Node                        Status         Port                          #Records&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] - ---------------------------------------------------------------------------------&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] - BROADCAST                   OK&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] -                                             In:0                               12&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] -                                            Out:0                               12&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] -                                            Out:1                               12&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] -                                            Out:2                               12&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] - BROADCAST2                  OK&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] -                                             In:0                               12&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] -                                            Out:0                               12&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] - INPUT1                      OK&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] -                                            Out:0                               12&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] - TRASH1                      OK&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] -                                             In:0                               12&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] - TRASH2                      OK&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] -                                             In:0                               12&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] - TRASH3                      OK&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] -                                             In:0                               12&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] - Time: 09/03/07 11:00:25&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] - Node                   Status     Port      #Records         #KB  Rec/s   KB/s&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] - ----------------------------------------------------------------------------------&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] - BROADCAST              FINISHED_O&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] - %CPU:-1.9                          In:0           12           8      0       0&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] -                                   Out:0           12           8      0       0&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] -                                   Out:1           12           8      0       0&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] -                                   Out:2           12           8      0       0&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] - BROADCAST2             FINISHED_O&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] - %CPU:-1.9                          In:0           12           8      0       0&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] -                                   Out:0           12           8      0       0&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] - INPUT1                 FINISHED_O&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] - %CPU:-1.9                         Out:0           12           8      0       0&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] - TRASH1                 FINISHED_O&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] - %CPU:-1.9                          In:0           12           8      0       0&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] - TRASH2                 FINISHED_O&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] - %CPU:-1.9                          In:0           12           8      0       0&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] - TRASH3                 FINISHED_O&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] - %CPU:-1.9                          In:0           12           8      0       0&lt;/TT&gt;
 &lt;TT&gt;INFO  [WatchDog] - ---------------------------------** End of Log **--------------------------------&lt;/TT&gt;
 &lt;TT&gt;INFO  [WatchDog] - Forcing garbage collection ...&lt;/TT&gt;
 &lt;TT&gt;INFO  [WatchDog] - -----------------------** Summary of Phases execution **---------------------&lt;/TT&gt;
 &lt;TT&gt;INFO  [WatchDog] - Phase#            Finished Status         RunTime(sec)    MemoryAllocation(KB)&lt;/TT&gt;
-&lt;TT&gt;INFO  [WatchDog] - 0                 0                                  1                64&lt;/TT&gt;
+&lt;TT&gt;INFO  [WatchDog] - 0                 0                                  1               842&lt;/TT&gt;
 &lt;TT&gt;INFO  [WatchDog] - ------------------------------** End of Summary **---------------------------&lt;/TT&gt;
 &lt;TT&gt;INFO  [main] - WatchDog thread finished - total execution time: 1 (sec)&lt;/TT&gt;
-&lt;TT&gt;INFO  [main] - Graph execution finished successfully&lt;/TT&gt;
-&lt;TT&gt;Execution of graph successful !&lt;/TT&gt;&lt;/PRE&gt;
-&lt;HR&gt;
-&lt;H3&gt;&lt;!-- Reformat --&gt;Reformat example&lt;/H3&gt;
+&lt;TT&gt;INFO  [main] - Graph execution finished successfully&lt;/TT&gt;&lt;/PRE&gt;&lt;H3&gt;
+&lt;!-- Reformat --&gt;Reformat example&lt;/H3&gt;
 &lt;P&gt;Reformat component changes format and/or content of data records
 by applying &quot;reformat&quot; method on all data records flowing
 through it.&lt;BR&gt;For every record it receives through input port it
 calls &lt;TT&gt;transform()&lt;/TT&gt; method of specified class (name defined
 through &lt;TT&gt;transformClass&lt;/TT&gt; attribute of Reformat component),
-which has to implement &lt;TT&gt;&lt;A HREF=&quot;reformatOrders.java&quot;&gt;org.jetel.component.RecordTransform&lt;/A&gt;&lt;/TT&gt;
+which has to implement &lt;TT&gt;&lt;A HREF=&quot;javaExamples/reformatOrders.java&quot;&gt;org.jetel.component.RecordTransform&lt;/A&gt;&lt;/TT&gt;
 interface.&lt;BR&gt;The transformation class has to be compiled separately
 prior to running Reformat component and it must reside in directory
 accessed by Java when searching for classes (i.e. either included in
 CLASSPATH or defined using &lt;TT&gt;-cp&lt;/TT&gt; parameter when starting java
 VM. 
 &lt;/P&gt;
-&lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;Prepare reformat class:&lt;BR&gt;javac -cp
+&quot;../cloveretl.engine.jar&quot;
+javaExamples/reformatOrders.java&lt;BR&gt;Execute graph:&lt;BR&gt;java -cp
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
 org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphOrdersReformat.grf&quot; TARGET=&quot;_blank&quot;&gt;graphOrdersReformat.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;H3&gt;&lt;!-- Reformat Inline --&gt;Reformat example with transformation
 class source embedded&lt;/H3&gt;
@@ -210,11 +253,10 @@
 started and then transformation object is created to be executed for
 each record.&lt;BR&gt;When the graph is run subsequently, the source is
 recompiled only if it changes between two runs.&lt;BR&gt;In order to run
-successfully,&lt;TT&gt;tools.jar&lt;/TT&gt; library (present in $JAVA_HOME/lib/)
-has to be part of CLASSPATH. 
-&lt;/P&gt;
+successfully, environment variable $JAVA_HOME have to be set
+correctly.&lt;/P&gt;
 &lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples:$JAVA_HOME/lib/tools.jar&quot;
 org.jetel.main.runGraph -plugins ../plugins
 &lt;A HREF=&quot;graphOrdersReformatInline.grf&quot; TARGET=&quot;_blank&quot;&gt;graphOrdersReformatInline.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;H3&gt;&lt;!-- Reformat with transformation --&gt;Reformat example with
@@ -224,18 +266,18 @@
 fields are combinations of inputs fields and some parameters, this is
 the simplest way how to do it.&lt;/P&gt;
 &lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&lt;TT&gt;:$JAVA_HOME/lib/tools.jar&lt;/TT&gt;&quot;
 org.jetel.main.runGraph -plugins ../plugins
 &lt;A HREF=&quot;graphOrdersReformatUsingTransform.grf&quot; TARGET=&quot;_blank&quot;&gt;graphOrdersReformatUsingTransform.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;H3&gt;&lt;!-- Reformat with transformation in Transform Language --&gt;Reformat
 example with transformation in Transform Language&lt;/H3&gt;
 &lt;P&gt;This example is similar to previous ones except transformation is
-given in &lt;A HREF=&quot;../docs/CloverETL_transformation_language.zip&quot;&gt;Transform
-Language.&lt;/A&gt;In this language You can write complicated
+given in &lt;A HREF=&quot;../docs/CloverETL_transformation_language.odt&quot;&gt;Transform
+Language.&lt;/A&gt;In this language you can write complicated
 transformations in relatively easy way. 
 &lt;/P&gt;
 &lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
 org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphOrdersTLReformat.grf&quot; TARGET=&quot;_blank&quot;&gt;graphOrdersTLReformat.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;H3&gt;&lt;!-- Merge --&gt;Merge example&lt;/H3&gt;
 &lt;P&gt;Merge component combines several &lt;U&gt;sorted&lt;/U&gt; input data flows
@@ -249,7 +291,7 @@
 file. 
 &lt;/P&gt;
 &lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
 org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphMergeData.grf&quot; TARGET=&quot;_blank&quot;&gt;graphMergeData.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;H3&gt;&lt;!-- Filter --&gt;Filter example&lt;/H3&gt;
 &lt;P&gt;Filter component allows filtering any input data records based on
@@ -258,8 +300,10 @@
 which don't.&lt;BR&gt;Filter condition is composed of one or more simple
 comparisons &lt;TT&gt;&lt;,&gt;,&lt;=,&gt;=,==,!=&lt;/TT&gt;. Individual
 comparisons can be combined using logical operators &lt;TT&gt;AND&lt;/TT&gt; and
-&lt;TT&gt;OR&lt;/TT&gt;. Parenthesis can be used to group comparisons.&lt;BR&gt;This
-graph illustrates usage of Filter and HashJoin components. It
+&lt;TT&gt;OR&lt;/TT&gt;. Parenthesis can be used to group comparisons. There are
+some logical functions (see description of &lt;A HREF=&quot;<A HREF="http://cloveretl.berlios.de/docs/CloverETL_components.html#0_4_19">http://cloveretl.berlios.de/docs/CloverETL_components.html#0_4_19</A>&quot;&gt;Extended
+Filter Component&lt;/A&gt;) you can use too.&lt;BR&gt;This graph is a bit more
+complex and illustrates usage of Filter and HashJoin components. It
 produces four output files: 
 &lt;/P&gt;
 &lt;UL&gt;
@@ -274,13 +318,13 @@
 	&lt;LI&gt;&lt;P&gt;all employees who were hired after 1993-12-31&lt;/P&gt;
 &lt;/UL&gt;
 &lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&lt;TT&gt;:$JAVA_HOME/lib/tools.jar&lt;/TT&gt;&quot;
 org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphExtFilter.grf&quot; TARGET=&quot;_blank&quot;&gt;graphExtFilter.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;H3&gt;&lt;!-- Join --&gt;Join example&lt;/H3&gt;
-&lt;P&gt;Join component joins two &lt;U&gt;sorted&lt;/U&gt; input data flows into one
-based on specified key. It can produce classical inner join or left
-outer join (based on parameters).&lt;BR&gt;This component can be useful
-when you have main data set - for example with orders (driver)
+&lt;P&gt;Join component joins two or more &lt;U&gt;sorted&lt;/U&gt; input data flows
+into one based on specified key. It can produce classical inner join
+or left outer join (based on parameters).&lt;BR&gt;This component can be
+useful when you have main data set - for example with orders (driver)
 containing part number and you need to join it with other data set
 containing price for each part (slave).&lt;BR&gt;The testing graph reads
 data form &lt;TT&gt;orders.dat&lt;/TT&gt; file (driver) and &lt;TT&gt;employees.dat&lt;/TT&gt;
@@ -289,79 +333,76 @@
 &lt;TT&gt;reformatJoinTest.class&lt;/TT&gt;. The source code for this class is
 attached as well. 
 &lt;/P&gt;
-&lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
-org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphJoinData.grf&quot; TARGET=&quot;_blank&quot;&gt;graphJoinData.grf&lt;/A&gt;&lt;/TT&gt;&lt;BR&gt;&lt;BR&gt;&lt;I&gt;!!!
-Important: note the change in running this example. You have to
-extend the CLASSPATH by the current directory as the class for
-transforming is present there.&lt;/I&gt; 
+&lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;Prepare reformat class:&lt;BR&gt;javac -cp
+&quot;../cloveretl.engine.jar&quot;
+javaExamples/&lt;TT&gt;reformatJoinTest&lt;/TT&gt;.java&lt;BR&gt;Execute graph:&lt;BR&gt;java
+-cp
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
+org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphJoinData.grf&quot; TARGET=&quot;_blank&quot;&gt;graphJoinData.grf&lt;/A&gt;&lt;/TT&gt;
 &lt;/P&gt;
 &lt;H3&gt;&lt;!-- Hash Join --&gt;Hash Join example&lt;/H3&gt;
-&lt;P&gt;Hash Join component joins two input data flows into one based on
-specified key. It can produce classical inner join or left outer join
-(based on parameters).&lt;BR&gt;Functionality of this component is similar
-to previous one, but it doesn't require input data to be sorted. It
-is most suited to join two data sets when one is relatively large
-(master) and the other one small (slave) - typically when using
-lookup table to convert key into corresponding value.&lt;BR&gt;The testing
-graph reads data form &lt;TT&gt;orders.dat&lt;/TT&gt; file (driver) and
+&lt;P&gt;Hash Join component joins two or more input data flows into one
+based on specified key. It can produce classical inner join or left
+outer join (based on parameters).&lt;BR&gt;Functionality of this component
+is similar to previous one, but it doesn't require input data to be
+sorted. It is most suited to join data sets when one is relatively
+large (master) and the others are small (slaves) - typically when
+using lookup table to convert key into corresponding value.&lt;BR&gt;The
+testing graph reads data form &lt;TT&gt;orders.dat&lt;/TT&gt; file (driver) and
 &lt;TT&gt;employees.dat&lt;/TT&gt; and produces records with combined information
 from both files.&lt;BR&gt;Each pair of corresponding records is transformed
 by &lt;TT&gt;reformatJoinTest.class&lt;/TT&gt;. The source code for this class is
 attached as well. 
 &lt;/P&gt;
 &lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
-org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphJoinHash.grf&quot; TARGET=&quot;_blank&quot;&gt;graphJoinHash.grf&lt;/A&gt;&lt;/TT&gt;&lt;BR&gt;&lt;BR&gt;&lt;I&gt;!!!
-Important: note the change in running this example. You have to
-extend the CLASSPATH by the current directory as the class for
-transforming is present there.&lt;/I&gt; 
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
+org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphJoinHash.grf&quot; TARGET=&quot;_blank&quot;&gt;graphJoinHash.grf&lt;/A&gt;&lt;/TT&gt;
 &lt;/P&gt;
 &lt;H3&gt;&lt;!-- Hash Join Inline--&gt;Hash Join with transformation class
 source embedded&lt;/H3&gt;
 &lt;P&gt;As with Reformat component, transformation class which is executed
-for each pair of input records can be embedded directly into
-graph.&lt;BR&gt;It is again dynamically compiled at run-time.&lt;BR&gt;&lt;I&gt;Note:In
-order to run successfully,&lt;TT&gt;tools.jar&lt;/TT&gt; library (present in
-$JAVA_HOME/lib/) has to be part of CLASSPATH.&lt;/I&gt; 
-&lt;/P&gt;
+for input records can be embedded directly into graph. It is again
+dynamically compiled at run-time.&lt;BR&gt;In this example you can see
+joining more then two input sets. Master data from &lt;TT&gt;orders.dat&lt;/TT&gt;
+are joined with two slave inputs: first &lt;TT&gt;employees.dat&lt;/TT&gt; due to
+key field &lt;TT&gt;EmployeeID&lt;/TT&gt; and with the second,
+&lt;TT&gt;customers_delimited.txt&lt;/TT&gt;, due to key field &lt;TT&gt;CustomerID.&lt;/TT&gt;
+So in output record there are information from all three input files.&lt;/P&gt;
 &lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&lt;TT&gt;:$JAVA_HOME/lib/tools.jar&lt;/TT&gt;&quot;
 org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphJoinHashInline.grf&quot; TARGET=&quot;_blank&quot;&gt;graphJoinHashInline.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;H3&gt;&lt;!-- Hash Join with transformation--&gt;Hash Join with
-transformation in special form&lt;/H3&gt;
+transformation in-line&lt;/H3&gt;
 &lt;P&gt;As with Reformat component, transformation can be written in
-summary form.&lt;BR&gt;&lt;I&gt;Note:In order to run successfully,&lt;TT&gt;tools.jar&lt;/TT&gt;
-library (present in $JAVA_HOME/lib/) has to be part of CLASSPATH.&lt;/I&gt;
+summary form.&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;
 &lt;/P&gt;
 &lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&lt;TT&gt;:$JAVA_HOME/lib/tools.jar&lt;/TT&gt;&quot;
 org.jetel.main.runGraph -plugins ../plugins
 &lt;A HREF=&quot;graphJoinHashUsingTransform.grf&quot; TARGET=&quot;_blank&quot;&gt;graphJoinHashUsingTransform.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;H3&gt;&lt;!-- Hash Join with transformation in Transform Language--&gt;Hash
 Join with transformation in Transform Language&lt;/H3&gt;
 &lt;P&gt;As with Reformat component, transformation can be written in
 &lt;A HREF=&quot;../docs/CloverETL_transformation_language.zip&quot;&gt;Transform
-Language.&lt;/A&gt;&lt;BR&gt;&lt;I&gt;Note:In order to run successfully,&lt;TT&gt;tools.jar&lt;/TT&gt;
-library (present in $JAVA_HOME/lib/) has to be part of CLASSPATH.&lt;/I&gt;
+Language.&lt;/A&gt;&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;
 &lt;/P&gt;
 &lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
 org.jetel.main.runGraph -plugins ../plugins
 &lt;A HREF=&quot;graphJoinHashUsingTransformLanguage.grf&quot; TARGET=&quot;_blank&quot;&gt;graphJoinHashUsingTransformLanguage.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;H3&gt;&lt;!-- Sort --&gt;Sort example&lt;/H3&gt;
 &lt;P&gt;Sort component sorts input data flow based on specified key. You
 can use more than one field name for key.&lt;BR&gt;Sorted data flow is
 required by several components (Merge, Join, etc..) so this is very
-useful component.&lt;BR&gt;One limitation - it can't perform external
-sorting. You are limited by the amount of memory you have.&lt;BR&gt;The
-testing graph reads data form &lt;TT&gt;orders.dat&lt;/TT&gt; file, sorts them
-and stores the result into &lt;TT&gt;orders.sorted&lt;/TT&gt; file. 
+useful component.&lt;BR&gt;The testing graph reads data form &lt;TT&gt;orders.dat&lt;/TT&gt;
+file, sorts them and stores the result into &lt;TT&gt;orders.sorted&lt;/TT&gt;
+file. 
 &lt;/P&gt;
 &lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
 org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphSortData.grf&quot; TARGET=&quot;_blank&quot;&gt;graphSortData.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
-&lt;H3&gt;&lt;!-- Sort Universal --&gt;Sort Universal example&lt;/H3&gt;
+&lt;H3&gt;&lt;A NAME=&quot;Sort Universal example|outline&quot;&gt;&lt;/A&gt;&lt;!-- Sort Universal --&gt;Sort
+Universal example&lt;/H3&gt;
 &lt;P&gt;Similar to previous example, this one sorts input data. The
 difference is that the exact datafile to be sorted is not hardcoded
 within graph definition, it is determined based on supplied
@@ -370,16 +411,15 @@
 reference is replaced by property value at run-time. In our example
 parameter's definitions are embedded in graph code (Executing: &lt;TT&gt;java
 -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
-org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphSortUniversal.grf&quot; TARGET=&quot;_blank&quot;&gt;graphSortUniversal.grf).
-&lt;/A&gt;&lt;/TT&gt;, but don't have to define parameters in-line. Instead of
-thad you can pass on parameters in executing command: &lt;BR&gt;&lt;TT&gt;java
--cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&quot;&lt;TT&gt;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&lt;/TT&gt;&quot;
+org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphSortUniversal.grf&quot; TARGET=&quot;_blank&quot;&gt;graphSortUniversal.grf)&lt;/A&gt;&lt;/TT&gt;
+but it is possible to define parameters in-line. In such case you can
+pass on parameters in executing command: &lt;BR&gt;&lt;TT&gt;java -cp
+&quot;&lt;TT&gt;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&lt;/TT&gt;&quot;
 org.jetel.main.runGraph -plugins ../plugins
 -P:sortKey=&lt;I&gt;&lt;..your.fieldName..&gt;&lt;/I&gt; -P:metadata=&lt;I&gt;&lt;..metadata
 filename..&gt;&lt;/I&gt; -P:data=&lt;I&gt;&lt;..datafile..&gt;&lt;/I&gt;
--P:output=&lt;I&gt;&lt;..datafile..&gt;&lt;/I&gt; &lt;A HREF=&quot;graphSortUniversal.grf&quot; TARGET=&quot;_blank&quot;&gt;graphSortUniversal.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
+-P:outputData=&lt;I&gt;&lt;..datafile..&gt;&lt;/I&gt; &lt;A HREF=&quot;graphSortUniversal.grf&quot; TARGET=&quot;_blank&quot;&gt;graphSortUniversal.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;H3&gt;&lt;!-- Phases examples --&gt;Phases example&lt;/H3&gt;
 &lt;P&gt;Components can be grouped into individual phases. Each phase has
 assigned a unique number. In each transformation graph, there must
@@ -396,7 +436,7 @@
 read and sorted, in second,data is copied into three similar flows.
 In third, data is again merged into one flow and saved to file.&lt;/P&gt;
 &lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
 org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphPhasesDemo.grf&quot; TARGET=&quot;_blank&quot;&gt;graphPhasesDemo.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;H3&gt;&lt;!-- Partition --&gt;Partition data example&lt;/H3&gt;
 &lt;P&gt;Partition component offers various ways of splitting input data
@@ -420,8 +460,12 @@
 	upper boundary (inclusive). 
 	&lt;/P&gt;
 &lt;/UL&gt;
-&lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&lt;P&gt;It is possible to write your own partition function. It has to
+implement &lt;TT&gt;&lt;A HREF=&quot;<A HREF="http://cloveretl.berlios.de/docs/JavaDoc/org/jetel/component/partition/PartitionFunction.html">http://cloveretl.berlios.de/docs/JavaDoc/org/jetel/component/partition/PartitionFunction.html</A>&quot;&gt;org.jetel.component.partition.PartitionFunction&lt;/A&gt;
+&lt;/TT&gt;and can be write as java source or in &lt;A HREF=&quot;../docs/CloverETL_transformation_language.odt&quot;&gt;Transformation
+Language.&lt;/A&gt;&lt;/P&gt;
+&lt;P&gt;Executing example:&lt;BR&gt;&lt;TT&gt;java -cp
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
 org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphPartition.grf&quot; TARGET=&quot;_blank&quot;&gt;graphPartition.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;H3&gt;&lt;!-- System call examples --&gt;System call example&lt;/H3&gt;
 &lt;P&gt;It is possible to call system command from CloverETL framework.
@@ -433,88 +477,52 @@
 is saved in temporary batch file and there is called interpreter to
 execute this script&lt;/P&gt;
 &lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
 org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphSystemExecute.grf&quot; TARGET=&quot;_blank&quot;&gt;graphSystemExecute.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;H3&gt;&lt;!-- Excel example --&gt;Working with Excel files example&lt;/H3&gt;
 &lt;P&gt;CloverETL can read and write data from/to xls files. In this
 example data are read from &lt;TT&gt;ORDERS.xls&lt;/TT&gt; file, partitioned to 3
 parts and each of thees parts are saved in &lt;TT&gt;orders.partitioned.xls&lt;/TT&gt;
-file in another sheet. 
+file in different sheets. 
 &lt;/P&gt;
-&lt;P&gt;&lt;I&gt;Important: Because it is impossible to write to different
-sheets in the same time each writing component has other phase.&lt;/I&gt; 
-&lt;/P&gt;
+&lt;P&gt;&lt;I&gt;Important: 1.Because it is impossible to write to different
+sheets in the same time each writing component has to be in different
+phase. 2. &lt;/I&gt;&lt;TT&gt;&lt;I&gt;poi-2.5.1.jar (reading/writing to excel files
+library) has to be in execution path.&lt;/I&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples:../lib/poi-2.5.1.jar&quot;
 org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphXLSReadWrite.grf&quot; TARGET=&quot;_blank&quot;&gt;graphXLSReadWrite.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;H3&gt;&lt;!-- XML example --&gt;XML extract example&lt;/H3&gt;
 &lt;P&gt;CloverETL can read data from xml files. In this example data are
 read from &lt;TT&gt;employees.xml &lt;/TT&gt;file. &#8220;Mapping&#8221; attribute
 describes dependencies between xml nodes and metadata fields. 
 &lt;/P&gt;
+&lt;P&gt;&lt;I&gt;Important: tools.jar has to be in execution path.&lt;/I&gt;&lt;/P&gt;
 &lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&lt;TT&gt;:$JAVA_HOME/lib/tools.jar&lt;/TT&gt;&quot;
 org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphXMLExtract.grf&quot; TARGET=&quot;_blank&quot;&gt;graphXMLExtract.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
-&lt;HR&gt;
-&lt;H2&gt;&lt;!-- Complex examples --&gt;Complex examples&lt;/H2&gt;
-&lt;P&gt;This examples combines several components to perform useful
-transformation similar to one you could use in a real life.&lt;/P&gt;
-&lt;H3&gt;&lt;!-- Join example --&gt;Join example&lt;/H3&gt;
-&lt;P&gt;Thees graphs combine information about orders made and information
-about individual items/products purchased within each order. It also
-adds information about which customer ordered the goods.&lt;BR&gt;To get
-all this information, it needs to join data from &lt;TT&gt;ORDERS.DBF&lt;/TT&gt;
-(a dBase table) &lt;TT&gt;ODETAILS.DBF&lt;/TT&gt; and &lt;TT&gt;Customers.txt&lt;/TT&gt;.&lt;BR&gt;First
-two data sets are joined using &lt;TT&gt;MERGE_JOIN&lt;/TT&gt; component, thus
-they have to be sorted first. Then information about customer is
-added using &lt;TT&gt;HASH_JOIN&lt;/TT&gt;. As both joins require transformation
-code, two transformation classes are embedded directly into graph
-file and dynamically compiled at run-time.&lt;BR&gt;As there is a
-possibility that data set containing info about orders references
-customer which is not in &lt;TT&gt;Customers.txt&lt;/TT&gt; file, second join is
-defined to be a left join. At the end, &lt;TT&gt;EXT_FILTER&lt;/TT&gt; is used to
-split data to two sets - one with customer info complete and the
-other with missing.&lt;/P&gt;
-&lt;P&gt;&lt;I&gt;Note:In order to run successfully,&lt;TT&gt;tools.jar&lt;/TT&gt; library
-(present in $JAVA_HOME/lib/) has to be part of CLASSPATH.&lt;/I&gt; 
-&lt;/P&gt;
+&lt;H3&gt;&lt;!-- Read example --&gt;Different ways of reading files&lt;/H3&gt;
+&lt;P&gt;There are few components for reading data from flat file:
+Delimited Data Reader &#8211; reads delimited data, Fixlen Data Reader &#8211;
+reads data of fixed length and Universal Data Reader, which can read
+delimited or fixed length data depending on metadata on output port.
+There are others reader components for reading data in different
+formats: DBFDataReader &#8211; reads dBase tables, XMLExtract &#8211; reads
+xml files, XLSDataReader &#8211; reads excel files, Clover Data Reader &#8211;
+reads data saved in clover internal folders. Most of thees readers
+can read data from &#8220;MultiFile&#8221; - it means that in fileURL
+attribute can be wildcards as * or ?. This illustrates following
+example:&lt;/P&gt;
 &lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
-org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphDBFJoin.grf&quot; TARGET=&quot;_blank&quot;&gt;graphDBFJoin.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
-&lt;P&gt;Graph &lt;A HREF=&quot;graphDBFJoinTL.grf&quot; TARGET=&quot;_blank&quot;&gt;graphDBFJoinTL.grf&lt;/A&gt;
-is very similar to preceding one, but with transformation written in
-&lt;A HREF=&quot;../docs/CloverETL_transformation_language.zip&quot;&gt;Transform
-Language.&lt;/A&gt;.&lt;/P&gt;
-&lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
-org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphDBFJoinTL.grf&quot; TARGET=&quot;_blank&quot;&gt;graphDBFJoinTL.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
-&lt;H3&gt;&lt;!-- Intersection example --&gt;Intersection example&lt;/H3&gt;
-&lt;P&gt;This graph reads personal data from three sources and finds
-records with the same values on corresponding fields (lname &#8211;
-last_name, fname &#8211; first_name). Matching pairs are transformed into
-one output record and saved in &lt;TT&gt;intersection_customer_employee.txt&lt;/TT&gt;
-file.&lt;/P&gt;
-&lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
-org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphDBRead.grf&quot; TARGET=&quot;_blank&quot;&gt;graphDBRead.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
-&lt;H3&gt;&lt;!-- Real life example --&gt;Real life example&lt;/H3&gt;
-&lt;P STYLE=&quot;margin-bottom: 0in&quot;&gt;This is practical illustration of usage
-CloverETL. This graph transforms data for branch bank. On inputs are
-clients, month interests and charges and half-year bonus. On outputs
-we have aggregated revenues by clients, clients without revenues and
-clients from database, who are not in input file. 
-&lt;/P&gt;
-&lt;P STYLE=&quot;margin-bottom: 0in&quot;&gt;&lt;I&gt;Note:In order to run successfully,
-you have to have database and database connection defined (see next
-examples) &lt;/I&gt;
-&lt;/P&gt;
-&lt;P STYLE=&quot;margin-bottom: 0in&quot;&gt;&lt;BR&gt;
-&lt;/P&gt;
-&lt;P STYLE=&quot;margin-bottom: 0in&quot;&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
-org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphRevenues.grf&quot; TARGET=&quot;_blank&quot;&gt;graphRevenues.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
-&lt;P STYLE=&quot;margin-bottom: 0in&quot;&gt;&lt;BR&gt;
-&lt;/P&gt;
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&lt;TT&gt;:$JAVA_HOME/lib/tools.jar&lt;/TT&gt;&quot;
+org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphCloverData.grf&quot;&gt;graphCloverData.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
+&lt;P&gt;It is possible to omit some data from flat file. For such purpose
+there is attribute &lt;SPAN STYLE=&quot;text-decoration: none&quot;&gt;shift on
+metadata, which indicates how many characters should be omitted from
+last field. Usage of this feature you can see in following example:&lt;/SPAN&gt;&lt;/P&gt;
+&lt;P&gt;&lt;SPAN STYLE=&quot;text-decoration: none&quot;&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&lt;TT&gt;:&lt;TT&gt;../lib/poi-2.5.1.jar&lt;/TT&gt;&lt;/TT&gt;&quot;
+org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphGenerateData.grf&quot;&gt;graphGenerateData.grf&lt;/A&gt;&lt;/TT&gt;&lt;/SPAN&gt;&lt;/P&gt;
 &lt;HR&gt;
 &lt;H2&gt;&lt;!-- Database related examples --&gt;Database related examples&lt;/H2&gt;
 &lt;P&gt;When experimenting with database, presented example graphs expect
@@ -540,20 +548,20 @@
 Oracle specific file &lt;TT&gt;populate_employee_table.ora&lt;/TT&gt;. 
 &lt;/P&gt;
 &lt;H3&gt;&lt;!-- DB Unload --&gt;DBUnload example&lt;/H3&gt;
-&lt;P&gt;DBUnload component can be used for extracting data from database.
-It allows a SQL query to be specified and run against database. The
-result set produced by DB is then sent by the component to output
-port - and gets propagated to other processing nodes. It uses JDBC to
-communicate with DB.&lt;BR&gt;You may wonder why to use CloverETL for
-processing data which is already in DB. It should be faster to
-perform any processing within DB itself. Well, it is not always
-true.&lt;BR&gt;DBUnload component (as all other DB related components)
-needs to know which JDBC driver to use, what is the DB connection
-string and under what user name it should connect to database. These
-parameters can be provided directly to component (one by one) or
-special config file can be created from which component is able to
-read required info.&lt;BR&gt;Following is an example of config file which
-can be used to connect to Borland Interbase DB:&lt;/P&gt;
+&lt;P&gt;DBInputTable component can be used for extracting data from
+database. It allows a SQL query to be specified and run against
+database. The result set produced by DB is then sent by the component
+to output port - and gets propagated to other processing nodes. It
+uses JDBC to communicate with DB.&lt;BR&gt;You may wonder why to use
+CloverETL for processing data which is already in DB. It should be
+faster to perform any processing within DB itself. Well, it is not
+always true.&lt;BR&gt;DBUnload component (as all other DB related
+components) needs to know which JDBC driver to use, what is the DB
+connection string and under what user name it should connect to
+database. These parameters can be provided directly to component (one
+by one) or special config file can be created from which component is
+able to read required info.&lt;BR&gt;Following is an example of config file
+which can be used to connect to Borland Interbase DB:&lt;/P&gt;
 &lt;HR&gt;
 &lt;PRE&gt;&lt;TT&gt;dbDriver=interbase.interclient.Driver&lt;/TT&gt;
 &lt;TT&gt;dbURL=jdbc:<A HREF="interbase://localhost/home/projects/interbase/examples/database/employee.gdb&lt;/TT">interbase://localhost/home/projects/interbase/examples/database/employee.gdb&lt;/TT</A>&gt;
@@ -562,23 +570,23 @@
 &lt;HR&gt;
 &lt;P&gt;I hope that the parameters (their names) are self-explanatory. If
 not, read some JDBC related documentation.&lt;BR&gt;In this example, the
-DBUnload component connects to database and unloads all records from
-&lt;B&gt;employee&lt;/B&gt; table. It then stores the records in
+DBInputTable component connects to database and unloads all records
+from &lt;B&gt;employee&lt;/B&gt; table. It then stores the records in
 &lt;TT&gt;employees.list.out&lt;/TT&gt; file. 
 &lt;/P&gt;
-&lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&lt;P&gt;Executing:&lt;BR&gt;j&lt;TT&gt;ava -cp
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
 org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphDBUnload.grf&quot; TARGET=&quot;_blank&quot;&gt;graphDBUnload.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;H3&gt;&lt;!-- DB Load --&gt;DBLoad example&lt;/H3&gt;
-&lt;P&gt;DBLoad component does the opposite to DBUnload, it populates
-database table with data processed by CloverETL framework. Similarly
-to DBUnload, it requires some JDBC related parameters to be supplied.
-In order to be able to run this example, you have to create a DB
-table with the name &lt;TT&gt;EMPLOYEE_TMP&lt;/TT&gt; and structure similar to
-&lt;TT&gt;EMPLOYEE&lt;/TT&gt; table presented above. 
+&lt;P&gt;DBOutputTable component does the opposite to DBInputTable, it
+populates database table with data processed by CloverETL framework.
+Similarly to DBInputTable, it requires some JDBC related parameters
+to be supplied. In order to be able to run this example, you have to
+create a DB table with the name &lt;TT&gt;EMPLOYEE_TMP&lt;/TT&gt; and structure
+similar to &lt;TT&gt;EMPLOYEE&lt;/TT&gt; table presented above. 
 &lt;/P&gt;
-&lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&lt;P&gt;Executing:&lt;BR&gt;j&lt;TT&gt;ava -cp
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
 org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphDBLoad.grf&quot; TARGET=&quot;_blank&quot;&gt;graphDBLoad.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;H3&gt;&lt;!-- DB Join --&gt;DBJoin example&lt;/H3&gt;
 &lt;P&gt;DBJoin component joins records from input port with records from
@@ -588,234 +596,793 @@
 to get output record. In this example for records from flat file are
 searched records from database where field &#8220;lname&#8221; on input has
 the same value as field &#8220;last_name&#8221; in database records.&lt;/P&gt;
-&lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;Prepare transform class:&lt;BR&gt;javac -cp
+&quot;../cloveretl.engine.jar&quot;
+javaExamples/TransformForDBjoin.java&lt;BR&gt;Execute graph:&lt;BR&gt;java -cp
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&lt;TT&gt;:$JAVA_HOME/lib/tools.jar&lt;/TT&gt;&quot;
 org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphDBJoin.grf&quot; TARGET=&quot;_blank&quot;&gt;graphDBJoin.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;H3&gt;&lt;!-- DB Lookup --&gt;DBLookup example&lt;/H3&gt;
-&lt;P&gt;graph &lt;A HREF=&quot;graphDBLookup.grf&quot; TARGET=&quot;_blank&quot;&gt;graphDBLookup.grf
+&lt;P&gt;Graph &lt;A HREF=&quot;graphDBLookup.grf&quot; TARGET=&quot;_blank&quot;&gt;graphDBLookup.grf
 &lt;/A&gt;has similar functionality as preceding graph, but You can see
 usage of Database Lookup Table.&lt;/P&gt;
 &lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
-&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:./&quot;
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&lt;TT&gt;:$JAVA_HOME/lib/tools.jar&lt;/TT&gt;&quot;
 org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphDBLookup.grf&quot; TARGET=&quot;_blank&quot;&gt;graphDBLookup.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
 &lt;HR&gt;
+&lt;H2&gt;&lt;!-- Complex examples --&gt;Complex examples&lt;/H2&gt;
+&lt;P&gt;This examples combines several components to perform useful
+transformation similar to one you could use in a real life.&lt;/P&gt;
+&lt;H3&gt;&lt;!-- Join example --&gt;Join example&lt;/H3&gt;
+&lt;P&gt;Thees graphs combine information about orders made and information
+about individual items/products purchased within each order. It also
+adds information about which customer ordered the goods.&lt;BR&gt;To get
+all this information, it needs to join data from &lt;TT&gt;ORDERS.DBF&lt;/TT&gt;
+(a dBase table) &lt;TT&gt;ODETAILS.DBF&lt;/TT&gt; and &lt;TT&gt;Customers.txt&lt;/TT&gt;.&lt;BR&gt;First
+two data sets are joined using &lt;TT&gt;MERGE_JOIN&lt;/TT&gt; component, thus
+they have to be sorted first. Then information about customer is
+added using &lt;TT&gt;HASH_JOIN&lt;/TT&gt;. As both joins require transformation
+code, two transformation classes are embedded directly into graph
+file and dynamically compiled at run-time.&lt;BR&gt;As there is a
+possibility that data set containing info about orders references
+customer which is not in &lt;TT&gt;Customers.txt&lt;/TT&gt; file, second join is
+defined to be a left join. At the end, &lt;TT&gt;EXT_FILTER&lt;/TT&gt; is used to
+split data to two sets - one with customer info complete and the
+other with missing.&lt;/P&gt;
+&lt;P&gt;&lt;I&gt;Note:In order to run successfully,&lt;TT&gt;tools.jar&lt;/TT&gt; library
+(present in $JAVA_HOME/lib/) has to be part of CLASSPATH.&lt;/I&gt; 
+&lt;/P&gt;
+&lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;java -cp
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&lt;TT&gt;:$JAVA_HOME/lib/tools.jar&lt;/TT&gt;&quot;
+org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphDBFJoin.grf&quot; TARGET=&quot;_blank&quot;&gt;graphDBFJoin.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
+&lt;P&gt;Graph &lt;A HREF=&quot;graphDBFJoinTL.grf&quot; TARGET=&quot;_blank&quot;&gt;graphDBFJoinTL.grf&lt;/A&gt;
+is very similar to preceding one, but with transformation written in
+&lt;A HREF=&quot;../docs/CloverETL_transformation_language.zip&quot;&gt;Transform
+Language.&lt;/A&gt;.&lt;/P&gt;
+&lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;&lt;TT&gt;java -cp
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples
+&lt;/TT&gt;&quot; org.jetel.main.runGraph -plugins ../plugins
+&lt;A HREF=&quot;graphDBFJoinTL.grf&quot; TARGET=&quot;_blank&quot;&gt;graphDBFJoinTL.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
+&lt;H3&gt;&lt;!-- Intersection example --&gt;Intersection example&lt;/H3&gt;
+&lt;P&gt;This graph reads personal data from three sources and finds
+records with the same values on corresponding fields (lname &#8211;
+last_name, fname &#8211; first_name). Matching pairs are transformed into
+one output record and saved in &lt;TT&gt;intersection_customer_employee.txt&lt;/TT&gt;
+file.&lt;/P&gt;
+&lt;P&gt;Executing:&lt;BR&gt;j&lt;TT&gt;&lt;TT&gt;ava -cp
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&lt;TT&gt;:$JAVA_HOME/lib/tools.jar&lt;/TT&gt;&lt;/TT&gt;&quot;
+org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphDBRead.grf&quot; TARGET=&quot;_blank&quot;&gt;graphDBRead.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
+&lt;H3&gt;&lt;!-- Approximative join example --&gt;Approximative join example&lt;/H3&gt;
+&lt;P&gt;Approximative join component is used for joining data which are
+similar on given fields. It requires data to be prepared: it joins
+data from two data flows with the same value of &lt;TT&gt;matching key &lt;/TT&gt;and
+similar value of &lt;TT&gt;join key. &lt;/TT&gt;In this example data are read
+from from file&lt;TT&gt;customers0.dat &lt;/TT&gt;and from database table
+&lt;TT&gt;employee; &lt;/TT&gt;then for both flows there is generated &lt;TT&gt;matching
+key &lt;/TT&gt;consisting of 4 letters of last name (flat file: lname,
+database: last_name) and 3 letters of first name (flat file: fname,
+database: first_name) . Approximative join component joins data from
+thees flows (sorted due the &lt;TT&gt;matching key&lt;/TT&gt;) ; it compares
+records with the same matching key only, but to conforming output
+sends only thees, which join key is similar enough (conformity
+attribute), so among conforming records you can found such record: &lt;TT&gt;4
+Damstra &lt;FONT COLOR=&quot;#ff0000&quot;&gt;Robert&lt;/FONT&gt; Damstra &lt;FONT COLOR=&quot;#ff0000&quot;&gt;Roberta&lt;/FONT&gt;
+0.875&#8221; &lt;/TT&gt;- with conformity 0.875 (conformity equals 1 means that
+records are identical).&lt;/P&gt;
+&lt;P&gt;This graph illustrates usage of &lt;TT&gt;CustomizedRecordTransform&lt;/TT&gt;
+class too. This class extend abstract class &lt;A HREF=&quot;<A HREF="http://cloveretl.berlios.de/docs/JavaDoc/org/jetel/component/DataRecordTransform.html">http://cloveretl.berlios.de/docs/JavaDoc/org/jetel/component/DataRecordTransform.html</A>&quot;&gt;DataRecordTransform&lt;/A&gt;
+and allows to create complex transformation in relatively easy way.&lt;/P&gt;
+&lt;P&gt;Executing:&lt;BR&gt;&lt;TT&gt;Prepare transform class:&lt;BR&gt;javac -cp
+&quot;../cloveretl.engine.jar:&lt;TT&gt;../lib/commons-logging.jar&lt;/TT&gt;&quot;
+javaExamples/customizedTransformExample.java&lt;BR&gt;Execute graph:&lt;BR&gt;java
+-cp
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&lt;TT&gt;:$JAVA_HOME/lib/tools.jar&lt;/TT&gt;&quot;
+org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphAproximativeJoin.grf&quot; TARGET=&quot;_blank&quot;&gt;graphAproximativeJoin.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
+&lt;H3&gt;&lt;!-- Real life example --&gt;Real life example&lt;/H3&gt;
+&lt;P STYLE=&quot;margin-bottom: 0in&quot;&gt;This is practical illustration of usage
+CloverETL. This graph transforms data for branch bank. On inputs are
+clients, month interests and charges and half-year bonus. On outputs
+we have aggregated revenues by clients, clients without revenues and
+clients from database, who are not in input file. 
+&lt;/P&gt;
+&lt;P STYLE=&quot;margin-bottom: 0in&quot;&gt;&lt;BR&gt;
+&lt;/P&gt;
+&lt;P STYLE=&quot;margin-bottom: 0in&quot;&gt;Executing:&lt;BR&gt;j&lt;TT&gt;&lt;TT&gt;ava -cp
+&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&lt;TT&gt;:$JAVA_HOME/lib/tools.jar&lt;/TT&gt;&lt;/TT&gt;&quot;
+org.jetel.main.runGraph -plugins ../plugins &lt;A HREF=&quot;graphRevenues.grf&quot; TARGET=&quot;_blank&quot;&gt;graphRevenues.grf&lt;/A&gt;&lt;/TT&gt;&lt;/P&gt;
+&lt;P STYLE=&quot;margin-bottom: 0in&quot;&gt;&lt;BR&gt;
+&lt;/P&gt;
+&lt;HR&gt;
 &lt;H1&gt;&lt;!--- ALL EXAMPLES INDEX ---&gt;Index of all examples&lt;/H1&gt;
-&lt;TABLE WIDTH=288 BORDER=0 CELLPADDING=2 CELLSPACING=0&gt;
-	&lt;COL WIDTH=284&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+&lt;TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=0&gt;
+	&lt;COL WIDTH=64*&gt;
+	&lt;COL WIDTH=192*&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphAggregateSorted.grf&quot;&gt;graphAggregateSorted.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates usage of Aggregate component. 
+			&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphAggregateUnsorted.grf&quot;&gt;graphAggregateUnsorted.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates usage of Aggregate component. 
+			&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
+			&lt;P&gt;&lt;A HREF=&quot;graphAproximativeJoin.grf&quot;&gt;graphAproximativeJoin.grf&lt;/A&gt;&lt;/P&gt;
+		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P STYLE=&quot;margin-bottom: 0in&quot;&gt;In this example data are read from
+			from file &lt;TT&gt;customers0.dat &lt;/TT&gt;and from database table
+			&lt;TT&gt;employee; &lt;/TT&gt;then for both flows there is generated &lt;TT&gt;matching
+			key &lt;/TT&gt;consisting of 4 letters of last name (flat file: lname,
+			database: last_name) and 3 letters of first name (flat file:
+			fname, database: first_name) . Approximative join component joins
+			data from thees flows (sorted due the &lt;TT&gt;matching key&lt;/TT&gt;) ; it
+			compares records with the same matching key only, but to
+			conforming output sends only thees, which join key is similar
+			enough (conformity attribute), so among conforming records you can
+			found such record: &#8220;&lt;TT&gt;&lt;FONT SIZE=2&gt;4 Damstra &lt;FONT COLOR=&quot;#ff0000&quot;&gt;Robert&lt;/FONT&gt;
+			Damstra &lt;FONT COLOR=&quot;#ff0000&quot;&gt;Roberta&lt;/FONT&gt; 0.875&#8221; &lt;/FONT&gt;&lt;/TT&gt;-
+			with conformity 0.875 (conformity equals 1 means that records are
+			identical).&lt;/P&gt;
+			&lt;P&gt;This graph illustrates usage of &lt;TT&gt;CustomizedRecordTransform&lt;/TT&gt;
+			class too. This class extend abstract class &lt;A HREF=&quot;<A HREF="http://cloveretl.berlios.de/docs/JavaDoc/org/jetel/component/DataRecordTransform.html">http://cloveretl.berlios.de/docs/JavaDoc/org/jetel/component/DataRecordTransform.html</A>&quot;&gt;DataRecordTransform&lt;/A&gt;
+			and allows to create complex transformation in relatively easy
+			way.&lt;/P&gt;
+		&lt;/TD&gt;
+	&lt;/TR&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
+			&lt;P&gt;&lt;A HREF=&quot;graphCloverData.grf&quot;&gt;graphCloverData.grf&lt;/A&gt;&lt;/P&gt;
+		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates usage of CloverDataReader/Writer
+			components. This components reads/writes data in clover internal
+			format and can be used for moving data between different graphs.
+			Reading/writing data in clover format is faster then in any other
+			format. This graph shows how works StructureWriter component (it
+			can be used for writing records and some additional information
+			eg. in xml format).&lt;/P&gt;
+		&lt;/TD&gt;
+	&lt;/TR&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphDBExecute.grf&quot;&gt;graphDBExecute.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates how-to run SQL/DDL/DML commands against
+			database. Commands in SQLCode are delimited by semicolon and are
+			executed one by one. If needed, they may be grouped into single
+			transaction. 
+			&lt;/P&gt;
+			&lt;P&gt;This graph creates two tables (EMPLOYEE and EMPLOYEE_TMP) and
+			populates table EMPLOYEE with sample data.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphDBFJoin.grf&quot;&gt;graphDBFJoin.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates complex transformation. It reads data
+			about orders made and combines them (joins) with data about which
+			items were purchased. It then adds information about which company
+			made particular order/bought particular item. It illustrates usage
+			of DBFDataReader,Sort,MergeJoin,HashJoin,Filter. It also shows how
+			to embed data transformation routine directly into transformation
+			graph layout file (both joins have the transformations embedded).
+			Note: It is faster to reference record's fields by index as
+			opposite to names &#8211; used in this example.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphDBFJoinTL.grf&quot;&gt;graphDBFJoinTL.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates complex transformation like preceding
+			example, but transformations are written in &lt;A HREF=&quot;../docs/CloverETL_transformation_language.odt&quot;&gt;Transform
+			Language&lt;/A&gt;,&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphDBJoin.grf&quot;&gt;graphDBJoin.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph shows usage of DBJoin component: data are read from
+			flat file and joined with the records from database due to
+			conforming key field (lname in records read from file, last_name
+			in records read from database).&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphDBFLoad.grf&quot;&gt;graphDBFLoad.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates reading data from DBF file.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphDBLoad.grf&quot;&gt;graphDBLoad.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates how to propagate data to database.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphDBLoad5.grf&quot;&gt;graphDBLoad5.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates usage of dbFields and cloverFields
+			parameters of DB_OUTPUT_TABLE component. Parameter dbFields allows
+			to specify that only certain fields of target DB table will be
+			populated. Parameter cloverFields allows to specify which
+			input/Clover fields are used for populating target fields. The
+			final mapping is determined by the order in which Clover fields
+			and DB fields appear in the parameters or can be set directly.
+			Note: parameter batchMode allows for grouping of inserts into DB
+			thus increasing throughput. It works only with DBs/JDBC drivers
+			which support this feature (e.g. Oracle).&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphDBLoad6.grf&quot;&gt;graphDBLoad6.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates how to run hand-written SQL/DML against
+			DB. Parameters (question-marks) are substituted by input fields
+			(in order they are listed in cloverFields). Also target parameter
+			types are devised from input field types - this may cause some
+			problems when trying to map incompatible data types.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphDBLookup.grf&quot; TARGET=&quot;_blank&quot;&gt;graphDBLookup.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates how to join data using reformat
+			component. &lt;A HREF=&quot;#graphLookupJoingrf&quot;&gt;graphLookupJoin.grf&lt;/A&gt;
+			shows how to do similar transformation in easier way.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphDBRead.grf&quot; TARGET=&quot;_blank&quot;&gt;graphDBRead.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph reads personal data from three sources and finds
+			records with the same values on corresponding fields (lname &#8211;
+			last_name, fname &#8211; first_name). Matching pairs are transformed
+			into one output record and saved in
+			&lt;TT&gt;intersection_customer_employee.txt&lt;/TT&gt; file.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphDBUnload.grf&quot;&gt;graphDBUnload.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;In this example, the DBInputTable component connects to
+			database and unloads all records from &lt;B&gt;employee&lt;/B&gt; table. It
+			then stores the records in &lt;TT&gt;employees.list.out&lt;/TT&gt; file. 
+			&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
+			&lt;P&gt;&lt;A HREF=&quot;graphDBUnloadParametrized.grf&quot;&gt;graphDBUnloadParametrized.grf&lt;/A&gt;&lt;/P&gt;
+		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates how to read not all records from
+			database. This example is similar to &lt;A HREF=&quot;graphDBJoin.grf&quot;&gt;graphDBJoin.grf&lt;/A&gt;,
+			but found records from database are not sent to transformation
+			function, but directly to output port. For illustration in the
+			next phase are read all data from the same table.&lt;/P&gt;
+		&lt;/TD&gt;
+	&lt;/TR&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphDBUnloadUniversal.grf&quot;&gt;graphDBUnloadUniversal.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates usage of dynamic metadata generation
+			based on SQL query. It allows unloading of database data without
+			prior assembly of DB table metadata. Dynamic metadata can be for
+			example used for easy migration of data between two different
+			databases when one universal graph with parameters specifying
+			which table should be unload/migrated can be used. This graph
+			requires db_table parameter to be defined. When running this
+			graph, use command like this one: &lt;TT&gt;java -cp
+			&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples
+			&quot; org.jetel.main.runGraph -plugins
+			../plugins-P:db_table=Employee graphDBUnloadUniversal.grf &lt;/TT&gt;Note:
+			where clause 1=0 in SQL query in dynamic metadata definition is
+			there only for speeding up query processing - no real data is
+			needed, only metadata describing the result - thus we specify
+			condition which ensures that no data should really be returned -
+			it is up to database whether it will optimize the execution plan
+			based on this.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
+			&lt;P&gt;&lt;A HREF=&quot;graphDenormalizeInline.grf&quot;&gt;graphDenormalizeInline.grf&lt;/A&gt;&lt;/P&gt;
+		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph demonstrates functionality of DENORMALIZER component
+			with denormalization specified by inline Java source.&lt;/P&gt;
+		&lt;/TD&gt;
+	&lt;/TR&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
+			&lt;P&gt;&lt;A HREF=&quot;graphDenormalizeTL.grf&quot;&gt;graphDenormalizeTL.grf&lt;/A&gt;&lt;/P&gt;
+		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph demonstrates functionality of DENORMALIZER component
+			with denormalization specified by inline &lt;A HREF=&quot;../docs/CloverETL_transformation_language.odt&quot;&gt;TransformLang&lt;/A&gt;
+			source.&lt;/P&gt;
+		&lt;/TD&gt;
+	&lt;/TR&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
+			&lt;P&gt;&lt;A HREF=&quot;graphGenerateData.grf&quot;&gt;graphGenerateData.grf&lt;/A&gt;&lt;/P&gt;
+		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates usage of Data Generator, Reader, Writer
+			components. It also shows how to use shift attribute on metadata.&lt;/P&gt;
+		&lt;/TD&gt;
+	&lt;/TR&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphExtFilter.grf&quot;&gt;graphExtFilter.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This illustrates usage of Filter and HashJoin components.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphExtFilter2.grf&quot;&gt;graphExtFilter2.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph shows some more functionality of EXT_FILTER
+			component. Filters all employees younger than 41 years. The
+			current age is calculated as today's date minus date of birth.
+			Notice that instead of classical comparison operators ==,!=,
+			...etc... one can use their textual abbreviations .eq. .ne. .lt.
+			.gt. ...etc...&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphFilter.grf&quot;&gt;graphFilter.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph demonstrates functionality of Filter component. It
+			can filter on text, date, integer, numeric fields with comparison
+			[&gt;, &lt;, ==, &lt;=, &gt;=, !=]. Text fields can also be
+			compared to a Java regexp using ~ (tilda) operator. A filter can
+			be made of different parts separated by a &quot;;&quot;
+			(semicolon). If one of the parts is verified, the record passes
+			the filter (it's an OR combination of the parts, and AND can be
+			achieved by several filters cascaded). Date format used for
+			comparison depends on input field's format &#8211; e.g. if input field
+			HireDate has defined date format &quot;yyyy-MM-dd&quot;, then the
+			same format must be used in filter when specifying date constant.
+			This graph produces two output files: First with all employees who
+			were hired before 1993-12-31. Second with all employees who have
+			in their memo that they are &quot;fluent&quot; in some language
+			Note: some of the comparison operators have to be XML encoded -
+			e.g. &quot;&gt;&quot; as &quot;&amp;gt;&quot; etc. 
+			&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphIntersectData.grf&quot;&gt;graphIntersectData.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph demonstrates functionality of DATA_INTERSECT
+			component - performs joining of two sorted (based on specified
+			key) data flows (A and B) and outputs: 1. to port 0 records found
+			only in flow A 2. to port 1 records found in A &amp; B 3. to port
+			2 records found only in flow B . Records both in flow A &amp;B
+			should be unique&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
+			&lt;P&gt;&lt;A HREF=&quot;graphJms.grf&quot;&gt;graphJms.grf&lt;/A&gt;&lt;/P&gt;
+		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates usage of JMS Reader/Writer Components.
+			It requires ACtiveMQ JMS server to be running on localhost!&lt;/P&gt;
+		&lt;/TD&gt;
+	&lt;/TR&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphJoinData.grf&quot;&gt;graphJoinData.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph demonstrates functionality of SORT and MERGE_JOIN
+			components. MERGE_JOIN component performs joining of master data
+			with slave data based on specified key. It requires both master
+			and slave data to be sorted according to used key. 
+			&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphJoinHash.grf&quot;&gt;graphJoinHash.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph demonstrates functionality of HASH_JOIN components.
+			HASH_JOIN component performs joining of master data with slave
+			data based on specified key. First all slave data (from all slave
+			ports) are read and hash-tables are constructed from them. Then
+			for every master record, attempt is made to find corresponding
+			slave-records. HASH_JOIN performs better than SORT/MERGE_JOIN when
+			you have relatively small slave data set and big master data set.
+			It doesn't require master and slave data to be sorted.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphJoinHashInline.grf&quot;&gt;graphJoinHashInline.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph demonstrates how to use HASH_JOIN component for 3way
+			join. HASH_JOIN component performs joining of master data with
+			slave data based on specified key. First all slave data are read
+			and hash-tables are constructed from them. Then for every master
+			record, attempt is made to find corresponding slave-records.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphJoinHashUsingTransform.grf&quot;&gt;graphJoinHashUsingTransform.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph demonstrates functionality of HASH_JOIN components.
+			Transformation function is written in compacted form.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphJoinHashUsingTransformLanguage.grf&quot;&gt;graphJoinHashUsingTransformLanguage.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph demonstrates functionality of HASH_JOIN components.
+			Transformation function is written in &lt;A HREF=&quot;../docs/CloverETL_transformation_language.odt&quot;&gt;Transform
+			Language&lt;/A&gt;,&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
+			&lt;P&gt;&lt;A HREF=&quot;graphJoinMergeInline.grf&quot;&gt;graphJoinMergeInline.grf&lt;/A&gt;&lt;/P&gt;
+		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates usage of MERGE component. It merges data
+			based on specified key. It can merge master flow with a few slave
+			flows.&lt;/P&gt;
+		&lt;/TD&gt;
+	&lt;/TR&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
+			&lt;P&gt;&lt;A HREF=&quot;graphLdapReader_Uninett.grf&quot;&gt;graphLdapReader_Uninett.grf&lt;/A&gt;&lt;/P&gt;
+		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;&lt;BR&gt;
+			&lt;/P&gt;
+		&lt;/TD&gt;
+	&lt;/TR&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
+			&lt;P&gt;&lt;A HREF=&quot;graphLdapReaderWriter.grf&quot;&gt;graphLdapReaderWriter.grf&lt;/A&gt;&lt;/P&gt;
+		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;Reads information from LDAP directory.&lt;/P&gt;
+		&lt;/TD&gt;
+	&lt;/TR&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
+			&lt;P&gt;&lt;A NAME=&quot;graphLookupJoingrf&quot;&gt;&lt;/A&gt;&lt;A HREF=&quot;graphLookupJoin.grf&quot;&gt;graphLookupJoin.grf&lt;/A&gt;&lt;/P&gt;
+		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph joins data from file with data from lookup table. 
+			&lt;/P&gt;
+		&lt;/TD&gt;
+	&lt;/TR&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
+			&lt;P&gt;&lt;A HREF=&quot;graphLookupReader.grf&quot;&gt;graphLookupReader.grf&lt;/A&gt;&lt;/P&gt;
+		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates usage of in-memory lookup table.&lt;/P&gt;
+		&lt;/TD&gt;
+	&lt;/TR&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphMergeData.grf&quot;&gt;graphMergeData.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates usage of MERGE component. It merges data
+			based on specified key. 
+			&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
-			&lt;P&gt;&lt;A HREF=&quot;graphOrdersReformat.grf&quot;&gt;graphOrdersReformat.grf&lt;/A&gt;&lt;/P&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
+			&lt;P&gt;&lt;A HREF=&quot;graphMysqlWriter.grf&quot;&gt;graphMysqlWriter.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates usage of MySQL Writer Component.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
+			&lt;P&gt;&lt;A HREF=&quot;graphNormalizeInline.grf&quot;&gt;graphNormalizeInline.grf&lt;/A&gt;&lt;/P&gt;
+		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph demonstrates functionality of NORMALIZER component
+			with normalization specified by in-line Java source.&lt;/P&gt;
+		&lt;/TD&gt;
+	&lt;/TR&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
+			&lt;P&gt;&lt;A HREF=&quot;graphNormalizeTL.grf&quot;&gt;graphNormalizeTL.grf&lt;/A&gt;&lt;/P&gt;
+		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph demonstrates functionality of NORMALIZER component
+			with normalization specified by in-line &lt;A HREF=&quot;../docs/CloverETL_transformation_language.odt&quot;&gt;TransformLang&lt;/A&gt;
+			source.&lt;/P&gt;
+		&lt;/TD&gt;
+	&lt;/TR&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
+			&lt;P&gt;&lt;A NAME=&quot;graphOrderReformat&quot;&gt;&lt;/A&gt;&lt;A HREF=&quot;graphOrdersReformat.grf&quot;&gt;graphOrdersReformat.grf&lt;/A&gt;&lt;/P&gt;
+		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This example illustrates usage of Reformat component. Source
+			data contains info about orders customers made. We add artificial
+			key - ProductID which is a sequence of integers. We also combine
+			individual fields of ship-to-address (address,city,country) into
+			one single field. Reformat component calls &quot;reformatOrders&quot;
+			class which implements &lt;A HREF=&quot;<A HREF="http://cloveretl.berlios.de/docs/JavaDoc/org/jetel/component/RecordTransform.html">http://cloveretl.berlios.de/docs/JavaDoc/org/jetel/component/RecordTransform.html</A>&quot;&gt;RecordTransform
+			interface&lt;/A&gt; (required by Reformat component). The directory in
+			which recormatOrders class exists must be part of the Java
+			classpath&lt;/P&gt;
+		&lt;/TD&gt;
+	&lt;/TR&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphOrdersReformatInline.grf&quot;&gt;graphOrdersReformatInline.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This example illustrates usage of Reformat component with
+			transformation code (class) inlined (saved with the graph itself).
+			The source code is automatically compiled at runtime. For
+			successful compilation, tools.jar library must be part of
+			CLASSPATH.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphOrdersReformatUsingTransform.grf&quot;&gt;graphOrdersReformatUsingTransform.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This example illustrates usage of Reformat component with
+			transformation written in compact form.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphOrdersTLReformat.grf&quot;&gt;graphOrdersTLReformat.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This example illustrates usage of Reformat component with
+			transformation written in &lt;A HREF=&quot;../docs/CloverETL_transformation_language.odt&quot;&gt;Transform
+			Language&lt;/A&gt;,&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphParametrizedLookup.grf&quot;&gt;graphParametrizedLookup.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph demonstrates usage of Node-level parameters.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphPartition.grf&quot;&gt;graphPartition.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph demonstrates functionality of Partition component.
+			This component can be used to split input data flow into several
+			(based on number of connected output ports) output data flows. 
+			&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphPhasesDemo.grf&quot;&gt;graphPhasesDemo.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates usage of several components in different
+			phases. First, all components from phase 0 are run, then the
+			execution continues with phase 1. Data which crosses phase
+			boundary is automatically buffered so the data producing node can
+			finish its work and the data consuming node can later start
+			reading the data. 
+			&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphRevenues.grf&quot;&gt;graphRevenues.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This is practical illustration of usage CloverETL. This graph
+			transforms data for branch bank. On inputs are clients, month
+			interests and charges and half-year bonus. On outputs we have
+			aggregated revenues by clients, clients without revenues and
+			clients from database, who are not in input file.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphSequence.grf&quot;&gt;graphSequence.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This example extends &lt;A HREF=&quot;#graphOrderReformat&quot;&gt;graphOrdersReformat&lt;/A&gt;
+			in a sense that the counter used for generating PRODUCTID is taken
+			from Sequence object which is persistent between graph executions
+			&#8211; i.e. you get continuous sequence of unique numbers. For
+			successful compilation, tools.jar library must be part of
+			CLASSPATH.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
+			&lt;P&gt;&lt;A HREF=&quot;graphSequenceCheckData.grf&quot;&gt;graphSequenceCheckData.grf&lt;/A&gt;&lt;/P&gt;
+		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates usage of Sequence Checker Component.&lt;/P&gt;
+		&lt;/TD&gt;
+	&lt;/TR&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphSimpleCopy.grf&quot;&gt;graphSimpleCopy.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph demonstrates functionality of SimpleCopy component.
+			Everything brought to SimpleCopy on port 0 is duplicated onto all
+			connected output ports. It also shows functionality of Trash
+			Component. It discards everything which is sent into it. Its
+			purpose is debugging - shows how many records ended in it and can
+			print incoming records, if desired (option debugPrint)&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphSimpleCopyEmbeddedMetadata.grf&quot;&gt;graphSimpleCopyEmbeddedMetadata.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph demonstrates functionality of SimpleCopy component.
+			Everything brought to SimpleCopy on port 0 is duplicated onto all
+			connected output ports. It also shows functionality of Trash
+			Component. It discards everything which is sent into it. Its
+			purpose is debugging - shows how many records ended in it and can
+			print incoming records, if desired (option debugPrint). Metadata
+			in this graph is embedded directly to graph instead of external
+			file.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphSimpleCopyLocale.grf&quot;&gt;graphSimpleCopyLocale.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph demonstrates functionality of SimpleCopy component.
+			Everything brought to SimpleCopy on port 0 is duplicated onto all
+			connected output ports. It also shows functionality of Trash
+			Component. It discards everything which is sent into it. Its
+			purpose is debugging - shows how many records ended in it and can
+			print incoming records, if desired (option debugPrint). Metadata
+			in this graph is embedded directly to graph instead of external
+			file. Output metadata is the same as input except that for
+			BirthDate and HireDate, locale property is defined. It allows to
+			specify language or language.Country locale which is used when
+			formatting output. In this example, date info on input is expected
+			to be in dd/MM/yyyy format, whereas on output it should follow
+			US/UK standard -&gt; (usually defined as MM/dd/YYYY).&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphSimpleLookup.grf&quot;&gt;graphSimpleLookup.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates how to join data using reformat
+			component.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphSortData.grf&quot;&gt;graphSortData.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates usage of Sort component. It sorts data
+			based on specified key. 
+			&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphSortUniversal.grf&quot;&gt;graphSortUniversal.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph illustrates usage of Sort component. It sorts data
+			based on specified key. It also shows how to use parameters/global
+			properties within graph. For executing see &lt;A HREF=&quot;#Sort Universal example|outline&quot;&gt;Sort
+			Universal example.&lt;/A&gt;&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphSystemExecute.grf&quot;&gt;graphSystemExecute.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph ilustrates usage of System Ececute Component&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphViewData.grf&quot;&gt;graphViewData.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;This graph is a simple utility which demonstrates usage of
+			parameters. It allows viewing content of particular data file (in
+			delimited format). It reads in data and stores them in &quot;debug&quot;
+			format.&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphXLSReadWrite.grf&quot;&gt;graphXLSReadWrite.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;In this example data are read from &lt;TT&gt;ORDERS.xls&lt;/TT&gt; file,
+			partitioned to 3 parts and each of thees parts are saved in
+			&lt;TT&gt;orders.partitioned.xls&lt;/TT&gt; file in different sheets. 
+			&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
-	&lt;TR&gt;
-		&lt;TD WIDTH=284&gt;
+	&lt;TR VALIGN=TOP&gt;
+		&lt;TD WIDTH=25%&gt;
 			&lt;P&gt;&lt;A HREF=&quot;graphXMLExtract.grf&quot;&gt;graphXMLExtract.grf&lt;/A&gt;&lt;/P&gt;
 		&lt;/TD&gt;
+		&lt;TD WIDTH=75%&gt;
+			&lt;P&gt;In this example data are read from &lt;TT&gt;employees.xml &lt;/TT&gt;file.
+			&#8220;Mapping&#8221; attribute describes dependencies between xml nodes
+			and metadata fields. 
+			&lt;/P&gt;
+		&lt;/TD&gt;
 	&lt;/TR&gt;
 &lt;/TABLE&gt;
 &lt;P&gt;&lt;BR&gt;&lt;BR&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000245.html">[Cloveretl-svn-commits] CloverETL repos r2609 -	trunk/cloveretl.engine/examples
</A></li>
	<LI>Next message: <A HREF="000247.html">[Cloveretl-svn-commits] CloverETL repos r2611 -	trunk/cloveretl.engine/examples
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#246">[ date ]</a>
              <a href="thread.html#246">[ thread ]</a>
              <a href="subject.html#246">[ subject ]</a>
              <a href="author.html#246">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cloveretl-svn-commits">More information about the Cloveretl-svn-commits
mailing list</a><br>
</body></html>
